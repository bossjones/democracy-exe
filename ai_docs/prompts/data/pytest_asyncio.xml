<documents>
<document index="1">
<source>/Users/malcolm/dev/pytest-asyncio/pytest_asyncio/__init__.py</source>
<document_content>
"""The main point for importing pytest-asyncio items."""

from __future__ import annotations

from ._version import version as __version__  # noqa: F401
from .plugin import fixture, is_async_test

__all__ = ("fixture", "is_async_test")

</document_content>
</document>
<document index="2">
<source>/Users/malcolm/dev/pytest-asyncio/pytest_asyncio/plugin.py</source>
<document_content>
"""pytest-asyncio implementation."""

from __future__ import annotations

import asyncio
import contextlib
import contextvars
import enum
import functools
import inspect
import socket
import warnings
from asyncio import AbstractEventLoop, AbstractEventLoopPolicy
from collections.abc import (
    AsyncIterator,
    Awaitable,
    Coroutine as AbstractCoroutine,
    Generator,
    Iterable,
    Iterator,
    Mapping,
    Sequence,
)
from textwrap import dedent
from typing import (
    Any,
    Callable,
    Literal,
    TypeVar,
    Union,
    overload,
)

import pluggy
import pytest
from pytest import (
    Class,
    Collector,
    Config,
    FixtureDef,
    FixtureRequest,
    Function,
    Item,
    Mark,
    Metafunc,
    Module,
    Package,
    Parser,
    PytestCollectionWarning,
    PytestDeprecationWarning,
    PytestPluginManager,
    Session,
    StashKey,
)

_ScopeName = Literal["session", "package", "module", "class", "function"]
_T = TypeVar("_T")

SimpleFixtureFunction = TypeVar(
    "SimpleFixtureFunction", bound=Callable[..., Awaitable[object]]
)
FactoryFixtureFunction = TypeVar(
    "FactoryFixtureFunction", bound=Callable[..., AsyncIterator[object]]
)
FixtureFunction = Union[SimpleFixtureFunction, FactoryFixtureFunction]
FixtureFunctionMarker = Callable[[FixtureFunction], FixtureFunction]


class PytestAsyncioError(Exception):
    """Base class for exceptions raised by pytest-asyncio"""


class MultipleEventLoopsRequestedError(PytestAsyncioError):
    """Raised when a test requests multiple asyncio event loops."""


class Mode(str, enum.Enum):
    AUTO = "auto"
    STRICT = "strict"


ASYNCIO_MODE_HELP = """\
'auto' - for automatically handling all async functions by the plugin
'strict' - for autoprocessing disabling (useful if different async frameworks \
should be tested together, e.g. \
both pytest-asyncio and pytest-trio are used in the same project)
"""


def pytest_addoption(parser: Parser, pluginmanager: PytestPluginManager) -> None:
    group = parser.getgroup("asyncio")
    group.addoption(
        "--asyncio-mode",
        dest="asyncio_mode",
        default=None,
        metavar="MODE",
        help=ASYNCIO_MODE_HELP,
    )
    parser.addini(
        "asyncio_mode",
        help="default value for --asyncio-mode",
        default="strict",
    )
    parser.addini(
        "asyncio_default_fixture_loop_scope",
        type="string",
        help="default scope of the asyncio event loop used to execute async fixtures",
        default=None,
    )


@overload
def fixture(
    fixture_function: FixtureFunction,
    *,
    scope: _ScopeName | Callable[[str, Config], _ScopeName] = ...,
    loop_scope: _ScopeName | None = ...,
    params: Iterable[object] | None = ...,
    autouse: bool = ...,
    ids: (
        Iterable[str | float | int | bool | None]
        | Callable[[Any], object | None]
        | None
    ) = ...,
    name: str | None = ...,
) -> FixtureFunction: ...


@overload
def fixture(
    fixture_function: None = ...,
    *,
    scope: _ScopeName | Callable[[str, Config], _ScopeName] = ...,
    loop_scope: _ScopeName | None = ...,
    params: Iterable[object] | None = ...,
    autouse: bool = ...,
    ids: (
        Iterable[str | float | int | bool | None]
        | Callable[[Any], object | None]
        | None
    ) = ...,
    name: str | None = None,
) -> FixtureFunctionMarker: ...


def fixture(
    fixture_function: FixtureFunction | None = None,
    loop_scope: _ScopeName | None = None,
    **kwargs: Any,
) -> FixtureFunction | FixtureFunctionMarker:
    if fixture_function is not None:
        _make_asyncio_fixture_function(fixture_function, loop_scope)
        return pytest.fixture(fixture_function, **kwargs)

    else:

        @functools.wraps(fixture)
        def inner(fixture_function: FixtureFunction) -> FixtureFunction:
            return fixture(fixture_function, loop_scope=loop_scope, **kwargs)

        return inner


def _is_asyncio_fixture_function(obj: Any) -> bool:
    obj = getattr(obj, "__func__", obj)  # instance method maybe?
    return getattr(obj, "_force_asyncio_fixture", False)


def _make_asyncio_fixture_function(obj: Any, loop_scope: _ScopeName | None) -> None:
    if hasattr(obj, "__func__"):
        # instance method, check the function object
        obj = obj.__func__
    obj._force_asyncio_fixture = True
    obj._loop_scope = loop_scope


def _is_coroutine_or_asyncgen(obj: Any) -> bool:
    return inspect.iscoroutinefunction(obj) or inspect.isasyncgenfunction(obj)


def _get_asyncio_mode(config: Config) -> Mode:
    val = config.getoption("asyncio_mode")
    if val is None:
        val = config.getini("asyncio_mode")
    try:
        return Mode(val)
    except ValueError as e:
        modes = ", ".join(m.value for m in Mode)
        raise pytest.UsageError(
            f"{val!r} is not a valid asyncio_mode. Valid modes: {modes}."
        ) from e


_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET = """\
The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching \
scope. Future versions of pytest-asyncio will default the loop scope for asynchronous \
fixtures to function scope. Set the default fixture loop scope explicitly in order to \
avoid unexpected behavior in the future. Valid fixture loop scopes are: \
"function", "class", "module", "package", "session"
"""


def pytest_configure(config: Config) -> None:
    default_loop_scope = config.getini("asyncio_default_fixture_loop_scope")
    if not default_loop_scope:
        warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
    config.addinivalue_line(
        "markers",
        "asyncio: "
        "mark the test as a coroutine, it will be "
        "run using an asyncio event loop",
    )


@pytest.hookimpl(tryfirst=True)
def pytest_report_header(config: Config) -> list[str]:
    """Add asyncio config to pytest header."""
    mode = _get_asyncio_mode(config)
    default_loop_scope = config.getini("asyncio_default_fixture_loop_scope")
    return [
        f"asyncio: mode={mode}, asyncio_default_fixture_loop_scope={default_loop_scope}"
    ]


def _preprocess_async_fixtures(
    collector: Collector,
    processed_fixturedefs: set[FixtureDef],
) -> None:
    config = collector.config
    default_loop_scope = config.getini("asyncio_default_fixture_loop_scope")
    asyncio_mode = _get_asyncio_mode(config)
    fixturemanager = config.pluginmanager.get_plugin("funcmanage")
    assert fixturemanager is not None
    for fixtures in fixturemanager._arg2fixturedefs.values():
        for fixturedef in fixtures:
            func = fixturedef.func
            if fixturedef in processed_fixturedefs or not _is_coroutine_or_asyncgen(
                func
            ):
                continue
            if asyncio_mode == Mode.STRICT and not _is_asyncio_fixture_function(func):
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
                continue
            scope = (
                getattr(func, "_loop_scope", None)
                or default_loop_scope
                or fixturedef.scope
            )
            if scope == "function" and "event_loop" not in fixturedef.argnames:
                fixturedef.argnames += ("event_loop",)
            _make_asyncio_fixture_function(func, scope)
            function_signature = inspect.signature(func)
            if "event_loop" in function_signature.parameters:
                warnings.warn(
                    PytestDeprecationWarning(
                        f"{func.__name__} is asynchronous and explicitly "
                        f'requests the "event_loop" fixture. Asynchronous fixtures and '
                        f'test functions should use "asyncio.get_running_loop()" '
                        f"instead."
                    )
                )
            if "request" not in fixturedef.argnames:
                fixturedef.argnames += ("request",)
            _synchronize_async_fixture(fixturedef)
            assert _is_asyncio_fixture_function(fixturedef.func)
            processed_fixturedefs.add(fixturedef)


def _synchronize_async_fixture(fixturedef: FixtureDef) -> None:
    """Wraps the fixture function of an async fixture in a synchronous function."""
    if inspect.isasyncgenfunction(fixturedef.func):
        _wrap_asyncgen_fixture(fixturedef)
    elif inspect.iscoroutinefunction(fixturedef.func):
        _wrap_async_fixture(fixturedef)


def _add_kwargs(
    func: Callable[..., Any],
    kwargs: dict[str, Any],
    event_loop: asyncio.AbstractEventLoop,
    request: FixtureRequest,
) -> dict[str, Any]:
    sig = inspect.signature(func)
    ret = kwargs.copy()
    if "request" in sig.parameters:
        ret["request"] = request
    if "event_loop" in sig.parameters:
        ret["event_loop"] = event_loop
    return ret


def _perhaps_rebind_fixture_func(func: _T, instance: Any | None) -> _T:
    if instance is not None:
        # The fixture needs to be bound to the actual request.instance
        # so it is bound to the same object as the test method.
        unbound, cls = func, None
        try:
            unbound, cls = func.__func__, type(func.__self__)  # type: ignore
        except AttributeError:
            pass
        # Only if the fixture was bound before to an instance of
        # the same type.
        if cls is not None and isinstance(instance, cls):
            func = unbound.__get__(instance)  # type: ignore
    return func


def _wrap_asyncgen_fixture(fixturedef: FixtureDef) -> None:
    fixture = fixturedef.func

    @functools.wraps(fixture)
    def _asyncgen_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)
        gen_obj = func(**_add_kwargs(func, kwargs, event_loop, request))

        async def setup():
            res = await gen_obj.__anext__()  # type: ignore[union-attr]
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
        result = event_loop.run_until_complete(setup_task)

        reset_contextvars = _apply_contextvar_changes(context)

        def finalizer() -> None:
            """Yield again, to finalize."""

            async def async_finalizer() -> None:
                try:
                    await gen_obj.__anext__()  # type: ignore[union-attr]
                except StopAsyncIteration:
                    pass
                else:
                    msg = "Async generator fixture didn't stop."
                    msg += "Yield only once."
                    raise ValueError(msg)

            task = _create_task_in_context(event_loop, async_finalizer(), context)
            event_loop.run_until_complete(task)
            if reset_contextvars is not None:
                reset_contextvars()

        request.addfinalizer(finalizer)
        return result

    fixturedef.func = _asyncgen_fixture_wrapper  # type: ignore[misc]


def _wrap_async_fixture(fixturedef: FixtureDef) -> None:
    fixture = fixturedef.func

    @functools.wraps(fixture)
    def _async_fixture_wrapper(request: FixtureRequest, **kwargs: Any):
        func = _perhaps_rebind_fixture_func(fixture, request.instance)
        event_loop_fixture_id = _get_event_loop_fixture_id_for_async_fixture(
            request, func
        )
        event_loop = request.getfixturevalue(event_loop_fixture_id)
        kwargs.pop(event_loop_fixture_id, None)

        async def setup():
            res = await func(**_add_kwargs(func, kwargs, event_loop, request))
            return res

        context = contextvars.copy_context()
        setup_task = _create_task_in_context(event_loop, setup(), context)
        result = event_loop.run_until_complete(setup_task)

        # Copy the context vars modified by the setup task into the current
        # context, and (if needed) add a finalizer to reset them.
        #
        # Note that this is slightly different from the behavior of a non-async
        # fixture, which would rely on the fixture author to add a finalizer
        # to reset the variables. In this case, the author of the fixture can't
        # write such a finalizer because they have no way to capture the Context
        # in which the setup function was run, so we need to do it for them.
        reset_contextvars = _apply_contextvar_changes(context)
        if reset_contextvars is not None:
            request.addfinalizer(reset_contextvars)

        return result

    fixturedef.func = _async_fixture_wrapper  # type: ignore[misc]


def _get_event_loop_fixture_id_for_async_fixture(
    request: FixtureRequest, func: Any
) -> str:
    default_loop_scope = request.config.getini("asyncio_default_fixture_loop_scope")
    loop_scope = (
        getattr(func, "_loop_scope", None) or default_loop_scope or request.scope
    )
    if loop_scope == "function":
        event_loop_fixture_id = "event_loop"
    else:
        event_loop_node = _retrieve_scope_root(request._pyfuncitem, loop_scope)
        event_loop_fixture_id = event_loop_node.stash.get(
            # Type ignored because of non-optimal mypy inference.
            _event_loop_fixture_id,  # type: ignore[arg-type]
            "",
        )
    assert event_loop_fixture_id
    return event_loop_fixture_id


def _create_task_in_context(
    loop: asyncio.AbstractEventLoop,
    coro: AbstractCoroutine[Any, Any, _T],
    context: contextvars.Context,
) -> asyncio.Task[_T]:
    """
    Return an asyncio task that runs the coro in the specified context,
    if possible.

    This allows fixture setup and teardown to be run as separate asyncio tasks,
    while still being able to use context-manager idioms to maintain context
    variables and make those variables visible to test functions.

    This is only fully supported on Python 3.11 and newer, as it requires
    the API added for https://github.com/python/cpython/issues/91150.
    On earlier versions, the returned task will use the default context instead.
    """
    try:
        return loop.create_task(coro, context=context)
    except TypeError:
        return loop.create_task(coro)


def _apply_contextvar_changes(
    context: contextvars.Context,
) -> Callable[[], None] | None:
    """
    Copy contextvar changes from the given context to the current context.

    If any contextvars were modified by the fixture, return a finalizer that
    will restore them.
    """
    context_tokens = []
    for var in context:
        try:
            if var.get() is context.get(var):
                # This variable is not modified, so leave it as-is.
                continue
        except LookupError:
            # This variable isn't yet set in the current context at all.
            pass
        token = var.set(context.get(var))
        context_tokens.append((var, token))

    if not context_tokens:
        return None

    def restore_contextvars():
        while context_tokens:
            (var, token) = context_tokens.pop()
            var.reset(token)

    return restore_contextvars


class PytestAsyncioFunction(Function):
    """Base class for all test functions managed by pytest-asyncio."""

    @classmethod
    def item_subclass_for(cls, item: Function, /) -> type[PytestAsyncioFunction] | None:
        """
        Returns a subclass of PytestAsyncioFunction if there is a specialized subclass
        for the specified function item.

        Return None if no specialized subclass exists for the specified item.
        """
        for subclass in cls.__subclasses__():
            if subclass._can_substitute(item):
                return subclass
        return None

    @classmethod
    def _from_function(cls, function: Function, /) -> Function:
        """
        Instantiates this specific PytestAsyncioFunction type from the specified
        Function item.
        """
        assert function.get_closest_marker("asyncio")
        subclass_instance = cls.from_parent(
            function.parent,
            name=function.name,
            callspec=getattr(function, "callspec", None),
            callobj=function.obj,
            fixtureinfo=function._fixtureinfo,
            keywords=function.keywords,
            originalname=function.originalname,
        )
        subclass_instance.own_markers = function.own_markers
        assert subclass_instance.own_markers == function.own_markers
        subclassed_function_signature = inspect.signature(subclass_instance.obj)
        if "event_loop" in subclassed_function_signature.parameters:
            subclass_instance.warn(
                PytestDeprecationWarning(
                    f"{subclass_instance.name} is asynchronous and explicitly "
                    f'requests the "event_loop" fixture. Asynchronous fixtures and '
                    f'test functions should use "asyncio.get_running_loop()" instead.'
                )
            )
        return subclass_instance

    @staticmethod
    def _can_substitute(item: Function) -> bool:
        """Returns whether the specified function can be replaced by this class"""
        raise NotImplementedError()


class Coroutine(PytestAsyncioFunction):
    """Pytest item created by a coroutine"""

    @staticmethod
    def _can_substitute(item: Function) -> bool:
        func = item.obj
        return inspect.iscoroutinefunction(func)

    def runtest(self) -> None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
        super().runtest()


class AsyncGenerator(PytestAsyncioFunction):
    """Pytest item created by an asynchronous generator"""

    @staticmethod
    def _can_substitute(item: Function) -> bool:
        func = item.obj
        return inspect.isasyncgenfunction(func)

    @classmethod
    def _from_function(cls, function: Function, /) -> Function:
        async_gen_item = super()._from_function(function)
        unsupported_item_type_message = (
            f"Tests based on asynchronous generators are not supported. "
            f"{function.name} will be ignored."
        )
        async_gen_item.warn(PytestCollectionWarning(unsupported_item_type_message))
        async_gen_item.add_marker(
            pytest.mark.xfail(run=False, reason=unsupported_item_type_message)
        )
        return async_gen_item


class AsyncStaticMethod(PytestAsyncioFunction):
    """
    Pytest item that is a coroutine or an asynchronous generator
    decorated with staticmethod
    """

    @staticmethod
    def _can_substitute(item: Function) -> bool:
        func = item.obj
        return isinstance(func, staticmethod) and _is_coroutine_or_asyncgen(
            func.__func__
        )

    def runtest(self) -> None:
        self.obj = wrap_in_sync(
            # https://github.com/pytest-dev/pytest-asyncio/issues/596
            self.obj,  # type: ignore[has-type]
        )
        super().runtest()


class AsyncHypothesisTest(PytestAsyncioFunction):
    """
    Pytest item that is coroutine or an asynchronous generator decorated by
    @hypothesis.given.
    """

    @staticmethod
    def _can_substitute(item: Function) -> bool:
        func = item.obj
        return (
            getattr(func, "is_hypothesis_test", False)  # type: ignore[return-value]
            and getattr(func, "hypothesis", None)
            and inspect.iscoroutinefunction(func.hypothesis.inner_test)
        )

    def runtest(self) -> None:
        self.obj.hypothesis.inner_test = wrap_in_sync(
            self.obj.hypothesis.inner_test,
        )
        super().runtest()


_HOLDER: set[FixtureDef] = set()


# The function name needs to start with "pytest_"
# see https://github.com/pytest-dev/pytest/issues/11307
@pytest.hookimpl(specname="pytest_pycollect_makeitem", tryfirst=True)
def pytest_pycollect_makeitem_preprocess_async_fixtures(
    collector: pytest.Module | pytest.Class, name: str, obj: object
) -> pytest.Item | pytest.Collector | list[pytest.Item | pytest.Collector] | None:
    """A pytest hook to collect asyncio coroutines."""
    if not collector.funcnamefilter(name):
        return None
    _preprocess_async_fixtures(collector, _HOLDER)
    return None


# The function name needs to start with "pytest_"
# see https://github.com/pytest-dev/pytest/issues/11307
@pytest.hookimpl(specname="pytest_pycollect_makeitem", hookwrapper=True)
def pytest_pycollect_makeitem_convert_async_functions_to_subclass(
    collector: pytest.Module | pytest.Class, name: str, obj: object
) -> Generator[None, pluggy.Result, None]:
    """
    Converts coroutines and async generators collected as pytest.Functions
    to AsyncFunction items.
    """
    hook_result = yield
    try:
        node_or_list_of_nodes: (
            pytest.Item | pytest.Collector | list[pytest.Item | pytest.Collector] | None
        ) = hook_result.get_result()
    except BaseException as e:
        hook_result.force_exception(e)
        return
    if not node_or_list_of_nodes:
        return
    if isinstance(node_or_list_of_nodes, Sequence):
        node_iterator = iter(node_or_list_of_nodes)
    else:
        # Treat single node as a single-element iterable
        node_iterator = iter((node_or_list_of_nodes,))
    updated_node_collection = []
    for node in node_iterator:
        updated_item = node
        if isinstance(node, Function):
            specialized_item_class = PytestAsyncioFunction.item_subclass_for(node)
            if specialized_item_class:
                if _get_asyncio_mode(
                    node.config
                ) == Mode.AUTO and not node.get_closest_marker("asyncio"):
                    node.add_marker("asyncio")
                if node.get_closest_marker("asyncio"):
                    updated_item = specialized_item_class._from_function(node)
        updated_node_collection.append(updated_item)
    hook_result.force_result(updated_node_collection)


_event_loop_fixture_id = StashKey[str]()
_fixture_scope_by_collector_type: Mapping[type[pytest.Collector], _ScopeName] = {
    Class: "class",
    # Package is a subclass of module and the dict is used in isinstance checks
    # Therefore, the order matters and Package needs to appear before Module
    Package: "package",
    Module: "module",
    Session: "session",
}

# A stack used to push package-scoped loops during collection of a package
# and pop those loops during collection of a Module
__package_loop_stack: list[FixtureFunctionMarker | FixtureFunction] = []


@pytest.hookimpl
def pytest_collectstart(collector: pytest.Collector) -> None:
    try:
        collector_scope = next(
            scope
            for cls, scope in _fixture_scope_by_collector_type.items()
            if isinstance(collector, cls)
        )
    except StopIteration:
        return
    # Session is not a PyCollector type, so it doesn't have a corresponding
    # "obj" attribute to attach a dynamic fixture function to.
    # However, there's only one session per pytest run, so there's no need to
    # create the fixture dynamically. We can simply define a session-scoped
    # event loop fixture once in the plugin code.
    if collector_scope == "session":
        event_loop_fixture_id = _session_event_loop.__name__
        collector.stash[_event_loop_fixture_id] = event_loop_fixture_id
        return
    # There seem to be issues when a fixture is shadowed by another fixture
    # and both differ in their params.
    # https://github.com/pytest-dev/pytest/issues/2043
    # https://github.com/pytest-dev/pytest/issues/11350
    # As such, we assign a unique name for each event_loop fixture.
    # The fixture name is stored in the collector's Stash, so it can
    # be injected when setting up the test
    event_loop_fixture_id = f"{collector.nodeid}::<event_loop>"
    collector.stash[_event_loop_fixture_id] = event_loop_fixture_id

    @pytest.fixture(
        scope=collector_scope,
        name=event_loop_fixture_id,
    )
    def scoped_event_loop(
        *args,  # Function needs to accept "cls" when collected by pytest.Class
        event_loop_policy,
    ) -> Iterator[asyncio.AbstractEventLoop]:
        new_loop_policy = event_loop_policy
        with _temporary_event_loop_policy(new_loop_policy):
            loop = _make_pytest_asyncio_loop(asyncio.new_event_loop())
            asyncio.set_event_loop(loop)
            yield loop
            loop.close()

    # @pytest.fixture does not register the fixture anywhere, so pytest doesn't
    # know it exists. We work around this by attaching the fixture function to the
    # collected Python object, where it will be picked up by pytest.Class.collect()
    # or pytest.Module.collect(), respectively
    if type(collector) is Package:
        # Packages do not have a corresponding Python object. Therefore, the fixture
        # for the package-scoped event loop is added to a stack. When a module inside
        # the package is collected, the module will attach the fixture to its
        # Python object.
        __package_loop_stack.append(scoped_event_loop)
    elif isinstance(collector, Module):
        # Accessing Module.obj triggers a module import executing module-level
        # statements. A module-level pytest.skip statement raises the "Skipped"
        # OutcomeException or a Collector.CollectError, if the "allow_module_level"
        # kwargs is missing. These cases are handled correctly when they happen inside
        # Collector.collect(), but this hook runs before the actual collect call.
        # Therefore, we monkey patch Module.collect to add the scoped fixture to the
        # module before it runs the actual collection.
        def _patched_collect():
            # If the collected module is a DoctestTextfile, collector.obj is None
            module = collector.obj
            if module is not None:
                module.__pytest_asyncio_scoped_event_loop = scoped_event_loop
                try:
                    package_loop = __package_loop_stack.pop()
                    module.__pytest_asyncio_package_scoped_event_loop = package_loop
                except IndexError:
                    pass
            return collector.__original_collect()

        collector.__original_collect = collector.collect  # type: ignore[attr-defined]
        collector.collect = _patched_collect  # type: ignore[method-assign]
    elif isinstance(collector, Class):
        collector.obj.__pytest_asyncio_scoped_event_loop = scoped_event_loop


@contextlib.contextmanager
def _temporary_event_loop_policy(policy: AbstractEventLoopPolicy) -> Iterator[None]:
    old_loop_policy = asyncio.get_event_loop_policy()
    try:
        old_loop = _get_event_loop_no_warn()
    except RuntimeError:
        old_loop = None
    asyncio.set_event_loop_policy(policy)
    try:
        yield
    finally:
        # Try detecting user-created event loops that were left unclosed
        # at the end of a test.
        try:
            current_loop: AbstractEventLoop | None = _get_event_loop_no_warn()
        except RuntimeError:
            current_loop = None
        if current_loop is not None and not current_loop.is_closed():
            warnings.warn(
                _UNCLOSED_EVENT_LOOP_WARNING % current_loop,
                DeprecationWarning,
            )
            current_loop.close()

        asyncio.set_event_loop_policy(old_loop_policy)
        # When a test uses both a scoped event loop and the event_loop fixture,
        # the "_provide_clean_event_loop" finalizer of the event_loop fixture
        # will already have installed a fresh event loop, in order to shield
        # subsequent tests from side-effects. We close this loop before restoring
        # the old loop to avoid ResourceWarnings.
        try:
            _get_event_loop_no_warn().close()
        except RuntimeError:
            pass
        asyncio.set_event_loop(old_loop)


_REDEFINED_EVENT_LOOP_FIXTURE_WARNING = dedent(
    """\
    The event_loop fixture provided by pytest-asyncio has been redefined in
    %s:%d
    Replacing the event_loop fixture with a custom implementation is deprecated
    and will lead to errors in the future.
    If you want to request an asyncio event loop with a scope other than function
    scope, use the "loop_scope" argument to the asyncio mark when marking the tests.
    If you want to return different types of event loops, use the event_loop_policy
    fixture.
    """
)


@pytest.hookimpl(tryfirst=True)
def pytest_generate_tests(metafunc: Metafunc) -> None:
    marker = metafunc.definition.get_closest_marker("asyncio")
    if not marker:
        return
    scope = _get_marked_loop_scope(marker)
    if scope == "function":
        return
    event_loop_node = _retrieve_scope_root(metafunc.definition, scope)
    event_loop_fixture_id = event_loop_node.stash.get(_event_loop_fixture_id, None)

    if event_loop_fixture_id:
        # This specific fixture name may already be in metafunc.argnames, if this
        # test indirectly depends on the fixture. For example, this is the case
        # when the test depends on an async fixture, both of which share the same
        # event loop fixture mark.
        if event_loop_fixture_id in metafunc.fixturenames:
            return
        fixturemanager = metafunc.config.pluginmanager.get_plugin("funcmanage")
        assert fixturemanager is not None
        if "event_loop" in metafunc.fixturenames:
            raise MultipleEventLoopsRequestedError(
                _MULTIPLE_LOOPS_REQUESTED_ERROR.format(
                    test_name=metafunc.definition.nodeid,
                    scope=scope,
                    scoped_loop_node=event_loop_node.nodeid,
                ),
            )
        # Add the scoped event loop fixture to Metafunc's list of fixture names and
        # fixturedefs and leave the actual parametrization to pytest
        # The fixture needs to be appended to avoid messing up the fixture evaluation
        # order
        metafunc.fixturenames.append(event_loop_fixture_id)
        metafunc._arg2fixturedefs[event_loop_fixture_id] = (
            fixturemanager._arg2fixturedefs[event_loop_fixture_id]
        )


@pytest.hookimpl(hookwrapper=True)
def pytest_fixture_setup(
    fixturedef: FixtureDef,
) -> Generator[None, pluggy.Result, None]:
    """Adjust the event loop policy when an event loop is produced."""
    if fixturedef.argname == "event_loop":
        # The use of a fixture finalizer is preferred over the
        # pytest_fixture_post_finalizer hook. The fixture finalizer is invoked once
        # for each fixture, whereas the hook may be invoked multiple times for
        # any specific fixture.
        # see https://github.com/pytest-dev/pytest/issues/5848
        _add_finalizers(
            fixturedef,
            _close_event_loop,
            _restore_event_loop_policy(asyncio.get_event_loop_policy()),
            _provide_clean_event_loop,
        )
        outcome = yield
        loop: asyncio.AbstractEventLoop = outcome.get_result()
        # Weird behavior was observed when checking for an attribute of FixtureDef.func
        # Instead, we now check for a special attribute of the returned event loop
        fixture_filename = inspect.getsourcefile(fixturedef.func)
        if not _is_pytest_asyncio_loop(loop):
            _, fixture_line_number = inspect.getsourcelines(fixturedef.func)
            warnings.warn(
                _REDEFINED_EVENT_LOOP_FIXTURE_WARNING
                % (fixture_filename, fixture_line_number),
                DeprecationWarning,
            )
        policy = asyncio.get_event_loop_policy()
        try:
            old_loop = _get_event_loop_no_warn(policy)
            if old_loop is not loop and not _is_pytest_asyncio_loop(old_loop):
                old_loop.close()
        except RuntimeError:
            # Either the current event loop has been set to None
            # or the loop policy doesn't specify to create new loops
            # or we're not in the main thread
            pass
        policy.set_event_loop(loop)
        return

    yield


def _make_pytest_asyncio_loop(loop: AbstractEventLoop) -> AbstractEventLoop:
    loop.__pytest_asyncio = True  # type: ignore[attr-defined]
    return loop


def _is_pytest_asyncio_loop(loop: AbstractEventLoop) -> bool:
    return getattr(loop, "__pytest_asyncio", False)


def _add_finalizers(fixturedef: FixtureDef, *finalizers: Callable[[], object]) -> None:
    """
    Registers the specified fixture finalizers in the fixture.

    Finalizers need to be specified in the exact order in which they should be invoked.

    :param fixturedef: Fixture definition which finalizers should be added to
    :param finalizers: Finalizers to be added
    """
    for finalizer in reversed(finalizers):
        fixturedef.addfinalizer(finalizer)


_UNCLOSED_EVENT_LOOP_WARNING = dedent(
    """\
    pytest-asyncio detected an unclosed event loop when tearing down the event_loop
    fixture: %r
    pytest-asyncio will close the event loop for you, but future versions of the
    library will no longer do so. In order to ensure compatibility with future
    versions, please make sure that:
        1. Any custom "event_loop" fixture properly closes the loop after yielding it
        2. The scopes of your custom "event_loop" fixtures do not overlap
        3. Your code does not modify the event loop in async fixtures or tests
    """
)


def _close_event_loop() -> None:
    policy = asyncio.get_event_loop_policy()
    try:
        loop = policy.get_event_loop()
    except RuntimeError:
        loop = None
    if loop is not None and not _is_pytest_asyncio_loop(loop):
        if not loop.is_closed():
            warnings.warn(
                _UNCLOSED_EVENT_LOOP_WARNING % loop,
                DeprecationWarning,
            )
        loop.close()


def _restore_event_loop_policy(previous_policy) -> Callable[[], None]:
    def _restore_policy():
        # Close any event loop associated with the old loop policy
        # to avoid ResourceWarnings in the _provide_clean_event_loop finalizer
        try:
            loop = _get_event_loop_no_warn(previous_policy)
        except RuntimeError:
            loop = None
        if loop and not _is_pytest_asyncio_loop(loop):
            loop.close()
        asyncio.set_event_loop_policy(previous_policy)

    return _restore_policy


def _provide_clean_event_loop() -> None:
    # At this point, the event loop for the current thread is closed.
    # When a user calls asyncio.get_event_loop(), they will get a closed loop.
    # In order to avoid this side effect from pytest-asyncio, we need to replace
    # the current loop with a fresh one.
    # Note that we cannot set the loop to None, because get_event_loop only creates
    # a new loop, when set_event_loop has not been called.
    policy = asyncio.get_event_loop_policy()
    try:
        old_loop = _get_event_loop_no_warn(policy)
    except RuntimeError:
        old_loop = None
    if old_loop is not None and not _is_pytest_asyncio_loop(old_loop):
        new_loop = policy.new_event_loop()
        policy.set_event_loop(new_loop)


def _get_event_loop_no_warn(
    policy: AbstractEventLoopPolicy | None = None,
) -> asyncio.AbstractEventLoop:
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", DeprecationWarning)
        if policy is not None:
            return policy.get_event_loop()
        else:
            return asyncio.get_event_loop()


@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_pyfunc_call(pyfuncitem: Function) -> object | None:
    """
    Pytest hook called before a test case is run.

    Wraps marked tests in a synchronous function
    where the wrapped test coroutine is executed in an event loop.
    """
    if pyfuncitem.get_closest_marker("asyncio") is not None:
        if isinstance(pyfuncitem, PytestAsyncioFunction):
            asyncio_mode = _get_asyncio_mode(pyfuncitem.config)
            for fixname, fixtures in pyfuncitem._fixtureinfo.name2fixturedefs.items():
                # name2fixturedefs is a dict between fixture name and a list of matching
                # fixturedefs. The last entry in the list is closest and the one used.
                func = fixtures[-1].func
                if (
                    asyncio_mode == Mode.STRICT
                    and _is_coroutine_or_asyncgen(func)
                    and not _is_asyncio_fixture_function(func)
                ):
                    warnings.warn(
                        PytestDeprecationWarning(
                            f"asyncio test {pyfuncitem.name!r} requested async "
                            "@pytest.fixture "
                            f"{fixname!r} in strict mode. "
                            "You might want to use @pytest_asyncio.fixture or switch "
                            "to auto mode. "
                            "This will become an error in future versions of "
                            "flake8-asyncio."
                        ),
                        stacklevel=1,
                    )
                    # no stacklevel points at the users code, so we set stacklevel=1
                    # so it at least indicates that it's the plugin complaining.
                    # Pytest gives the test file & name in the warnings summary at least

        else:
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove the asyncio mark. "
                    "If the test is not marked explicitly, "
                    "check for global marks applied via 'pytestmark'."
                )
            )
    yield
    return None


def wrap_in_sync(
    func: Callable[..., Awaitable[Any]],
):
    """
    Return a sync wrapper around an async function executing it in the
    current event loop.
    """
    # if the function is already wrapped, we rewrap using the original one
    # not using __wrapped__ because the original function may already be
    # a wrapped one
    raw_func = getattr(func, "_raw_test_func", None)
    if raw_func is not None:
        func = raw_func

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        _loop = _get_event_loop_no_warn()
        task = asyncio.ensure_future(coro, loop=_loop)
        try:
            _loop.run_until_complete(task)
        except BaseException:
            # run_until_complete doesn't get the result from exceptions
            # that are not subclasses of `Exception`. Consume all
            # exceptions to prevent asyncio's warning from logging.
            if task.done() and not task.cancelled():
                task.exception()
            raise

    inner._raw_test_func = func  # type: ignore[attr-defined]
    return inner


_MULTIPLE_LOOPS_REQUESTED_ERROR = dedent(
    """\
        Multiple asyncio event loops with different scopes have been requested
        by {test_name}. The test explicitly requests the event_loop fixture, while
        another event loop with {scope} scope is provided by {scoped_loop_node}.
        Remove "event_loop" from the requested fixture in your test to run the test
        in a {scope}-scoped event loop or remove the scope argument from the "asyncio"
        mark to run the test in a function-scoped event loop.
    """
)


def pytest_runtest_setup(item: pytest.Item) -> None:
    marker = item.get_closest_marker("asyncio")
    if marker is None:
        return
    scope = _get_marked_loop_scope(marker)
    if scope != "function":
        parent_node = _retrieve_scope_root(item, scope)
        event_loop_fixture_id = parent_node.stash[_event_loop_fixture_id]
    else:
        event_loop_fixture_id = "event_loop"
    fixturenames = item.fixturenames  # type: ignore[attr-defined]
    if event_loop_fixture_id not in fixturenames:
        fixturenames.append(event_loop_fixture_id)
    obj = getattr(item, "obj", None)
    if not getattr(obj, "hypothesis", False) and getattr(
        obj, "is_hypothesis_test", False
    ):
        pytest.fail(
            f"test function `{item!r}` is using Hypothesis, but pytest-asyncio "
            "only works with Hypothesis 3.64.0 or later."
        )


_DUPLICATE_LOOP_SCOPE_DEFINITION_ERROR = """\
An asyncio pytest marker defines both "scope" and "loop_scope", \
but it should only use "loop_scope".
"""

_MARKER_SCOPE_KWARG_DEPRECATION_WARNING = """\
The "scope" keyword argument to the asyncio marker has been deprecated. \
Please use the "loop_scope" argument instead.
"""


def _get_marked_loop_scope(asyncio_marker: Mark) -> _ScopeName:
    assert asyncio_marker.name == "asyncio"
    if asyncio_marker.args or (
        asyncio_marker.kwargs and set(asyncio_marker.kwargs) - {"loop_scope", "scope"}
    ):
        raise ValueError("mark.asyncio accepts only a keyword argument 'loop_scope'.")
    if "scope" in asyncio_marker.kwargs:
        if "loop_scope" in asyncio_marker.kwargs:
            raise pytest.UsageError(_DUPLICATE_LOOP_SCOPE_DEFINITION_ERROR)
        warnings.warn(PytestDeprecationWarning(_MARKER_SCOPE_KWARG_DEPRECATION_WARNING))
    scope = asyncio_marker.kwargs.get("loop_scope") or asyncio_marker.kwargs.get(
        "scope", "function"
    )
    assert scope in {"function", "class", "module", "package", "session"}
    return scope


def _retrieve_scope_root(item: Collector | Item, scope: str) -> Collector:
    node_type_by_scope = {
        "class": Class,
        "module": Module,
        "package": Package,
        "session": Session,
    }
    scope_root_type = node_type_by_scope[scope]
    for node in reversed(item.listchain()):
        if isinstance(node, scope_root_type):
            assert isinstance(node, pytest.Collector)
            return node
    error_message = (
        f"{item.name} is marked to be run in an event loop with scope {scope}, "
        f"but is not part of any {scope}."
    )
    raise pytest.UsageError(error_message)


@pytest.fixture
def event_loop(request: FixtureRequest) -> Iterator[asyncio.AbstractEventLoop]:
    """Create an instance of the default event loop for each test case."""
    new_loop_policy = request.getfixturevalue(event_loop_policy.__name__)
    with _temporary_event_loop_policy(new_loop_policy):
        loop = asyncio.get_event_loop_policy().new_event_loop()
        # Add a magic value to the event loop, so pytest-asyncio can determine if the
        # event_loop fixture was overridden. Other implementations of event_loop don't
        # set this value.
        # The magic value must be set as part of the function definition, because pytest
        # seems to have multiple instances of the same FixtureDef or fixture function
        loop = _make_pytest_asyncio_loop(loop)
        yield loop
        loop.close()


@pytest.fixture(scope="session")
def _session_event_loop(
    request: FixtureRequest, event_loop_policy: AbstractEventLoopPolicy
) -> Iterator[asyncio.AbstractEventLoop]:
    new_loop_policy = event_loop_policy
    with _temporary_event_loop_policy(new_loop_policy):
        loop = _make_pytest_asyncio_loop(asyncio.new_event_loop())
        asyncio.set_event_loop(loop)
        yield loop
        loop.close()


@pytest.fixture(scope="session", autouse=True)
def event_loop_policy() -> AbstractEventLoopPolicy:
    """Return an instance of the policy used to create asyncio event loops."""
    return asyncio.get_event_loop_policy()


def is_async_test(item: Item) -> bool:
    """Returns whether a test item is a pytest-asyncio test"""
    return isinstance(item, PytestAsyncioFunction)


def _unused_port(socket_type: int) -> int:
    """Find an unused localhost port from 1024-65535 and return it."""
    with contextlib.closing(socket.socket(type=socket_type)) as sock:
        sock.bind(("127.0.0.1", 0))
        return sock.getsockname()[1]


@pytest.fixture
def unused_tcp_port() -> int:
    return _unused_port(socket.SOCK_STREAM)


@pytest.fixture
def unused_udp_port() -> int:
    return _unused_port(socket.SOCK_DGRAM)


@pytest.fixture(scope="session")
def unused_tcp_port_factory() -> Callable[[], int]:
    """A factory function, producing different unused TCP ports."""
    produced = set()

    def factory():
        """Return an unused port."""
        port = _unused_port(socket.SOCK_STREAM)

        while port in produced:
            port = _unused_port(socket.SOCK_STREAM)

        produced.add(port)

        return port

    return factory


@pytest.fixture(scope="session")
def unused_udp_port_factory() -> Callable[[], int]:
    """A factory function, producing different unused UDP ports."""
    produced = set()

    def factory():
        """Return an unused port."""
        port = _unused_port(socket.SOCK_DGRAM)

        while port in produced:
            port = _unused_port(socket.SOCK_DGRAM)

        produced.add(port)

        return port

    return factory

</document_content>
</document>
<document index="3">
<source>/Users/malcolm/dev/pytest-asyncio/pytest_asyncio/py.typed</source>
<document_content>

</document_content>
</document>
<document index="4">
<source>/Users/malcolm/dev/pytest-asyncio/tests/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="5">
<source>/Users/malcolm/dev/pytest-asyncio/tests/conftest.py</source>
<document_content>
from __future__ import annotations

import asyncio

import pytest

pytest_plugins = "pytester"


@pytest.fixture
def dependent_fixture(event_loop):
    """A fixture dependent on the event_loop fixture, doing some cleanup."""
    counter = 0

    async def just_a_sleep():
        """Just sleep a little while."""
        nonlocal event_loop
        await asyncio.sleep(0.1)
        nonlocal counter
        counter += 1

    event_loop.run_until_complete(just_a_sleep())
    yield
    event_loop.run_until_complete(just_a_sleep())

    assert counter == 2


@pytest.fixture(scope="session", name="factory_involving_factories")
def factory_involving_factories_fixture(unused_tcp_port_factory):
    def factory():
        return unused_tcp_port_factory()

    return factory

</document_content>
</document>
<document index="6">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_asyncio_fixture.py</source>
<document_content>
from __future__ import annotations

import asyncio
from textwrap import dedent

import pytest
from pytest import Pytester

import pytest_asyncio


@pytest_asyncio.fixture
async def fixture_bare():
    await asyncio.sleep(0)
    return 1


@pytest.mark.asyncio
async def test_bare_fixture(fixture_bare):
    await asyncio.sleep(0)
    assert fixture_bare == 1


@pytest_asyncio.fixture(name="new_fixture_name")
async def fixture_with_name(request):
    await asyncio.sleep(0)
    return request.fixturename


@pytest.mark.asyncio
async def test_fixture_with_name(new_fixture_name):
    await asyncio.sleep(0)
    assert new_fixture_name == "new_fixture_name"


@pytest_asyncio.fixture(params=[2, 4])
async def fixture_with_params(request):
    await asyncio.sleep(0)
    return request.param


@pytest.mark.asyncio
async def test_fixture_with_params(fixture_with_params):
    await asyncio.sleep(0)
    assert fixture_with_params % 2 == 0


@pytest.mark.parametrize("mode", ("auto", "strict"))
def test_sync_function_uses_async_fixture(pytester: Pytester, mode):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import pytest_asyncio

        pytest_plugins = 'pytest_asyncio'

        @pytest_asyncio.fixture
        async def always_true():
            return True

        def test_sync_function_uses_async_fixture(always_true):
           assert always_true is True
        """
        )
    )
    result = pytester.runpytest(f"--asyncio-mode={mode}")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="7">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_asyncio_mark.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_on_sync_function_emits_warning(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio
            def test_a():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1)
    result.stdout.fnmatch_lines(
        ["*is marked with '@pytest.mark.asyncio' but it is not an async function.*"]
    )


def test_asyncio_mark_on_async_generator_function_emits_warning_in_strict_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio
            async def test_a():
                yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )


def test_asyncio_mark_on_async_generator_function_emits_warning_in_auto_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            async def test_a():
                yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=auto", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )


def test_asyncio_mark_on_async_generator_method_emits_warning_in_strict_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            class TestAsyncGenerator:
                @pytest.mark.asyncio
                async def test_a(self):
                    yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )


def test_asyncio_mark_on_async_generator_method_emits_warning_in_auto_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            class TestAsyncGenerator:
                @staticmethod
                async def test_a():
                    yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=auto", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )


def test_asyncio_mark_on_async_generator_staticmethod_emits_warning_in_strict_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            class TestAsyncGenerator:
                @staticmethod
                @pytest.mark.asyncio
                async def test_a():
                    yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )


def test_asyncio_mark_on_async_generator_staticmethod_emits_warning_in_auto_mode(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            class TestAsyncGenerator:
                @staticmethod
                async def test_a():
                    yield
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=auto", "-W default")
    result.assert_outcomes(xfailed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*Tests based on asynchronous generators are not supported*"]
    )

</document_content>
</document>
<document index="8">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_dependent_fixtures.py</source>
<document_content>
from __future__ import annotations

import asyncio

import pytest


@pytest.mark.asyncio
async def test_dependent_fixture(dependent_fixture):
    """Test a dependent fixture."""
    await asyncio.sleep(0.1)


@pytest.mark.asyncio
async def test_factory_involving_factories(factory_involving_factories):
    factory_involving_factories()

</document_content>
</document>
<document index="9">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_doctest.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_plugin_does_not_interfere_with_doctest_collection(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            '''\
            def any_function():
                """
                >>> 42
                42
                """
            '''
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict", "--doctest-modules")
    result.assert_outcomes(passed=1)


def test_plugin_does_not_interfere_with_doctest_textfile_collection(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makefile(".txt", "")  # collected as DoctestTextfile
    pytester.makepyfile(
        __init__="",
        test_python_file=dedent(
            """\
                import pytest

                pytest_plugins = "pytest_asyncio"

                @pytest.mark.asyncio
                async def test_anything():
                    pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="10">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_event_loop_fixture.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_event_loop_fixture_respects_event_loop_policy(pytester: Pytester):
    pytester.makeconftest(
        dedent(
            """\
            '''Defines and sets a custom event loop policy'''
            import asyncio
            from asyncio import DefaultEventLoopPolicy, SelectorEventLoop

            class TestEventLoop(SelectorEventLoop):
                pass

            class TestEventLoopPolicy(DefaultEventLoopPolicy):
                def new_event_loop(self):
                    return TestEventLoop()

            # This statement represents a code which sets a custom event loop policy
            asyncio.set_event_loop_policy(TestEventLoopPolicy())
            """
        )
    )
    pytester.makepyfile(
        dedent(
            """\
            '''Tests that any externally provided event loop policy remains unaltered'''
            import asyncio

            import pytest


            @pytest.mark.asyncio
            async def test_uses_loop_provided_by_custom_policy():
                '''Asserts that test cases use the event loop
                provided by the custom event loop policy'''
                assert type(asyncio.get_event_loop()).__name__ == "TestEventLoop"


            @pytest.mark.asyncio
            async def test_custom_policy_is_not_overwritten():
                '''
                Asserts that any custom event loop policy stays the same
                across test cases.
                '''
                assert type(asyncio.get_event_loop()).__name__ == "TestEventLoop"
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)

</document_content>
</document>
<document index="11">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_event_loop_fixture_finalizer.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_event_loop_fixture_finalizer_returns_fresh_loop_after_test(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            @pytest.mark.asyncio
            async def test_1():
                # This async test runs in its own event loop
                global loop
                running_loop = asyncio.get_event_loop_policy().get_event_loop()
                # Make sure this test case received a different loop
                assert running_loop is not loop

            def test_2():
                # Code outside of pytest-asyncio should not receive a "used" event loop
                current_loop = asyncio.get_event_loop_policy().get_event_loop()
                assert not current_loop.is_running()
                assert not current_loop.is_closed()
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_event_loop_fixture_finalizer_handles_loop_set_to_none_sync(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            def test_sync(event_loop):
                asyncio.get_event_loop_policy().set_event_loop(None)
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_event_loop_fixture_finalizer_handles_loop_set_to_none_async_without_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio
            async def test_async_without_explicit_fixture_request():
                asyncio.get_event_loop_policy().set_event_loop(None)
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_event_loop_fixture_finalizer_handles_loop_set_to_none_async_with_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio
            async def test_async_with_explicit_fixture_request(event_loop):
                asyncio.get_event_loop_policy().set_event_loop(None)
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        '*is asynchronous and explicitly requests the "event_loop" fixture*'
    )


def test_event_loop_fixture_finalizer_raises_warning_when_fixture_leaves_loop_unclosed(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytest_plugins = 'pytest_asyncio'

            @pytest.fixture
            def event_loop():
                loop = asyncio.get_event_loop_policy().new_event_loop()
                yield loop

            @pytest.mark.asyncio
            async def test_ends_with_unclosed_loop():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W", "default")
    result.assert_outcomes(passed=1, warnings=2)
    result.stdout.fnmatch_lines("*unclosed event loop*")


def test_event_loop_fixture_finalizer_raises_warning_when_test_leaves_loop_unclosed(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytest_plugins = 'pytest_asyncio'

            @pytest.mark.asyncio
            async def test_ends_with_unclosed_loop():
                asyncio.set_event_loop(asyncio.new_event_loop())
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W", "default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines("*unclosed event loop*")

</document_content>
</document>
<document index="12">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_event_loop_fixture_override_deprecation.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_emit_warning_when_event_loop_fixture_is_redefined(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.fixture
            def event_loop():
                loop = asyncio.new_event_loop()
                yield loop
                loop.close()

            @pytest.mark.asyncio
            async def test_emits_warning():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ["*event_loop fixture provided by pytest-asyncio has been redefined*"]
    )


def test_emit_warning_when_event_loop_fixture_is_redefined_explicit_request(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.fixture
            def event_loop():
                loop = asyncio.new_event_loop()
                yield loop
                loop.close()

            @pytest.mark.asyncio
            async def test_emits_warning_when_requested_explicitly(event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=2)
    result.stdout.fnmatch_lines(
        ["*event_loop fixture provided by pytest-asyncio has been redefined*"]
    )
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_does_not_emit_warning_when_no_test_uses_the_event_loop_fixture(
    pytester: Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.fixture
            def event_loop():
                loop = asyncio.new_event_loop()
                yield loop
                loop.close()

            def test_emits_no_warning():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1, warnings=0)


def test_emit_warning_when_redefined_event_loop_is_used_by_fixture(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest
            import pytest_asyncio

            @pytest.fixture
            def event_loop():
                loop = asyncio.new_event_loop()
                yield loop
                loop.close()

            @pytest_asyncio.fixture
            async def uses_event_loop():
                pass

            def test_emits_warning(uses_event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)

</document_content>
</document>
<document index="13">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_explicit_event_loop_fixture_request.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_emit_warning_when_event_loop_is_explicitly_requested_in_coroutine(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio
            async def test_coroutine_emits_warning(event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_emit_warning_when_event_loop_is_explicitly_requested_in_coroutine_method(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            class TestEmitsWarning:
                @pytest.mark.asyncio
                async def test_coroutine_emits_warning(self, event_loop):
                    pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_emit_warning_when_event_loop_is_explicitly_requested_in_coroutine_staticmethod(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            class TestEmitsWarning:
                @staticmethod
                @pytest.mark.asyncio
                async def test_coroutine_emits_warning(event_loop):
                    pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_emit_warning_when_event_loop_is_explicitly_requested_in_coroutine_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            @pytest_asyncio.fixture
            async def emits_warning(event_loop):
                pass

            @pytest.mark.asyncio
            async def test_uses_fixture(emits_warning):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_emit_warning_when_event_loop_is_explicitly_requested_in_async_gen_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            @pytest_asyncio.fixture
            async def emits_warning(event_loop):
                yield

            @pytest.mark.asyncio
            async def test_uses_fixture(emits_warning):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        ['*is asynchronous and explicitly requests the "event_loop" fixture*']
    )


def test_does_not_emit_warning_when_event_loop_is_explicitly_requested_in_sync_function(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            def test_uses_fixture(event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_does_not_emit_warning_when_event_loop_is_explicitly_requested_in_sync_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.fixture
            def any_fixture(event_loop):
                pass

            def test_uses_fixture(any_fixture):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="14">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_fixture_loop_scopes.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

import pytest
from pytest import Pytester


@pytest.mark.parametrize(
    "fixture_scope", ("session", "package", "module", "class", "function")
)
def test_loop_scope_session_is_independent_of_fixture_scope(
    pytester: Pytester,
    fixture_scope: str,
):
    pytester.makepyfile(
        dedent(
            f"""\
            import asyncio
            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop = None

            @pytest_asyncio.fixture(scope="{fixture_scope}", loop_scope="session")
            async def fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="session")
            async def test_runs_in_same_loop_as_fixture(fixture):
                global loop
                assert loop == asyncio.get_running_loop()
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.parametrize("default_loop_scope", ("function", "module", "session"))
def test_default_loop_scope_config_option_changes_fixture_loop_scope(
    pytester: Pytester,
    default_loop_scope: str,
):
    pytester.makeini(
        dedent(
            f"""\
            [pytest]
            asyncio_default_fixture_loop_scope = {default_loop_scope}
            """
        )
    )
    pytester.makepyfile(
        dedent(
            f"""\
            import asyncio
            import pytest
            import pytest_asyncio

            @pytest_asyncio.fixture
            async def fixture_loop():
                return asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="{default_loop_scope}")
            async def test_runs_in_fixture_loop(fixture_loop):
                assert asyncio.get_running_loop() is fixture_loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_default_class_loop_scope_config_option_changes_fixture_loop_scope(
    pytester: Pytester,
):
    pytester.makeini(
        dedent(
            """\
            [pytest]
            asyncio_default_fixture_loop_scope = class
            """
        )
    )
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest
            import pytest_asyncio

            class TestClass:
                @pytest_asyncio.fixture
                async def fixture_loop(self):
                    return asyncio.get_running_loop()

                @pytest.mark.asyncio(loop_scope="class")
                async def test_runs_in_fixture_loop(self, fixture_loop):
                    assert asyncio.get_running_loop() is fixture_loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_default_package_loop_scope_config_option_changes_fixture_loop_scope(
    pytester: Pytester,
):
    pytester.makeini(
        dedent(
            """\
            [pytest]
            asyncio_default_fixture_loop_scope = package
            """
        )
    )
    pytester.makepyfile(
        __init__="",
        test_a=dedent(
            """\
            import asyncio
            import pytest
            import pytest_asyncio

            @pytest_asyncio.fixture
            async def fixture_loop():
                return asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="package")
            async def test_runs_in_fixture_loop(fixture_loop):
                assert asyncio.get_running_loop() is fixture_loop
            """
        ),
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="15">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_import.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_import_warning_does_not_cause_internal_error(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                raise ImportWarning()

                async def test_errors_out():
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(errors=1)


def test_import_warning_in_package_does_not_cause_internal_error(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__=dedent(
            """\
                raise ImportWarning()
            """
        ),
        test_a=dedent(
            """\
                async def test_errors_out():
                    pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(errors=1)


def test_does_not_import_unrelated_packages(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pkg_dir = pytester.mkpydir("mypkg")
    pkg_dir.joinpath("__init__.py").write_text(
        dedent(
            """\
                raise ImportError()
            """
        ),
    )
    test_dir = pytester.mkdir("tests")
    test_dir.joinpath("test_a.py").write_text(
        dedent(
            """\
                async def test_passes():
                    pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="16">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_is_async_test.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_returns_false_for_sync_item(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            def test_sync():
                pass

            def pytest_collection_modifyitems(items):
                async_tests = [
                    item
                    for item in items
                    if pytest_asyncio.is_async_test(item)
                ]
                assert len(async_tests) == 0
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_returns_true_for_marked_coroutine_item_in_strict_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            @pytest.mark.asyncio
            async def test_coro():
                pass

            def pytest_collection_modifyitems(items):
                async_tests = [
                    item
                    for item in items
                    if pytest_asyncio.is_async_test(item)
                ]
                assert len(async_tests) == 1
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_returns_false_for_unmarked_coroutine_item_in_strict_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            async def test_coro():
                pass

            def pytest_collection_modifyitems(items):
                async_tests = [
                    item
                    for item in items
                    if pytest_asyncio.is_async_test(item)
                ]
                assert len(async_tests) == 0
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(failed=1)


def test_returns_true_for_unmarked_coroutine_item_in_auto_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import pytest_asyncio

            async def test_coro():
                pass

            def pytest_collection_modifyitems(items):
                async_tests = [
                    item
                    for item in items
                    if pytest_asyncio.is_async_test(item)
                ]
                assert len(async_tests) == 1
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="17">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_multiloop.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_event_loop_override(pytester: Pytester):
    pytester.makeconftest(
        dedent(
            '''\
            import asyncio

            import pytest


            @pytest.fixture
            def dependent_fixture(event_loop):
                """A fixture dependent on the event_loop fixture, doing some cleanup."""
                counter = 0

                async def just_a_sleep():
                    """Just sleep a little while."""
                    nonlocal event_loop
                    await asyncio.sleep(0.1)
                    nonlocal counter
                    counter += 1

                event_loop.run_until_complete(just_a_sleep())
                yield
                event_loop.run_until_complete(just_a_sleep())

                assert counter == 2


            class CustomSelectorLoop(asyncio.SelectorEventLoop):
                """A subclass with no overrides, just to test for presence."""


            @pytest.fixture
            def event_loop():
                """Create an instance of the default event loop for each test case."""
                loop = CustomSelectorLoop()
                yield loop
                loop.close()
            '''
        )
    )
    pytester.makepyfile(
        dedent(
            '''\
            """Unit tests for overriding the event loop."""
            import asyncio

            import pytest


            @pytest.mark.asyncio
            async def test_for_custom_loop():
                """This test should be executed using the custom loop."""
                await asyncio.sleep(0.01)
                assert type(asyncio.get_event_loop()).__name__ == "CustomSelectorLoop"


            @pytest.mark.asyncio
            async def test_dependent_fixture(dependent_fixture):
                await asyncio.sleep(0.1)
            '''
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2, warnings=2)

</document_content>
</document>
<document index="18">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_port_factories.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester

import pytest_asyncio.plugin


def test_unused_tcp_port_selects_unused_port(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            @pytest.mark.asyncio
            async def test_unused_port_fixture(unused_tcp_port):
                async def closer(_, writer):
                    writer.close()

                server1 = await asyncio.start_server(
                    closer, host="localhost", port=unused_tcp_port
                )

                with pytest.raises(IOError):
                    await asyncio.start_server(
                        closer, host="localhost", port=unused_tcp_port
                    )

                server1.close()
                await server1.wait_closed()
            """
        )
    )


def test_unused_udp_port_selects_unused_port(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            @pytest.mark.asyncio
            async def test_unused_udp_port_fixture(unused_udp_port):
                class Closer:
                    def connection_made(self, transport):
                        pass

                    def connection_lost(self, *arg, **kwd):
                        pass

                event_loop = asyncio.get_running_loop()
                transport1, _ = await event_loop.create_datagram_endpoint(
                    Closer,
                    local_addr=("127.0.0.1", unused_udp_port),
                    reuse_port=False,
                )

                with pytest.raises(IOError):
                    await event_loop.create_datagram_endpoint(
                        Closer,
                        local_addr=("127.0.0.1", unused_udp_port),
                        reuse_port=False,
                    )

                transport1.abort()
            """
        )
    )


def test_unused_tcp_port_factory_selects_unused_port(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            @pytest.mark.asyncio
            async def test_unused_port_factory_fixture(unused_tcp_port_factory):
                async def closer(_, writer):
                    writer.close()

                port1, port2, port3 = (
                    unused_tcp_port_factory(),
                    unused_tcp_port_factory(),
                    unused_tcp_port_factory(),
                )

                server1 = await asyncio.start_server(
                    closer, host="localhost", port=port1
                )
                server2 = await asyncio.start_server(
                    closer, host="localhost", port=port2
                )
                server3 = await asyncio.start_server(
                    closer, host="localhost", port=port3
                )

                for port in port1, port2, port3:
                    with pytest.raises(IOError):
                        await asyncio.start_server(closer, host="localhost", port=port)

                server1.close()
                await server1.wait_closed()
                server2.close()
                await server2.wait_closed()
                server3.close()
                await server3.wait_closed()
            """
        )
    )


def test_unused_udp_port_factory_selects_unused_port(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            @pytest.mark.asyncio
            async def test_unused_udp_port_factory_fixture(unused_udp_port_factory):
                class Closer:
                    def connection_made(self, transport):
                        pass

                    def connection_lost(self, *arg, **kwd):
                        pass

                port1, port2, port3 = (
                    unused_udp_port_factory(),
                    unused_udp_port_factory(),
                    unused_udp_port_factory(),
                )

                event_loop = asyncio.get_running_loop()
                transport1, _ = await event_loop.create_datagram_endpoint(
                    Closer,
                    local_addr=("127.0.0.1", port1),
                    reuse_port=False,
                )
                transport2, _ = await event_loop.create_datagram_endpoint(
                    Closer,
                    local_addr=("127.0.0.1", port2),
                    reuse_port=False,
                )
                transport3, _ = await event_loop.create_datagram_endpoint(
                    Closer,
                    local_addr=("127.0.0.1", port3),
                    reuse_port=False,
                )

                for port in port1, port2, port3:
                    with pytest.raises(IOError):
                        await event_loop.create_datagram_endpoint(
                            Closer,
                            local_addr=("127.0.0.1", port),
                            reuse_port=False,
                        )

                transport1.abort()
                transport2.abort()
                transport3.abort()
            """
        )
    )


def test_unused_port_factory_duplicate(unused_tcp_port_factory, monkeypatch):
    """Test correct avoidance of duplicate ports."""
    counter = 0

    def mock_unused_tcp_port(_ignored):
        """Force some duplicate ports."""
        nonlocal counter
        counter += 1
        if counter < 5:
            return 10000
        else:
            return 10000 + counter

    monkeypatch.setattr(pytest_asyncio.plugin, "_unused_port", mock_unused_tcp_port)

    assert unused_tcp_port_factory() == 10000
    assert unused_tcp_port_factory() > 10000


def test_unused_udp_port_factory_duplicate(unused_udp_port_factory, monkeypatch):
    """Test correct avoidance of duplicate UDP ports."""
    counter = 0

    def mock_unused_udp_port(_ignored):
        """Force some duplicate ports."""
        nonlocal counter
        counter += 1
        if counter < 5:
            return 10000
        else:
            return 10000 + counter

    monkeypatch.setattr(pytest_asyncio.plugin, "_unused_port", mock_unused_udp_port)

    assert unused_udp_port_factory() == 10000
    assert unused_udp_port_factory() > 10000

</document_content>
</document>
<document index="19">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_simple.py</source>
<document_content>
"""Quick'n'dirty unit tests for provided fixtures and markers."""

from __future__ import annotations

import asyncio
from textwrap import dedent

import pytest
from pytest import Pytester


async def async_coro():
    await asyncio.sleep(0)
    return "ok"


def test_event_loop_fixture(event_loop):
    """Test the injection of the event_loop fixture."""
    assert event_loop
    ret = event_loop.run_until_complete(async_coro())
    assert ret == "ok"


@pytest.mark.asyncio
async def test_asyncio_marker():
    """Test the asyncio pytest marker."""
    await asyncio.sleep(0)


def test_asyncio_marker_compatibility_with_xfail(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest_plugins = "pytest_asyncio"

                @pytest.mark.xfail(reason="need a failure", strict=True)
                @pytest.mark.asyncio
                async def test_asyncio_marker_fail():
                    raise AssertionError
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(xfailed=1)


def test_asyncio_auto_mode_compatibility_with_xfail(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest_plugins = "pytest_asyncio"

                @pytest.mark.xfail(reason="need a failure", strict=True)
                async def test_asyncio_marker_fail():
                    raise AssertionError
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(xfailed=1)


@pytest.mark.asyncio
async def test_asyncio_marker_with_default_param(a_param=None):
    """Test the asyncio pytest marker."""
    await asyncio.sleep(0)


class TestMarkerInClassBasedTests:
    """Test that asyncio marked functions work for methods of test classes."""

    @pytest.mark.asyncio
    async def test_asyncio_marker_with_implicit_loop_fixture(self):
        """
        Test the "asyncio" marker works on a method in
        a class-based test with implicit loop fixture.
        """
        ret = await async_coro()
        assert ret == "ok"


class TestEventLoopStartedBeforeFixtures:
    @pytest.fixture
    async def loop(self):
        return asyncio.get_event_loop()

    @staticmethod
    def foo():
        return 1

    @pytest.mark.asyncio
    async def test_no_event_loop(self, loop):
        assert await loop.run_in_executor(None, self.foo) == 1

    @pytest.mark.asyncio
    async def test_event_loop_after_fixture(self, loop):
        assert await loop.run_in_executor(None, self.foo) == 1

    @pytest.mark.asyncio
    async def test_event_loop_before_fixture(self, loop):
        assert await loop.run_in_executor(None, self.foo) == 1


def test_invalid_asyncio_mode(pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    result = pytester.runpytest("-o", "asyncio_mode=True")
    result.stderr.no_fnmatch_line("INTERNALERROR> *")
    result.stderr.fnmatch_lines(
        "ERROR: 'True' is not a valid asyncio_mode. Valid modes: auto, strict."
    )

</document_content>
</document>
<document index="20">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_skips.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_strict_mode_skip(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest_plugins = "pytest_asyncio"

                @pytest.mark.asyncio
                async def test_no_warning_on_skip():
                    pytest.skip("Test a skip error inside asyncio")
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(skipped=1)


def test_asyncio_auto_mode_skip(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest_plugins = "pytest_asyncio"

                async def test_no_warning_on_skip():
                    pytest.skip("Test a skip error inside asyncio")
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(skipped=1)


def test_asyncio_strict_mode_module_level_skip(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest.skip("Skip all tests", allow_module_level=True)

                @pytest.mark.asyncio
                async def test_is_skipped():
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(skipped=1)


def test_asyncio_auto_mode_module_level_skip(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest.skip("Skip all tests", allow_module_level=True)

                async def test_is_skipped():
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(skipped=1)


def test_asyncio_auto_mode_wrong_skip_usage(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                import pytest

                pytest.skip("Skip all tests")

                async def test_is_skipped():
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(errors=1)


def test_unittest_skiptest_compatibility(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
                from unittest import SkipTest

                raise SkipTest("Skip all tests")

                async def test_is_skipped():
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(skipped=1)


def test_skip_in_module_does_not_skip_package(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_skip=dedent(
            """\
                import pytest

                pytest.skip("Skip all tests", allow_module_level=True)

                def test_a():
                    pass

                def test_b():
                    pass
            """
        ),
        test_something=dedent(
            """\
                import pytest

                @pytest.mark.asyncio
                async def test_something():
                    pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1, skipped=1)

</document_content>
</document>
<document index="21">
<source>/Users/malcolm/dev/pytest-asyncio/tests/test_subprocess.py</source>
<document_content>
"""Tests for using subprocesses in tests."""

from __future__ import annotations

import asyncio.subprocess
import sys

import pytest

if sys.platform == "win32":
    # The default asyncio event loop implementation on Windows does not
    # support subprocesses. Subprocesses are available for Windows if a
    # ProactorEventLoop is used.
    @pytest.fixture()
    def event_loop():
        loop = asyncio.ProactorEventLoop()
        yield loop
        loop.close()


@pytest.mark.asyncio
async def test_subprocess():
    """Starting a subprocess should be possible."""
    proc = await asyncio.subprocess.create_subprocess_exec(
        sys.executable, "--version", stdout=asyncio.subprocess.PIPE
    )
    await proc.communicate()

</document_content>
</document>
<document index="22">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="23">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_async_fixtures.py</source>
<document_content>
from __future__ import annotations

import asyncio
import unittest.mock

import pytest

START = object()
END = object()
RETVAL = object()


@pytest.fixture
def mock():
    return unittest.mock.Mock(return_value=RETVAL)


@pytest.fixture
async def async_fixture(mock):
    return await asyncio.sleep(0.1, result=mock(START))


@pytest.mark.asyncio
async def test_async_fixture(async_fixture, mock):
    assert mock.call_count == 1
    assert mock.call_args_list[-1] == unittest.mock.call(START)
    assert async_fixture is RETVAL


class TestAsyncFixtureMethod:
    is_same_instance = False

    @pytest.fixture(autouse=True)
    async def async_fixture_method(self):
        self.is_same_instance = True

    @pytest.mark.asyncio
    async def test_async_fixture_method(self):
        assert self.is_same_instance

</document_content>
</document>
<document index="24">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_async_fixtures_contextvars.py</source>
<document_content>
"""
Regression test for https://github.com/pytest-dev/pytest-asyncio/issues/127:
contextvars were not properly maintained among fixtures and tests.
"""

from __future__ import annotations

import sys
from textwrap import dedent

import pytest
from pytest import Pytester

_prelude = dedent(
    """
    import pytest
    import pytest_asyncio
    from contextlib import contextmanager
    from contextvars import ContextVar

    _context_var = ContextVar("context_var")

    @contextmanager
    def context_var_manager(value):
        token = _context_var.set(value)
        try:
            yield
        finally:
            _context_var.reset(token)
"""
)


def test_var_from_sync_generator_propagates_to_async(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest.fixture
        def var_fixture():
            with context_var_manager("value"):
                yield

        @pytest_asyncio.fixture
        async def check_var_fixture(var_fixture):
            assert _context_var.get() == "value"

        @pytest.mark.asyncio
        async def test(check_var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_from_async_generator_propagates_to_sync(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def var_fixture():
            with context_var_manager("value"):
                yield

        @pytest.fixture
        def check_var_fixture(var_fixture):
            assert _context_var.get() == "value"

        @pytest.mark.asyncio
        async def test(check_var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_from_async_fixture_propagates_to_sync(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def var_fixture():
            _context_var.set("value")
            # Rely on async fixture teardown to reset the context var.

        @pytest.fixture
        def check_var_fixture(var_fixture):
            assert _context_var.get() == "value"

        def test(check_var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_from_generator_reset_before_previous_fixture_cleanup(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def no_var_fixture():
            with pytest.raises(LookupError):
                _context_var.get()
            yield
            with pytest.raises(LookupError):
                _context_var.get()

        @pytest_asyncio.fixture
        async def var_fixture(no_var_fixture):
            with context_var_manager("value"):
                yield

        @pytest.mark.asyncio
        async def test(var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_from_fixture_reset_before_previous_fixture_cleanup(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def no_var_fixture():
            with pytest.raises(LookupError):
                _context_var.get()
            yield
            with pytest.raises(LookupError):
                _context_var.get()

        @pytest_asyncio.fixture
        async def var_fixture(no_var_fixture):
            _context_var.set("value")
            # Rely on async fixture teardown to reset the context var.

        @pytest.mark.asyncio
        async def test(var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_previous_value_restored_after_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def var_fixture_1():
            with context_var_manager("value1"):
                yield
                assert _context_var.get() == "value1"

        @pytest_asyncio.fixture
        async def var_fixture_2(var_fixture_1):
            with context_var_manager("value2"):
                yield
                assert _context_var.get() == "value2"

        @pytest.mark.asyncio
        async def test(var_fixture_2):
            assert _context_var.get() == "value2"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


@pytest.mark.xfail(
    sys.version_info < (3, 11),
    reason="requires asyncio Task context support",
    strict=True,
)
def test_var_set_to_existing_value_ok(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        _prelude
        + dedent(
            """
        @pytest_asyncio.fixture
        async def var_fixture():
            with context_var_manager("value"):
                yield

        @pytest_asyncio.fixture
        async def same_var_fixture(var_fixture):
            with context_var_manager(_context_var.get()):
                yield

        @pytest.mark.asyncio
        async def test(same_var_fixture):
            assert _context_var.get() == "value"
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="25">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_async_fixtures_scope.py</source>
<document_content>
"""
We support module-scoped async fixtures, but only if the event loop is
module-scoped too.
"""

from __future__ import annotations

import asyncio

import pytest


@pytest.fixture(scope="module")
def event_loop():
    """A module-scoped event loop."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="module")
async def async_fixture():
    await asyncio.sleep(0.1)
    return 1


@pytest.mark.asyncio
async def test_async_fixture_scope(async_fixture):
    assert async_fixture == 1
    await asyncio.sleep(0.1)

</document_content>
</document>
<document index="26">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_async_fixtures_with_finalizer.py</source>
<document_content>
from __future__ import annotations

import asyncio
import functools

import pytest

import pytest_asyncio


@pytest.mark.asyncio(loop_scope="module")
async def test_module_with_event_loop_finalizer(port_with_event_loop_finalizer):
    await asyncio.sleep(0.01)
    assert port_with_event_loop_finalizer


@pytest.mark.asyncio(loop_scope="module")
async def test_module_with_get_event_loop_finalizer(port_with_get_event_loop_finalizer):
    await asyncio.sleep(0.01)
    assert port_with_get_event_loop_finalizer


@pytest.fixture(scope="module")
def event_loop():
    """Change event_loop fixture to module level."""
    policy = asyncio.get_event_loop_policy()
    loop = policy.new_event_loop()
    yield loop
    loop.close()


@pytest_asyncio.fixture(loop_scope="module", scope="module")
async def port_with_event_loop_finalizer(request):
    def port_finalizer(finalizer):
        async def port_afinalizer():
            # await task using loop provided by event_loop fixture
            # RuntimeError is raised if task is created on a different loop
            await finalizer

        asyncio.run(port_afinalizer())

    worker = asyncio.ensure_future(asyncio.sleep(0.2))
    request.addfinalizer(functools.partial(port_finalizer, worker))
    return True


@pytest_asyncio.fixture(loop_scope="module", scope="module")
async def port_with_get_event_loop_finalizer(request):
    def port_finalizer(finalizer):
        async def port_afinalizer():
            # await task using current loop retrieved from the event loop policy
            # RuntimeError is raised if task is created on a different loop.
            # This can happen when pytest_fixture_setup
            # does not set up the loop correctly,
            # for example when policy.set_event_loop() is called with a wrong argument
            await finalizer

        current_loop = asyncio.get_event_loop_policy().get_event_loop()
        current_loop.run_until_complete(port_afinalizer())

    worker = asyncio.ensure_future(asyncio.sleep(0.2))
    request.addfinalizer(functools.partial(port_finalizer, worker))
    return True

</document_content>
</document>
<document index="27">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_async_gen_fixtures.py</source>
<document_content>
from __future__ import annotations

import unittest.mock

import pytest

START = object()
END = object()
RETVAL = object()


@pytest.fixture(scope="module")
def mock():
    return unittest.mock.Mock(return_value=RETVAL)


@pytest.fixture
async def async_gen_fixture(mock):
    try:
        yield mock(START)
    except Exception as e:
        mock(e)
    else:
        mock(END)


@pytest.mark.asyncio
async def test_async_gen_fixture(async_gen_fixture, mock):
    assert mock.called
    assert mock.call_args_list[-1] == unittest.mock.call(START)
    assert async_gen_fixture is RETVAL


@pytest.mark.asyncio
async def test_async_gen_fixture_finalized(mock):
    try:
        assert mock.called
        assert mock.call_args_list[-1] == unittest.mock.call(END)
    finally:
        mock.reset_mock()


class TestAsyncGenFixtureMethod:
    is_same_instance = False

    @pytest.fixture(autouse=True)
    async def async_gen_fixture_method(self):
        self.is_same_instance = True
        yield None

    @pytest.mark.asyncio
    async def test_async_gen_fixture_method(self):
        assert self.is_same_instance

</document_content>
</document>
<document index="28">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_nested.py</source>
<document_content>
from __future__ import annotations

import asyncio

import pytest


@pytest.fixture()
async def async_inner_fixture():
    await asyncio.sleep(0.01)
    print("inner start")
    yield True
    print("inner stop")


@pytest.fixture()
async def async_fixture_outer(async_inner_fixture):
    await asyncio.sleep(0.01)
    print("outer start")
    assert async_inner_fixture is True
    yield True
    print("outer stop")


@pytest.mark.asyncio
async def test_async_fixture(async_fixture_outer):
    assert async_fixture_outer is True
    print("test_async_fixture")

</document_content>
</document>
<document index="29">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_parametrized_loop.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_event_loop_parametrization(pytester: Pytester):
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            TESTS_COUNT = 0


            def teardown_module():
                # parametrized 2 * 2 times: 2 for 'event_loop' and 2 for 'fix'
                assert TESTS_COUNT == 4


            @pytest.fixture(scope="module", params=[1, 2])
            def event_loop(request):
                request.param
                loop = asyncio.new_event_loop()
                yield loop
                loop.close()


            @pytest_asyncio.fixture(params=["a", "b"])
            async def fix(request):
                await asyncio.sleep(0)
                return request.param


            @pytest.mark.asyncio
            async def test_parametrized_loop(fix):
                await asyncio.sleep(0)
                global TESTS_COUNT
                TESTS_COUNT += 1
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=4)

</document_content>
</document>
<document index="30">
<source>/Users/malcolm/dev/pytest-asyncio/tests/async_fixtures/test_shared_module_fixture.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_provides_package_scoped_loop_strict_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        conftest=dedent(
            """\
            import pytest_asyncio
            @pytest_asyncio.fixture(loop_scope="module", scope="module")
            async def async_shared_module_fixture():
                return True
            """
        ),
        test_module_one=dedent(
            """\
            import pytest
            @pytest.mark.asyncio
            async def test_shared_module_fixture_use_a(async_shared_module_fixture):
                assert async_shared_module_fixture is True
            """
        ),
        test_module_two=dedent(
            """\
            import pytest
            @pytest.mark.asyncio
            async def test_shared_module_fixture_use_b(async_shared_module_fixture):
                assert async_shared_module_fixture is True
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)

</document_content>
</document>
<document index="31">
<source>/Users/malcolm/dev/pytest-asyncio/tests/modes/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="32">
<source>/Users/malcolm/dev/pytest-asyncio/tests/modes/test_auto_mode.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_auto_mode_cmdline(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'

        async def test_a():
            await asyncio.sleep(0)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_auto_mode_cfg(pytester: Pytester):
    pytester.makeini(
        dedent(
            """\
            [pytest]
            asyncio_default_fixture_loop_scope = function
            asyncio_mode = auto
            """
        )
    )
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'

        async def test_a():
            await asyncio.sleep(0)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_auto_mode_async_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'

        @pytest.fixture
        async def fixture_a():
            await asyncio.sleep(0)
            return 1

        async def test_a(fixture_a):
            await asyncio.sleep(0)
            assert fixture_a == 1
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_auto_mode_method_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'


        class TestA:

            @pytest.fixture
            async def fixture_a(self):
                await asyncio.sleep(0)
                return 1

            async def test_a(self, fixture_a):
                await asyncio.sleep(0)
                assert fixture_a == 1
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_auto_mode_static_method(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio

        pytest_plugins = 'pytest_asyncio'


        class TestA:

            @staticmethod
            async def test_a():
                await asyncio.sleep(0)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_auto_mode_static_method_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'


        class TestA:

            @staticmethod
            @pytest.fixture
            async def fixture_a():
                await asyncio.sleep(0)
                return 1

            @staticmethod
            async def test_a(fixture_a):
                await asyncio.sleep(0)
                assert fixture_a == 1
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="33">
<source>/Users/malcolm/dev/pytest-asyncio/tests/modes/test_strict_mode.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_strict_mode_cmdline(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'

        @pytest.mark.asyncio
        async def test_a():
            await asyncio.sleep(0)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_strict_mode_cfg(pytester: Pytester):
    pytester.makeini(
        dedent(
            """\
            [pytest]
            asyncio_default_fixture_loop_scope = function
            asyncio_mode = strict
            """
        )
    )
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest

        pytest_plugins = 'pytest_asyncio'

        @pytest.mark.asyncio
        async def test_a():
            await asyncio.sleep(0)
        """
        )
    )
    result = pytester.runpytest()
    result.assert_outcomes(passed=1)


def test_strict_mode_method_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest
        import pytest_asyncio

        pytest_plugins = 'pytest_asyncio'

        class TestA:

            @pytest_asyncio.fixture
            async def fixture_a(self):
                await asyncio.sleep(0)
                return 1

            @pytest.mark.asyncio
            async def test_a(self, fixture_a):
                await asyncio.sleep(0)
                assert fixture_a == 1
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_strict_mode_ignores_unmarked_coroutine(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import pytest

        async def test_anything():
            pass
        """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(skipped=1, warnings=1)
    result.stdout.fnmatch_lines(["*async def functions are not natively supported*"])


def test_strict_mode_ignores_unmarked_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import pytest

        # Not using pytest_asyncio.fixture
        @pytest.fixture()
        async def any_fixture():
            raise RuntimeError()

        async def test_anything(any_fixture):
            pass
        """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(skipped=1, warnings=2)
    result.stdout.fnmatch_lines(
        [
            "*async def functions are not natively supported*",
            "*coroutine 'any_fixture' was never awaited*",
        ],
    )


def test_strict_mode_marked_test_unmarked_fixture_warning(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import pytest

        # Not using pytest_asyncio.fixture
        @pytest.fixture()
        async def any_fixture():
            pass

        @pytest.mark.asyncio
        async def test_anything(any_fixture):
            # suppress unawaited coroutine warning
            try:
                any_fixture.send(None)
            except StopIteration:
                pass
        """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, failed=0, skipped=0, warnings=1)
    result.stdout.fnmatch_lines(
        [
            "*warnings summary*",
            (
                "test_strict_mode_marked_test_unmarked_fixture_warning.py::"
                "test_anything"
            ),
            (
                "*/pytest_asyncio/plugin.py:*: PytestDeprecationWarning: "
                "asyncio test 'test_anything' requested async "
                "@pytest.fixture 'any_fixture' in strict mode. "
                "You might want to use @pytest_asyncio.fixture or switch to "
                "auto mode. "
                "This will become an error in future versions of flake8-asyncio."
            ),
        ],
    )


# autouse is not handled in any special way currently
def test_strict_mode_marked_test_unmarked_autouse_fixture_warning(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import pytest

        # Not using pytest_asyncio.fixture
        @pytest.fixture(autouse=True)
        async def any_fixture():
            pass

        @pytest.mark.asyncio
        async def test_anything(any_fixture):
            # suppress unawaited coroutine warning
            try:
                any_fixture.send(None)
            except StopIteration:
                pass
        """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        [
            "*warnings summary*",
            (
                "test_strict_mode_marked_test_unmarked_autouse_fixture_warning.py::"
                "test_anything"
            ),
            (
                "*/pytest_asyncio/plugin.py:*: PytestDeprecationWarning: "
                "*asyncio test 'test_anything' requested async "
                "@pytest.fixture 'any_fixture' in strict mode. "
                "You might want to use @pytest_asyncio.fixture or switch to "
                "auto mode. "
                "This will become an error in future versions of flake8-asyncio."
            ),
        ],
    )

</document_content>
</document>
<document index="34">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="35">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_class_scope.py</source>
<document_content>
"""Test if pytestmark works when defined on a class."""

from __future__ import annotations

import asyncio
from textwrap import dedent

import pytest


class TestPyTestMark:
    pytestmark = pytest.mark.asyncio

    async def test_is_asyncio(self, sample_fixture):
        assert asyncio.get_event_loop()
        counter = 1

        async def inc():
            nonlocal counter
            counter += 1
            await asyncio.sleep(0)

        await asyncio.ensure_future(inc())
        assert counter == 2


@pytest.fixture
def sample_fixture():
    return None


def test_asyncio_mark_provides_class_scoped_loop_when_applied_to_functions(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            class TestClassScopedLoop:
                loop: asyncio.AbstractEventLoop

                @pytest.mark.asyncio(loop_scope="class")
                async def test_remember_loop(self):
                    TestClassScopedLoop.loop = asyncio.get_running_loop()

                @pytest.mark.asyncio(loop_scope="class")
                async def test_this_runs_in_same_loop(self):
                    assert asyncio.get_running_loop() is TestClassScopedLoop.loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_class_scoped_loop_when_applied_to_class(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio(loop_scope="class")
            class TestClassScopedLoop:
                loop: asyncio.AbstractEventLoop

                async def test_remember_loop(self):
                    TestClassScopedLoop.loop = asyncio.get_running_loop()

                async def test_this_runs_in_same_loop(self):
                    assert asyncio.get_running_loop() is TestClassScopedLoop.loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_raises_when_class_scoped_is_request_without_class(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio(loop_scope="class")
            async def test_has_no_surrounding_class():
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines(
        "*is marked to be run in an event loop with scope*",
    )


def test_asyncio_mark_is_inherited_to_subclasses(pytester: pytest.Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio(loop_scope="class")
            class TestSuperClassWithMark:
                pass

            class TestWithoutMark(TestSuperClassWithMark):
                loop: asyncio.AbstractEventLoop

                async def test_remember_loop(self):
                    TestWithoutMark.loop = asyncio.get_running_loop()

                async def test_this_runs_in_same_loop(self):
                    assert asyncio.get_running_loop() is TestWithoutMark.loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_respects_the_loop_policy(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass

            class TestUsesCustomEventLoop:
                @pytest.fixture(scope="class")
                def event_loop_policy(self):
                    return CustomEventLoopPolicy()

                @pytest.mark.asyncio
                async def test_uses_custom_event_loop_policy(self):
                    assert isinstance(
                        asyncio.get_event_loop_policy(),
                        CustomEventLoopPolicy,
                    )

            @pytest.mark.asyncio
            async def test_does_not_use_custom_event_loop_policy():
                assert not isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_respects_parametrized_loop_policies(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            @pytest.fixture(
                scope="class",
                params=[
                    asyncio.DefaultEventLoopPolicy(),
                    asyncio.DefaultEventLoopPolicy(),
                ]
            )
            def event_loop_policy(request):
                return request.param

            @pytest.mark.asyncio(loop_scope="class")
            class TestWithDifferentLoopPolicies:
                async def test_parametrized_loop(self, request):
                    pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_class_scoped_loop_to_fixtures(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            @pytest.mark.asyncio(loop_scope="class")
            class TestClassScopedLoop:
                loop: asyncio.AbstractEventLoop

                @pytest_asyncio.fixture
                async def my_fixture(self):
                    TestClassScopedLoop.loop = asyncio.get_running_loop()

                @pytest.mark.asyncio
                async def test_runs_is_same_loop_as_fixture(self, my_fixture):
                    assert asyncio.get_running_loop() is TestClassScopedLoop.loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_class_scoped_fixture_with_function_scoped_test(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            class TestMixedScopes:
                @pytest_asyncio.fixture(loop_scope="class", scope="class")
                async def async_fixture(self):
                    global loop
                    loop = asyncio.get_running_loop()

                @pytest.mark.asyncio(loop_scope="function")
                async def test_runs_in_different_loop_as_fixture(self, async_fixture):
                    global loop
                    assert asyncio.get_running_loop() is not loop

            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_handles_missing_event_loop_triggered_by_fixture(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import asyncio

            class TestClass:
                @pytest.fixture(scope="class")
                def sets_event_loop_to_none(self):
                    # asyncio.run() creates a new event loop without closing the
                    # existing one. For any test, but the first one, this leads to
                    # a ResourceWarning when the discarded loop is destroyed by the
                    # garbage collector. We close the current loop to avoid this.
                    try:
                        asyncio.get_event_loop().close()
                    except RuntimeError:
                        pass
                    return asyncio.run(asyncio.sleep(0))
                    # asyncio.run() sets the current event loop to None when finished

                @pytest.mark.asyncio(loop_scope="class")
                # parametrization may impact fixture ordering
                @pytest.mark.parametrize("n", (0, 1))
                async def test_does_not_fail(self, sets_event_loop_to_none, n):
                    pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_standalone_test_does_not_trigger_warning_about_no_current_event_loop_being_set(
    pytester: pytest.Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="class")
            class TestClass:
                async def test_anything(self):
                    pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(warnings=0, passed=1)

</document_content>
</document>
<document index="36">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_function_scope.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_provides_function_scoped_loop_strict_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytestmark = pytest.mark.asyncio

            loop: asyncio.AbstractEventLoop

            async def test_remember_loop():
                global loop
                loop = asyncio.get_running_loop()

            async def test_does_not_run_in_same_loop():
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_loop_scope_function_provides_function_scoped_event_loop(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="function")

            loop: asyncio.AbstractEventLoop

            async def test_remember_loop():
                global loop
                loop = asyncio.get_running_loop()

            async def test_does_not_run_in_same_loop():
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_raises_when_scope_and_loop_scope_arguments_are_present(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(scope="function", loop_scope="function")
            async def test_raises():
                ...
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(errors=1)


def test_warns_when_scope_argument_is_present(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(scope="function")
            async def test_warns():
                ...
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1, warnings=2)
    result.stdout.fnmatch_lines("*DeprecationWarning*")


def test_function_scope_supports_explicit_event_loop_fixture_request(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            pytestmark = pytest.mark.asyncio

            async def test_remember_loop(event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=1)
    result.stdout.fnmatch_lines(
        '*is asynchronous and explicitly requests the "event_loop" fixture*'
    )


def test_asyncio_mark_respects_the_loop_policy(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytestmark = pytest.mark.asyncio

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass

            @pytest.fixture(scope="function")
            def event_loop_policy():
                return CustomEventLoopPolicy()

            async def test_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_respects_parametrized_loop_policies(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            pytestmark = pytest.mark.asyncio

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass

            @pytest.fixture(
                scope="module",
                params=[
                    CustomEventLoopPolicy(),
                    CustomEventLoopPolicy(),
                ],
            )
            def event_loop_policy(request):
                return request.param

            async def test_parametrized_loop():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_function_scoped_loop_to_fixtures(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            pytestmark = pytest.mark.asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture
            async def my_fixture():
                global loop
                loop = asyncio.get_running_loop()

            async def test_runs_is_same_loop_as_fixture(my_fixture):
                global loop
                assert asyncio.get_running_loop() is loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_handles_missing_event_loop_triggered_by_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import asyncio

            @pytest.fixture
            def sets_event_loop_to_none():
                # asyncio.run() creates a new event loop without closing the existing
                # one. For any test, but the first one, this leads to a ResourceWarning
                # when the discarded loop is destroyed by the garbage collector.
                # We close the current loop to avoid this
                try:
                    asyncio.get_event_loop().close()
                except RuntimeError:
                    pass
                return asyncio.run(asyncio.sleep(0))
                # asyncio.run() sets the current event loop to None when finished

            @pytest.mark.asyncio
            # parametrization may impact fixture ordering
            @pytest.mark.parametrize("n", (0, 1))
            async def test_does_not_fail(sets_event_loop_to_none, n):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_standalone_test_does_not_trigger_warning_about_no_current_event_loop_being_set(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(warnings=0, passed=1)


def test_asyncio_mark_does_not_duplicate_other_marks_in_auto_mode(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makeconftest(
        dedent(
            """\
            def pytest_configure(config):
                config.addinivalue_line(
                    "markers", "dummy_marker: mark used for testing purposes"
                )
            """
        )
    )
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.dummy_marker
            async def test_markers_not_duplicated(request):
                markers = []
                for node, marker in request.node.iter_markers_with_node():
                    markers.append(marker)
                assert len(markers) == 2
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=auto")
    result.assert_outcomes(warnings=0, passed=1)

</document_content>
</document>
<document index="37">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_invalid_arguments.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

import pytest


def test_no_error_when_scope_passed_as_sole_keyword_argument(
    pytester: pytest.Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="session")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess()
    result.assert_outcomes(passed=1)
    result.stdout.no_fnmatch_line("*ValueError*")


def test_error_when_scope_passed_as_positional_argument(
    pytester: pytest.Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio("session")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess()
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines(
        ["*ValueError: mark.asyncio accepts only a keyword argument*"]
    )


def test_error_when_wrong_keyword_argument_is_passed(
    pytester: pytest.Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(cope="session")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess()
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines(
        ["*ValueError: mark.asyncio accepts only a keyword argument 'loop_scope'*"]
    )


def test_error_when_additional_keyword_arguments_are_passed(
    pytester: pytest.Pytester,
):
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="session", more="stuff")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess()
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines(
        ["*ValueError: mark.asyncio accepts only a keyword argument*"]
    )

</document_content>
</document>
<document index="38">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_mixed_scope.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_function_scoped_loop_restores_previous_loop_scope(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest


            module_loop: asyncio.AbstractEventLoop

            @pytest.mark.asyncio(loop_scope="module")
            async def test_remember_loop():
                global module_loop
                module_loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="function")
            async def test_with_function_scoped_loop():
                pass

            @pytest.mark.asyncio(loop_scope="module")
            async def test_runs_in_same_loop():
                global module_loop
                assert asyncio.get_running_loop() is module_loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=3)

</document_content>
</document>
<document index="39">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_module_scope.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_works_on_module_level(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            pytestmark = pytest.mark.asyncio


            class TestPyTestMark:
                async def test_is_asyncio(self, event_loop, sample_fixture):
                    assert asyncio.get_event_loop()

                    counter = 1

                    async def inc():
                        nonlocal counter
                        counter += 1
                        await asyncio.sleep(0)

                    await asyncio.ensure_future(inc())
                    assert counter == 2


            async def test_is_asyncio(event_loop, sample_fixture):
                assert asyncio.get_event_loop()
                counter = 1

                async def inc():
                    nonlocal counter
                    counter += 1
                    await asyncio.sleep(0)

                await asyncio.ensure_future(inc())
                assert counter == 2


            @pytest.fixture
            def sample_fixture():
                return None
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=2, warnings=2)
    result.stdout.fnmatch_lines(
        '*is asynchronous and explicitly requests the "event_loop" fixture*'
    )


def test_asyncio_mark_provides_module_scoped_loop_strict_mode(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            loop: asyncio.AbstractEventLoop

            async def test_remember_loop():
                global loop
                loop = asyncio.get_running_loop()

            async def test_this_runs_in_same_loop():
                global loop
                assert asyncio.get_running_loop() is loop

            class TestClassA:
                async def test_this_runs_in_same_loop(self):
                    global loop
                    assert asyncio.get_running_loop() is loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=3)


def test_raise_when_event_loop_fixture_is_requested_in_addition_to_scoped_loop(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            async def test_remember_loop(event_loop):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines("*MultipleEventLoopsRequestedError: *")


def test_asyncio_mark_respects_the_loop_policy(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        custom_policy=dedent(
            """\
            import asyncio

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass
            """
        ),
        test_uses_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            @pytest.fixture(scope="module")
            def event_loop_policy():
                return CustomEventLoopPolicy()

            async def test_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
        test_does_not_use_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            async def test_does_not_use_custom_event_loop_policy():
                assert not isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_respects_parametrized_loop_policies(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            @pytest.fixture(
                scope="module",
                params=[
                    asyncio.DefaultEventLoopPolicy(),
                    asyncio.DefaultEventLoopPolicy(),
                ],
            )
            def event_loop_policy(request):
                return request.param

            async def test_parametrized_loop():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_module_scoped_loop_to_fixtures(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            pytestmark = pytest.mark.asyncio(loop_scope="module")

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="module", scope="module")
            async def my_fixture():
                global loop
                loop = asyncio.get_running_loop()

            async def test_runs_is_same_loop_as_fixture(my_fixture):
                global loop
                assert asyncio.get_running_loop() is loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_module_scoped_fixture_with_class_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="module", scope="module")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="class")
            class TestMixedScopes:
                async def test_runs_in_different_loop_as_fixture(self, async_fixture):
                    global loop
                    assert asyncio.get_running_loop() is not loop

            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_module_scoped_fixture_with_function_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="module", scope="module")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="function")
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_allows_combining_module_scoped_asyncgen_fixture_with_function_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="module", scope="module")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()
                yield

            @pytest.mark.asyncio(loop_scope="function")
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_handles_missing_event_loop_triggered_by_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import asyncio

            @pytest.fixture(scope="module")
            def sets_event_loop_to_none():
                # asyncio.run() creates a new event loop without closing the existing
                # one. For any test, but the first one, this leads to a ResourceWarning
                # when the discarded loop is destroyed by the garbage collector.
                # We close the current loop to avoid this
                try:
                    asyncio.get_event_loop().close()
                except RuntimeError:
                    pass
                return asyncio.run(asyncio.sleep(0))
                # asyncio.run() sets the current event loop to None when finished

            @pytest.mark.asyncio(loop_scope="module")
            # parametrization may impact fixture ordering
            @pytest.mark.parametrize("n", (0, 1))
            async def test_does_not_fail(sets_event_loop_to_none, n):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_standalone_test_does_not_trigger_warning_about_no_current_event_loop_being_set(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="module")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(warnings=0, passed=1)

</document_content>
</document>
<document index="40">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_package_scope.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_provides_package_scoped_loop_strict_mode(pytester: Pytester):
    package_name = pytester.path.name
    subpackage_name = "subpkg"
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        shared_module=dedent(
            """\
            import asyncio

            loop: asyncio.AbstractEventLoop = None
            """
        ),
        test_module_one=dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            @pytest.mark.asyncio(loop_scope="package")
            async def test_remember_loop():
                shared_module.loop = asyncio.get_running_loop()
            """
        ),
        test_module_two=dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            async def test_this_runs_in_same_loop():
                assert asyncio.get_running_loop() is shared_module.loop

            class TestClassA:
                async def test_this_runs_in_same_loop(self):
                    assert asyncio.get_running_loop() is shared_module.loop
            """
        ),
    )
    subpkg = pytester.mkpydir(subpackage_name)
    subpkg.joinpath("__init__.py").touch()
    subpkg.joinpath("test_subpkg.py").write_text(
        dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            async def test_subpackage_runs_in_different_loop():
                assert asyncio.get_running_loop() is not shared_module.loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=4)


def test_raise_when_event_loop_fixture_is_requested_in_addition_to_scoped_loop(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_raises=dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio(loop_scope="package")
            async def test_remember_loop(event_loop):
                pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines("*MultipleEventLoopsRequestedError: *")


def test_asyncio_mark_respects_the_loop_policy(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        conftest=dedent(
            """\
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            @pytest.fixture(scope="package")
            def event_loop_policy():
                return CustomEventLoopPolicy()
            """
        ),
        custom_policy=dedent(
            """\
            import asyncio

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass
            """
        ),
        test_uses_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            async def test_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
        test_also_uses_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            async def test_also_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_respects_parametrized_loop_policies(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_parametrization=dedent(
            """\
            import asyncio

            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            @pytest.fixture(
                scope="package",
                params=[
                    asyncio.DefaultEventLoopPolicy(),
                    asyncio.DefaultEventLoopPolicy(),
                ],
            )
            def event_loop_policy(request):
                return request.param

            async def test_parametrized_loop():
                pass
            """
        ),
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_package_scoped_loop_to_fixtures(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    package_name = pytester.path.name
    pytester.makepyfile(
        __init__="",
        conftest=dedent(
            f"""\
            import asyncio

            import pytest_asyncio

            from {package_name} import shared_module

            @pytest_asyncio.fixture(loop_scope="package", scope="package")
            async def my_fixture():
                shared_module.loop = asyncio.get_running_loop()
            """
        ),
        shared_module=dedent(
            """\
            import asyncio

            loop: asyncio.AbstractEventLoop = None
            """
        ),
        test_fixture_runs_in_scoped_loop=dedent(
            f"""\
            import asyncio

            import pytest
            import pytest_asyncio

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="package")

            async def test_runs_in_same_loop_as_fixture(my_fixture):
                assert asyncio.get_running_loop() is shared_module.loop
            """
        ),
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_package_scoped_fixture_with_module_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="package", scope="package")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="module")
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_package_scoped_fixture_with_class_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="package", scope="package")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="class")
            class TestMixedScopes:
                async def test_runs_in_different_loop_as_fixture(self, async_fixture):
                    global loop
                    assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_package_scoped_fixture_with_function_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="package", scope="package")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_handles_missing_event_loop_triggered_by_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_loop_is_none=dedent(
            """\
            import pytest
            import asyncio

            @pytest.fixture(scope="package")
            def sets_event_loop_to_none():
                # asyncio.run() creates a new event loop without closing the existing
                # one. For any test, but the first one, this leads to a ResourceWarning
                # when the discarded loop is destroyed by the garbage collector.
                # We close the current loop to avoid this
                try:
                    asyncio.get_event_loop().close()
                except RuntimeError:
                    pass
                return asyncio.run(asyncio.sleep(0))
                # asyncio.run() sets the current event loop to None when finished

            @pytest.mark.asyncio(loop_scope="package")
            # parametrization may impact fixture ordering
            @pytest.mark.parametrize("n", (0, 1))
            async def test_does_not_fail(sets_event_loop_to_none, n):
                pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_standalone_test_does_not_trigger_warning_about_no_current_event_loop_being_set(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_module=dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="package")
            async def test_anything():
                pass
            """
        ),
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(warnings=0, passed=1)

</document_content>
</document>
<document index="41">
<source>/Users/malcolm/dev/pytest-asyncio/tests/markers/test_session_scope.py</source>
<document_content>
from __future__ import annotations

from textwrap import dedent

from pytest import Pytester


def test_asyncio_mark_provides_session_scoped_loop_strict_mode(pytester: Pytester):
    package_name = pytester.path.name
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        shared_module=dedent(
            """\
            import asyncio

            loop: asyncio.AbstractEventLoop = None
            """
        ),
        test_module_one=dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            @pytest.mark.asyncio(loop_scope="session")
            async def test_remember_loop():
                shared_module.loop = asyncio.get_running_loop()
            """
        ),
        test_module_two=dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            async def test_this_runs_in_same_loop():
                assert asyncio.get_running_loop() is shared_module.loop

            class TestClassA:
                async def test_this_runs_in_same_loop(self):
                    assert asyncio.get_running_loop() is shared_module.loop
            """
        ),
    )

    # subpackage_name must alphabetically come after test_module_one.py
    subpackage_name = "z_subpkg"
    subpkg = pytester.mkpydir(subpackage_name)
    subpkg.joinpath("test_subpkg.py").write_text(
        dedent(
            f"""\
            import asyncio
            import pytest

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            async def test_subpackage_runs_in_same_loop():
                assert asyncio.get_running_loop() is shared_module.loop
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=4)


def test_raise_when_event_loop_fixture_is_requested_in_addition_to_scoped_loop(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_raises=dedent(
            """\
            import asyncio
            import pytest

            @pytest.mark.asyncio(loop_scope="session")
            async def test_remember_loop(event_loop):
                pass
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(errors=1)
    result.stdout.fnmatch_lines("*MultipleEventLoopsRequestedError: *")


def test_asyncio_mark_respects_the_loop_policy(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        conftest=dedent(
            """\
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            @pytest.fixture(scope="session")
            def event_loop_policy():
                return CustomEventLoopPolicy()
            """
        ),
        custom_policy=dedent(
            """\
            import asyncio

            class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
                pass
            """
        ),
        test_uses_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            async def test_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
        test_also_uses_custom_policy=dedent(
            """\
            import asyncio
            import pytest

            from .custom_policy import CustomEventLoopPolicy

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            async def test_also_uses_custom_event_loop_policy():
                assert isinstance(
                    asyncio.get_event_loop_policy(),
                    CustomEventLoopPolicy,
                )
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_respects_parametrized_loop_policies(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_parametrization=dedent(
            """\
            import asyncio

            import pytest

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            @pytest.fixture(
                scope="session",
                params=[
                    asyncio.DefaultEventLoopPolicy(),
                    asyncio.DefaultEventLoopPolicy(),
                ],
            )
            def event_loop_policy(request):
                return request.param

            async def test_parametrized_loop():
                pass
            """
        ),
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_asyncio_mark_provides_session_scoped_loop_to_fixtures(
    pytester: Pytester,
):
    package_name = pytester.path.name
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        conftest=dedent(
            f"""\
            import asyncio

            import pytest_asyncio

            from {package_name} import shared_module

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def my_fixture():
                shared_module.loop = asyncio.get_running_loop()
            """
        ),
        shared_module=dedent(
            """\
            import asyncio

            loop: asyncio.AbstractEventLoop = None
            """
        ),
    )
    subpackage_name = "subpkg"
    subpkg = pytester.mkpydir(subpackage_name)
    subpkg.joinpath("test_subpkg.py").write_text(
        dedent(
            f"""\
            import asyncio

            import pytest
            import pytest_asyncio

            from {package_name} import shared_module

            pytestmark = pytest.mark.asyncio(loop_scope="session")

            async def test_runs_in_same_loop_as_fixture(my_fixture):
                assert asyncio.get_running_loop() is shared_module.loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_session_scoped_fixture_with_package_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="package")
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_session_scoped_fixture_with_module_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="module")
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_session_scoped_fixture_with_class_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio(loop_scope="class")
            class TestMixedScopes:
                async def test_runs_in_different_loop_as_fixture(self, async_fixture):
                    global loop
                    assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_allows_combining_session_scoped_fixture_with_function_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()

            @pytest.mark.asyncio
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_allows_combining_session_scoped_asyncgen_fixture_with_function_scoped_test(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        __init__="",
        test_mixed_scopes=dedent(
            """\
            import asyncio

            import pytest
            import pytest_asyncio

            loop: asyncio.AbstractEventLoop

            @pytest_asyncio.fixture(loop_scope="session", scope="session")
            async def async_fixture():
                global loop
                loop = asyncio.get_running_loop()
                yield

            @pytest.mark.asyncio
            async def test_runs_in_different_loop_as_fixture(async_fixture):
                global loop
                assert asyncio.get_running_loop() is not loop
            """
        ),
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=1)


def test_asyncio_mark_handles_missing_event_loop_triggered_by_fixture(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            import asyncio

            @pytest.fixture(scope="session")
            def sets_event_loop_to_none():
                # asyncio.run() creates a new event loop without closing the existing
                # one. For any test, but the first one, this leads to a ResourceWarning
                # when the discarded loop is destroyed by the garbage collector.
                # We close the current loop to avoid this
                try:
                    asyncio.get_event_loop().close()
                except RuntimeError:
                    pass
                return asyncio.run(asyncio.sleep(0))
                # asyncio.run() sets the current event loop to None when finished

            @pytest.mark.asyncio(loop_scope="session")
            # parametrization may impact fixture ordering
            @pytest.mark.parametrize("n", (0, 1))
            async def test_does_not_fail(sets_event_loop_to_none, n):
                pass
            """
        )
    )
    result = pytester.runpytest("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)


def test_standalone_test_does_not_trigger_warning_about_no_current_event_loop_being_set(
    pytester: Pytester,
):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest

            @pytest.mark.asyncio(loop_scope="session")
            async def test_anything():
                pass
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(warnings=0, passed=1)

</document_content>
</document>
<document index="42">
<source>/Users/malcolm/dev/pytest-asyncio/tests/loop_fixture_scope/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="43">
<source>/Users/malcolm/dev/pytest-asyncio/tests/loop_fixture_scope/conftest.py</source>
<document_content>
from __future__ import annotations

import asyncio

import pytest


class CustomSelectorLoop(asyncio.SelectorEventLoop):
    """A subclass with no overrides, just to test for presence."""


@pytest.fixture(scope="module")
def event_loop():
    """Create an instance of the default event loop for each test case."""
    loop = CustomSelectorLoop()
    yield loop
    loop.close()

</document_content>
</document>
<document index="44">
<source>/Users/malcolm/dev/pytest-asyncio/tests/loop_fixture_scope/test_loop_fixture_scope.py</source>
<document_content>
"""Unit tests for overriding the event loop with a larger scoped one."""

from __future__ import annotations

import asyncio

import pytest


@pytest.mark.asyncio
async def test_for_custom_loop():
    """This test should be executed using the custom loop."""
    await asyncio.sleep(0.01)
    assert type(asyncio.get_event_loop()).__name__ == "CustomSelectorLoop"


@pytest.mark.asyncio
async def test_dependent_fixture(dependent_fixture):
    await asyncio.sleep(0.1)

</document_content>
</document>
<document index="45">
<source>/Users/malcolm/dev/pytest-asyncio/tests/hypothesis/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="46">
<source>/Users/malcolm/dev/pytest-asyncio/tests/hypothesis/test_base.py</source>
<document_content>
"""
Tests for the Hypothesis integration, which wraps async functions in a
sync shim for Hypothesis.
"""

from __future__ import annotations

from textwrap import dedent

import pytest
from hypothesis import given, strategies as st
from pytest import Pytester


def test_hypothesis_given_decorator_before_asyncio_mark(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
            import pytest
            from hypothesis import given, strategies as st

            @given(st.integers())
            @pytest.mark.asyncio
            async def test_mark_inner(n):
                assert isinstance(n, int)
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1)


@pytest.mark.asyncio
@given(st.integers())
async def test_mark_outer(n):
    assert isinstance(n, int)


@pytest.mark.parametrize("y", [1, 2])
@given(x=st.none())
@pytest.mark.asyncio
async def test_mark_and_parametrize(x, y):
    assert x is None
    assert y in (1, 2)


def test_can_use_explicit_event_loop_fixture(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = module")
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest
            from hypothesis import given
            import hypothesis.strategies as st

            pytest_plugins = 'pytest_asyncio'

            @pytest.fixture(scope="module")
            def event_loop():
                loop = asyncio.get_event_loop_policy().new_event_loop()
                yield loop
                loop.close()

            @given(st.integers())
            @pytest.mark.asyncio
            async def test_explicit_fixture_request(event_loop, n):
                semaphore = asyncio.Semaphore(value=0)
                event_loop.call_soon(semaphore.release)
                await semaphore.acquire()
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict", "-W default")
    result.assert_outcomes(passed=1, warnings=2)
    result.stdout.fnmatch_lines(
        [
            '*is asynchronous and explicitly requests the "event_loop" fixture*',
            "*event_loop fixture provided by pytest-asyncio has been redefined*",
        ]
    )


def test_async_auto_marked(pytester: Pytester):
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest
        from hypothesis import given
        import hypothesis.strategies as st

        pytest_plugins = 'pytest_asyncio'

        @given(n=st.integers())
        async def test_hypothesis(n: int):
            assert isinstance(n, int)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)


def test_sync_not_auto_marked(pytester: Pytester):
    """Assert that synchronous Hypothesis functions are not marked with asyncio"""
    pytester.makeini("[pytest]\nasyncio_default_fixture_loop_scope = function")
    pytester.makepyfile(
        dedent(
            """\
        import asyncio
        import pytest
        from hypothesis import given
        import hypothesis.strategies as st

        pytest_plugins = 'pytest_asyncio'

        @given(n=st.integers())
        def test_hypothesis(request, n: int):
            markers = [marker.name for marker in request.node.own_markers]
            assert "asyncio" not in markers
            assert isinstance(n, int)
        """
        )
    )
    result = pytester.runpytest("--asyncio-mode=auto")
    result.assert_outcomes(passed=1)

</document_content>
</document>
<document index="47">
<source>/Users/malcolm/dev/pytest-asyncio/docs/concepts.rst</source>
<document_content>
========
Concepts
========

.. _concepts/event_loops:

asyncio event loops
===================
In order to understand how pytest-asyncio works, it helps to understand how pytest collectors work.
If you already know about pytest collectors, please :ref:`skip ahead <pytest-asyncio-event-loops>`.
Otherwise, continue reading.
Let's assume we have a test suite with a file named *test_all_the_things.py* holding a single test, async or not:

.. include:: concepts_function_scope_example.py
    :code: python

The file *test_all_the_things.py* is a Python module with a Python test function.
When we run pytest, the test runner descends into Python packages, modules, and classes, in order to find all tests, regardless whether the tests will run or not.
This process is referred to as *test collection* by pytest.
In our particular example, pytest will find our test module and the test function.
We can visualize the collection result by running ``pytest --collect-only``::

    <Module test_all_the_things.py>
      <Function test_runs_in_a_loop>

The example illustrates that the code of our test suite is hierarchical.
Pytest uses so called *collectors* for each level of the hierarchy.
Our contrived example test suite uses the *Module* and *Function* collectors, but real world test code may contain additional hierarchy levels via the *Package* or *Class* collectors.
There's also a special *Session* collector at the root of the hierarchy.
You may notice that the individual levels resemble the possible `scopes of a pytest fixture. <https://docs.pytest.org/en/7.4.x/how-to/fixtures.html#scope-sharing-fixtures-across-classes-modules-packages-or-session>`__

.. _pytest-asyncio-event-loops:

Pytest-asyncio provides one asyncio event loop for each pytest collector.
By default, each test runs in the event loop provided by the *Function* collector, i.e. tests use the loop with the narrowest scope.
This gives the highest level of isolation between tests.
If two or more tests share a common ancestor collector, the tests can be configured to run in their ancestor's loop by passing the appropriate *loop_scope* keyword argument to the *asyncio* mark.
For example, the following two tests use the asyncio event loop provided by the *Module* collector:

.. include:: concepts_module_scope_example.py
    :code: python

It's highly recommended for neighboring tests to use the same event loop scope.
For example, all tests in a class or module should use the same scope.
Assigning neighboring tests to different event loop scopes is discouraged as it can make test code hard to follow.

Test discovery modes
====================

Pytest-asyncio provides two modes for test discovery, *strict* and *auto*.


Strict mode
-----------

In strict mode pytest-asyncio will only run tests that have the *asyncio* marker and will only evaluate async fixtures decorated with ``@pytest_asyncio.fixture``. Test functions and fixtures without these markers and decorators will not be handled by pytest-asyncio.

This mode is intended for projects that want so support multiple asynchronous programming libraries as it allows pytest-asyncio to coexist with other async testing plugins in the same codebase.

Pytest automatically enables installed plugins. As a result pytest plugins need to coexist peacefully in their default configuration. This is why strict mode is the default mode.

Auto mode
---------

In *auto* mode pytest-asyncio automatically adds the *asyncio* marker to all asynchronous test functions. It will also take ownership of all async fixtures, regardless of whether they are decorated with ``@pytest.fixture`` or ``@pytest_asyncio.fixture``.

This mode is intended for projects that use *asyncio* as their only asynchronous programming library. Auto mode makes for the simplest test and fixture configuration and is the recommended default.

If you intend to support multiple asynchronous programming libraries, e.g. *asyncio* and *trio*, strict mode will be the preferred option.

</document_content>
</document>
<document index="48">
<source>/Users/malcolm/dev/pytest-asyncio/docs/concepts_function_scope_example.py</source>
<document_content>
import asyncio

import pytest


@pytest.mark.asyncio
async def test_runs_in_a_loop():
    assert asyncio.get_running_loop()

</document_content>
</document>
<document index="49">
<source>/Users/malcolm/dev/pytest-asyncio/docs/concepts_module_scope_example.py</source>
<document_content>
import asyncio

import pytest

loop: asyncio.AbstractEventLoop


@pytest.mark.asyncio(loop_scope="module")
async def test_remember_loop():
    global loop
    loop = asyncio.get_running_loop()


@pytest.mark.asyncio(loop_scope="module")
async def test_runs_in_a_loop():
    global loop
    assert asyncio.get_running_loop() is loop

</document_content>
</document>
<document index="50">
<source>/Users/malcolm/dev/pytest-asyncio/docs/conf.py</source>
<document_content>
# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

import importlib.metadata

project = "pytest-asyncio"
copyright = "2023, pytest-asyncio contributors"
author = "Tin Tvrtković"
release = importlib.metadata.version(project)

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = []

templates_path = ["_templates"]
exclude_patterns = []


# -- Options for HTML output -------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

html_theme = "sphinx_rtd_theme"
html_static_path = []

</document_content>
</document>
<document index="51">
<source>/Users/malcolm/dev/pytest-asyncio/docs/index.rst</source>
<document_content>
==========================
Welcome to pytest-asyncio!
==========================

.. toctree::
  :maxdepth: 1
  :hidden:

  concepts
  how-to-guides/index
  reference/index
  support

pytest-asyncio is a `pytest <https://docs.pytest.org/en/latest/contents.html>`_ plugin. It facilitates testing of code that uses the `asyncio <https://docs.python.org/3/library/asyncio.html>`_ library.

Specifically, pytest-asyncio provides support for coroutines as test functions. This allows users to *await* code inside their tests. For example, the following code is executed as a test item by pytest:

.. code-block:: python

    @pytest.mark.asyncio
    async def test_some_asyncio_code():
        res = await library.do_something()
        assert b"expected result" == res


Note that test classes subclassing the standard `unittest <https://docs.python.org/3/library/unittest.html>`__ library are not supported. Users
are advised to use `unittest.IsolatedAsyncioTestCase <https://docs.python.org/3/library/unittest.html#unittest.IsolatedAsyncioTestCase>`__
or an async framework such as `asynctest <https://asynctest.readthedocs.io/en/latest>`__.


pytest-asyncio is available under the `Apache License 2.0 <https://github.com/pytest-dev/pytest-asyncio/blob/main/LICENSE>`_.

</document_content>
</document>
<document index="52">
<source>/Users/malcolm/dev/pytest-asyncio/docs/support.rst</source>
<document_content>
===============
Getting support
===============

Enterprise support
==================
`Tidelift <https://www.tidelift.com>`_ works with maintainers of numerous open source projects to ensure enterprise-grade support for your software supply chain.

The Tidelift subscription includes security updates, verified license compliance, continuous software maintenance, and more. As a result, you get the guarantees provided by commercial software for the open source packages you use.

Consider `signing up for the Tidelift subscription <https://tidelift.com/subscription/pkg/pypi-pytest-asyncio?utm_source=pypi-pytest-asyncio&utm_medium=referral&utm_campaign=enterprise>`__.


Direct maintainer support
=========================
If you require commercial support outside of the Tidelift subscription, reach out to `Michael Seifert, <https://seifertm.de>`__ one of the project's maintainers.


Community support
=================
The GitHub page of pytest-asyncio offers free community support on a best-effort basis. Please use the `issue tracker <https://github.com/pytest-dev/pytest-asyncio/issues>`__ to report bugs and the Matrix chat room `#pytest-asyncio:matrix.org <https://matrix.to/#/#pytest-asyncio:matrix.org>`__ or `GitHub discussions <https://github.com/pytest-dev/pytest-asyncio/discussions>`__ to ask questions.

</document_content>
</document>
<document index="53">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/change_default_fixture_loop.rst</source>
<document_content>
==========================================================
How to change the default event loop scope of all fixtures
==========================================================
The :ref:`configuration/asyncio_default_fixture_loop_scope` configuration option sets the default event loop scope for asynchronous fixtures. The following code snippets configure all fixtures to run in a session-scoped loop by default:

.. code-block:: ini
    :caption: pytest.ini

    [pytest]
    asyncio_default_fixture_loop_scope = session

.. code-block:: toml
    :caption: pyproject.toml

    [tool.pytest.ini_options]
    asyncio_default_fixture_loop_scope = "session"

.. code-block:: ini
    :caption: setup.cfg

    [tool:pytest]
    asyncio_default_fixture_loop_scope = session

Please refer to :ref:`configuration/asyncio_default_fixture_loop_scope` for other valid scopes.

</document_content>
</document>
<document index="54">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/change_fixture_loop.rst</source>
<document_content>
===============================================
How to change the event loop scope of a fixture
===============================================
The event loop scope of an asynchronous fixture is specified via the *loop_scope* keyword argument to :ref:`pytest_asyncio.fixture <decorators/pytest_asyncio_fixture>`. The following fixture runs in the module-scoped event loop:

.. include:: change_fixture_loop_example.py
    :code: python

</document_content>
</document>
<document index="55">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/change_fixture_loop_example.py</source>
<document_content>
import asyncio

import pytest

import pytest_asyncio


@pytest_asyncio.fixture(loop_scope="module")
async def current_loop():
    return asyncio.get_running_loop()


@pytest.mark.asyncio(loop_scope="module")
async def test_runs_in_module_loop(current_loop):
    assert current_loop is asyncio.get_running_loop()

</document_content>
</document>
<document index="56">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/class_scoped_loop_example.py</source>
<document_content>
import asyncio

import pytest


@pytest.mark.asyncio(loop_scope="class")
class TestInOneEventLoopPerClass:
    loop: asyncio.AbstractEventLoop

    async def test_remember_loop(self):
        TestInOneEventLoopPerClass.loop = asyncio.get_running_loop()

    async def test_assert_same_loop(self):
        assert asyncio.get_running_loop() is TestInOneEventLoopPerClass.loop

</document_content>
</document>
<document index="57">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/index.rst</source>
<document_content>
=============
How-To Guides
=============

.. toctree::
  :hidden:

  migrate_from_0_21
  migrate_from_0_23
  change_fixture_loop
  change_default_fixture_loop
  run_class_tests_in_same_loop
  run_module_tests_in_same_loop
  run_package_tests_in_same_loop
  run_session_tests_in_same_loop
  multiple_loops
  uvloop
  test_item_is_async

This section of the documentation provides code snippets and recipes to accomplish specific tasks with pytest-asyncio.

</document_content>
</document>
<document index="58">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/migrate_from_0_21.rst</source>
<document_content>
.. _how_to_guides/migrate_from_0_21:

========================================
How to migrate from pytest-asyncio v0.21
========================================
1. If your test suite re-implements the *event_loop* fixture, make sure the fixture implementations don't do anything besides creating a new asyncio event loop, yielding it, and closing it.
2. Convert all synchronous test cases requesting the *event_loop* fixture to asynchronous test cases.
3. Convert all synchronous fixtures requesting the *event_loop* fixture to asynchronous fixtures.
4. Remove the *event_loop* argument from all asynchronous test cases in favor of ``event_loop = asyncio.get_running_loop()``.
5. Remove the *event_loop* argument from all asynchronous fixtures in favor of ``event_loop = asyncio.get_running_loop()``.

Go through all re-implemented *event_loop* fixtures in your test suite one by one, starting with the the fixture with the deepest nesting level and take note of the fixture scope:

1. For all tests and fixtures affected by the re-implemented *event_loop* fixture, configure the *loop_scope* for async tests and fixtures to match the *event_loop* fixture scope. This can be done for each test and fixture individually using either the ``pytest.mark.asyncio(loop_scope="…")`` marker for async tests or ``@pytest_asyncio.fixture(loop_scope="…")`` for async fixtures. Alternatively, you can set the default loop scope for fixtures using the :ref:`asyncio_default_fixture_loop_scope <configuration/asyncio_default_fixture_loop_scope>` configuration option. Snippets to mark all tests with the same *asyncio* marker, thus sharing the same loop scope, are present in the how-to section of the documentation. Depending on the homogeneity of your test suite, you may want a mixture of explicit decorators and default settings.
2. Remove the re-implemented *event_loop* fixture.

If you haven't set the *asyncio_default_fixture_loop_scope* configuration option, yet, set it to *function* to silence the deprecation warning.

</document_content>
</document>
<document index="59">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/migrate_from_0_23.rst</source>
<document_content>
========================================
How to migrate from pytest-asyncio v0.23
========================================
The following steps assume that your test suite has no re-implementations of the *event_loop* fixture, nor explicit fixtures requests for it. If this isn't the case, please follow the :ref:`migration guide for pytest-asyncio v0.21. <how_to_guides/migrate_from_0_21>`

1. Explicitly set the *loop_scope* of async fixtures by replacing occurrences of ``@pytest.fixture(scope="…")`` and ``@pytest_asyncio.fixture(scope="…")`` with ``@pytest_asyncio.fixture(loop_scope="…", scope="…")`` such that *loop_scope* and *scope* are the same. If you use auto mode, resolve all import errors from missing imports of *pytest_asyncio*. If your async fixtures all use the same *loop_scope*, you may choose to set the *asyncio_default_fixture_loop_scope* configuration option to that loop scope, instead.
2. If you haven't set *asyncio_default_fixture_loop_scope*, set it to *function* to address the deprecation warning about the unset configuration option.
3. Change all occurrences of ``pytest.mark.asyncio(scope="…")`` to ``pytest.mark.asyncio(loop_scope="…")`` to address the deprecation warning about the *scope* argument to the *asyncio* marker.

</document_content>
</document>
<document index="60">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/module_scoped_loop_example.py</source>
<document_content>
import asyncio

import pytest

pytestmark = pytest.mark.asyncio(loop_scope="module")

loop: asyncio.AbstractEventLoop


async def test_remember_loop():
    global loop
    loop = asyncio.get_running_loop()


async def test_assert_same_loop():
    global loop
    assert asyncio.get_running_loop() is loop

</document_content>
</document>
<document index="61">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/multiple_loops.rst</source>
<document_content>
======================================
How to test with different event loops
======================================

Parametrizing the *event_loop_policy* fixture parametrizes all async tests. The following example causes all async tests to run multiple times, once for each event loop in the fixture parameters:

.. include:: multiple_loops_example.py
    :code: python

You may choose to limit the scope of the fixture to *package,* *module,* or *class,* if you only want a subset of your tests to run with different event loops.

</document_content>
</document>
<document index="62">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/multiple_loops_example.py</source>
<document_content>
import asyncio
from asyncio import DefaultEventLoopPolicy

import pytest


class CustomEventLoopPolicy(DefaultEventLoopPolicy):
    pass


@pytest.fixture(
    scope="session",
    params=(
        CustomEventLoopPolicy(),
        CustomEventLoopPolicy(),
    ),
)
def event_loop_policy(request):
    return request.param


@pytest.mark.asyncio
async def test_uses_custom_event_loop_policy():
    assert isinstance(asyncio.get_event_loop_policy(), CustomEventLoopPolicy)

</document_content>
</document>
<document index="63">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/package_scoped_loop_example.py</source>
<document_content>
import pytest

pytestmark = pytest.mark.asyncio(loop_scope="package")

</document_content>
</document>
<document index="64">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/run_class_tests_in_same_loop.rst</source>
<document_content>
======================================================
How to run all tests in a class in the same event loop
======================================================
All tests can be run inside the same event loop by marking them with ``pytest.mark.asyncio(loop_scope="class")``.
This is easily achieved by using the *asyncio* marker as a class decorator.

.. include:: class_scoped_loop_example.py
    :code: python

</document_content>
</document>
<document index="65">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/run_module_tests_in_same_loop.rst</source>
<document_content>
=======================================================
How to run all tests in a module in the same event loop
=======================================================
All tests can be run inside the same event loop by marking them with ``pytest.mark.asyncio(loop_scope="module")``.
This is easily achieved by adding a `pytestmark` statement to your module.

.. include:: module_scoped_loop_example.py
    :code: python

</document_content>
</document>
<document index="66">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/run_package_tests_in_same_loop.rst</source>
<document_content>
========================================================
How to run all tests in a package in the same event loop
========================================================
All tests can be run inside the same event loop by marking them with ``pytest.mark.asyncio(loop_scope="package")``.
Add the following code to the ``__init__.py`` of the test package:

.. include:: package_scoped_loop_example.py
    :code: python

Note that this marker is not passed down to tests in subpackages.
Subpackages constitute their own, separate package.

</document_content>
</document>
<document index="67">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/run_session_tests_in_same_loop.rst</source>
<document_content>
==========================================================
How to run all tests in the session in the same event loop
==========================================================
All tests can be run inside the same event loop by marking them with ``pytest.mark.asyncio(loop_scope="session")``.
The easiest way to mark all tests is via a ``pytest_collection_modifyitems`` hook in the ``conftest.py`` at the root folder of your test suite.

.. include:: session_scoped_loop_example.py
    :code: python

Note that this will also override *all* manually applied marks in *strict* mode.

</document_content>
</document>
<document index="68">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/session_scoped_loop_example.py</source>
<document_content>
import pytest

from pytest_asyncio import is_async_test


def pytest_collection_modifyitems(items):
    pytest_asyncio_tests = (item for item in items if is_async_test(item))
    session_scope_marker = pytest.mark.asyncio(loop_scope="session")
    for async_test in pytest_asyncio_tests:
        async_test.add_marker(session_scope_marker, append=False)

</document_content>
</document>
<document index="69">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/test_item_is_async.rst</source>
<document_content>
=======================================
How to tell if a test function is async
=======================================
Use ``pytest_asyncio.is_async_item`` to determine if a test item is asynchronous and managed by pytest-asyncio.

.. include:: test_item_is_async_example.py
    :code: python

</document_content>
</document>
<document index="70">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/test_item_is_async_example.py</source>
<document_content>
from pytest_asyncio import is_async_test


def pytest_collection_modifyitems(items):
    for item in items:
        if is_async_test(item):
            pass

</document_content>
</document>
<document index="71">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/test_session_scoped_loop_example.py</source>
<document_content>
from pathlib import Path
from textwrap import dedent

from pytest import Pytester


def test_session_scoped_loop_configuration_works_in_auto_mode(
    pytester: Pytester,
):
    session_wide_mark_conftest = (
        Path(__file__).parent / "session_scoped_loop_example.py"
    )
    pytester.makeconftest(session_wide_mark_conftest.read_text())
    pytester.makepyfile(
        dedent(
            """\
            import asyncio

            session_loop = None

            async def test_store_loop(request):
                global session_loop
                session_loop = asyncio.get_running_loop()

            async def test_compare_loop(request):
                global session_loop
                assert asyncio.get_running_loop() is session_loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=auto")
    result.assert_outcomes(passed=2)


def test_session_scoped_loop_configuration_works_in_strict_mode(
    pytester: Pytester,
):
    session_wide_mark_conftest = (
        Path(__file__).parent / "session_scoped_loop_example.py"
    )
    pytester.makeconftest(session_wide_mark_conftest.read_text())
    pytester.makepyfile(
        dedent(
            """\
            import asyncio
            import pytest

            session_loop = None

            @pytest.mark.asyncio
            async def test_store_loop(request):
                global session_loop
                session_loop = asyncio.get_running_loop()

            @pytest.mark.asyncio
            async def test_compare_loop(request):
                global session_loop
                assert asyncio.get_running_loop() is session_loop
            """
        )
    )
    result = pytester.runpytest_subprocess("--asyncio-mode=strict")
    result.assert_outcomes(passed=2)

</document_content>
</document>
<document index="72">
<source>/Users/malcolm/dev/pytest-asyncio/docs/how-to-guides/uvloop.rst</source>
<document_content>
=======================
How to test with uvloop
=======================

Redefinig the *event_loop_policy* fixture will parametrize all async tests. The following example causes all async tests to run multiple times, once for each event loop in the fixture parameters:
Replace the default event loop policy in your *conftest.py:*

.. code-block:: python

    import pytest
    import uvloop


    @pytest.fixture(scope="session")
    def event_loop_policy():
        return uvloop.EventLoopPolicy()

You may choose to limit the scope of the fixture to *package,* *module,* or *class,* if you only want a subset of your tests to run with uvloop.

</document_content>
</document>
<document index="73">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/changelog.rst</source>
<document_content>
=========
Changelog
=========

0.25.1 (2025-01-02)
===================
- Fixes an issue that caused a broken event loop when a function-scoped test was executed in between two tests with wider loop scope `#950 <https://github.com/pytest-dev/pytest-asyncio/issues/950>`_
- Improves test collection speed in auto mode `#1020 <https://github.com/pytest-dev/pytest-asyncio/pull/1020>`_
- Corrects the warning that is emitted upon redefining the event_loop fixture


0.25.0 (2024-12-13)
===================
- Deprecated: Added warning when asyncio test requests async ``@pytest.fixture`` in strict mode. This will become an error in a future version of flake8-asyncio. `#979 <https://github.com/pytest-dev/pytest-asyncio/pull/979>`_
- Updates the error message about `pytest.mark.asyncio`'s `scope` keyword argument to say `loop_scope` instead. `#1004 <https://github.com/pytest-dev/pytest-asyncio/pull/1004>`_
- Verbose log displays correct parameter name: asyncio_default_fixture_loop_scope `#990 <https://github.com/pytest-dev/pytest-asyncio/pull/990>`_
- Propagates `contextvars` set in async fixtures to other fixtures and tests on Python 3.11 and above. `#1008 <https://github.com/pytest-dev/pytest-asyncio/pull/1008>`_



0.24.0 (2024-08-22)
===================
- BREAKING: Updated minimum supported pytest version to v8.2.0
- Adds an optional `loop_scope` keyword argument to `pytest.mark.asyncio`. This argument controls which event loop is used to run the marked async test. `#706`_, `#871 <https://github.com/pytest-dev/pytest-asyncio/pull/871>`_
- Deprecates the optional `scope` keyword argument to `pytest.mark.asyncio` for API consistency with ``pytest_asyncio.fixture``. Users are encouraged to use the `loop_scope` keyword argument, which does exactly the same.
- Raises an error when passing `scope` or `loop_scope` as a positional argument to ``@pytest.mark.asyncio``. `#812 <https://github.com/pytest-dev/pytest-asyncio/issues/812>`_
- Fixes a bug that caused module-scoped async fixtures to fail when reused in other modules `#862 <https://github.com/pytest-dev/pytest-asyncio/issues/862>`_ `#668 <https://github.com/pytest-dev/pytest-asyncio/issues/668>`_
- Added the ``asyncio_default_fixture_loop_scope`` configuration option `c74d1c3 <https://github.com/pytest-dev/pytest-asyncio/commit/c74d1c3fba1afac0b8316763257c915bfba5f5e3>`_


0.23.8 (2024-07-17)
===================
- Fixes a bug that caused duplicate markers in async tests `#813 <https://github.com/pytest-dev/pytest-asyncio/issues/813>`_
- Declare support for Python 3.13

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.


0.23.7 (2024-05-19)
===================
- Silence deprecation warnings about unclosed event loops that occurred with certain CPython patch releases `#817 <https://github.com/pytest-dev/pytest-asyncio/pull/817>`_

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.


0.23.6 (2024-03-19)
===================
- Fix compatibility with pytest 8.2 `#800 <https://github.com/pytest-dev/pytest-asyncio/pull/800>`_

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.


0.23.5 (2024-02-09)
===================
- Declare compatibility with pytest 8 `#737 <https://github.com/pytest-dev/pytest-asyncio/issues/737>`_
- Fix typing errors with recent versions of mypy `#769 <https://github.com/pytest-dev/pytest-asyncio/issues/769>`_
- Prevent DeprecationWarning about internal use of `asyncio.get_event_loop()` from affecting test cases `#757 <https://github.com/pytest-dev/pytest-asyncio/issues/757>`_

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.


0.23.4 (2024-01-28)
===================
- pytest-asyncio no longer imports additional, unrelated packages during test collection `#729 <https://github.com/pytest-dev/pytest-asyncio/issues/729>`_
- Addresses further issues that caused an internal pytest error during test collection
- Declares incompatibility with pytest 8 `#737 <https://github.com/pytest-dev/pytest-asyncio/issues/737>`_

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.

0.23.3 (2024-01-01)
===================
- Fixes a bug that caused event loops to be closed prematurely when using async generator fixtures with class scope or wider in a function-scoped test `#706 <https://github.com/pytest-dev/pytest-asyncio/issues/706>`_
- Fixes various bugs that caused an internal pytest error during test collection `#711 <https://github.com/pytest-dev/pytest-asyncio/issues/711>`_ `#713 <https://github.com/pytest-dev/pytest-asyncio/issues/713>`_ `#719 <https://github.com/pytest-dev/pytest-asyncio/issues/719>`_

Known issues
------------
As of v0.23, pytest-asyncio attaches an asyncio event loop to each item of the test suite (i.e. session, packages, modules, classes, functions) and allows tests to be run in those loops when marked accordingly. Pytest-asyncio currently assumes that async fixture scope is correlated with the new event loop scope. This prevents fixtures from being evaluated independently from the event loop scope and breaks some existing test suites (see `#706`_). For example, a test suite may require all fixtures and tests to run in the same event loop, but have async fixtures that are set up and torn down for each module. If you're affected by this issue, please continue using the v0.21 release, until it is resolved.


0.23.2 (2023-12-04)
===================
- Fixes a bug that caused an internal pytest error when collecting .txt files `#703 <https://github.com/pytest-dev/pytest-asyncio/issues/703>`_


0.23.1 (2023-12-03)
===================
- Fixes a bug that caused an internal pytest error when using module-level skips `#701 <https://github.com/pytest-dev/pytest-asyncio/issues/701>`_


0.23.0 (2023-12-03)
===================
This release is backwards-compatible with v0.21.
Changes are non-breaking, unless you upgrade from v0.22.

- BREAKING: The *asyncio_event_loop* mark has been removed. Event loops with class, module, package, and session scopes can be requested via the *scope* keyword argument to the _asyncio_ mark.
- Introduces the *event_loop_policy* fixture which allows testing with non-default or multiple event loops  `#662 <https://github.com/pytest-dev/pytest-asyncio/pull/662>`_
- Introduces ``pytest_asyncio.is_async_test`` which returns whether a test item is managed by pytest-asyncio `#376 <https://github.com/pytest-dev/pytest-asyncio/issues/376>`_
- Removes and *pytest-trio,* *mypy,* and *flaky* from the test dependencies `#620 <https://github.com/pytest-dev/pytest-asyncio/pull/620>`_, `#674 <https://github.com/pytest-dev/pytest-asyncio/pull/674>`_, `#678 <https://github.com/pytest-dev/pytest-asyncio/pull/678>`_,

0.22.0 (2023-10-31)
===================
This release has been yanked from PyPI due to fundamental issues with the _asyncio_event_loop_ mark.

- Class-scoped and module-scoped event loops can be requested
  via the _asyncio_event_loop_ mark. `#620 <https://github.com/pytest-dev/pytest-asyncio/pull/620>`_
- Deprecate redefinition of the `event_loop` fixture. `#587 <https://github.com/pytest-dev/pytest-asyncio/issues/531>`_
  Users requiring a class-scoped or module-scoped asyncio event loop for their tests
  should mark the corresponding class or module with `asyncio_event_loop`.
- Test items based on asynchronous generators always exit with *xfail* status and emit a warning during the collection phase. This behavior is consistent with synchronous yield tests. `#642 <https://github.com/pytest-dev/pytest-asyncio/issues/642>`__
- Remove support for Python 3.7
- Declare support for Python 3.12

0.21.2 (2024-04-29)
===================
- Fix compatibility with pytest 8.2. Backport of `#800 <https://github.com/pytest-dev/pytest-asyncio/pull/800>`_ to pytest-asyncio v0.21 for users who are unable to upgrade to a more recent version (see `#706`_)

0.21.1 (2023-07-12)
===================
- Output a proper error message when an invalid ``asyncio_mode`` is selected.
- Extend warning message about unclosed event loops with additional possible cause.
  `#531 <https://github.com/pytest-dev/pytest-asyncio/issues/531>`_
- Previously, some tests reported "skipped" or "xfailed" as a result. Now all tests report a "success" result.

0.21.0 (2023-03-19)
===================
- Drop compatibility with pytest 6.1. Pytest-asyncio now depends on pytest 7.0 or newer.
- pytest-asyncio cleans up any stale event loops when setting up and tearing down the
  event_loop fixture. This behavior has been deprecated and pytest-asyncio emits a
  DeprecationWarning when tearing down the event_loop fixture and current event loop
  has not been closed.

0.20.3 (2022-12-08)
===================
- Prevent DeprecationWarning to bubble up on CPython 3.10.9 and 3.11.1.
  `#460 <https://github.com/pytest-dev/pytest-asyncio/issues/460>`_

0.20.2 (2022-11-11)
===================
- Fixes an issue with async fixtures that are defined as methods on a test class not being rebound to the actual test instance. `#197 <https://github.com/pytest-dev/pytest-asyncio/issues/197>`_
- Replaced usage of deprecated ``@pytest.mark.tryfirst`` with ``@pytest.hookimpl(tryfirst=True)`` `#438 <https://github.com/pytest-dev/pytest-asyncio/pull/438>`_

0.20.1 (2022-10-21)
===================
- Fixes an issue that warned about using an old version of pytest, even though the most recent version was installed. `#430 <https://github.com/pytest-dev/pytest-asyncio/issues/430>`_

0.20.0 (2022-10-21)
===================
- BREAKING: Removed *legacy* mode. If you're upgrading from v0.19 and you haven't configured ``asyncio_mode = legacy``, you can upgrade without taking any additional action. If you're upgrading from an earlier version or you have explicitly enabled *legacy* mode, you need to switch to *auto* or *strict* mode before upgrading to this version.
- Deprecate use of pytest v6.
- Fixed an issue which prevented fixture setup from being cached. `#404 <https://github.com/pytest-dev/pytest-asyncio/pull/404>`_

0.19.0 (2022-07-13)
===================
- BREAKING: The default ``asyncio_mode`` is now *strict*. `#293 <https://github.com/pytest-dev/pytest-asyncio/issues/293>`_
- Removes `setup.py` since all relevant configuration is present `setup.cfg`. Users requiring an editable installation of pytest-asyncio need to use pip v21.1 or newer. `#283 <https://github.com/pytest-dev/pytest-asyncio/issues/283>`_
- Declare support for Python 3.11.

0.18.3 (2022-03-25)
===================
- Adds `pytest-trio <https://pypi.org/project/pytest-trio/>`_ to the test dependencies
- Fixes a bug that caused pytest-asyncio to try to set up async pytest_trio fixtures in strict mode. `#298 <https://github.com/pytest-dev/pytest-asyncio/issues/298>`_

0.18.2 (2022-03-03)
===================
- Fix asyncio auto mode not marking static methods. `#295 <https://github.com/pytest-dev/pytest-asyncio/issues/295>`_
- Fix a compatibility issue with Hypothesis 6.39.0. `#302 <https://github.com/pytest-dev/pytest-asyncio/issues/302>`_

0.18.1 (2022-02-10)
===================
- Fixes a regression that prevented async fixtures from working in synchronous tests. `#286 <https://github.com/pytest-dev/pytest-asyncio/issues/286>`_

0.18.0 (2022-02-07)
===================

- Raise a warning if @pytest.mark.asyncio is applied to non-async function. `#275 <https://github.com/pytest-dev/pytest-asyncio/issues/275>`_
- Support parametrized ``event_loop`` fixture. `#278 <https://github.com/pytest-dev/pytest-asyncio/issues/278>`_

0.17.2 (2022-01-17)
===================

- Require ``typing-extensions`` on Python<3.8 only. `#269 <https://github.com/pytest-dev/pytest-asyncio/issues/269>`_
- Fix a regression in tests collection introduced by 0.17.1, the plugin works fine with non-python tests again. `#267 <https://github.com/pytest-dev/pytest-asyncio/issues/267>`_


0.17.1 (2022-01-16)
===================
- Fixes a bug that prevents async Hypothesis tests from working without explicit ``asyncio`` marker when ``--asyncio-mode=auto`` is set. `#258 <https://github.com/pytest-dev/pytest-asyncio/issues/258>`_
- Fixed a bug that closes the default event loop if the loop doesn't exist `#257 <https://github.com/pytest-dev/pytest-asyncio/issues/257>`_
- Added type annotations. `#198 <https://github.com/pytest-dev/pytest-asyncio/issues/198>`_
- Show asyncio mode in pytest report headers. `#266 <https://github.com/pytest-dev/pytest-asyncio/issues/266>`_
- Relax ``asyncio_mode`` type definition; it allows to support pytest 6.1+. `#262 <https://github.com/pytest-dev/pytest-asyncio/issues/262>`_

0.17.0 (2022-01-13)
===================
- `pytest-asyncio` no longer alters existing event loop policies. `#168 <https://github.com/pytest-dev/pytest-asyncio/issues/168>`_, `#188 <https://github.com/pytest-dev/pytest-asyncio/issues/168>`_
- Drop support for Python 3.6
- Fixed an issue when pytest-asyncio was used in combination with `flaky` or inherited asynchronous Hypothesis tests. `#178 <https://github.com/pytest-dev/pytest-asyncio/issues/178>`_ `#231 <https://github.com/pytest-dev/pytest-asyncio/issues/231>`_
- Added `flaky <https://pypi.org/project/flaky/>`_ to test dependencies
- Added ``unused_udp_port`` and ``unused_udp_port_factory`` fixtures (similar to ``unused_tcp_port`` and ``unused_tcp_port_factory`` counterparts. `#99 <https://github.com/pytest-dev/pytest-asyncio/issues/99>`_
- Added the plugin modes: *strict*, *auto*, and *legacy*. See `documentation <https://github.com/pytest-dev/pytest-asyncio#modes>`_ for details. `#125 <https://github.com/pytest-dev/pytest-asyncio/issues/125>`_
- Correctly process ``KeyboardInterrupt`` during async fixture setup phase `#219 <https://github.com/pytest-dev/pytest-asyncio/issues/219>`_

0.16.0 (2021-10-16)
===================
- Add support for Python 3.10

0.15.1 (2021-04-22)
===================
- Hotfix for errors while closing event loops while replacing them.
  `#209 <https://github.com/pytest-dev/pytest-asyncio/issues/209>`_
  `#210 <https://github.com/pytest-dev/pytest-asyncio/issues/210>`_

0.15.0 (2021-04-19)
===================
- Add support for Python 3.9
- Abandon support for Python 3.5. If you still require support for Python 3.5, please use pytest-asyncio v0.14 or earlier.
- Set ``unused_tcp_port_factory`` fixture scope to 'session'.
  `#163 <https://github.com/pytest-dev/pytest-asyncio/pull/163>`_
- Properly close event loops when replacing them.
  `#208 <https://github.com/pytest-dev/pytest-asyncio/issues/208>`_

0.14.0 (2020-06-24)
===================
- Fix `#162 <https://github.com/pytest-dev/pytest-asyncio/issues/162>`_, and ``event_loop`` fixture behavior now is coherent on all scopes.
  `#164 <https://github.com/pytest-dev/pytest-asyncio/pull/164>`_

0.12.0 (2020-05-04)
===================
- Run the event loop fixture as soon as possible. This helps with fixtures that have an implicit dependency on the event loop.
  `#156 <https://github.com/pytest-dev/pytest-asyncio/pull/156>`_

0.11.0 (2020-04-20)
===================
- Test on 3.8, drop 3.3 and 3.4. Stick to 0.10 for these versions.
  `#152 <https://github.com/pytest-dev/pytest-asyncio/pull/152>`_
- Use the new Pytest 5.4.0 Function API. We therefore depend on pytest >= 5.4.0.
  `#142 <https://github.com/pytest-dev/pytest-asyncio/pull/142>`_
- Better ``pytest.skip`` support.
  `#126 <https://github.com/pytest-dev/pytest-asyncio/pull/126>`_

0.10.0 (2019-01-08)
====================
- ``pytest-asyncio`` integrates with `Hypothesis <https://hypothesis.readthedocs.io>`_
  to support ``@given`` on async test functions using ``asyncio``.
  `#102 <https://github.com/pytest-dev/pytest-asyncio/pull/102>`_
- Pytest 4.1 support.
  `#105 <https://github.com/pytest-dev/pytest-asyncio/pull/105>`_

0.9.0 (2018-07-28)
==================
- Python 3.7 support.
- Remove ``event_loop_process_pool`` fixture and
  ``pytest.mark.asyncio_process_pool`` marker (see
  https://bugs.python.org/issue34075 for deprecation and removal details)

0.8.0 (2017-09-23)
==================
- Improve integration with other packages (like aiohttp) with more careful event loop handling.
  `#64 <https://github.com/pytest-dev/pytest-asyncio/pull/64>`_

0.7.0 (2017-09-08)
==================
- Python versions pre-3.6 can use the async_generator library for async fixtures.
  `#62 <https://github.com/pytest-dev/pytest-asyncio/pull/62>`

0.6.0 (2017-05-28)
==================
- Support for Python versions pre-3.5 has been dropped.
- ``pytestmark`` now works on both module and class level.
- The ``forbid_global_loop`` parameter has been removed.
- Support for async and async gen fixtures has been added.
  `#45 <https://github.com/pytest-dev/pytest-asyncio/pull/45>`_
- The deprecation warning regarding ``asyncio.async()`` has been fixed.
  `#51 <https://github.com/pytest-dev/pytest-asyncio/pull/51>`_

0.5.0 (2016-09-07)
==================
- Introduced a changelog.
  `#31 <https://github.com/pytest-dev/pytest-asyncio/issues/31>`_
- The ``event_loop`` fixture is again responsible for closing itself.
  This makes the fixture slightly harder to correctly override, but enables
  other fixtures to depend on it correctly.
  `#30 <https://github.com/pytest-dev/pytest-asyncio/issues/30>`_
- Deal with the event loop policy by wrapping a special pytest hook,
  ``pytest_fixture_setup``. This allows setting the policy before fixtures
  dependent on the ``event_loop`` fixture run, thus allowing them to take
  advantage of the ``forbid_global_loop`` parameter. As a consequence of this,
  we now depend on pytest 3.0.
  `#29 <https://github.com/pytest-dev/pytest-asyncio/issues/29>`_

0.4.1 (2016-06-01)
==================
- Fix a bug preventing the propagation of exceptions from the plugin.
  `#25 <https://github.com/pytest-dev/pytest-asyncio/issues/25>`_

0.4.0 (2016-05-30)
==================
- Make ``event_loop`` fixtures simpler to override by closing them in the
  plugin, instead of directly in the fixture.
  `#21 <https://github.com/pytest-dev/pytest-asyncio/pull/21>`_
- Introduce the ``forbid_global_loop`` parameter.
  `#21 <https://github.com/pytest-dev/pytest-asyncio/pull/21>`_

0.3.0 (2015-12-19)
==================
- Support for Python 3.5 ``async``/``await`` syntax.
  `#17 <https://github.com/pytest-dev/pytest-asyncio/pull/17>`_

0.2.0 (2015-08-01)
==================
- ``unused_tcp_port_factory`` fixture.
  `#10 <https://github.com/pytest-dev/pytest-asyncio/issues/10>`_

0.1.1 (2015-04-23)
==================
Initial release.

</document_content>
</document>
<document index="74">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/configuration.rst</source>
<document_content>
=============
Configuration
=============

.. _configuration/asyncio_default_fixture_loop_scope:

asyncio_default_fixture_loop_scope
==================================
Determines the default event loop scope of asynchronous fixtures. When this configuration option is unset, it defaults to the fixture scope. In future versions of pytest-asyncio, the value will default to ``function`` when unset. Possible values are: ``function``, ``class``, ``module``, ``package``, ``session``

asyncio_mode
============
The pytest-asyncio mode can be set by the ``asyncio_mode`` configuration option in the `configuration file
<https://docs.pytest.org/en/latest/reference/customize.html>`_:

.. code-block:: ini

   # pytest.ini
   [pytest]
   asyncio_mode = auto

The value can also be set via the ``--asyncio-mode`` command-line option:

.. code-block:: bash

   $ pytest tests --asyncio-mode=strict


If the asyncio mode is set in both the pytest configuration file and the command-line option, the command-line option takes precedence. If no asyncio mode is specified, the mode defaults to `strict`.

</document_content>
</document>
<document index="75">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/functions.rst</source>
<document_content>
=========
Functions
=========

is_async_test
=============
Returns whether a specific pytest Item is an asynchronous test managed by pytest-asyncio.

This function is intended to be used in pytest hooks or by plugins that depend on pytest-asyncio.

</document_content>
</document>
<document index="76">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/index.rst</source>
<document_content>
=========
Reference
=========

.. toctree::
  :hidden:

  configuration
  fixtures/index
  functions
  markers/index
  decorators/index
  changelog

This section of the documentation provides descriptions of the individual parts provided by pytest-asyncio.
The reference section also provides a chronological list of changes for each release.

</document_content>
</document>
<document index="77">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/class_scoped_loop_custom_policies_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest


@pytest.fixture(
    params=[
        asyncio.DefaultEventLoopPolicy(),
        asyncio.DefaultEventLoopPolicy(),
    ]
)
def event_loop_policy(request):
    return request.param


class TestWithDifferentLoopPolicies:
    @pytest.mark.asyncio
    async def test_parametrized_loop(self):
        pass

</document_content>
</document>
<document index="78">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/class_scoped_loop_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest


@pytest.mark.asyncio(loop_scope="class")
class TestClassScopedLoop:
    loop: asyncio.AbstractEventLoop

    async def test_remember_loop(self):
        TestClassScopedLoop.loop = asyncio.get_running_loop()

    async def test_this_runs_in_same_loop(self):
        assert asyncio.get_running_loop() is TestClassScopedLoop.loop

</document_content>
</document>
<document index="79">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/class_scoped_loop_with_fixture_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest

import pytest_asyncio


@pytest.mark.asyncio(loop_scope="class")
class TestClassScopedLoop:
    loop: asyncio.AbstractEventLoop

    @pytest_asyncio.fixture(loop_scope="class")
    async def my_fixture(self):
        TestClassScopedLoop.loop = asyncio.get_running_loop()

    async def test_runs_is_same_loop_as_fixture(self, my_fixture):
        assert asyncio.get_running_loop() is TestClassScopedLoop.loop

</document_content>
</document>
<document index="80">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/function_scoped_loop_pytestmark_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest

# Marks all test coroutines in this module
pytestmark = pytest.mark.asyncio


async def test_runs_in_asyncio_event_loop():
    assert asyncio.get_running_loop()

</document_content>
</document>
<document index="81">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/function_scoped_loop_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest


@pytest.mark.asyncio
async def test_runs_in_asyncio_event_loop():
    assert asyncio.get_running_loop()

</document_content>
</document>
<document index="82">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/index.rst</source>
<document_content>
=======
Markers
=======

.. _reference/markers/asyncio:

``pytest.mark.asyncio``
=======================
A coroutine or async generator with this marker is treated as a test function by pytest.
The marked function is executed as an asyncio task in the event loop provided by pytest-asyncio.

.. include:: function_scoped_loop_strict_mode_example.py
    :code: python

Multiple async tests in a single class or module can be marked using |pytestmark|_.

.. include:: function_scoped_loop_pytestmark_strict_mode_example.py
    :code: python

The ``pytest.mark.asyncio`` marker can be omitted entirely in |auto mode|_ where the *asyncio* marker is added automatically to *async* test functions.

By default, each test runs in it's own asyncio event loop.
Multiple tests can share the same event loop by providing a *loop_scope* keyword argument to the *asyncio* mark.
The supported scopes are *class,* and *module,* and *package*.
The following code example provides a shared event loop for all tests in `TestClassScopedLoop`:

.. include:: class_scoped_loop_strict_mode_example.py
    :code: python

If you request class scope for a test that is not part of a class, it will result in a *UsageError*.
Similar to class-scoped event loops, a module-scoped loop is provided when setting mark's scope to *module:*

.. include:: module_scoped_loop_strict_mode_example.py
    :code: python

Package-scoped loops only work with `regular Python packages. <https://docs.python.org/3/glossary.html#term-regular-package>`__
That means they require an *__init__.py* to be present.
Package-scoped loops do not work in `namespace packages. <https://docs.python.org/3/glossary.html#term-namespace-package>`__
Subpackages do not share the loop with their parent package.

Tests marked with *session* scope share the same event loop, even if the tests exist in different packages.

.. |auto mode| replace:: *auto mode*
.. _auto mode: ../../concepts.html#auto-mode
.. |pytestmark| replace:: ``pytestmark``
.. _pytestmark: http://doc.pytest.org/en/latest/example/markers.html#marking-whole-classes-or-modules

</document_content>
</document>
<document index="83">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/markers/module_scoped_loop_strict_mode_example.py</source>
<document_content>
import asyncio

import pytest

pytestmark = pytest.mark.asyncio(loop_scope="module")

loop: asyncio.AbstractEventLoop


async def test_remember_loop():
    global loop
    loop = asyncio.get_running_loop()


async def test_this_runs_in_same_loop():
    global loop
    assert asyncio.get_running_loop() is loop


class TestClassA:
    async def test_this_runs_in_same_loop(self):
        global loop
        assert asyncio.get_running_loop() is loop

</document_content>
</document>
<document index="84">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/decorators/index.rst</source>
<document_content>
.. _decorators/pytest_asyncio_fixture:

==========
Decorators
==========
The ``@pytest_asyncio.fixture`` decorator allows coroutines and async generator functions to be used as pytest fixtures.

The decorator takes all arguments supported by `@pytest.fixture`.
Additionally, ``@pytest_asyncio.fixture`` supports the *loop_scope* keyword argument, which selects the event loop in which the fixture is run (see :ref:`concepts/event_loops`).
The default event loop scope is *function* scope.
Possible loop scopes are *session,* *package,* *module,* *class,* and *function*.

The *loop_scope* of a fixture can be chosen independently from its caching *scope*.
However, the event loop scope must be larger or the same as the fixture's caching scope.
In other words, it's possible to reevaluate an async fixture multiple times within the same event loop, but it's not possible to switch out the running event loop in an async fixture.

Examples:

.. include:: pytest_asyncio_fixture_example.py
    :code: python

*auto* mode automatically converts coroutines and async generator functions declared with the standard ``@pytest.fixture`` decorator to pytest-asyncio fixtures.

</document_content>
</document>
<document index="85">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/decorators/pytest_asyncio_fixture_example.py</source>
<document_content>
import pytest_asyncio


@pytest_asyncio.fixture
async def fixture_runs_in_fresh_loop_for_every_function(): ...


@pytest_asyncio.fixture(loop_scope="session", scope="module")
async def fixture_runs_in_session_loop_once_per_module(): ...


@pytest_asyncio.fixture(loop_scope="module", scope="module")
async def fixture_runs_in_module_loop_once_per_module(): ...


@pytest_asyncio.fixture(loop_scope="module")
async def fixture_runs_in_module_loop_once_per_function(): ...

</document_content>
</document>
<document index="86">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/fixtures/event_loop_example.py</source>
<document_content>
import asyncio


def test_event_loop_fixture(event_loop):
    event_loop.run_until_complete(asyncio.sleep(0))

</document_content>
</document>
<document index="87">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/fixtures/event_loop_policy_example.py</source>
<document_content>
import asyncio

import pytest


class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
    pass


@pytest.fixture(scope="module")
def event_loop_policy(request):
    return CustomEventLoopPolicy()


@pytest.mark.asyncio(loop_scope="module")
async def test_uses_custom_event_loop_policy():
    assert isinstance(asyncio.get_event_loop_policy(), CustomEventLoopPolicy)

</document_content>
</document>
<document index="88">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/fixtures/event_loop_policy_parametrized_example.py</source>
<document_content>
import asyncio
from asyncio import DefaultEventLoopPolicy

import pytest


class CustomEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
    pass


@pytest.fixture(
    params=(
        DefaultEventLoopPolicy(),
        CustomEventLoopPolicy(),
    ),
)
def event_loop_policy(request):
    return request.param


@pytest.mark.asyncio
async def test_uses_custom_event_loop_policy():
    assert isinstance(asyncio.get_event_loop_policy(), DefaultEventLoopPolicy)

</document_content>
</document>
<document index="89">
<source>/Users/malcolm/dev/pytest-asyncio/docs/reference/fixtures/index.rst</source>
<document_content>
========
Fixtures
========

event_loop
==========
*This fixture is deprecated.*

*If you want to request an asyncio event loop with a scope other than function
scope, use the "loop_scope" argument to* :ref:`reference/markers/asyncio` *when marking the tests.
If you want to return different types of event loops, use the* :ref:`reference/fixtures/event_loop_policy`
*fixture.*

Creates a new asyncio event loop based on the current event loop policy. The new loop
is available as the return value of this fixture for synchronous functions, or via `asyncio.get_running_loop <https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop>`__ for asynchronous functions.
The event loop is closed when the fixture scope ends.
The fixture scope defaults to ``function`` scope.

.. include:: event_loop_example.py
    :code: python

Note that, when using the ``event_loop`` fixture, you need to interact with the event loop using methods like ``event_loop.run_until_complete``. If you want to *await* code inside your test function, you need to write a coroutine and use it as a test function. The :ref:`asyncio <reference/markers/asyncio>` marker
is used to mark coroutines that should be treated as test functions.

If you need to change the type of the event loop, prefer setting a custom event loop policy over redefining the ``event_loop`` fixture.

If the ``pytest.mark.asyncio`` decorator is applied to a test function, the ``event_loop``
fixture will be requested automatically by the test function.

.. _reference/fixtures/event_loop_policy:

event_loop_policy
=================
Returns the event loop policy used to create asyncio event loops.
The default return value is *asyncio.get_event_loop_policy().*

This fixture can be overridden when a different event loop policy should be used.

.. include:: event_loop_policy_example.py
    :code: python

Multiple policies can be provided via fixture parameters.
The fixture is automatically applied to all pytest-asyncio tests.
Therefore, all tests managed by pytest-asyncio are run once for each fixture parameter.
The following example runs the test with different event loop policies.

.. include:: event_loop_policy_parametrized_example.py
    :code: python

unused_tcp_port
===============
Finds and yields a single unused TCP port on the localhost interface. Useful for
binding temporary test servers.

unused_tcp_port_factory
=======================
A callable which returns a different unused TCP port each invocation. Useful
when several unused TCP ports are required in a test.

.. code-block:: python

    def a_test(unused_tcp_port_factory):
        _port1, _port2 = unused_tcp_port_factory(), unused_tcp_port_factory()

unused_udp_port and unused_udp_port_factory
===========================================
Works just like their TCP counterparts but returns unused UDP ports.

</document_content>
</document>
</documents>
