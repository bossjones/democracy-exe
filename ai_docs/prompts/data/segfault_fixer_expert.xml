<?xml version="1.0" encoding="UTF-8"?>
<segfault_guidelines>
    <system>
        This document serves as an expert guide for analyzing and fixing segmentation faults in Python applications, with a specific focus on concurrent operations, resource management, and thread safety in the context of LangChain and LangGraph applications.
    </system>

    <context>
        The democracy-exe project experiences segmentation faults during concurrent operations, particularly in LangSmith client background threads and LangGraph SSE handling. This document provides comprehensive analysis and actionable guidelines for fixing these issues through proper resource management, thread safety, and async operation handling.
    </context>

    <instructions>
        1. Follow the diagnostic points to identify similar issues in your code
        2. Implement the recommended fixes based on priority
        3. Use the provided code patterns as templates for implementation
        4. Add appropriate tests based on the testing recommendations
        5. Ensure all implementations follow the style preferences
    </instructions>

    <style_preferences>
        - Use comprehensive error handling with proper cleanup
        - Implement full type annotations for all functions
        - Add detailed docstrings following Google style
        - Use clear, descriptive variable and function names
        - Include comments explaining complex concurrent operations
        - Follow async/await best practices consistently
        - Maintain clear separation between blocking and non-blocking code
    </style_preferences>

    <quotes>
        <quote source="error_trace">
            Thread 0x0000ffff5fe0f180 shows issues in LangSmith client background thread operations, particularly in _multipart_ingest_ops and _tracing_thread_handle_batch
        </quote>
        <quote source="error_trace">
            Current thread shows the error occurring in langgraph_api/sse.py during stream_response, indicating potential issues with SSE handling
        </quote>
        <quote source="error_trace">
            Multiple threads show concurrent operations involving asyncio, threading, and multiprocessing
        </quote>
        <quote source="democracy_exe/utils/async_.py">
            Detected I/O inside the event loop. This is causing stability issues. Please report issue for integration doing I/O
        </quote>
        <quote source="democracy_exe/utils/aiodbx.py">
            SafeFileHandler implements proper error handling and cleanup with async context management
        </quote>
        <quote source="democracy_exe/clients/aio_gallery_dl.py">
            Run a function in the default executor to avoid blocking the event loop
        </quote>
        <quote source="democracy_exe/chatbot/cogs/autocrop.py">
            Thread pools being shut down without waiting: pool.shutdown(wait=False)
        </quote>
        <quote source="democracy_exe/utils/async_.py">
            I/O must be done in the executor; Use `await hass.async_add_executor_job()` at {found_frame.filename[index:]}, line {found_frame.lineno}: {found_frame.line.strip()}
        </quote>
        <quote source="democracy_exe/utils/aiodbx.py">
            async with self._cleanup_lock: if self._closed: return
        </quote>
        <quote source="democracy_exe/utils/twitter_utils/storage.py">
            Proper cleanup pattern: try: await self.cleanup() finally: await self.close()
        </quote>
        <quote source="democracy_exe/chatbot/terminal_bot.py">
            SEM = asyncio.Semaphore(1) # Thread synchronization example
        </quote>
        <quote source="democracy_exe/__init__.py">
            Ensure proper initialization sequence for LangSmith and LangGraph components
        </quote>
        <quote source="democracy_exe/aio_settings.py">
            Configure thread and process pools with appropriate lifecycle management
        </quote>
        <quote source="democracy_exe/base.py">
            Implement proper resource cleanup in base classes for consistent behavior
        </quote>
    </quotes>

    <info>
        <diagnostic_points>
            <point>The segfault occurs during concurrent operations involving LangSmith client background threads</point>
            <point>Server-Sent Events (SSE) handling in LangGraph API may be triggering memory corruption</point>
            <point>Multiple Python extension modules are loaded which could contribute to thread safety issues</point>
            <point>The error involves interaction between asyncio, threading, and multiprocessing</point>
            <point>I/O operations being performed inside event loop causing stability issues</point>
            <point>Thread pools being shut down prematurely without proper cleanup</point>
            <point>Resources not being properly cleaned up in async context managers</point>
            <point>Missing synchronization for shared resource access across threads</point>
            <point>Improper handling of cleanup locks leading to resource leaks</point>
            <point>Lack of proper error boundaries in async operations</point>
            <point>Missing thread synchronization in critical sections</point>
            <point>Improper shutdown sequence for thread pools and executors</point>
            <point>Initialization sequence may not properly handle component dependencies</point>
            <point>Resource cleanup during shutdown may be incomplete or out of order</point>
            <point>Thread pool configuration may not be optimized for the application's needs</point>
            <point>Base class implementations may not consistently handle resource cleanup</point>
        </diagnostic_points>

        <recommended_fixes>
            <fix priority="high">
                <issue>LangSmith Client Thread Safety</issue>
                <solution>
                    <step>Ensure LangSmith client is properly initialized with thread-safe configuration</step>
                    <step>Implement proper cleanup of background threads</step>
                    <step>Add thread synchronization mechanisms for shared resources</step>
                    <step>Use asyncio.Lock() for thread synchronization</step>
                    <step>Implement proper cleanup in async context managers</step>
                </solution>
            </fix>

            <fix priority="high">
                <issue>SSE Stream Handling</issue>
                <solution>
                    <step>Implement proper resource cleanup in stream_response</step>
                    <step>Add error boundaries around SSE stream handling</step>
                    <step>Ensure proper closing of connections and cleanup of resources</step>
                    <step>Use SafeFileHandler pattern for file operations</step>
                    <step>Add proper exception handling with cleanup in finally blocks</step>
                </solution>
            </fix>

            <fix priority="medium">
                <issue>Extension Module Interactions</issue>
                <solution>
                    <step>Review extension module initialization order</step>
                    <step>Ensure proper GIL handling in extension modules</step>
                    <step>Add cleanup handlers for extension module resources</step>
                    <step>Move I/O operations to executors using run_in_executor</step>
                </solution>
            </fix>

            <fix priority="medium">
                <issue>Concurrent Operations</issue>
                <solution>
                    <step>Implement proper shutdown sequence for all threads</step>
                    <step>Add proper exception handling in thread workers</step>
                    <step>Use thread pools with proper lifecycle management</step>
                    <step>Ensure thread pools are shut down with wait=True when appropriate</step>
                    <step>Add proper coordination between asyncio, threading and multiprocessing</step>
                </solution>
            </fix>
        </recommended_fixes>

        <implementation_guidelines>
            <guideline>
                <name>Thread Safety</name>
                <description>
                    - Use thread-local storage for thread-specific data
                    - Implement proper locking mechanisms using asyncio.Lock()
                    - Ensure proper resource cleanup on thread exit
                    - Add synchronization for shared resource access
                    - Use thread pools with proper lifecycle management
                </description>
            </guideline>

            <guideline>
                <name>Resource Management</name>
                <description>
                    - Implement proper context managers for resource cleanup
                    - Use SafeFileHandler pattern for file operations
                    - Add proper error handling and cleanup in finally blocks
                    - Ensure proper closing of connections and resources
                    - Implement proper cleanup in async context managers
                </description>
            </guideline>

            <guideline>
                <name>Memory Management</name>
                <description>
                    - Monitor memory usage in background threads
                    - Implement proper cleanup of large objects
                    - Use memory profiling tools to identify leaks
                    - Ensure proper cleanup of resources in __aexit__ methods
                    - Add proper exception handling with cleanup
                </description>
            </guideline>

            <guideline>
                <name>Error Handling</name>
                <description>
                    - Add comprehensive error logging
                    - Implement proper error propagation
                    - Add error recovery mechanisms
                    - Add error boundaries around thread operations
                    - Ensure proper cleanup in error cases
                </description>
            </guideline>

            <guideline>
                <name>Event Loop Safety</name>
                <description>
                    - Move I/O operations out of event loop using run_in_executor
                    - Add proper error boundaries around async operations
                    - Avoid mixing blocking and non-blocking code
                    - Use proper async context management
                    - Implement proper coordination between different execution contexts
                </description>
            </guideline>

            <guideline>
                <n>Functionality Preservation</n>
                <description>
                    - Verify all original functionality is preserved after modifications
                    - Document any removed functionality that needs to be restored
                    - Report any functionality changes at the end of generation
                    - Ensure critical functions maintain their original behavior
                    - Track and report any API changes that affect backwards compatibility
                </description>
            </guideline>
        </implementation_guidelines>

        <testing_recommendations>
            <recommendation>Add stress tests for concurrent operations</recommendation>
            <recommendation>Implement memory leak tests</recommendation>
            <recommendation>Add thread safety tests</recommendation>
            <recommendation>Test proper cleanup of resources</recommendation>
            <recommendation>Add tests for proper thread pool lifecycle management</recommendation>
            <recommendation>Test error handling and recovery mechanisms</recommendation>
            <recommendation>Add tests for proper async context management</recommendation>
            <recommendation>Test proper coordination between different execution contexts</recommendation>
            <recommendation>Ensure event loops are properly scoped and managed in tests</recommendation>
            <recommendation>Test thread-safe operations from both async and non-async contexts</recommendation>
            <recommendation>Verify proper cleanup of event loop references</recommendation>
            <recommendation>Test thread synchronization with explicit coordination mechanisms</recommendation>

            <async_testing_patterns>
                <pattern name="event_loop_management">
                    <description>
                        When testing async code that involves event loops:
                        - Store event loops at appropriate scope (function, class, module)
                        - Verify event loop is running before use
                        - Clean up event loop references after use
                        - Handle event loop access from different threads properly
                        - Use proper fixture scopes for event loops
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio(loop_scope="module")
                        class TestAsync:
                            # Store loop at class level for shared access
                            _loop: asyncio.AbstractEventLoop | None = None

                            async def test_remember_loop(self) -> None:
                                """Test loop storage for shared tests."""
                                current_loop = asyncio.get_running_loop()
                                assert isinstance(current_loop, asyncio.AbstractEventLoop)
                                TestAsync._loop = current_loop
                                assert current_loop.is_running()
                        ]]>
                    </example>
                </pattern>

                <pattern name="thread_safe_event_testing">
                    <description>
                        When testing thread-safe event coordination:
                        - Create events in proper async context
                        - Use explicit thread synchronization
                        - Test multiple concurrent waiters
                        - Verify proper cleanup in all scenarios
                        - Test error handling in different contexts
                        - Use appropriate timeouts to prevent hangs
                    </description>
                    <example>
                        <![CDATA[
                        async def test_thread_safe_event(self) -> None:
                            event = ThreadSafeEvent()  # Create in async context
                            results: list[bool] = []
                            ready_event = threading.Event()  # Thread coordination

                            async def waiter() -> None:
                                try:
                                    await asyncio.wait_for(event.wait(), timeout=2.0)
                                    results.append(True)
                                except TimeoutError:
                                    results.append(False)

                            def thread_set() -> None:
                                ready_event.wait(timeout=1.0)  # Wait for signal
                                event.set()

                            # Coordinate threads explicitly
                            thread = threading.Thread(target=thread_set)
                            thread.start()
                            ready_event.set()
                            await asyncio.gather(*[waiter() for _ in range(5)])
                            thread.join()
                        ]]>
                    </example>
                </pattern>

                <pattern name="resource_cleanup_verification">
                    <description>
                        When testing resource cleanup:
                        - Verify all resources are properly closed
                        - Test cleanup during normal operation
                        - Test cleanup during exceptions
                        - Verify resource state after cleanup
                        - Test operations after cleanup
                        - Ensure proper reference cleanup
                    </description>
                    <example>
                        <![CDATA[
                        # Test cleanup and post-cleanup state
                        event.close()
                        assert event._closed, "Event should be closed"
                        assert event._event is None, "Internal event should be None"
                        assert event._loop is None, "Event loop reference should be cleared"

                        # Verify operations after cleanup
                        event.set()  # Should return silently
                        event.clear()  # Should return silently
                        with pytest.raises(RuntimeError, match="Event is closed"):
                            await event.wait()
                        ]]>
                    </example>
                </pattern>

                <pattern name="thread_context_validation">
                    <description>
                        When testing operations across different thread contexts:
                        - Test creation in async vs non-async contexts
                        - Verify proper error handling in wrong contexts
                        - Test thread-safe operations from different threads
                        - Ensure proper error messages for context violations
                        - Test thread coordination mechanisms
                    </description>
                    <example>
                        <![CDATA[
                        # Test creating event in non-async context
                        def create_event_in_thread() -> None:
                            with pytest.raises(RuntimeError,
                                match="must be created from an async context"):
                                ThreadSafeEvent()

                        thread = threading.Thread(target=create_event_in_thread)
                        thread.start()
                        thread.join()
                        ]]>
                    </example>
                </pattern>
            </async_testing_patterns>

            <iterative_testing_strategy>
                <description>
                    When developing and debugging tests, use an iterative approach focusing on individual tests to isolate issues and ensure thorough coverage. This methodical approach allows you to:
                    - Focus on one test at a time
                    - Get detailed debugging information
                    - Quickly iterate on test implementations
                    - Understand test failures more clearly
                </description>

                <execution_pattern>
                    <command>
                        <![CDATA[
                        # Base format for running individual tests with maximum debugging info
                        uv run pytest -s --record-mode=none --verbose -vvvv --showlocals --tb=short tests/test_file.py -k test_name

                        # Example: Testing thread safety in isolation
                        uv run pytest -s --record-mode=none --verbose -vvvv --showlocals --tb=short tests/test_async.py -k test_thread_safe_event
                        ]]>
                    </command>

                    <flag_explanations>
                        <flag>-s: Show print statements and other output</flag>
                        <flag>--record-mode=none: Disable any recording features</flag>
                        <flag>--verbose -vvvv: Maximum verbosity for detailed test information</flag>
                        <flag>--showlocals: Display local variables on test failure</flag>
                        <flag>--tb=short: Concise traceback format</flag>
                        <flag>-k test_name: Filter to run only tests matching the given name</flag>
                    </flag_explanations>

                    <usage_scenarios>
                        <scenario>Implementing new test cases</scenario>
                        <scenario>Debugging failing tests</scenario>
                        <scenario>Refining test assertions</scenario>
                        <scenario>Investigating timing-related issues</scenario>
                        <scenario>Troubleshooting thread safety problems</scenario>
                        <scenario>Verifying resource cleanup</scenario>
                        <scenario>Testing error handling paths</scenario>
                    </usage_scenarios>
                </execution_pattern>

                <best_practices>
                    <practice>Start with simple test cases and gradually add complexity</practice>
                    <practice>Use descriptive test names that indicate the scenario being tested</practice>
                    <practice>Add detailed comments explaining complex test setups</practice>
                    <practice>Include proper error handling in test fixtures</practice>
                    <practice>Clean up resources even if tests fail</practice>
                    <practice>Test both success and failure paths</practice>
                    <practice>Verify thread safety with concurrent operations</practice>
                </best_practices>
            </iterative_testing_strategy>

            <async_testing_guidelines>
                <guideline>
                    <name>Event Loop Management</name>
                    <description>
                        - Use @pytest.mark.asyncio for all async tests
                        - Configure asyncio_mode = auto in pytest config
                        - Use loop_scope="module" for class-based tests sharing a loop
                        - Initialize loops properly with _async_setup_hook()
                        - Clean up loops in teardown with shutdown_asyncgens() and close()
                        - Handle event loop lifecycle consistently across tests
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio(loop_scope="module")
                        class TestAsyncOperations:
                            async def test_async_operation(self):
                                await self.setup_loop()
                                try:
                                    await self.run_test()
                                finally:
                                    await self.cleanup_loop()
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Resource Cleanup</name>
                    <description>
                        - Clear shared resources between tests
                        - Use fixtures for proper setup/teardown
                        - Implement proper cleanup in async context managers
                        - Handle executor shutdown carefully to avoid deadlocks
                        - Close all async generators before loop shutdown
                        - Ensure proper cleanup order in teardown
                    </description>
                    <example>
                        <![CDATA[
                        @pytest_asyncio.fixture
                        async def database():
                            db = await setup_test_db()
                            yield db
                            await db.cleanup()
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Error Handling</name>
                    <description>
                        - Re-raise errors in test environment for better debugging
                        - Use structured logging for test output
                        - Implement proper exception boundaries
                        - Add comprehensive error context
                        - Track and log all async operations
                        - Handle timeouts properly
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_with_error_handling():
                            with structlog.testing.capture_logs() as logs:
                                try:
                                    await async_operation()
                                except Exception as e:
                                    assert "expected error" in str(e)
                                    assert any(
                                        "error_event" in log.get("event")
                                        for log in logs
                                    )
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Test Organization</name>
                    <description>
                        - Group related tests in classes with shared loop
                        - Use fixtures for common setup/teardown
                        - Separate unit and integration tests
                        - Add proper type annotations for test functions
                        - Document test requirements and assumptions
                        - Maintain consistent test structure
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        @pytest.mark.integration
                        class TestIntegration:
                            @pytest_asyncio.fixture(autouse=True)
                            async def setup(self):
                                self.resource = await setup_test_resource()
                                yield
                                await cleanup_test_resource(self.resource)
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Thread Safety Testing</name>
                    <description>
                        - Use thread-safe event handling in tests
                        - Implement proper synchronization for shared resources
                        - Handle concurrent operations carefully
                        - Use proper thread pool management
                        - Clean up thread resources in teardown
                        - Test thread interaction scenarios
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_thread_safety():
                            async with ThreadPoolManager() as pool:
                                futures = [
                                    pool.submit(thread_operation)
                                    for _ in range(10)
                                ]
                                results = await asyncio.gather(*futures)
                                assert all(results)
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Event Loop Policy Management</name>
                    <description>
                        - Configure custom event loop policies when needed
                        - Handle policy changes safely between tests
                        - Restore default policies in teardown
                        - Handle platform-specific policy requirements
                        - Ensure proper cleanup of policy changes
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.fixture
                        def event_loop_policy(request):
                            """Configure and cleanup custom event loop policies."""
                            original_policy = asyncio.get_event_loop_policy()
                            policy = CustomEventLoopPolicy()
                            asyncio.set_event_loop_policy(policy)
                            yield policy
                            asyncio.set_event_loop_policy(original_policy)
                        ]]>
                    </example>
                </guideline>

                <guideline>
                    <name>Structured Logging in Tests</name>
                    <description>
                        - Use structlog for test logging
                        - Configure logging specifically for test environment
                        - Capture and verify log messages
                        - Add context to log messages
                        - Clean up logging handlers
                    </description>
                    <example>
                        <![CDATA[
                        @pytest.fixture(autouse=True)
                        def configure_structlog(log_output):
                            structlog.configure(
                                processors=[
                                    structlog.processors.add_log_level,
                                    structlog.processors.TimeStamper(fmt="iso"),
                                    log_output
                                ],
                                wrapper_class=structlog.make_filtering_bound_logger("DEBUG"),
                                context_class=dict,
                                logger_factory=structlog.testing.LogCapture,
                                cache_logger_on_first_use=True
                            )
                        ]]>
                    </example>
                </guideline>
            </async_testing_guidelines>

            <test_patterns>
                <pattern name="AsyncFixture">
                    <description>Pattern for async fixture setup and teardown</description>
                    <example>
                        <![CDATA[
                        @pytest_asyncio.fixture
                        async def database():
                            db = await setup_test_db()
                            yield db
                            await db.cleanup()
                        ]]>
                    </example>
                </pattern>

                <pattern name="SharedLoopTest">
                    <description>Pattern for tests sharing an event loop</description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio(loop_scope="module")
                        class TestSharedLoop:
                            loop: asyncio.AbstractEventLoop

                            async def test_remember_loop(self):
                                self.loop = asyncio.get_running_loop()

                            async def test_using_loop(self):
                                assert self.loop is asyncio.get_running_loop()
                        ]]>
                    </example>
                </pattern>

                <pattern name="AsyncErrorBoundary">
                    <description>Pattern for testing async error handling</description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_error_boundary():
                            with pytest.raises(CustomError) as exc_info:
                                async with error_boundary():
                                    await failing_operation()
                            assert "expected error" in str(exc_info.value)
                        ]]>
                    </example>
                </pattern>

                <pattern name="ResourceCleanup">
                    <description>Pattern for comprehensive resource cleanup in tests</description>
                    <example>
                        <![CDATA[
                        @pytest_asyncio.fixture(autouse=True)
                        async def cleanup_resources():
                            yield
                            await asyncio.gather(*[
                                resource.cleanup()
                                for resource in active_resources
                            ])
                        ]]>
                    </example>
                </pattern>

                <pattern name="AsyncGeneratorTest">
                    <description>Pattern for testing async generators and cleanup</description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_async_generator():
                            agen = async_generator_func()
                            try:
                                async for item in agen:
                                    assert item is not None
                            finally:
                                await agen.aclose()  # Proper cleanup of async generator
                        ]]>
                    </example>
                </pattern>

                <pattern name="AsyncMocking">
                    <description>Pattern for mocking async functions and methods</description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_with_async_mock(mocker):
                            async def async_mock(*args, **kwargs):
                                return "mocked"

                            mocker.patch(
                                "module.async_function",
                                side_effect=async_mock
                            )
                            result = await function_under_test()
                            assert result == "mocked"
                        ]]>
                    </example>
                </pattern>

                <pattern name="AsyncContextVerification">
                    <description>Pattern for verifying async context manager behavior</description>
                    <example>
                        <![CDATA[
                        @pytest.mark.asyncio
                        async def test_async_context():
                            entered = False
                            exited = False

                            class TestContext:
                                async def __aenter__(self):
                                    nonlocal entered
                                    entered = True
                                    return self

                                async def __aexit__(self, exc_type, exc_val, exc_tb):
                                    nonlocal exited
                                    exited = True

                            async with TestContext():
                                assert entered
                                assert not exited
                            assert exited
                        ]]>
                    </example>
                </pattern>
            </test_patterns>

            <configuration>
                <pytest_config>
                    <![CDATA[
                    # pytest.ini or pyproject.toml
                    [tool.pytest.ini_options]
                    asyncio_mode = "auto"
                    markers = [
                        "asyncio: mark test as async",
                        "integration: mark as integration test",
                    ]
                    ]]>
                </pytest_config>
            </configuration>

            <code_patterns>
                <pattern name="SafeFileHandler">
                    <description>Pattern for safe file operations with proper cleanup</description>
                    <example>
                        <![CDATA[
                        async with SafeFileHandler(path, mode="r") as f:
                            content = await f.read()
                        ]]>
                    </example>
                </pattern>

                <pattern name="ThreadPoolExecutor">
                    <description>Pattern for proper thread pool management</description>
                    <example>
                        <![CDATA[
                        with ThreadPoolExecutor() as pool:
                            try:
                                result = await loop.run_in_executor(pool, func)
                            finally:
                                pool.shutdown(wait=True)
                        ]]>
                    </example>
                </pattern>

                <pattern name="AsyncContextManager">
                    <description>Pattern for proper async resource management</description>
                    <example>
                        <![CDATA[
                        async def __aexit__(self, exc_type, exc_val, exc_tb):
                            try:
                                await self.cleanup()
                            finally:
                                await self.close()
                        ]]>
                    </example>
                </pattern>

                <pattern name="EventLoopSafety">
                    <description>Pattern for safe event loop operations</description>
                    <example>
                        <![CDATA[
                        async def io_operation():
                            return await loop.run_in_executor(None, blocking_io_func)
                        ]]>
                    </example>
                </pattern>

                <pattern name="ThreadSynchronization">
                    <description>Pattern for proper thread synchronization</description>
                    <example>
                        <![CDATA[
                        self._lock = asyncio.Lock()
                        async with self._lock:
                            await self._perform_operation()
                        ]]>
                    </example>
                </pattern>

                <pattern name="ComprehensiveCleanup">
                    <description>Pattern for comprehensive resource cleanup</description>
                    <example>
                        <![CDATA[
                        async def cleanup(self):
                            async with self._cleanup_lock:
                                try:
                                    await self._cleanup_resources()
                                finally:
                                    self._closed = True
                        ]]>
                    </example>
                </pattern>
            </code_patterns>
        </testing_recommendations>
    </info>

    <implementation>
        <priority_order>
            1. Fix immediate thread safety issues in LangSmith client
            2. Implement proper SSE stream handling
            3. Add proper resource cleanup in async contexts
            4. Improve thread pool lifecycle management
            5. Add comprehensive error boundaries
        </priority_order>

        <verification_steps>
            1. Run memory leak tests
            2. Perform stress testing with concurrent operations
            3. Verify proper resource cleanup
            4. Check thread pool shutdown behavior
            5. Validate error handling and recovery
        </verification_steps>
    </implementation>

    <functionality_check>
        <instruction>
            After implementing fixes and improvements, analyze the modified code to:
            1. Identify any removed or altered functionality from the original module
            2. Document these changes at the end of the generation
            3. Explain the impact of any removed functionality
            4. Provide recommendations for restoring critical functionality
            5. Note any API changes that might affect dependent code
        </instruction>
        <report_format>
            <removed_functionality>
                List functions, methods, or features that were removed or significantly altered
            </removed_functionality>
            <impact_assessment>
                Explain the impact of these changes on the module's usage
            </impact_assessment>
            <restoration_steps>
                Provide steps to restore critical functionality if needed
            </restoration_steps>
        </report_format>
    </functionality_check>
</segfault_guidelines>
