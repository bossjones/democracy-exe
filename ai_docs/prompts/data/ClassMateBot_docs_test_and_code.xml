<documents>
<document index="1">
<source>/Users/malcolm/dev/ClassMateBot/conftest.py</source>
<document_content>
import os
import sys

import discord.ext.test as dpytest
import pytest_asyncio
from discord import Intents
from discord.ext.commands import Bot
from setuptools import glob
from os.path import dirname as d
from os.path import abspath, join
import db

db.TESTING_MODE = True

intents = Intents.all()

root_dir = d(d(abspath("test/test_bot.py")))
sys.path.append(root_dir)


# Default parameters for the simulated dpytest bot. Loads the bot with commands from the /cogs directory
# Ran everytime pytest is called
@pytest_asyncio.fixture
async def bot(event_loop):
    bot = Bot(intents=intents, command_prefix="$", loop=event_loop)
    dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(dir)
    os.chdir("cogs")
    for filename in os.listdir(os.getcwd()):
        if filename.endswith(".py"):
            await bot.load_extension(f"cogs.{filename[:-3]}")
    await bot.load_extension("jishaku")
    await bot._async_setup_hook()
    dpytest.configure(bot)
    return bot


# Cleans up leftover files generated through dpytest
def pytest_sessionfinish():
    # Clean up attachment files
    files = glob.glob("./dpytest_*.dat")
    for path in files:
        try:
            os.remove(path)
        except Exception as e:
            print(f"Error while deleting file {path}: {e}")
    print("\npySession closed successfully")
    # rollback all db modifications made
    db.CONN.rollback()


# Copyright (c) 2021 War-Keeper

</document_content>
</document>
<document index="2">
<source>/Users/malcolm/dev/ClassMateBot/bot.py</source>
<document_content>
# bot.py
# Copyright (c) 2021 War-Keeper

import os

import discord
from discord.utils import get
from discord import Intents
from dotenv import load_dotenv
from discord.ext.commands import Bot, has_permissions, CheckFailure

# from better_profanity import profanity


import profanity_helper

# ----------------------------------------------------------------------------------------------
# Initializes the discord bot with a unique TOKEN and joins the bot to a server provided by the
# GUILD token. Handles bot shutdown and error events
# ----------------------------------------------------------------------------------------------

# Load the environment

load_dotenv()
# Get the token for our bot
TOKEN = os.getenv("TOKEN")
UNVERIFIED_ROLE_NAME = os.getenv("UNVERIFIED_ROLE_NAME")
# Set the bots intents to all
intents = Intents.all()
# Set all bot commands to begin with $
bot = Bot(intents=intents, command_prefix="$")


# ------------------------------------------------------------------------------------------------------------------
#    Function: on_guild_join()
#    Description: Activates when the bot joins a new guild, prints the name of the server it joins and the names of all members
#                 of that server
#    Inputs:
#    -guild which is bot is joining
#    Outputs:
#    -Success messages for channel creation and role creation
#    -Error if
# ------------------------------------------------------------------------------------------------------------------
@bot.event
async def on_guild_join(guild):
    for channel in guild.text_channels:
        if (
            channel.permissions_for(guild.me).send_messages
            and channel.name == "general"
        ):
            if "instructor-commands" not in guild.text_channels:
                await guild.create_text_channel("instructor-commands")
                await channel.send("instructor-commands channel has been added!")
            if "q-and-a" not in guild.text_channels:
                await guild.create_text_channel("q-and-a")
                await channel.send("q-and-a channel has been added!")
            if "reminders" not in guild.text_channels:
                await guild.create_text_channel("reminders")
                await channel.send("reminders channel has been added!")

            if discord.utils.get(guild.roles, name="verified") is None:
                await guild.create_role(
                    name="verified",
                    colour=discord.Colour(0x2ECC71),
                    permissions=discord.Permissions.general(),
                )
            if discord.utils.get(guild.roles, name="unverified") is None:
                await guild.create_role(
                    name="unverified",
                    colour=discord.Colour(0xE74C3C),
                    permissions=discord.Permissions.none(),
                )
                unverified = discord.utils.get(guild.roles, name="unverified")
                # unverified members can only see/send messages in general channel until they verify
                overwrite = discord.PermissionOverwrite()
                overwrite.update(send_messages=True)
                overwrite.update(read_messages=True)
                await channel.set_permissions(unverified, overwrite=overwrite)
            if discord.utils.get(guild.roles, name="Instructor") is None:
                await guild.create_role(
                    name="Instructor",
                    colour=discord.Colour(0x3498DB),
                    permissions=discord.Permissions.all(),
                )
            # Assign Verified role to Guild owner
            leader = guild.owner
            leadrole = get(guild.roles, name="verified")
            unverified = discord.utils.get(guild.roles, name="unverified")
            await leader.add_roles(leadrole, reason=None, atomic=True)
            await channel.send(leader.name + " has been given verified role!")
            # Assign Instructor role to Guild owner
            leadrole = get(guild.roles, name="Instructor")
            await leader.add_roles(leadrole, reason=None, atomic=True)
            await channel.send(leader.name + " has been given Instructor role!")
            # Assign unverified role to all other members
            await leader.add_roles(leadrole, reason=None, atomic=True)
            for member in guild.members:
                if member != guild.owner:
                    await member.add_roles(unverified, reason=None, atomic=True)
            await channel.send('To verify yourself, use "$verify <FirstName LastName>"')


# ------------------------------------------------------------------------------------------------------------------
#    Function: on_ready()
#    Description: Activates when the bot starts.
#    Inputs:
#    -
#    Outputs:
#    -
# ------------------------------------------------------------------------------------------------------------------
@bot.event
async def on_ready():
    # guild = discord.utils.get(bot.guilds, name=GUILD)

    # print(
    #     f"{bot.user} is connected to the following guild:\n"
    #     f"{guild.name}(id: {guild.id})"
    # )

    # members = "\n -".join([member.name for member in guild.members])
    # print(f"Guild Members:\n - {members}")
    # db.connect()

    for filename in os.listdir("./cogs"):
        if filename.endswith(".py"):
            await bot.load_extension(f"cogs.{filename[:-3]}")
    await bot.load_extension("jishaku")

    await bot.change_presence(
        activity=discord.Activity(
            type=discord.ActivityType.watching, name="Over This Server"
        )
    )

    # LOAD ALL COMMANDS INTO WHITELISTS.
    # gonna have to figure out an optimal way... for now, do everything!
    for n in bot.commands:
        profanity_helper.whitelist.append(n.name)
        profanity_helper.command_list.append(n.name)

    profanity_helper.loadwhitelist()
    # profanity_helper.loadDefaultWhitelist()

    print("READY!")


###########################
# Function: on_message
# Description: run when a message is sent to a discord the bot occupies
# Inputs:
#      - message: the message the user sent to a channel
###########################
@bot.event
async def on_message(message):
    """run on message sent to a channel"""
    # allow messages from test bot
    # NOTE from Group25: Not sure if this is actually being used anywhere.
    if message.author.bot and message.author.id == 889697640411955251:
        ctx = await bot.get_context(message)
        await bot.invoke(ctx)

    if message.author == bot.user:
        return

    cname = message.channel.name
    # CHECK CHANNELS.
    # don't want to accidentally censor a word before it can be whitelisted
    if profanity_helper.filtering:
        if cname != "instructor-commands":
            nustr = message.content.replace('"', "")
            if profanity_helper.helpChecker(nustr) or profanity_helper.helpChecker(
                message.content
            ):
                # if profanity_helper.helpChecker(message.content):
                badmsg = "Please do not use inappropriate language in this server. Your message:\n"
                badmsg += profanity_helper.helpCensor(nustr)
                # badmsg += profanity_helper.helpCensor(message.content)
                # if message.author.bot: # if the author is the bot
                # return
                await message.author.send(badmsg)
                await message.delete()
                return
    await bot.process_commands(message)


###########################
# Function: on_message_edit
# Description: run when a user edits a message
# Inputs:
#      - before: the old message
#      - after: the new message
###########################
@bot.event
async def on_message_edit(before, after):
    """run on message edited"""

    if profanity_helper.filtering:
        if profanity_helper.helpChecker(after.content):
            if not after.author.bot:
                await after.channel.send(
                    after.author.name
                    + " says: "
                    + profanity_helper.helpCensor(after.content)
                )
                await after.delete()
            else:
                numsg = profanity_helper.helpCensor(after.content)
                await after.edit(content=numsg)


# -----------------------------------------------------------------------
#    Function: toggleFilter
#    Description: Command to toggle the filter
#    Inputs:
#    - ctx: used to access the values passed through the current context
#    Outputs:
#    -
# ------------------------------------------------------------------------
@bot.command(name="toggleFilter", help="Turns the profanity filter on or off")
@has_permissions(administrator=True)
async def toggleFilter(ctx):
    if profanity_helper.filtering:
        profanity_helper.filtering = False
    else:
        profanity_helper.filtering = True
    await ctx.send(f"Profanity filter set to: {profanity_helper.filtering}")


# -----------------------------------------------------------------------
#    Function: whitelistWord
#    Description: Command to add a word to the whitelist
#    Inputs:
#    - ctx: used to access the values passed through the current context
#    - word: the word or sentence to be whitelisted
#    Outputs:
#    -
# ------------------------------------------------------------------------
@bot.command(
    name="whitelist",
    help="adds a word to the whitelist. EX: $whitelist word or sentence",
)
@has_permissions(administrator=True)
async def whitelistWord(ctx, *, word=""):
    if not ctx.channel.name == "instructor-commands":
        await ctx.author.send("Please use this command inside #instructor-commands")
        await ctx.message.delete()
        return

    if word == "":
        return

    profanity_helper.wlword(word)

    await ctx.send(f"**{word}** has been added to the whitelist.")


# -----------------------------------------------------------------------
#    Function: dewhitelistWord
#    Description: Command to remove a word from the whitelist
#    Inputs:
#    - ctx: used to access the values passed through the current context
#    - word: the word or sentence to be de-whitelisted
#    Outputs:
#    -
# ------------------------------------------------------------------------
@bot.command(
    name="dewhitelist",
    help="Removes a word from the whitelist. EX: $dewhitelist word or sentence",
)
@has_permissions(administrator=True)
async def dewhitelistWord(ctx, *, word=""):
    if not ctx.channel.name == "instructor-commands":
        await ctx.author.send("Please use this command inside #instructor-commands")
        await ctx.message.delete()
        return

    if word == "":
        return

    if word in profanity_helper.command_list:
        await ctx.send("Cannot remove a command from the whitelist.")
        return

    if word in profanity_helper.whitelist:
        profanity_helper.unwlword(word)
        await ctx.send(f"**{word}** has been removed from the whitelist.")
        return

    await ctx.send(f"**{word}** not found in whitelist.")


# ------------------------------------------------------------------------------------------
#    Function: on_member_join(member)
#    Description: Handles on_member_join events, DMs the user and asks for verification through newComer.py
#    Inputs:
#    - member: used to add member to the knowledge of the bot
#    Outputs:
#    -
# ------------------------------------------------------------------------------------------
@bot.event
async def on_member_join(member):
    unverified = discord.utils.get(
        member.guild.roles, name="unverified"
    )  # finds the unverified role in the guild
    await member.add_roles(unverified)  # assigns the unverified role to the new member
    await member.send("Hello " + member.name + "!")
    await member.send(
        "Verify yourself before getting started! \n To use the verify command, do: $verify <your_full_name> \n \
        ( For example: $verify Jane Doe )"
    )


# ------------------------------------------------
#    Function: on_error(event, *args, **kwargs)
#    Description: Handles bot errors, prints errors to a log file
#    Inputs:
#    - member: event of the error
#    - *args: any arguments that come with error
#    - **kwargs: other args
#    Outputs:
#    -
# ------------------------------------------------
@bot.event
async def on_error(event, *args, **kwargs):
    with open("err.log", "a") as f:
        if event == "on_message":
            f.write(f"Unhandled message: {args[0]}\n")
        else:
            raise


# ----------------------------------
#    Function: on_member_join(member)
#    Description: Command for shutting down the bot
#    Inputs:
#    - ctx: used to access the values passed through the current context
#    Outputs:
#    -
# ----------------------------------
@bot.command(name="shutdown", help="Shuts down the bot, only usable by the owner")
@has_permissions(administrator=True)
async def shutdown(ctx):
    await ctx.send("Shutting Down bot")
    print("Bot closed successfully")
    ctx.bot.logout()
    exit()


# Starts the bot with the current token
bot.run(TOKEN)

</document_content>
</document>
<document index="3">
<source>/Users/malcolm/dev/ClassMateBot/test/test_bot.py</source>
<document_content>
# Copyright (c) 2021 War-Keeper
import discord
import os
import asyncio
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import discord.ext.test as dpytest
from dotenv import load_dotenv
import pytest
from PyPDF2 import PdfReader
from discord.ext import commands
import vobject

import db


# ------------------------------------------------------------------------------------------------------
# Main file bot testing. Uses dpytest to test bot activity on a simulated server with simulated members
# ------------------------------------------------------------------------------------------------------


# -------------------
# Tests cogs/ping.py
# -------------------
@pytest.mark.asyncio
async def test_ping(bot):
    await dpytest.message("$ping")
    assert dpytest.verify().message().contains().content("Pong!")


# TODO Test user join messages


# ---------------------
# Tests cogs/groups.py
# ---------------------
@pytest.mark.asyncio
async def test_groupJoin(bot):
    # first leave all groups just in case in any
    await dpytest.message("$leave")
    dpytest.get_message()

    # Try to join a group
    await dpytest.message("$join 99")
    assert (
        dpytest.verify()
        .message()
        .content("You are now in Group 99! There are now 1/6 members.")
    )

    # try to join a different group
    await dpytest.message("$join 1")
    assert dpytest.verify().message().content("You are already in Group 99")

    # leave your group
    await dpytest.message("$leave")
    assert dpytest.verify().message().content("You have been removed from Group 99!")

    # leave with no group
    await dpytest.message("$leave")
    assert dpytest.verify().message().content("You are not in a group!")

    # Reset Groups
    await dpytest.message("$reset")
    print(dpytest.get_message())
    assert dpytest.verify().message().content("Roles deleted!")

    await dpytest.message("$startupgroups")
    print(dpytest.get_message())

    await dpytest.message("$connect")


# # ------------------------------------
# # Tests cogs/groups.py error handling
# # ------------------------------------
@pytest.mark.asyncio
async def test_groupError(bot):
    # Try to join a group that doesn't exist
    await dpytest.message("$join -1")
    assert dpytest.verify().message().content("Not a valid group")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the join command, do: $join <Num> "
            "where 0 <= <Num> <= total groups$ \n ( For example: $join 0 )"
        )
    )

    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$join")
    assert (
        dpytest.verify()
        .message()
        .content("To use the join command, do: $join <Num> \n ( For example: $join 0 )")
    )


# ---------------------
# Tests cogs/assignments.py
# ---------------------
@pytest.mark.asyncio
async def test_assignments(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Set up grade categories
    await dpytest.message("$addgradecategory Homework 0.3")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.3 ")
    )
    await dpytest.message("$addgradecategory Project 0.7")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Project  with weight: 0.7 ")
    )
    await dpytest.message("$addgradecategory Test 0.1")
    assert (
        dpytest.verify()
        .message()
        .content("This category weight would make the total weight more than 1..!!")
    )
    ##Adding Assignments
    # Test adding a valid assignment with new category
    await dpytest.message("$addassignment HW1 Homework 30")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW1  with points: 30 and category: Homework"
        )
    )
    # Test adding into an existing category
    await dpytest.message("$addassignment HW2 Homework 30")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW2  with points: 30 and category: Homework"
        )
    )
    ##Editing Assignments
    # Test editing an assignment points
    await dpytest.message("$editassignment HW2 Homework 20")
    assert (
        dpytest.verify()
        .message()
        .content(
            "HW2 assignment has been updated with points:20 and category: Homework"
        )
    )
    # Test editing an assignment category
    await dpytest.message("$editassignment HW1 Project 70")
    assert (
        dpytest.verify()
        .message()
        .content("HW1 assignment has been updated with points:70 and category: Project")
    )
    ##Deleting Assignments
    # Test deleting an assignment
    await dpytest.message("$deleteassignment HW1")
    assert dpytest.verify().message().content("HW1 assignment has been deleted ")


# ---------------------
# Tests cogs/assignments.py
# ---------------------
@pytest.mark.asyncio
async def test_assignments_error(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Set up grade categories
    await dpytest.message("$addgradecategory Homework 0.3")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.3 ")
    )
    await dpytest.message("$addgradecategory Project 0.7")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Project  with weight: 0.7 ")
    )
    ##Adding Assignments
    # Test invalid points
    await dpytest.message("$addassignment HW2 Homework points")
    assert dpytest.verify().message().content("Points could not be parsed")
    await dpytest.message("$addassignment HW3 Homework -1")
    assert (
        dpytest.verify()
        .message()
        .content("Assignment points must be greater than or equal to zero")
    )
    # Test invalid parameters
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$addassignment HW1 Homework")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the addassignment command, do: $addassignment <assignmentname> <categoryname> <points> \n ( For example: $addassignment test1 tests 100 )"
        )
    )
    # Test duplicate assignment
    await dpytest.message("$addassignment HW2 Homework 20")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW2  with points: 20 and category: Homework"
        )
    )
    await dpytest.message("$addassignment HW2 Homework 20")
    assert (
        dpytest.verify().message().content("This assignment has already been added..!!")
    )
    ##Editing Assignments
    # Test invalid points
    await dpytest.message("$editassignment HW2 Homework points")
    assert dpytest.verify().message().content("Points could not be parsed")
    await dpytest.message("$editassignment HW2 Homework -1")
    assert (
        dpytest.verify()
        .message()
        .content("Assignment points must be greater than or equal to zero")
    )
    # Test assignment that does not exist
    await dpytest.message("$editassignment HW1 Homework 30")
    assert dpytest.verify().message().content("This assignment does not exist")
    # Test invalid parameters
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$editassignment HW2 Homework")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the editassignment command, do: $editassignment <assignmentname> <categoryname> <points> \n ( For example: $editassignment test1 tests 95 )"
        )
    )
    ##Deleting Assignments
    # Test non existing assignment
    await dpytest.message("$deleteassignment HW1")
    assert dpytest.verify().message().content("This assignment does not exist")
    # Test invalid parameters
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$deleteassignment")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the deleteassignment command, do: $deleteassignment <assignmentname>\n ( For example: $deleteassignment test1)"
        )
    )


# -----------------------
# Tests cogs/grades.py
# -----------------------
@pytest.mark.asyncio
async def test_gradesStudent(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    await dpytest.message("$addgradecategory Homework 0.3")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.3 ")
    )
    await dpytest.message("$addassignment HW1 Homework 30")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW1  with points: 30 and category: Homework"
        )
    )
    await guild.create_role(name="unverified")
    await guild.create_role(name="verified")
    role = discord.utils.get(guild.roles, name="unverified")
    await dpytest.add_role(user, role)
    channel = await guild.create_text_channel("general")
    await dpytest.message("$verify TestUser0", channel=channel)
    assert dpytest.verify().message().contains().content("Thank you for verifying!")
    # this is to clear the empty spot on the queue
    dpytest.get_message()
    await dpytest.message("$inputgrades HW1 TestingTrue ../test/data/grades.csv")
    assert dpytest.verify().message().contains().content("Entered grades for")
    await dpytest.message("$grade HW1")
    assert dpytest.verify().message().content("Grade for HW1: 25%, worth 30 points")
    await dpytest.message("$gradebycategory Homework")
    assert dpytest.verify().message().content("Grade for Homework: 25.00%")
    await dpytest.message("$gradeforclass")
    assert dpytest.verify().message().content("Grade for class: 25.00%")
    await dpytest.message("$graderequired Homework 50 30")
    assert (
        dpytest.verify()
        .message()
        .content("Grade on next assignment needed to keep 30% in Homework: 33.00%")
    )
    await dpytest.message("$graderequiredforclass Homework 50  60")
    assert (
        dpytest.verify()
        .message()
        .content("Grade on next assignment needed to keep 60%: 305.00%")
    )
    await dpytest.message("$categories")
    assert dpytest.verify().message().content("Category | Weight")
    assert dpytest.verify().message().content("================")
    assert dpytest.verify().message().content("Homework | 0.300")


# -----------------------
# Tests cogs/grades.py
# -----------------------
@pytest.mark.asyncio
async def test_gradesStudentError(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    await dpytest.message("$addgradecategory Homework 0.3")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.3 ")
    )
    await dpytest.message("$addassignment HW1 Homework 30")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW1  with points: 30 and category: Homework"
        )
    )
    await guild.create_role(name="unverified")
    await guild.create_role(name="verified")
    role = discord.utils.get(guild.roles, name="unverified")
    await dpytest.add_role(user, role)
    channel = await guild.create_text_channel("general")
    await dpytest.message("$verify TestUser0", channel=channel)
    assert dpytest.verify().message().contains().content("Thank you for verifying!")
    # this is to clear the empty spot on the queue
    dpytest.get_message()
    await dpytest.message("$inputgrades HW1 TestingTrue ../test/data/grades.csv")
    assert dpytest.verify().message().contains().content("Entered grades for")
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$grade")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the grade command, do: $grade <assignmentname>\n ( For example: $grade test1 )"
        )
    )
    await dpytest.message("$grade FakeHW")
    assert dpytest.verify().message().content("Grade for FakeHW does not exist")
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$gradebycategory")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the gradebycategory command, do: $gradebycategory <categoryname>\n"
            + "( For example: $gradebycategory tests )"
        )
    )
    await dpytest.message("$gradebycategory FakeCat")
    assert dpytest.verify().message().content("Grades for FakeCat do not exist")
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$graderequired")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the graderequired command, do: $graderequired <categoryname> <pointsvalue> <desiredgrade>\n ( For example: $graderequired tests 200 90 )"
        )
    )
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$graderequiredforclass")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the graderequiredforclass command, do: $graderequiredforclass <categoryname> <pointsvalue> <desiredgrade>\n ( For example: $graderequiredforclass tests 200 90 )"
        )
    )
    await dpytest.message("$graderequiredforclass Testing33 50  60")
    assert dpytest.verify().message().content("Grades for Testing33 do not exist")


# -----------------------
# Tests cogs/grades.py
# -----------------------
@pytest.mark.asyncio
async def test_gradesInstructor(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    await dpytest.message("$addgradecategory Homework 0.2")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.2 ")
    )
    await dpytest.message("$editgradecategory Homework 0.3")
    assert (
        dpytest.verify()
        .message()
        .content("Homework category has been updated with weight:0.3 ")
    )
    await dpytest.message("$addgradecategory Exams 0.7")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Exams  with weight: 0.7 ")
    )
    await dpytest.message("$deletegradecategory Exams")
    assert dpytest.verify().message().content("Exams category has been deleted ")
    await dpytest.message("$addgradecategory Exams 0.7")  # add back
    dpytest.get_message()
    await dpytest.message("$addassignment Midterm1 Exams 100")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A grading assignment has been added for: Midterm1  with points: 100 and category: Exams"
        )
    )

    await dpytest.message("$addassignment HW1 Homework 10")
    assert (
        dpytest.verify()
        .message()
        .content(
            "A grading assignment has been added for: HW1  with points: 10 and category: Homework"
        )
    )

    await dpytest.message("$categories")
    assert dpytest.verify().message().contains().content("Category | Weight")
    assert dpytest.verify().message().contains().content("================")
    assert dpytest.verify().message().contains().content("Exams | 0.700")
    assert dpytest.verify().message().contains().content("Homework | 0.300")

    # Create TestUser0
    await guild.create_role(name="unverified")
    await guild.create_role(name="verified")
    role = discord.utils.get(guild.roles, name="unverified")
    await dpytest.add_role(user, role)
    channel = await guild.create_text_channel("general")
    await dpytest.message("$verify TestUser0", channel=channel)
    assert dpytest.verify().message().contains().content("Thank you for verifying!")

    # this is to clear the empty spot on the queue
    dpytest.get_message()

    # Enters new grade and editing existing grade
    await dpytest.message("$inputgrades HW1 TestingTrue ../test/data/hwGrades.csv")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Entered grades for HW1, 1 new grades entered, 1 grades edited")
    )

    await dpytest.message(
        "$inputgrades Midterm1 TestingTrue ../test/data/examGrades.csv"
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Invalid grade value for student TestUser0, skipping entry")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Invalid student name InvalidUser0, skipping entry")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Entered grades for Midterm1, 1 new grades entered, 0 grades edited")
    )

    # await dpytest.message("$gradereportcategory")
    # assert dpytest.verify().message().contains().content("Grade Breakdown by Category")
    # assert dpytest.verify().message().contains().content("Exams | Average:")
    # assert dpytest.verify().message().contains().content("Homework | Average:")

    # await dpytest.message("$gradereportassignment")
    # assert (
    #     dpytest.verify().message().contains().content("Grade Breakdown by Assignment")
    # )
    # assert dpytest.verify().message().contains().content("HW1 | Average:")
    # assert dpytest.verify().message().contains().content("Midterm1 | Average:")


# -----------------------
# Tests cogs/grades.py
# -----------------------
@pytest.mark.asyncio
async def test_gradesInstructorError(bot):
    # pytest.set_trace()
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    await dpytest.message("$addgradecategory Homework 0.2")
    assert (
        dpytest.verify()
        .message()
        .content("A grading category has been added for: Homework  with weight: 0.2 ")
    )
    await dpytest.message("$addgradecategory Homework asdf")
    assert dpytest.verify().message().content("Weight could not be parsed")
    await dpytest.message("$addgradecategory Homework -1")
    assert dpytest.verify().message().content("Weight must be greater than 0")
    await dpytest.message("$addgradecategory Homework 0.5")
    assert (
        dpytest.verify().message().content("This category has already been added..!!")
    )
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$addgradecategory")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("To use the gradecategory command")
    )
    await dpytest.message("$editgradecategory Homework asdf")
    assert dpytest.verify().message().content("Weight could not be parsed")
    await dpytest.message("$editgradecategory Homework -1")
    assert dpytest.verify().message().content("Weight must be greater than 0")
    await dpytest.message("$editgradecategory Invalid 0.5")
    assert dpytest.verify().message().content("This category does not exist")
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$editgradecategory")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("To use the editgradecategory command")
    )
    await dpytest.message("$deletegradecategory Invalid")
    assert dpytest.verify().message().content("This category does not exist")
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$deletegradecategory")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("To use the deletegradecategory command")
    )
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$inputgrades")
    assert (
        dpytest.verify().message().contains().content("To use the inputgrades command")
    )


# -----------------------
# Tests cogs/deadline.py
# -----------------------
@pytest.mark.asyncio
async def test_deadline(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Clear our reminders: Only if testing fails and leaves a reminders.JSON file with values behind
    # await dpytest.message("$clearreminders")
    # assert dpytest.verify().message().contains().content("All reminders have been cleared..!!")
    # Test reminders while none have been set
    await dpytest.message("$coursedue CSC505")
    assert (
        dpytest.verify()
        .message()
        .content("Rejoice..!! You have no pending reminders for CSC505..!!")
    )
    # Test setting 1 reminder
    await dpytest.message("$duedate CSC505 DANCE SEP 21 2050 10:00")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A date has been added for: CSC505 reminder named: DANCE which is due on: 2050-09-21 10:00:00"
        )
    )
    # Test setting a 2nd reminder
    await dpytest.message("$duedate CSC510 HW1 DEC 21 2050 19:59")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A date has been added for: CSC510 reminder named: HW1 which is due on: 2050-12-21 19:59:00"
        )
    )
    # Test deleting reminder
    await dpytest.message("$deletereminder CSC510 HW1")
    assert (
        dpytest.verify()
        .message()
        .content(
            "Following reminder has been deleted: Course: CSC510, reminder Name: HW1, Due Date: 2050-12-21 19:59:00"
        )
    )
    # Test re-adding a reminder
    await dpytest.message("$duedate CSC510 HW1 DEC 21 2050 19:59")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A date has been added for: CSC510 reminder named: HW1 which is due on: 2050-12-21 19:59:00"
        )
    )

    # Test adding an assignment twice
    await dpytest.message("$duedate CSC510 HW1 DEC 21 2050 19:59")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("This reminder has already been added..!!")
    )

    # Clear reminders at the end of testing since we're using a local JSON file to store them
    await dpytest.message("$clearreminders")
    assert dpytest.verify().message().content("All reminders have been cleared..!!")


# --------------------------------
# Test listing multiple reminders
# --------------------------------
@pytest.mark.asyncio
async def test_listreminders(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Test listing multiple reminders
    await dpytest.message("$duedate CSC505 DANCE SEP 21 2050 10:00")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A date has been added for: CSC505 reminder named: DANCE which is due on: 2050-09-21 10:00:00"
        )
    )
    # Test setting a 2nd reminder
    await dpytest.message("$duedate CSC510 HW1 DEC 21 2050 19:59")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A date has been added for: CSC510 reminder named: HW1 which is due on: "
        )
    )
    await dpytest.message("$listreminders")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("CSC505 reminder named: DANCE which is due on:")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("CSC510 reminder named: HW1 which is due on:")
    )
    # Test $coursedue
    await dpytest.message("$coursedue CSC505")
    assert dpytest.verify().message().contains().content("DANCE is due at ")
    # Clear reminders at the end of testing since we're using a local JSON file to store them
    await dpytest.message("$clearreminders")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("All reminders have been cleared..!!")
    )


# ------------------------------
# Tests reminders due this week
# ------------------------------
@pytest.mark.asyncio
async def test_duethisweek(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Try adding a reminder due in an hour
    now = datetime.now() + timedelta(hours=1)
    dt_string = now.strftime("%b %d %Y %H:%M")
    await dpytest.message(f"$duedate CSC600 HW0 {dt_string}")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("A date has been added for: CSC600 reminder named: HW0")
    )
    # Check to see that the reminder is due this week
    await dpytest.message("$duethisweek")
    assert dpytest.verify().message().contains().content("CSC600 HW0 is due ")
    # Clear reminders at the end of testing since we're using a local JSON file to store them
    await dpytest.message("$clearreminders")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("All reminders have been cleared..!!")
    )


# ------------------------------
# Tests reminders due today
# ------------------------------
@pytest.mark.asyncio
async def test_duetoday(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Try adding a reminder due in an hour
    now = datetime.now() + timedelta(hours=6)
    dt_string = now.strftime("%b %d %Y %H:%M")
    await dpytest.message(f"$duedate CSC600 HW0 {dt_string}")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("A date has been added for: CSC600 reminder named: HW0")
    )
    # Check to see that the reminder is due today
    await dpytest.message("$duetoday")
    assert dpytest.verify().message().contains().content("CSC600 HW0 is due ")
    # Clear reminders at the end of testing since we're using a local JSON file to store them
    await dpytest.message("$clearreminders")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("All reminders have been cleared..!!")
    )


# ------------------------------
# Tests overdue reminders
# ------------------------------
@pytest.mark.asyncio
async def test_overdue(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)
    # Try adding a reminder due in the past
    await dpytest.message("$duedate CSC600 HW0 SEP 21 2000 10:00")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("A date has been added for: CSC600 reminder named: HW0")
    )
    # Check to see that the reminder is overdue
    await dpytest.message("$overdue")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "CSC600 reminder named: HW0 which was due on: Sep 21 2000 10:00:00+0000"
        )
    )
    # Clear reminders at the end of testing since we're using a local JSON file to store them
    await dpytest.message("$clearoverdue")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("All overdue reminders have been cleared..!!")
    )
    # Confirm overdue was removed
    await dpytest.message("$overdue")
    assert (
        dpytest.verify().message().contains().content("There are no overdue reminders")
    )


# ------------------------------
# Tests deadline errors
# ------------------------------
@pytest.mark.asyncio
async def test_deadline_errors(bot):
    # create instuctor user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Tests timenow without an argument
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$timenow")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the timenow command (with current time), do: "
            "$timenow MMM DD YYYY HH:MM ex. $timenow SEP 25 2024 17:02"
        )
    )

    # Test timenow with bad argument
    # with pytest.raises(commands.MissingRequiredArgument):
    await dpytest.message("$timenow blab")
    assert dpytest.verify().message().content("Due date could not be parsed")

    # Test duedate with bad argument
    # with pytest.raises(commands.MissingRequiredArgument):
    await dpytest.message("$duedate blab blab blab")
    assert dpytest.verify().message().content("Due date could not be parsed")
    # Tests duedate without an argument
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$duedate")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the duedate command, do: $duedate CLASSNAME NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)\n ( For example: $duedate CSC510 HW2 SEP 25 2024 17:02 EST )"
        )
    )

    # Tests deletereminder without an argument
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$deletereminder")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the deletereminder command, do: $deletereminder CLASSNAME HW_NAME \n "
            "( For example: $deletereminder CSC510 HW2 )"
        )
    )

    # Tests changeduedate without an argument
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$changeduedate")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the changeduedate command, do: $changeduedate CLASSNAME HW_NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)\n"
            " ( For example: $changeduedate CSC510 HW2 SEP 25 2024 17:02 EST)"
        )
    )

    # Test changeduedate with bad argument
    # with pytest.raises(commands.MissingRequiredArgument):
    await dpytest.message("$changeduedate blab blab blab")
    assert dpytest.verify().message().content("Due date could not be parsed")

    # Tests coursedue without an argument
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$coursedue")
    assert (
        dpytest.verify()
        .message()
        .content(
            "To use the coursedue command, do: $coursedue CLASSNAME \n ( For example: $coursedue CSC510 )"
        )
    )


# --------------------
# Tests cogs/pinning
# --------------------
@pytest.mark.asyncio
async def test_pinning(bot):
    # Test pinning a message
    await dpytest.message("$pin TestMessage www.google.com this is a test")
    # print(dpytest.get_message().content)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage and description: www.google.com this is a test"
        )
    )
    await dpytest.message("$pin TestMessage www.discord.com this is also a test")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage and description: www.discord.com this is also a test"
        )
    )

    # clean up
    # await dpytest.message("$unpin TestMessage")


# ----------------
# Tests unpinning
# ----------------
@pytest.mark.asyncio
async def test_unpinning(bot):
    # Test pinning a message
    await dpytest.message("$pin TestMessage www.google.com this is a test")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage and description: www.google.com this is a test"
        )
    )
    await dpytest.message("$pin TestMessage www.discord.com this is also a test")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage and description: www.discord.com this is also a test"
        )
    )
    # Tests unpinning a message that doesn't exist
    await dpytest.message("$unpin None")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No message found with the combination of tagname: None, and author:")
    )
    # Tests unpinning messages that DO exist
    await dpytest.message("$unpin TestMessage")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("2 pinned message(s) has been deleted with tag: TestMessage")
    )


# ---------------------
# Tests updating pins
# ---------------------
@pytest.mark.asyncio
async def test_updatepin(bot):
    # Tests adding another message to update pins
    await dpytest.message("$pin TestMessage2 www.discord.com test")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage2 and description: www.discord.com test"
        )
    )
    # Tests updatepin
    await dpytest.message("$updatepin TestMessage2 www.zoom.com test")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("1 pinned message(s) has been deleted with tag: TestMessage2")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: TestMessage2 and description: www.zoom.com test"
        )
    )

    # Tests updating a non-existent pin
    await dpytest.message("$updatepin Tag Test")
    # Confirm no message exists
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No message found with the combination of tagname: Tag, and author:")
    )
    # Ensure that a message is pinned.
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("A new message has been pinned with tag: Tag and description: Test")
    )


# ------------------------
# Tests pinnedmessages
# ------------------------
@pytest.mark.asyncio
async def test_pinnedmessages(bot):
    # Tests getting pins by tag: no pinned messages
    await dpytest.message("$pinnedmessages TestTag")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No messages found with the given tagname and author combination")
    )

    # pin and dequeue
    await dpytest.message("$pin Tag1 never gonna give you up")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: Tag1 and description: never gonna give you up"
        )
    )
    # pin and dequeue
    await dpytest.message("$pin Tag1 never gonna let you down")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: Tag1 and description: never gonna let you down"
        )
    )
    # pin and dequeue
    await dpytest.message("$pin Tag2 never gonna run around and desert you")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new message has been pinned with tag: Tag2 and description: never gonna run around and desert you"
        )
    )

    # Tests getting pins by tag
    await dpytest.message("$pinnedmessages Tag1")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Tag: Tag1, Description: never gonna give you up")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Tag: Tag1, Description: never gonna let you down")
    )

    # Tests getting all pins
    await dpytest.message("$pinnedmessages")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Tag: Tag1, Description: never gonna give you up")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Tag: Tag1, Description: never gonna let you down")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Tag: Tag2, Description: never gonna run around and desert you")
    )


# ------------------------
# Tests pin-related errors
# ------------------------
@pytest.mark.asyncio
async def test_pinningErrors(bot):
    # Tests pinning without a message
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$pin")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the pin command, do: $pin TAGNAME DESCRIPTION \n ( For example: $pin HW8 https://"
            "discordapp.com/channels/139565116151562240/139565116151562240/890813190433292298 HW8 reminder )"
        )
    )

    # Tests unpinning without a message
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$unpin")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the unpin command, do: $unpin TAGNAME \n ( For example: $unpin HW8 )"
        )
    )

    # Tests updating a pin with invalid input
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$updatepin")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the updatepin command, do: $pin TAGNAME DESCRIPTION \n ( $updatepin HW8 https://discordapp"
            ".com/channels/139565116151562240/139565116151562240/890814489480531969 HW8 reminder )"
        )
    )

    # Tests using pinnedmessages with invalid input
    # with pytest.raises(commands.CommandError):
    # await dpytest.message("$pinnedmessages \" please fail omg")
    # assert dpytest.verify().message().contains().content(
    # "To use the pinnedmessages command, do: $pinnedmessages:"
    # " TAGNAME \n ( For example: $pinnedmessages HW8 )")

    # The above test requires the else statement below to be included
    # in pinning.py's retrieveMessages_error function.

    # @retrieveMessages.error
    # async def retrieveMessages_error(self, ctx, error):
    # if isinstance(error, commands.MissingRequiredArgument):
    # ...
    # else:
    # await ctx.send(
    # "To use the pinnedmessages command, do: $pinnedmessages:"
    # " TAGNAME \n ( For example: $pinnedmessages HW8 )")
    # print(error)


# --------------------
# Tests cogs/newComer
# --------------------


@pytest.mark.asyncio
async def test_verify(bot):
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    channel = await guild.create_text_channel("general")

    await dpytest.message("$verify Student Name", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Warning: Please make sure the verified and unverified roles exist in this server!"
        )
    )

    # Test self-verification - unverified role assigned
    await guild.create_role(name="unverified")
    await guild.create_role(name="verified")
    role = discord.utils.get(guild.roles, name="unverified")
    await dpytest.add_role(user, role)
    await dpytest.message("$verify Student Name", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(f"Thank you for verifying! You can start using {guild.name}!")
    )
    dpytest.get_message()


@pytest.mark.asyncio
async def test_verifyNoName(bot):
    guild = dpytest.get_config().guilds[0]
    await guild.create_role(name="unverified")
    await guild.create_role(name="verified")
    # Test verification without proper argument given
    await dpytest.message("$verify")
    # print(dpytest.get_message().content)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the verify command, do: $verify <FirstName LastName> \n ( For example: $verify Jane Doe )"
        )
    )


# We cannot currently test newComer.py in a meaningful way due to not having a way to DM the test bot directly,
# as well as inability to have dpytest add/remove roles to test specific cases


# --------------------
# Tests cogs/Voting
# --------------------
@pytest.mark.asyncio
async def test_voting(bot):
    # Test voting
    await dpytest.message(content="$vote 1")
    assert (
        dpytest.verify()
        .message()
        .content(
            "You are not in a group. You must join a group before voting on a project."
        )
    )
    await dpytest.message("$join 99")
    dpytest.get_message()
    await dpytest.message(content="$vote 1")
    assert dpytest.verify().message().content("Group 99 has voted for Project 1!")
    await dpytest.message(content="$vote 2")
    assert dpytest.verify().message().content("Group 99 removed vote for Project 1")
    assert dpytest.verify().message().content("Group 99 has voted for Project 2!")
    await dpytest.message(content="$vote 2")
    assert dpytest.verify().message().content("You already voted for Project 2")
    with pytest.raises(commands.UserInputError):
        await dpytest.message(content="$vote")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To join a project, use the join command, do: $vote <Num> \n( For example: $vote 0 )"
        )
    )
    await dpytest.message(content="$vote -1")
    assert dpytest.verify().message().content("A valid project number is 1-99.")


# -------------------
# Tests cogs/qanda
# --------------------
@pytest.mark.asyncio
async def test_qanda(bot):
    # Test q and a functionalities
    # create channel and get user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    channel = await guild.create_text_channel("q-and-a")
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Test asking a question anonymously
    await dpytest.message('$ask "What class is this?" anonymous', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q1: What class is this? by anonymous")
    )

    # Test asking a question with name
    await dpytest.message('$ask "When is the last day of classes?"', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q2: When is the last day of classes? by " + user.name)
    )

    # Tests getting answers: no answers
    await dpytest.message("$getAnswersFor 1", channel=channel)
    assert dpytest.verify().message().contains().content("No answers for Q1")

    # Test answering a question
    await dpytest.message('$answer 2 "TestA"', channel=channel)
    # Test answering a question anonymously
    await dpytest.message('$answer 2 "TestB" anonymous', channel=channel)

    # Tests getting answers: question has answers
    await dpytest.message("$getAnswersFor 2", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Q2: When is the last day of classes? by "
            + user.name
            + "\n"
            + user.name
            + " (Instructor) Ans: TestA\n"
            "anonymous (Instructor) Ans: TestB\n"
        )
    )

    # Tests channelGhost: not a ghost, has answers
    await dpytest.message("$channelGhost 2", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("This question is not a ghost. Fetching anyway. . .")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Q2: When is the last day of classes? by "
            + user.name
            + "\n"
            + user.name
            + " (Instructor) Ans: TestA\n"
            "anonymous (Instructor) Ans: TestB\n"
        )
    )

    # test deleting all answers for a question with none
    await dpytest.message("$DALLAF 1", channel=channel)
    assert dpytest.verify().message().contains().content("No answers exist for Q1")

    # test deleting all answers
    await dpytest.message("$DALLAF 2", channel=channel)
    assert dpytest.verify().message().contains().content("deleted 2 answers for Q2")

    # Test reviveGhost: non-existent question
    await dpytest.message("$reviveGhost 100", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 100")
    )

    # Test channelGhost: non-existent question
    await dpytest.message("$channelGhost 100", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 100")
    )

    # GHOST AND ZOMBIE TESTING

    # ask and dequeue
    await dpytest.message('$ask "Am I a zombie?" anon', channel=channel)
    assert (
        dpytest.verify().message().contains().content("Q3: Am I a zombie? by anonymous")
    )

    # hold on to q3
    q3_id = channel.last_message_id
    q3 = await channel.fetch_message(q3_id)

    # Tests channelGhost: not a ghost, no answers
    await dpytest.message("$channelGhost 3", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("This question is not a ghost. Fetching anyway. . .")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q3: Am I a zombie? by anonymous\n" "No answers for Q3\n")
    )

    # Test spooky: no ghosts or zombies
    await dpytest.message("$spooky", channel=channel)
    assert dpytest.verify().message().contains().content("This channel isn't haunted.")

    # Test unearthZombies: no zombies
    await dpytest.message("$unearthZombies", channel=channel)
    assert dpytest.verify().message().contains().content("No zombies detected.")

    # zomb-ify Q3
    await q3.delete()

    # test answering a zombie
    await dpytest.message('$answer 3 "zombie test"', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Question 3 not found. It's a zombie!")
    )

    # test getting answers for a zombie
    await dpytest.message("$getAnswersFor 3", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Question 3 not found. It's a zombie!")
    )

    # ask and dequeue
    await dpytest.message('$ask "Am I a ghost?" anonymous', channel=channel)
    assert (
        dpytest.verify().message().contains().content("Q4: Am I a ghost? by anonymous")
    )
    # answer Q4
    await dpytest.message('$answer 4 "Yes" anon', channel=channel)

    # ask and dequeue
    await dpytest.message('$ask "Zombie" anonymous', channel=channel)
    assert dpytest.verify().message().contains().content("Q5: Zombie by anonymous")

    # hold on to q5
    q5_id = channel.last_message_id
    q5 = await channel.fetch_message(q5_id)

    # answer Q5; zombie with an answer
    await dpytest.message('$answer 5 "test" anonymous', channel=channel)

    # Test deleting a question
    await dpytest.message("$deleteQuestion 4", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q4 is now a ghost. To restore it, use: $reviveGhost 4")
    )

    # Test deleting a ghost question
    await dpytest.message("$deleteQuestion 4", channel=channel)
    assert dpytest.verify().message().contains().content("Q4 is already a ghost!")

    # test answering a ghost
    await dpytest.message('$answer 4 "Ghost Test"', channel=channel)
    assert dpytest.verify().message().contains().content("You can't answer a ghost!")

    # Test channelGhost: answers
    await dpytest.message("$channelGhost 4", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q4: Am I a ghost? by anonymous\nanonymous (Instructor) Ans: Yes\n")
    )

    # Tests getting answers for a ghost
    await dpytest.message("$getAnswersFor 4", channel=channel)
    assert dpytest.verify().message().contains().content("Q4 is a ghost!")

    # Test allChannelGhosts: answers
    await dpytest.message("$allChannelGhosts", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q4: Am I a ghost? by anonymous\n" "anonymous (Instructor) Ans: Yes\n")
    )

    # test deleting all answers for ghost
    await dpytest.message("$DALLAF 4", channel=channel)
    assert dpytest.verify().message().contains().content("deleted 1 answers for Q4")
    assert dpytest.verify().message().contains().content("Q4 is a ghost!")

    # Test channelGhost: no answers
    await dpytest.message("$channelGhost 4", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q4: Am I a ghost? by anonymous\n" "No answers for Q4\n")
    )

    # Test allChannelGhosts: no answers
    await dpytest.message("$allChannelGhosts", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q4: Am I a ghost? by anonymous\n" "No answers for Q4\n")
    )

    # Test spooky: ghosts and zombies are present
    await dpytest.message("$spooky", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("This channel is haunted by 1 ghosts and 1 zombies.")
    )

    # Test archiveQA: zombie, ghost, questions with and without answers
    await dpytest.message("$archiveQA", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q1: What class is this? by anonymous\n" "No answers for Q1\n")
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Q2: When is the last day of classes? by " + user.name + "\n"
            "No answers for Q2\n"
        )
    )
    assert (
        dpytest.verify().message().contains().content("Q3 was deleted. It's a zombie!")
    )
    assert dpytest.verify().message().contains().content("Q4 is a ghost!")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q5: Zombie by anonymous\n" "anonymous (Instructor) Ans: test\n")
    )

    # Test reviving a ghost (revive without answers)
    await dpytest.message("$reviveGhost 4", channel=channel)
    # no assert needed!

    # ghosts: 0, zombies: 1

    # Test deleting a zombie (ghosts + 1, zombies -1)
    await dpytest.message("$deleteQuestion 3", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q3 was not found in channel. To restore it, use: $reviveGhost 3")
    )

    # ghosts: 1, zombies: 0

    # zomb-ify Q5
    await q5.delete()

    # ghosts: 1, zombies: 1

    # test reviving a zombie with answers
    await dpytest.message("$reviveGhost 5", channel=channel)
    # now we can assert because a message is actually posted this time.
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Q5: Zombie by anonymous\n" "anonymous (Instructor) Ans: test\n")
    )

    # ghosts: 1, zombies: 0

    # create another zombie
    await dpytest.message('$ask "Zombie2" anonymous', channel=channel)
    assert dpytest.verify().message().contains().content("Q6: Zombie2 by anonymous")

    # hold on to q5
    q6_id = channel.last_message_id
    q6 = await channel.fetch_message(q6_id)
    await q6.delete()

    # test unearthZombies: zombies found
    await dpytest.message("$unearthZombies", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Found 1 zombies and assigned them ghost status.\n"
            "To view them, use: $allChannelGhosts\n"
            "To restore a question, use: $reviveGhost QUESTION_NUMBER"
        )
    )

    # ghosts: 2, zombies: 0

    # create final zombie
    await dpytest.message('$ask "Zombie3" anonymous', channel=channel)
    assert dpytest.verify().message().contains().content("Q7: Zombie3 by anonymous")
    # hold on to q7
    qz_id = channel.last_message_id
    qz = await channel.fetch_message(qz_id)

    await dpytest.message('$answer 7 "test" anonymous', channel=channel)

    # zomb-ify Q7
    await qz.delete()

    # ghosts: 2, zombies: 1

    # test deleting all answers for zombie
    await dpytest.message("$DALLAF 7", channel=channel)
    assert dpytest.verify().message().contains().content("deleted 1 answers for Q7")
    assert dpytest.verify().message().contains().content("Q7 is a zombie!")

    # test deleteAllQA: questions with and without answers, ghosts and zombies
    await dpytest.message("$deleteAllQA", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Deleted 7 questions from the database, including 1 zombies and 2 ghosts."
        )
    )


# -------------------------
# Tests cogs/qanda: error testing
# -------------------------
@pytest.mark.asyncio
async def test_qanda_errors(bot):
    # Test q and a functionalities
    # create channel and get user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    channel = await guild.create_text_channel("q-and-a")
    gen_channel = await guild.create_text_channel("general")
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Test asking a question in the wrong channel
    msg = await dpytest.message(
        '$ask "Is this the right channel?"', channel=gen_channel
    )
    with pytest.raises(discord.NotFound):
        await gen_channel.fetch_message(msg.id)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please send questions to the #q-and-a channel.")
    )

    # Tests unknown anonymous input (question)
    await dpytest.message('$ask "Who am I?" wronganon', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Unknown input for *anonymous* option. Please type **anonymous**, **anon**, or leave blank."
        )
    )

    # Tests incorrect use of ask command: missing args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$ask", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            'To use the ask command, do: $ask "QUESTION" anonymous*<optional>* \n '
            '(For example: $ask "What class is this?" anonymous)'
        )
    )

    # Test answering a question in the wrong channel
    msga = await dpytest.message('$answer 1 "Test"', channel=gen_channel)
    with pytest.raises(discord.NotFound):
        await gen_channel.fetch_message(msga.id)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please send answers to the #q-and-a channel.")
    )

    # Tests unknown anonymous input (answer)
    await dpytest.message('$answer 1 "A Thing" wronganon', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "Unknown input for *anonymous* option. Please type **anonymous**, **anon**, or leave blank."
        )
    )

    # Tests answering a nonexistent question (answer)
    await dpytest.message('$answer 100 "nope"', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 100")
    )

    # placeholder test for empty input (answer)
    # await dpytest.message("$answer 100 \"\" ", channel=channel)
    # assert dpytest.verify().message().contains().content('STRING GOES HERE')

    # Tests incorrect use of answer command: no args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$answer", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            'To use the answer command, do: $answer QUESTION_NUMBER "ANSWER" anonymous*<optional>*\n '
            '(For example: $answer 2 "Yes")'
        )
    )

    # Tests answering with bad input (answer)
    await dpytest.message('$answer "nope" lol', channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            'Please include a valid question number. EX: $answer 1 /"Oct 12/" anonymous'
        )
    )

    # Test getAnswersFor in wrong channel
    msg = await dpytest.message("$getAnswersFor 1", channel=gen_channel)
    with pytest.raises(discord.NotFound):
        await gen_channel.fetch_message(msg.id)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Tests getting answers for nonexistent question
    await dpytest.message("$getAnswersFor 100", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 100")
    )

    # Tests getAnswersFor with bad input: no arg
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$getAnswersFor", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the getAnswersFor command, do: $getAnswersFor QUESTION_NUMBER\n "
            "(Example: $getAnswersFor 1)"
        )
    )

    # Tests getting answers with bad input
    await dpytest.message("$getAnswersFor abc", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please include a valid question number. EX: $getAnswersFor 1")
    )

    # Test that deleting answers does not work outside of QA
    msg = await dpytest.message("$DALLAF 1", channel=gen_channel)
    with pytest.raises(discord.NotFound):
        await gen_channel.fetch_message(msg.id)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # test deleting all answers with bad input: no args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$DALLAF", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the deleteAllAnswersFor command, do: $DALLAF QUESTION_NUMBER\n "
            "(Example: $DALLAF 1)"
        )
    )

    # test deleting all answers with bad input
    await dpytest.message("$DALLAF abc", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please include a valid question number. EX: $DALLAF 1")
    )

    # test deleting all answers for a non-existent question
    await dpytest.message("$DALLAF 100", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 100")
    )

    # Test that deleting questions does not work outside of QA
    msg = await dpytest.message("$deleteQuestion 1", channel=gen_channel)
    with pytest.raises(discord.NotFound):
        await gen_channel.fetch_message(msg.id)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # test deleting questions with bad input: no args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$deleteQuestion", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the deleteQuestion command, do: $deleteQuestion QUESTION_NUMBER\n "
            "(Example: $deleteQuestion 1"
        )
    )

    # test deleting question with bad input
    await dpytest.message("$deleteQuestion abc", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please include a valid question number. EX: $deleteQuestion 1")
    )

    # test deleting a non-existent question
    await dpytest.message("$deleteQuestion 100", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Question number not in database: 100")
    )

    # Test that deleting all QAs does not work outside of QA
    await dpytest.message("$deleteAllQA", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Test deleting all QAs without any questions
    await dpytest.message("$deleteAllQA", channel=channel)
    assert (
        dpytest.verify().message().contains().content("No questions found in database.")
    )

    # Test archiveQA: empty database
    await dpytest.message("$archiveQA", channel=channel)
    assert (
        dpytest.verify().message().contains().content("No questions found in database.")
    )

    # Test that archiveQA does not work outside of QA
    await dpytest.message("$archiveQA", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Test channelGhost in the wrong channel
    await dpytest.message("$channelGhost 1", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Tests channelGhost: missing args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$channelGhost", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the channelGhost command, do: $channelGhost QUESTION_NUMBER\n "
            "(Example: $channelGhost 1)"
        )
    )

    # Tests channelGhost: invalid arg
    await dpytest.message("$channelGhost blah", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please include a valid question number. EX: $channelGhost 1")
    )

    # Tests channelGhost: empty database
    await dpytest.message("$channelGhost 1", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 1")
    )

    # Test allChannelGhosts in the wrong channel
    await dpytest.message("$allChannelGhosts", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # allChannelGhosts without any ghosts
    await dpytest.message("$allChannelGhosts", channel=channel)
    assert dpytest.verify().message().contains().content("No ghosts found in database.")

    # Test spooky in the wrong channel
    await dpytest.message("$spooky", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Test spooky: empty database
    await dpytest.message("$spooky", channel=channel)
    assert dpytest.verify().message().contains().content("This channel isn't haunted.")

    # Test unearthZombies in the wrong channel
    await dpytest.message("$unearthZombies", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Test unearthZombies: empty database
    await dpytest.message("$unearthZombies", channel=channel)
    assert dpytest.verify().message().contains().content("No zombies detected.")

    # Test reviveGhost in the wrong channel
    await dpytest.message("$reviveGhost 1", channel=gen_channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please use this command inside the #q-and-a channel.")
    )

    # Tests reviveGhost: missing args
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$reviveGhost", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "To use the reviveGhost command, do: $reviveGhost QUESTION_NUMBER\n "
            "(Example: $reviveGhost 1)"
        )
    )

    # Tests reviveGhost: invalid arg
    await dpytest.message("$reviveGhost blah", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please include a valid question number. EX: $reviveGhost 1")
    )

    # Test reviveGhost: empty database
    await dpytest.message("$reviveGhost 1", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("No such question with the number: 1")
    )

    # Test ask: empty question
    await dpytest.message('$ask ""', channel=channel)
    assert (
        dpytest.verify().message().contains().content("Please enter a valid question.")
    )

    # Test ask: whitepaces only
    await dpytest.message('$ask "   "', channel=channel)
    assert (
        dpytest.verify().message().contains().content("Please enter a valid question.")
    )

    # Test ask: one char question
    await dpytest.message('$ask "A"', channel=channel)
    assert dpytest.verify().message().contains().content("Question too short.")

    # Test answer: empty answer
    await dpytest.message('$answer 1 ""', channel=channel)
    assert dpytest.verify().message().contains().content("Please enter a valid answer.")

    # Test answer: whitespaces only
    await dpytest.message('$answer 1 "    "', channel=channel)
    assert dpytest.verify().message().contains().content("Please enter a valid answer.")


# --------------------
# Tests cogs/reviewQs
# --------------------
@pytest.mark.asyncio
async def test_review_qs(bot):
    # Test review question functionalities
    # create roles and get user
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    await guild.create_role(name="Instructor")
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Test adding a question
    await dpytest.message('$addQuestion "What class is this?" "CSC510"', member=user)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            "A new review question has been added! Question: What class is this? and Answer: CSC510."
        )
    )

    # Test getting a question
    await dpytest.message("$getQuestion", member=user)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("What class is this? \n ||CSC510||")
    )

    # Test error
    with pytest.raises(Exception):
        await dpytest.message('$addQuestion "Is this a test question?"', member=user)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            'To use the addQuestion command, do: $addQuestion "Question" "Answer" \n'
            '(For example: $addQuestion "What class is this?" "CSC510")'
        )
    )


# --------------------------------
# Test polling: poll
# --------------------------------
@pytest.mark.asyncio
async def test_poll(bot):
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    channel = await guild.create_text_channel("polls")

    # Test poll: no input
    await dpytest.message("$poll", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please enter a question for your poll.")
    )

    # Test poll: whitespace
    await dpytest.message("$poll    ", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Please enter a question for your poll.")
    )

    # Test poll: question too short
    await dpytest.message("$poll ab", channel=channel)
    assert dpytest.verify().message().contains().content("Poll question too short.")

    # Test poll: student
    await dpytest.message("$poll abc", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("**POLL by Student**\n\nabc\n** **")
    )

    await guild.create_role(name="Instructor")
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Test poll: instructor
    await dpytest.message("$poll abc", channel=channel)
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("**POLL by Instructor**\n\nabc\n** **")
    )

    # Test poll: reactions
    msgid = channel.last_message_id
    msg = await channel.fetch_message(msgid)

    # should have three reactions, but this is a known bug.
    # From dpytest: This is d.py/discord's fault, the message object from send isn't
    # the same as the one in the state
    assert len(msg.reactions) == 1


# --------------------------------
# Test polling: quizpoll
# --------------------------------
@pytest.mark.asyncio
async def test_quizpoll(bot):
    # user = dpytest.get_config().members[0]
    # guild = dpytest.get_config().guilds[0]
    # channel = await guild.create_text_channel('polls')

    # Test quizpoll: no input
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message("$quizpoll")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content(
            'To use the quizpoll command, do: $quizpoll "TITLE" [option1] [option2] ... [option6]\n '
            "Be sure to enclose title with quotes and options with brackets!\n"
            'EX: $quizpoll "I am a poll" [Vote for me!] [I am option 2]'
        )
    )

    # Test quizpoll: title is whitespace
    await dpytest.message('$quizpoll "  " [a] [b] [c] [d] [e] [f]')
    assert dpytest.verify().message().contains().content("Please enter a valid title.")

    # Test quizpoll: title is too short
    await dpytest.message('$quizpoll "a" [a] [b] [c] [d] [e] [f]')
    assert dpytest.verify().message().contains().content("Title too short.")

    # Test quizpoll: too few options
    await dpytest.message('$quizpoll "TITLE" [a]')
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Polls need at least two options.")
    )

    # Test quizpoll: too many options
    await dpytest.message('$quizpoll "TITLE" [a] [b] [c] [d] [e] [f] [g]')
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Polls cannot have more than six options.")
    )

    # Test quizpoll: option is empty
    await dpytest.message('$quizpoll "TITLE" [] [b] [c]')
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Options cannot be blank or whitespace only.")
    )

    e = discord.Embed(
        title="**TITLE**",
        description="\n\n🇦     a\n\n🇧     b\n\n🇨     c",
        colour=0x83BAE3,
    )

    # Test quizpoll embed
    await dpytest.message('$quizpoll "TITLE" [a] [b] [c]')
    assert dpytest.verify().message().embed(e)


# --------------------------------
# Test calendar: subscribe and remove
# --------------------------------
@pytest.mark.asyncio
async def test_calendar(bot):
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Test subscribeCalendar success
    await dpytest.message("$subscribeCalendar johndoe@gmail.com")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Added johndoe@gmail.com to the calendar.")
    )

    # Test subscribeCalendar failure
    await dpytest.message("$subscribeCalendar johndoe")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Error adding user: johndoe is not a valid email.")
    )

    # Test removeCalendar failure
    await dpytest.message("$removeCalendar johndoe")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("User johndoe was not found in the calendar's permissions.")
    )

    # Test removeCalendar failure
    await dpytest.message("$removeCalendar johndoe@gmail.com")
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("User johndoe@gmail.com has been removed from the calendar.")
    )


@pytest.mark.asyncio
async def test_get_resource_by_topic(bot):
    user = dpytest.get_config().members[0]
    guild = dpytest.get_config().guilds[0]
    irole = await guild.create_role(name="Instructor")
    await irole.edit(permissions=discord.Permissions(8))
    role = discord.utils.get(guild.roles, name="Instructor")
    await dpytest.add_role(user, role)

    # Testing add resource
    await dpytest.message(
        "$addResource Testing https://github.com/txt/se23/blob/main/docs/testing1.md"
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("Resource successfully added to the topic Testing")
    )

    # Testing delete Resource
    await dpytest.message(
        "$deleteResource Testing https://github.com/txt/se23/blob/main/docs/testing1.md"
    )
    assert (
        dpytest.verify()
        .message()
        .contains()
        .content("The Resource has been deleted successfully.")
    )

    # Test missing argument topic
    await dpytest.message("$showResourceByTopic -1")
    assert dpytest.verify().message().contains().content("No resources found.")


@pytest.mark.asyncio
async def test_get_calendar_downloads(bot):
    await dpytest.message("$clearCalendar")
    assert dpytest.verify().message().contains().content("Calendar has been cleared")
    await dpytest.message("$getPdfDownload")
    assert dpytest.verify().message().contains().content("No upcoming events found.")
    date = datetime.now(ZoneInfo("America/New_York")) + timedelta(days=1)
    caldate = date.astimezone(ZoneInfo("UTC"))
    dateiso = date.isoformat(timespec="seconds")
    caldateiso = caldate.isoformat(timespec="seconds")[:-6]
    await dpytest.message(f"$addCalendarEvent HW3 CSC510 {caldateiso}Z")
    assert dpytest.verify().message().contains().content("Event HW3 added to calendar!")

    await dpytest.message("$getPdfDownload")
    calendar_path = os.getenv("CALENDAR_PATH")

    reader = PdfReader(f"{calendar_path}calendar.pdf")

    page = reader.pages[0]

    text = page.extract_text()
    text = text.split("\n")

    assert len(text) == 7
    assert text[0] == "Summary"
    assert text[1] == "Start"
    assert text[2] == "End"
    assert text[3] == "0"
    assert text[4] == "HW3"
    assert text[5][:10] == dateiso[:10]
    assert text[5][10:16] == dateiso[10:16]

    await dpytest.message("$getiCalDownload")

    # referenced https://stackoverflow.com/questions/3408097/parsing-files-ics-icalendar-using-python

    caldata = open(f"{calendar_path}ical.ics").read()

    for cal in vobject.readComponents(caldata):
        for component in cal.components():
            if component.name == "VEVENT":
                assert component.description.valueRepr() == "CSC510"
                assert component.summary.valueRepr() == "HW3"
                assert component.dtstart.valueRepr().month == caldate.month
                assert component.dtstart.valueRepr().year == caldate.year
                assert component.dtstart.valueRepr().day == caldate.day
                assert component.dtstart.valueRepr().hour == caldate.hour

</document_content>
</document>
<document index="4">
<source>/Users/malcolm/dev/ClassMateBot/test/data/examGrades.csv</source>
<document_content>
name,grade
TestUser0,-1
TestUser0,75
InvalidUser0,50
</document_content>
</document>
<document index="5">
<source>/Users/malcolm/dev/ClassMateBot/test/data/grades.csv</source>
<document_content>
name,grade
TestUser0,25
</document_content>
</document>
<document index="6">
<source>/Users/malcolm/dev/ClassMateBot/test/data/hwGrades.csv</source>
<document_content>
name,grade
TestUser0,69
TestUser0,70
</document_content>
</document>
<document index="7">
<source>/Users/malcolm/dev/ClassMateBot/test/data/lotr_plagiarism_test.txt</source>
<document_content>
You shall not pass! Definitely one of the most quoted lines from the entire saga, Gandalf's epic defiance of the Balrog on the Bridge of Khazad-dûm became unforgettable with
</document_content>
</document>
<document index="8">
<source>/Users/malcolm/dev/ClassMateBot/cogs/assignments.py</source>
<document_content>
# Copyright (c) 2023 nfoster1492
# This functionality provides various methods to manage assignments
# The isntructor is able to add/edit/and delete assignments
# and specify their grading category and point value.
import os
import sys
import discord
from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


class Assignments(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_assignment(self, ctx, assignmentname, categoryname, points)
    #    Description: This command lets the instructor add a new gradeable assignment
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - assignmentname: the name of the assignment
    #    - categoryname: the name of the grade category if the assignment
    #    - points: the points that the assignment is worth
    #    Outputs: Whether or not the add was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="addassignment",
        help="add a grading assignment and points $addassignment NAME CATEGORY POINTS",
    )
    async def add_assignment(
        self, ctx, assignmentname: str, categoryname: str, points: str
    ):
        """Add a grading assignment and points"""
        try:
            assignmentpoints = int(points)
        except ValueError:
            await ctx.send("Points could not be parsed")
            return
        category = db.query(
            "SELECT id FROM grade_categories WHERE guild_id = %s AND category_name = %s",
            (ctx.guild.id, categoryname),
        )

        if not category:
            await ctx.send(f"Category with name {categoryname} does not exist")
            return
        if assignmentpoints < 0:
            await ctx.send("Assignment points must be greater than or equal to zero")
            return
        existing = db.query(
            "SELECT id FROM assignments WHERE guild_id = %s AND assignment_name = %s",
            (ctx.guild.id, assignmentname),
        )

        if not existing:
            db.query(
                "INSERT INTO assignments (guild_id, category_id, assignment_name, points) VALUES (%s, %s, %s, %s)",
                (ctx.guild.id, category[0], assignmentname, points),
            )
            await ctx.send(
                f"A grading assignment has been added for: {assignmentname}  with points: {points} and category: {categoryname}"
            )
        else:
            await ctx.send("This assignment has already been added..!!")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: edit_assignment(self, ctx, assignmentname, categoryname, points)
    #    Description: This command lets the instructor edit a gradeable assignment with a new categoryname and/or points
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - assignmentname: the name of the assignment
    #    - categoryname: the new name of the grade category if the assignment
    #    - points: the new points that the assignment is worth
    #    Outputs: Whether or not the edit was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="editassignment",
        help="edit a grading assignment and points $editassignment NAME CATEGORY POINTS",
    )
    async def edit_assignment(
        self, ctx, assignmentname: str, categoryname: str, points: str
    ):
        """edit a grading assignment and points $editassignment NAME CATEGORY POINTS"""
        try:
            assignmentpoints = int(points)
        except ValueError:
            await ctx.send("Points could not be parsed")
            return
        category = db.query(
            "SELECT id FROM grade_categories WHERE guild_id = %s AND category_name = %s",
            (ctx.guild.id, categoryname),
        )
        if not category:
            await ctx.send(f"Category with name {categoryname} does not exist")
            return
        if assignmentpoints < 0:
            await ctx.send("Assignment points must be greater than or equal to zero")
            return
        existing = db.query(
            "SELECT id FROM assignments WHERE guild_id = %s AND assignment_name = %s",
            (ctx.guild.id, assignmentname),
        )
        if existing:
            db.query(
                "UPDATE assignments SET category_id = %s, points = %s WHERE id = %s",
                (category[0], points, existing[0]),
            )
            await ctx.send(
                f"{assignmentname} assignment has been updated with points:{points} and category: {categoryname}"
            )
        else:
            await ctx.send("This assignment does not exist")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: delete_assignment(self, ctx, assignmentname)
    #    Description: This command lets the instructor delete a gradeable assignment
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - assignmentname: the name of the assignment
    #    Outputs: Whether or not the delete was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deleteassignment",
        help="delete a grading assignment $deleteassignment NAME",
    )
    async def delete_assignment(self, ctx, assignmentname: str):
        """delete a grading assignment $deleteassignment NAME"""
        existing = db.query(
            "SELECT id FROM assignments WHERE guild_id = %s AND assignment_name = %s",
            (ctx.guild.id, assignmentname),
        )
        if existing:
            db.query("DELETE FROM assignments WHERE id = %s", (existing[0]))
            await ctx.send(f"{assignmentname} assignment has been deleted ")
        else:
            await ctx.send("This assignment does not exist")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_assignment_error(self, ctx, error)
    #    Description: prints error message for addassignment command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @add_assignment.error
    async def add_assignment_error(self, ctx, error):
        """Error handling of addassignment function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the addassignment command, do: $addassignment <assignmentname> <categoryname> <points> \n ( For example: $addassignment test1 tests 100 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: edit_assignment_error(self, ctx, error)
    #    Description: prints error message for editassignment command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @edit_assignment.error
    async def edit_assignment_error(self, ctx, error):
        """Error handling of editassignment function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the editassignment command, do: $editassignment <assignmentname> <categoryname> <points> \n ( For example: $editassignment test1 tests 95 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: delete_assignment_error(self, ctx, error)
    #    Description: prints error message for deleteassignment command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @delete_assignment.error
    async def delete_assignment_error(self, ctx, error):
        """Error handling of deleteassignment function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the deleteassignment command, do: $deleteassignment <assignmentname>\n ( For example: $deleteassignment test1)"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)


# -------------------------------------
# add the file to the bot's cog system
# -------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Assignments(bot))

</document_content>
</document>
<document index="9">
<source>/Users/malcolm/dev/ClassMateBot/cogs/calendar.py</source>
<document_content>
# Copyright (c) 2023 nfoster1492
from __future__ import print_function

import os.path
import datetime
import discord
import asyncio
from dotenv import load_dotenv
from discord.ext import commands, tasks

from google.auth.transport.requests import Request
from datetime import timedelta, datetime, date
from google.oauth2.credentials import Credentials
from urllib.request import urlopen
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import pdfkit
import pandas as pd


class Calendar(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.checkForEvents.start()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: credsSetUp(self)
    #    Description: Sets up the credentials for all calendar actions
    #    Outputs:
    #       - The credentials needed to access the google calendar api calls
    # -----------------------------------------------------------------------------------------------------------------
    def credsSetUp(self):
        """Set up Google Calendar with authentication"""
        # If modifying these scopes, delete the file token.json.
        SCOPES = ["https://www.googleapis.com/auth/calendar"]

        creds = None
        # The file token.json stores the user's access and refresh tokens, and is
        # created automatically when the authorization flow completes for the first
        # time.
        if os.path.exists("token.json"):
            creds = Credentials.from_authorized_user_file("token.json", SCOPES)
        # If there are no (valid) credentials available, let the user log in.
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(
                    "credentials.json", SCOPES
                )
                creds = flow.run_local_server(port=0)
            # Save the credentials for the next run
            with open("token.json", "w", encoding="utf-8") as token:
                token.write(creds.to_json())
            with open("cogs/token.json", "w", encoding="utf-8") as token:
                token.write(creds.to_json())
        return creds

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: addCalendarEvent(self, ctx, name, description, eventTime)
    #    Description: adds an event to the Google Calendar specified in .env configuration
    #    Inputs:
    #       - ctx: context of the command
    #       - name: name of event
    #       - decription: description of event
    #       - eventTime: Time of event
    #    Outputs:
    #       - Event added to calendar
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="addCalendarEvent",
        help="Add an event to the course calendar using the format"
        ": $addCalendarEvent NAME DESCRIPTION DATE/TIME",
    )
    async def addCalendarEvent(self, ctx, name, description, eventTime):
        """Adds specified event to shared Google Calendar"""
        creds = self.credsSetUp()
        try:
            calendar = os.getenv("CALENDAR_ID")
            service = build("calendar", "v3", credentials=creds)
            event = {
                "summary": name,
                "description": description,
                "colorId": 4,
                "start": {"dateTime": str(eventTime), "timeZone": "UTC"},
                "end": {"dateTime": str(eventTime), "timeZone": "UTC"},
            }
            event = service.events().insert(calendarId=calendar, body=event).execute()
            await ctx.send(f"Event {name} added to calendar!")

        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_office_hours(self, ctx, ta_name, event_time, end_year, end_month, end_day)
    #    Description: adds a recurring office hour event for a specific TA or instructor to the Google Calendar
    #    specified in .env configuration
    #    Inputs:
    #       - ctx: context of the command
    #       - ta_name: name of TA or instructor to add office hours for
    #       - event_time: time of event to recur by
    #       - end_year: year to stop recurring event
    #       - end_month: month to stop recurring event
    #       - end_day: day to stop recurring event
    #    Outputs:
    #       - Recurring event added to calendar, confirmation that event is added
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="add_office_hours")
    # pylint: disable=too-many-arguments
    async def add_office_hours(
        self, ctx, ta_name, event_time, end_year, end_month, end_day
    ):
        creds = self.credsSetUp()
        try:
            calendar = os.getenv("CALENDAR_ID")
            service = build("calendar", "v3", credentials=creds)
            event = {
                "summary": f"{ta_name}'s office hours",
                "colorId": 2,
                "start": {"dateTime": str(event_time), "timeZone": "UTC"},
                "end": {"dateTime": str(event_time), "timeZone": "UTC"},
                "recurrence": [
                    f"RRULE:FREQ=WEEKLY;UNTIL={end_year}{end_month}{end_day}"
                ],
            }
            event = service.events().insert(calendarId=calendar, body=event).execute()
            await ctx.send(f"Office hours for {ta_name} added to calendar!")

        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_lectures(self, ctx, class_name, address, event_time, end_year, end_month, end_day)
    #    Description: adds a recurring lecture event with a specific address to the Google Calendar specified in .env
    #    configuration. Assumes lectures will always occur at the same address
    #    Inputs:
    #       - ctx: context of the command
    #       - class_name: name of class to add recurring lectures for
    #       - address: address of recurring lectures
    #       - event_time: time of event to recur by
    #       - end_year: year to stop recurring event
    #       - end_month: month to stop recurring event
    #       - end_day: day to stop recurring event
    #    Outputs:
    #       - Recurring event added to calendar, confirmation that event is added
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="add_lectures")
    # pylint: disable=too-many-arguments
    async def add_lectures(
        self, ctx, class_name, address, event_time, end_year, end_month, end_day
    ):
        creds = self.credsSetUp()
        try:
            calendar = os.getenv("CALENDAR_ID")
            service = build("calendar", "v3", credentials=creds)
            event = {
                "summary": f"{class_name} lecture",
                "description": f"Address: {address}",
                "colorId": 2,
                "start": {"dateTime": str(event_time), "timeZone": "UTC"},
                "end": {"dateTime": str(event_time), "timeZone": "UTC"},
                "recurrence": [
                    f"RRULE:FREQ=WEEKLY;UNTIL={end_year}{end_month}{end_day}"
                ],
            }
            event = service.events().insert(calendarId=calendar, body=event).execute()
            await ctx.send(f"Lecture for {class_name} added to calendar!")

        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: clearCalendar(self, ctx)
    #    Description: clears all events from the google calendar
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - Whether the command was a success or a failure
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="clearCalendar", help="Clear all events from calendar")
    async def clearCalendar(self, ctx):
        """Clears all events from shared Google Calendar"""
        creds = self.credsSetUp()
        try:
            page_token = None
            calendar = os.getenv("CALENDAR_ID")
            service = build("calendar", "v3", credentials=creds)
            calendar_events = []
            while True:
                events = (
                    service.events()
                    .list(calendarId=calendar, pageToken=page_token)
                    .execute()
                )
                for event in events["items"]:
                    calendar_events.append(event["id"])
                page_token = events.get("nextPageToken")
                if not page_token:
                    break

            for cid in calendar_events:
                service.events().delete(calendarId=calendar, eventId=cid).execute()
            await ctx.send("Calendar has been cleared")

        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: getiCalDownload(self, ctx)
    #    Description: sends an ics file of the class calendar to the channel the command was issued in
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - The ics file of the calendar
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="getiCalDownload",
        help="Enter the command to receive an ics"
        " file of the calendar$getiCalDownload",
    )
    async def getiCalDownload(self, ctx):
        """Generates an ICAL file of the Google Calendar"""
        # Get the calendar in ics format
        url = os.getenv("CALENDAR_ICS")
        text = urlopen(url).read().decode("iso-8859-1")
        # parse the received text to remove all \n characters
        newText = ""
        for character in text:
            if character != "\n":
                newText = newText + character
        # write to the ics file
        f = open(os.getenv("CALENDAR_PATH") + "ical.ics", "w", encoding="utf-8")
        f.write(newText)
        f.close()
        await ctx.send(file=discord.File(os.getenv("CALENDAR_PATH") + "ical.ics"))

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: getPdfDownload(self, ctx)
    #    Description: sends an pdf file of the class calendar to the channel the command was issued in
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - The pdf file of the calendar
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="getPdfDownload",
        help="Enter the command to receive an ics"
        " file of the calendar$getiCalDownload",
    )
    async def getPdfDownload(self, ctx):
        """Sends a pdf file of the class calendar to the Discord Channel"""
        creds = self.credsSetUp()
        try:
            service = build("calendar", "v3", credentials=creds)
            # Call the Calendar API
            now = datetime.utcnow().isoformat() + "Z"  # 'Z' indicates UTC time
            calendar = os.getenv("CALENDAR_ID")
            events_result = (
                service.events()
                .list(
                    calendarId=calendar,
                    timeMin=now,
                    maxResults=150,
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute()
            )
            events = events_result.get("items", [])

            if not events:
                await ctx.send("No upcoming events found.")
                return
            calEvents = []
            for event in events:
                start = event["start"].get("dateTime", event["start"].get("date"))
                end = event["end"].get("dateTime", event["end"].get("date"))
                calEvent = {"Summary": event["summary"], "Start": start, "End": end}
                calEvents.append(calEvent)
            df = pd.DataFrame(calEvents)
            htmlCal = df.to_html()
            pdfkit.from_string(htmlCal, os.getenv("CALENDAR_PATH") + "calendar.pdf")
            await ctx.send(
                file=discord.File(os.getenv("CALENDAR_PATH") + "calendar.pdf")
            )

        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: checkForEvents(self)
    #    Description: Checks the calendar once per day for any events that are due the same day
    #    Outputs:
    #       - Message to the general chat where everyone is pinged of what events are due today
    # -----------------------------------------------------------------------------------------------------------------
    @tasks.loop(hours=24)
    async def checkForEvents(self):
        """Checks calendar daily for the events due that day"""
        creds = self.credsSetUp()
        try:
            service = build("calendar", "v3", credentials=creds)
            # Call the Calendar API
            now = datetime.utcnow().isoformat() + "Z"  # 'Z' indicates UTC time
            calendar = os.getenv("CALENDAR_ID")
            events_result = (
                service.events()
                .list(
                    calendarId=calendar,
                    timeMin=now,
                    maxResults=150,
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute()
            )
            events = events_result.get("items", [])
            summary = ""
            for event in events:
                dt = datetime.strptime(
                    (event["start"]["dateTime"])[0:18], "%Y-%m-%dT%H:%M:%S"
                )
                if dt.day == date.today().day and dt.year == date.today().year:
                    summary = summary + event["summary"] + ","
            if len(summary) != 0:
                # If the bot is used in more than one server
                for guild in self.bot.guilds:
                    for channel in guild.text_channels:
                        # Find the general channel and ping
                        if channel.name == "general":
                            await channel.send("@everyone " + summary + "due TODAY!")
                            break
        except HttpError as error:
            print(f"An error occurred: {error}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: subscribeCalendar(self, ctx, userEmail)
    #    Description: adds specified user to shared Google Calendar
    #    Inputs:
    #       - ctx: context of the command
    #       - target: calendar to modify
    #       - userEmail: user to add to target Google Calendar
    #    Outputs:
    #       - Confirmation string for successful add, error string for failure.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="subscribeCalendar",
        help="Adds user to shared Google Calendar. Ex: subscribeCalendar john.doe@gmail.com",
    )
    async def subscribeCalendar(self, ctx, userEmail):
        """Adds user to shared Google Calendar"""
        creds = self.credsSetUp()
        try:
            service = build("calendar", "v3", credentials=creds)
            calendar = os.getenv("CALENDAR_ID")
            acl_rule = {
                "scope": {"type": "user", "value": userEmail},
                "role": "reader",  # Adjust the role as needed (e.g., reader, owner)
            }
            acl_rule = (
                service.acl().insert(calendarId=calendar, body=acl_rule).execute()
            )

            await ctx.author.send(f"Added {userEmail} to the calendar.")
        except HttpError as e:
            print(f"An error occurred: {e}")
            await ctx.author.send(
                f"Error adding user: {userEmail} is not a valid email."
            )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: removeCalendar(self, ctx, userEmail)
    #    Description: removes specified user from shared Google Calendar
    #    Inputs:
    #       - ctx: context of the command
    #       - target: calendar to modify
    #       - userEmail: user to remove from target Google Calendar
    #    Outputs:
    #       - Confirmation string for successful removal, error string for failure.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="removeCalendar",
        help="Removes user from shared Google Calendar. Ex: removeCalendar john.doe@gmail.com",
    )
    async def removeCalendar(self, ctx, userEmail):
        """Removes user from shared Google Calendar"""
        creds = self.credsSetUp()
        try:
            service = build("calendar", "v3", credentials=creds)
            calendar = os.getenv("CALENDAR_ID")
            acl_rule_id = None
            # Get the list of ACL rules (permissions) for the calendar.
            acl_list = service.acl().list(calendarId=calendar).execute()
            for acl_rule in acl_list.get("items", []):
                if (
                    acl_rule["scope"]["type"] == "user"
                    and acl_rule["scope"]["value"] == userEmail
                ):
                    acl_rule_id = acl_rule["id"]
                    break
            if acl_rule_id:
                # Delete the ACL rule (permission) to remove the user from the calendar.
                service.acl().delete(calendarId=calendar, ruleId=acl_rule_id).execute()
                await ctx.author.send(
                    f"User {userEmail} has been removed from the calendar."
                )
            else:
                await ctx.author.send(
                    f"User {userEmail} was not found in the calendar's permissions."
                )
        except HttpError as e:
            print(f"An error occurred: {e}")
            await ctx.author.send(
                f"Error removing user: {userEmail} is not a valid email."
            )


async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = Calendar(bot)
    await bot.add_cog(n)

</document_content>
</document>
<document index="10">
<source>/Users/malcolm/dev/ClassMateBot/cogs/deadline.py</source>
<document_content>
# TODO deadline reminder for all students
# Copyright (c) 2021 War-Keeper
# This functionality provides various methods to manage reminders (in the form of creation, retrieval,
# updation and deletion)
# A user can set up a reminder, check what is due this week or what is due today.
# He/She can also check all the due homeworks based on hte coursename.
# A user can also update or delete a reminder if needed.
import os
import asyncio
from datetime import datetime, timedelta, timezone, time
from dateutil import parser
import sys
from discord.ext import commands, tasks
import discord

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


class Deadline(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.units = {
            "second": 1,
            "minute": 60,
            "hour": 3600,
            "day": 86400,
            "week": 604800,
            "month": 2592000,
        }

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: timenow(self, ctx, *, date: str)
    #    Description: This command lets the user get the offset needed for proper datetime reminders in UTC.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - date: current date and 24-hour time
    #    Outputs: offset from the user's current time with UTC.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="timenow",
        help="put in current time to get offset needed for proper "
        "datetime notifications $timenow MMM DD YYYY HH:MM ex. $timenow SEP 25 2024 17:02",
    )
    async def timenow(self, ctx, *, date: str):
        """Gets offset for proper datetime notifications compared to UTC"""
        try:
            input_time = parser.parse(date)
        except ValueError:
            await ctx.send("Due date could not be parsed")
            return

        utc_dt = datetime.utcnow()
        difference = utc_dt - input_time
        diff_in_hours = int(difference.total_seconds() / 3600)
        input_time += timedelta(hours=diff_in_hours)

        await ctx.send(
            f"Current time is {-diff_in_hours} hours from system time (UTC)."
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: timenow_error(self, ctx, error)
    #    Description: prints error message for timenow command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @timenow.error
    async def timenow_error(self, ctx, error):
        """Error handling for timenow command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the timenow command (with current time), do: "
                "$timenow MMM DD YYYY HH:MM ex. $timenow SEP 25 2024 17:02"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duedate(self, ctx, coursename: str, hwcount: str, *, date: str)
    #    Description: Adds the reminder to database in the specified format
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - coursename: name of the course for which reminder is to be added
    #    - hwcount: name of the reminder
    #    - date: due date of the assignment
    #    Outputs: returns either an error stating a reason for failure or returns a success message
    #          indicating that the reminder has been added
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="duedate",
        help="add reminder and due-date $duedate CLASSNAME NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)"
        "ex. $duedate CSC510 HW2 SEP 25 2024 17:02 EST",
    )
    async def duedate(self, ctx, coursename: str, hwcount: str, *, date: str):
        """Add reminder for specified course, assignment, and date"""
        author = ctx.message.author

        try:
            duedate = parser.parse(date)
        except ValueError:
            await ctx.send("Due date could not be parsed")
            return

        existing = db.query(
            "SELECT author_id FROM reminders WHERE guild_id = %s AND course = %s AND reminder_name = %s",
            (ctx.guild.id, coursename, hwcount),
        )
        if not existing:
            db.query(
                "INSERT INTO reminders (guild_id, author_id, course, reminder_name, due_date) VALUES (%s, %s, %s, %s, %s)",
                (ctx.guild.id, author.id, coursename, hwcount, duedate),
            )
            calduedate = duedate.astimezone(timezone.utc)
            isodate = calduedate.isoformat(timespec="seconds")[:-6]
            await ctx.send(
                f"A date has been added for: {coursename} reminder named: {hwcount} "
                f"which is due on: {duedate} by {author}."
                f"Use this command to add the reminder to the calendar! **`$addCalendarEvent {hwcount} {coursename} {isodate}Z`**"
            )
        else:
            await ctx.send("This reminder has already been added..!!")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duedate_error(self, ctx, error)
    #    Description: prints error message for duedate command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @duedate.error
    async def duedate_error(self, ctx, error):
        """Error handling for duedate command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the duedate command, do: $duedate CLASSNAME NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)\n "
                "( For example: $duedate CSC510 HW2 SEP 25 2024 17:02 EST )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteReminder(self, ctx, courseName: str, hwName: str)
    #    Description: Delete a reminder using Classname and Homework name
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - coursename: name of the course for which homework is to be added
    #    - hwName: name of the homework
    #    Outputs: returns either an error stating a reason for failure or
    #          returns a success message indicating that the reminder has been deleted
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deletereminder",
        pass_context=True,
        help="delete a specific reminder using course name and reminder name using "
        "$deletereminder CLASSNAME HW_NAME ex. $deletereminder CSC510 HW2 ",
    )
    async def deleteReminder(self, ctx, courseName: str, hwName: str):
        """Deletes a specified reminder"""
        reminders_deleted = db.query(
            "SELECT course, reminder_name, due_date FROM reminders WHERE guild_id = %s AND reminder_name = %s AND course = %s",
            (ctx.guild.id, hwName, courseName),
        )
        db.query(
            "DELETE FROM reminders WHERE guild_id = %s AND reminder_name = %s AND course = %s",
            (ctx.guild.id, hwName, courseName),
        )

        for course, reminder_name, due_date in reminders_deleted:
            due = due_date.strftime("%Y-%m-%d %H:%M:%S")
            await ctx.send(
                f"Following reminder has been deleted: Course: {course}, "
                f"reminder Name: {reminder_name}, Due Date: {due}"
            )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteReminder_error(self, ctx, error)
    #    Description: prints error message for deletereminder command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @deleteReminder.error
    async def deleteReminder_error(self, ctx, error):
        """Error handling for deleteReminder"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the deletereminder command, do: $deletereminder CLASSNAME HW_NAME \n "
                "( For example: $deletereminder CSC510 HW2 )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: changeduedate(self, ctx, classid: str, hwid: str, *, date: str)
    #    Description: Update the 'Due date' for a homework by providing the classname and homewwork name
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - classid: name of the course for which homework is to be added
    #    - hwid: name of the homework
    #    - date: due date of the assignment
    #    Outputs: returns either an error stating a reason for failure or
    #          returns a success message indicating that the reminder has been updated
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="changeduedate",
        pass_context=True,
        help="update the assignment date. $changeduedate CLASSNAME HW_NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)"
        "ex. $changeduedate CSC510 HW2 SEP 25 2024 17:02 EST",
    )
    async def changeduedate(self, ctx, classid: str, hwid: str, *, date: str):
        """Updates an assignment's due date in the database"""
        author = ctx.message.author
        try:
            duedate = parser.parse(date)
            print(duedate)
        except ValueError:
            await ctx.send("Due date could not be parsed")
            return

        # future = (time.time() + (duedate - datetime.today()).total_seconds())
        db.query(
            "UPDATE reminders SET author_id = %s, due_date = %s WHERE guild_id = %s AND reminder_name = %s AND course = %s",
            (author.id, duedate, ctx.guild.id, hwid, classid),
        )
        await ctx.send(
            f"{classid} {hwid} has been updated with following date: {duedate}"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: changeduedate_error(self, ctx, error)
    #    Description: prints error message for changeduedate command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @changeduedate.error
    async def changeduedate_error(self, ctx, error):
        """Error handling for changeduedate command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the changeduedate command, do: $changeduedate CLASSNAME HW_NAME MMM DD YYYY optional(HH:MM) optional(TIMEZONE)\n"
                " ( For example: $changeduedate CSC510 HW2 SEP 25 2024 17:02 EST)"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duethisweek(self, ctx)
    #    Description: Displays all the homeworks that are due this week along with the coursename and due date
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: returns either an error stating a reason for failure
    #             or returns a list of all the assignments that are due this week
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="duethisweek",
        pass_context=True,
        help="check all the homeworks that are due this week $duethisweek",
    )
    async def duethisweek(self, ctx):
        """Checks all homeworks or assignments due this week"""
        reminders = db.query(
            "SELECT course, reminder_name, due_date "
            "FROM reminders "
            "WHERE guild_id = %s AND date_part('day', due_date - now()) <= 7 AND date_part('minute', due_date - now()) >= 0",
            (ctx.guild.id,),
        )

        curr_date = datetime.now(timezone.utc)

        for course, reminder_name, due_date in reminders:
            delta = due_date - curr_date
            formatted_due_date = due_date.strftime("%b %d %Y %H:%M:%S%z")
            await ctx.author.send(
                f"{course} {reminder_name} is due in {delta.days} days, {delta.seconds//3600}"
                f" hours and {(delta.seconds//60)%60} minutes ({formatted_due_date})"
            )
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duethisweek_error(self, ctx, error)
    #    Description: prints error message for duethisweek command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @duethisweek.error
    async def duethisweek_error(self, ctx, error):
        """Error handling for duethisweek command"""
        await ctx.author.send(error)
        print(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duetoday(self, ctx)
    #    Description: Displays all the homeworks that are due today
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    # Outputs: returns either an error stating a reason for failure or
    #          returns a list of all the assignments that are due on the day the command is run
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="duetoday",
        pass_context=True,
        help="check all the reminders that are due today $duetoday",
    )
    async def duetoday(self, ctx):
        """Checks for all reminders that are due today"""
        due_today = db.query(
            "SELECT course, reminder_name, due_date "
            "FROM reminders "
            "WHERE guild_id = %s AND date_part('day', due_date - now()) <= 1 AND date_part('minute', due_date - now()) >= 0",
            (ctx.guild.id,),
        )
        for course, reminder_name, due_date in due_today:
            delta = due_date - datetime.now(timezone.utc)
            await ctx.author.send(
                f"{course} {reminder_name} is due in {delta.days} days, {delta.seconds//3600}"
                f" hours and {(delta.seconds//60)%60} minutes"
            )
        if len(due_today) == 0:
            await ctx.author.send("You have no dues today..!!")
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: duetoday_error(self, ctx, error)
    #    Description: prints error message for duetoday command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @duetoday.error
    async def duetoday_error(self, ctx, error):
        """Error handling for duetoday command"""
        await ctx.author.send(error)
        print(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: coursedue(self, ctx, courseid: str)
    #    Description: Displays all the reminder_names that are due for a specific course
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - courseid: name of the course for which reminder_name is to be added
    #    Outputs: returns either an error stating a reason for failure or
    #          a list of assignments that are due for the provided courseid
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="coursedue",
        pass_context=True,
        help="check all the reminders that are due for a specific course $coursedue coursename "
        "ex. $coursedue CSC505",
    )
    async def coursedue(self, ctx, courseid: str):
        """Displays a list of all reminders due for a specific course"""
        reminders = db.query(
            "SELECT reminder_name, due_date FROM reminders WHERE guild_id = %s AND course = %s",
            (ctx.guild.id, courseid),
        )
        for reminder_name, due_date in reminders:
            formatted_due_date = due_date.strftime("%b %d %Y %H:%M:%S")
            await ctx.author.send(f"{reminder_name} is due at {formatted_due_date}")
        if len(reminders) == 0:
            await ctx.author.send(
                f"Rejoice..!! You have no pending reminders for {courseid}..!!"
            )
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: coursedue_error(self, ctx, error)
    #    Description: prints error message for coursedue command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @coursedue.error
    async def coursedue_error(self, ctx, error):
        """Error handling for coursedue command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the coursedue command, do: $coursedue CLASSNAME \n ( For example: $coursedue CSC510 )"
            )
        else:
            await ctx.author.send(error)
            print(error)
        await ctx.message.delete()

    # ---------------------------------------------------------------------------------
    #    Function: listreminders(self, ctx)
    #    Description: Print out all the reminders
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: returns either an error stating a reason for failure or
    #             returns a list of all the assignments
    # ---------------------------------------------------------------------------------
    @commands.command(
        name="listreminders", pass_context=True, help="lists all reminders"
    )
    async def listreminders(self, ctx):
        """Displays user with list of all reminders"""
        author = ctx.message.author
        reminders = db.query(
            "SELECT course, reminder_name, due_date FROM reminders WHERE guild_id = %s and author_id = %s and now() < due_date",
            (ctx.guild.id, author.id),
        )

        for course, reminder_name, due_date in reminders:
            formatted_due_date = due_date.strftime("%b %d %Y %H:%M:%S%z")
            await ctx.author.send(
                f"{course} reminder named: {reminder_name} which is due on: {formatted_due_date} by {author.name}"
            )
        if not reminders:
            await ctx.author.send(
                "Mission Accomplished..!! You don't have any more dues..!!"
            )
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: listreminders_error(self, ctx, error)
    #    Description: prints error message for listreminders command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @listreminders.error
    async def listreminders_error(self, ctx, error):
        """Error handling for listreminders command"""
        await ctx.author.send(error)
        print(error)
        await ctx.message.delete()

    # ---------------------------------------------------------------------------------
    #    Function: overdue(self, ctx)
    #    Description: Print out all the reminders
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: returns either an error stating a reason for failure or
    #             returns a list of all the assignments
    # ---------------------------------------------------------------------------------
    @commands.command(name="overdue", pass_context=True, help="lists overdue reminders")
    async def overdue(self, ctx):
        """Displays list of homeworks and assignments that are overdue"""
        author = ctx.message.author
        reminders = db.query(
            "SELECT course, reminder_name, due_date FROM reminders WHERE guild_id = %s and author_id = %s"
            " and now() > due_date",
            (ctx.guild.id, author.id),
        )

        for course, reminder_name, due_date in reminders:
            formatted_due_date = due_date.strftime("%b %d %Y %H:%M:%S%z")
            await ctx.author.send(
                f"{course} reminder named: {reminder_name} which was due on: {formatted_due_date} by {author.name}"
            )
        if not reminders:
            await ctx.author.send("There are no overdue reminders")
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: listreminders_error(self, ctx, error)
    #    Description: prints error message for listreminders command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @overdue.error
    async def overdue_error(self, ctx, error):
        """Error handling for overdue command"""
        await ctx.author.send(error)
        print(error)
        await ctx.message.delete()

    # ---------------------------------------------------------------------------------
    #    Function: clearallreminders(self, ctx)
    #    Description: Delete all the reminders
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: returns either an error stating a reason for failure or
    #             returns a success message stating that reminders have been deleted
    # ---------------------------------------------------------------------------------

    @commands.command(
        name="clearreminders", pass_context=True, help="deletes all reminders"
    )
    async def clearallreminders(self, ctx):
        """Clears all reminders from database"""
        db.query("DELETE FROM reminders WHERE guild_id = %s", (ctx.guild.id,))
        await ctx.send("All reminders have been cleared..!!")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: clearallreminders_error(self, ctx, error)
    #    Description: prints error message for clearreminders command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @clearallreminders.error
    async def clearallreminders_error(self, ctx, error):
        """Error handling for clearreminders command"""
        await ctx.author.send(error)
        print(error)

    # ---------------------------------------------------------------------------------
    #    Function: remindme(self, ctx, quantity: int, time_unit : str,*, text :str)
    #    Description: Personal remind me functionality
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - quantity - time after which the data will be erased
    #    Outputs: returns either an error stating a reason for failure or
    #             returns a success message stating that reminders have been deleted
    # ---------------------------------------------------------------------------------

    # @commands.command(name="remindme", pass_context=True, help="Request the bot to set a reminder for a due date")
    # async def remindme(self, ctx, quantity: int, time_unit: str, *, text: str):

    #     time_unit = time_unit.lower()
    #     author = ctx.message.author
    #     s = ""
    #     if time_unit.endswith("s"):
    #         time_unit = time_unit[:-1]
    #         s = "s"
    #     if not time_unit in self.units:
    #         await ctx.send("Invalid unit of time. Select from seconds/minutes/hours/days/weeks/months")
    #         return
    #     if quantity < 1:
    #         await ctx.send("Quantity must not be 0 or negative")
    #         return
    #     if len(text) > 1960:
    #         await ctx.send("Text is too long.")
    #         return

    #     seconds = self.units[time_unit] * quantity
    #     future = int(time.time() + seconds)
    #     # TODO set timestamp compatible with db

    #     db.query(
    #         'INSERT INTO reminders (guild_id, author_id, future, text) VALUES (%s, %s, %s)',
    #         (ctx.guild.id, author.id, future, text)
    #     )

    #     await ctx.send("I will remind you that in {} {}.".format(str(quantity), time_unit + s))

    # @commands.Cog.listener()
    # async def on_command_error(self, ctx, error):
    #     await ctx.send('Unidentified command..please use $help to get the list of available commands')

    # -----------------------------------------------------------------------------------------------------
    #    Function: clearoverdue(self)
    #    Description: checks for expired reminders and cleans them.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: context of the command
    # -----------------------------------------------------------------------------------------------------
    @commands.command(
        name="clearoverdue", pass_context=True, help="deletes overdue reminders"
    )
    async def clearoverdue(self, ctx):
        """Clears all overdue reminders from database"""
        db.query("DELETE FROM reminders WHERE now() > due_date")
        await ctx.send("All overdue reminders have been cleared..!!")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: clearoverdue_error(self, ctx, error)
    #    Description: prints error message for clearoverdue command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @clearoverdue.error
    async def clearoverdue_error(self, ctx, error):
        """Error handling for clearoverdue"""
        await ctx.author.send(error)
        print(error)

    # -----------------------------------------------------------------------------------------------------
    #    Function: send_reminders_day(self)
    #    Description: task that runs once per day and sends a reminders for assignments due
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    # -----------------------------------------------------------------------------------------------------
    @tasks.loop(hours=24)
    async def send_reminders_day(self):
        """Task running once per day to send a reminder for assignments due"""
        channel = discord.utils.get(self.bot.get_all_channels(), name="reminders")
        if channel:
            reminders = db.query(
                "SELECT course, reminder_name, due_date "
                "FROM reminders "
                "WHERE due_date::date = now()::date"
            )
            for course, reminder_name, due_date in reminders:
                difference = due_date - datetime.now(timezone.utc)
                await channel.send(
                    f"{reminder_name} for {course} is due in {(difference.seconds//3600)} hours"
                )

    # -----------------------------------------------------------------------------------------------------
    #    Function: bofore(self)
    #    Description: runs once per day and waits until 8:00 AM EST to send reminders via the send
    #       reminders day function
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    # -----------------------------------------------------------------------------------------------------
    @send_reminders_day.before_loop
    async def before(self):
        """Task that runs once per day and waits until 8am EST to send reminders via send_reminders_day function"""
        WHEN = time(13, 0, 0)  # 8:00 AM eastern
        now = datetime.utcnow()
        target_time = datetime.combine(now.date(), WHEN)
        seconds_until_target = (target_time - now).total_seconds()
        if seconds_until_target < 0:
            target_time = datetime.combine(now.date() + timedelta(days=1), WHEN)
            seconds_until_target = (target_time - now).total_seconds()
        await asyncio.sleep(seconds_until_target)

    # -----------------------------------------------------------------------------------------------------
    #    Function: send_reminders_hour(self)
    #    Description: task that runs once per hours and sends a reminders for assignments due
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    # -----------------------------------------------------------------------------------------------------
    @tasks.loop(hours=1)
    async def send_reminders_hour(self):
        """Task that runs once per hour ans sends a reminder for assignments due"""
        channel = discord.utils.get(self.bot.get_all_channels(), name="reminders")
        if channel:
            reminders = db.query(
                "SELECT course, reminder_name, due_date "
                "FROM reminders "
                "WHERE due_date::date = now()::date"
            )
            for course, reminder_name, due_date in reminders:
                difference = due_date - datetime.now(timezone.utc)
                if difference.seconds // 3600 == 0:
                    await channel.send(
                        f"{reminder_name} for {course} is due within the hour"
                    )


# -------------------------------------
# add the file to the bot's cog system
# -------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = Deadline(bot)
    n.send_reminders_day.start()  # pylint: disable=no-member
    n.send_reminders_hour.start()  # pylint: disable=no-member
    await bot.add_cog(n)

</document_content>
</document>
<document index="11">
<source>/Users/malcolm/dev/ClassMateBot/cogs/grades.py</source>
<document_content>
# Copyright (c) 2023 nfoster1492
# This functionality provides various methods to manage grades
# It allows for the inputing of grades, searching of grades, and several
# different calculations based on existing grades in the system
import os
import sys
import discord
import pandas as pd
import requests
from io import StringIO
from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# -----------------------------------------------------------------------------------------------------------------
#    Function: get_grade_for_class(member_name: str, guild_id: str) -> int
#    Description: This function queries the DB to find current grade for class
#    Inputs:
#    - member_name: username of the member to get grade for
#    - guild_id: guild ID of the member to get grade for
#    Outputs: Total grade for the class given the grades that are currently available. If an assignment does not yet
#    have a grade it's contributiont towards the total grade is ignored.
# -----------------------------------------------------------------------------------------------------------------
def get_grade_for_class(member_name: str, guild_id: str) -> int:
    categories = db.query(
        "SELECT category_name, category_weight FROM grade_categories WHERE guild_id = %s ORDER BY category_weight DESC",
        (guild_id,),
    )

    class_total = 0
    weight_total = 0
    no_grades = True

    for category_name, category_weight in categories:
        grades = db.query(
            """SELECT grades.grade
            FROM grades
            INNER JOIN assignments ON grades.assignment_id = assignments.id
            INNER JOIN grade_categories ON assignments.category_id = grade_categories.id
            WHERE grades.guild_id = %s AND grades.member_name = %s AND grade_categories.category_name = %s
            ORDER BY grades.assignment_id""",
            (guild_id, member_name, category_name),
        )

        points = db.query(
            """SELECT assignments.points
            FROM assignments
            INNER JOIN grade_categories ON assignments.category_id = grade_categories.id
            WHERE assignments.guild_id = %s AND grade_categories.category_name = %s
            ORDER BY assignments.id""",
            (guild_id, category_name),
        )

        # Ignore if the assignment is not yet graded (does not yet contribute to grade)
        if not grades:
            continue
        if not points:
            continue

        no_grades = False

        actual_grades = [x[0] for x in grades]
        actual_points = [x[0] for x in points]

        total = 0
        points_total = 0

        for i in range(len(actual_grades)):
            total = total + (actual_grades[i] / 100) * actual_points[i]
            points_total = points_total + actual_points[i]

        average = (total / points_total) * 100

        class_total += average * float(category_weight)
        weight_total += float(category_weight)

    if no_grades:  # cannot give a grade because there are no assignments graded
        raise ValueError("No assignments are graded")

    return (
        class_total / weight_total
    )  # correct for grades that are not yet inputted (null)


class Grades(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_grade_bound(self, ctx, letter_grade: str, lower_bound: str, upper_bound: str)
    #    Description: Command to set upper and lower bounds for a letter grade in the class.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - letter_grade: letter grade to add bounds for or modify bounds of
    #    - lower_bound: number for lower_bound to be that letter_grade (inclusive)
    #    - upper_bound: number for upper_bound to be that letter_grade (inclusive)
    #    Outputs: Context author confirmation (Discord DM).
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="add_grade_bound",
        help="add upper bound and lower bound for a letter grade",
    )
    async def add_grade_bound(
        self, ctx, letter_grade: str, lower_bound: str, upper_bound: str
    ):
        try:
            exists_result = db.query(
                """SELECT lower_bound, upper_bound
                FROM grade_bounds
                WHERE grade_letter = %s""",
                (letter_grade,),
            )

            # ASSUMES THAT VALUES DO NOT OVERLAP AND ARE INPUT CORRECTLY
            if len(exists_result) >= 1:
                # If bounds already exist, update
                db.query(
                    """UPDATE grade_bounds
                    SET lower_bound = %s, upper_bound = %s
                    WHERE grade_letter = %s""",
                    (lower_bound, upper_bound, letter_grade),
                )
                await ctx.author.send(
                    f'"{letter_grade}" lower bound updated from {exists_result[0][0]} to '
                    + f"{lower_bound}, upper bound updated from {exists_result[0][1]} to {upper_bound}"
                )
            else:
                # If bounds do not exist, insert
                db.query(
                    "INSERT INTO grade_bounds VALUES (%s, %s, %s)",
                    (letter_grade, lower_bound, upper_bound),
                )
                await ctx.author.send(
                    f'"{letter_grade}" added with lower bound: {lower_bound}, '
                    + f"and upper bound: {upper_bound}"
                )
        except ValueError as e:
            await ctx.author.send(str(e))

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: grade(self, ctx, assignmentName)
    #    Description: This command lets a student get their grade for a certain assignment
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - assignmentName: the name of the desired assignment
    #    Outputs: Grade of the provided assignment
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="grade", help="get your grade for a specific assignment $grade ASSIGNMENT"
    )
    async def grade(self, ctx, assignmentName: str):
        """Lets a student get their grade for a certain assignment"""
        memberName = ctx.author.name

        grade = db.query(
            "SELECT grades.grade FROM grades INNER JOIN assignments ON grades.assignment_id = assignments.id WHERE grades.guild_id = %s AND grades.member_name = %s AND assignments.assignment_name = %s",
            (ctx.guild.id, memberName, assignmentName),
        )

        points = db.query(
            "SELECT assignments.points FROM assignments WHERE assignments.guild_id = %s AND assignments.assignment_name = %s",
            (ctx.guild.id, assignmentName),
        )

        if not grade:
            await ctx.author.send(f"Grade for {assignmentName} does not exist")
            return

        if not points:
            await ctx.author.send(f"{assignmentName} does not exist")
            return

        await ctx.author.send(
            f"Grade for {assignmentName}: {grade[0][0]}%, worth {points[0][0]} points"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: grade_error(self, ctx, error)
    #    Description: prints error message for grade command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @grade.error
    async def grade_error(self, ctx, error):
        """Error handling of grade function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the grade command, do: $grade <assignmentname>\n ( For example: $grade test1 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: gradebycategory(self, ctx, categoryName)
    #    Description: This command lets a student get their average grade for a certain category
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryName: the name of the desired category
    #    Outputs: Average grade of all the assignments in the provided category, accounting for assignment point values
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="gradebycategory",
        help="get your grade for a specific category $gradebycategory CATEGORY",
    )
    async def gradebycategory(self, ctx, categoryName: str):
        """Lets a student get their grade for a specific grade category"""
        memberName = ctx.author.name

        grades = db.query(
            "SELECT grades.grade FROM grades INNER JOIN assignments ON grades.assignment_id = assignments.id INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE grades.guild_id = %s AND grades.member_name = %s AND grade_categories.category_name = %s ORDER BY grades.assignment_id",
            (ctx.guild.id, memberName, categoryName),
        )

        points = db.query(
            "SELECT assignments.points FROM assignments INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE assignments.guild_id = %s AND grade_categories.category_name = %s ORDER BY assignments.id",
            (ctx.guild.id, categoryName),
        )

        if not grades:
            await ctx.author.send(f"Grades for {categoryName} do not exist")
            return

        if not points:
            await ctx.author.send(f"Assignments for {categoryName} do not exist")
            return

        actualGrades = []
        for grade in grades:
            actualGrades.append(grade[0])

        actualPoints = []
        for point in points:
            actualPoints.append(point[0])

        total = 0
        pointsTotal = 0

        for i in range(len(actualGrades)):
            total = total + (actualGrades[i] / 100) * actualPoints[i]
            pointsTotal = pointsTotal + actualPoints[i]

        average = (total / pointsTotal) * 100

        await ctx.author.send(f"Grade for {categoryName}: {average:.2f}%")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: gradebycategory_error(self, ctx, error)
    #    Description: prints error message for gradebycategory command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @gradebycategory.error
    async def gradebycategory_error(self, ctx, error):
        """Error handling of gradebycategory function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the gradebycategory command, do: $gradebycategory <categoryname>\n"
                + "( For example: $gradebycategory tests )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: gradeforclass(self, ctx)
    #    Description: This command lets a student get their average grade for the whole class
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Average grade of all the assignments in the class, weighted by category, accounting for assignment
    #    point values
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="gradeforclass",
        help="get your grade for the whole class $gradeforclass",
    )
    async def gradeforclass(self, ctx):
        """Lets a student get their overall average grade for the class"""
        try:
            await ctx.author.send(
                f"Grade for class: {get_grade_for_class(ctx.author.name, ctx.guild.id):.2f}%"
            )
        except ValueError as e:
            await ctx.author.send(str(e))

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: calculate_gpa(self, ctx)
    #    Description: This command lets a student get their FORCASTED gpa using grades in previous classes as well as
    #    their forcasted GPA in their current class. Courses are weighted as if they all have the same weight.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Context message of forcasted GPA as well as current letter grade and points grade in class.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="calculate_gpa")
    async def calculate_gpa(self, ctx):
        try:
            curr_grade = get_grade_for_class(ctx.author.name, ctx.guild.id)

            curr_grade_point, curr_letter = db.query(
                f"""SELECT grade_point, grade_letter
                FROM (
                    SELECT grade_letter
                    FROM grade_bounds
                    WHERE {curr_grade} BETWEEN lower_bound AND upper_bound
                ) AS curr_grade_letter
                JOIN letter_grades
                ON letter = grade_letter"""
            )[0]

            previous_gpa = db.query(
                """SELECT AVG(grade_point)
                FROM (
                    SELECT grade_point
                    FROM letter_grades JOIN (
                        SELECT course_grade
                        FROM previous_course_grades
                        WHERE member_name = %s
                    ) AS student_grades
                    ON letter = course_grade
                ) AS previous_grades""",
                (ctx.author.name,),
            )[0][0]

            forcasted_gpa = db.query(
                f"""SELECT AVG(grade_point)
                FROM (
                    SELECT grade_point
                    FROM letter_grades JOIN (
                        SELECT course_grade
                        FROM previous_course_grades
                        WHERE member_name = %s
                    ) AS student_grades
                    ON letter = course_grade

                    UNION ALL

                    SELECT {curr_grade_point} AS grade_point
                ) AS all_grades""",
                (ctx.author.name,),
            )[0][0]

            await ctx.author.send(
                f"Current grade for class: {curr_grade:.2f}\n"
                + f"Current letter grade for class: {curr_letter}\n"
                + f"Current grade point for class: {curr_grade_point}\n"
                + f"Previous GPA: {previous_gpa:.2f}\n"
                + f"Forcasted GPA: {forcasted_gpa:.2f}"
            )

        except ValueError as e:
            await ctx.author.send(str(e))
            print(e)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: gradeforclass_error(self, ctx, error)
    #    Description: prints error message for gradeforclass command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @gradeforclass.error
    async def gradeforclass_error(self, ctx, error):
        """Error handling of gradeforclass function"""
        await ctx.author.send(error)
        print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: graderequired(self, ctx, categoryName, pointValue, desiredGrade)
    #    Description: This command lets a student get the grade they need on the next assignment to keep a desired grade
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryName: the name of the desired category
    #    - pointValue: the amount of points the next assignment will be worth
    #    - desiredGrade: the grade desired for the category
    #    Outputs: The necessary grade on the next assignment to maintain a certain grade in a category
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="graderequired",
        help="get your grade required on the next assignment for a category and a desired grade $graderequired CATEGORY POINTS GRADE",
    )
    async def graderequired(
        self, ctx, categoryName: str, pointValue: str, desiredGrade: str
    ):
        """Lets a student calculate the grade they need for a desired grade in a category"""
        memberName = ctx.author.name

        grades = db.query(
            "SELECT grades.grade FROM grades INNER JOIN assignments ON grades.assignment_id = assignments.id INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE grades.guild_id = %s AND grades.member_name = %s AND grade_categories.category_name = %s ORDER BY grades.assignment_id",
            (ctx.guild.id, memberName, categoryName),
        )

        points = db.query(
            "SELECT assignments.points FROM assignments INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE assignments.guild_id = %s AND grade_categories.category_name = %s ORDER BY assignments.id",
            (ctx.guild.id, categoryName),
        )

        if not grades:
            await ctx.author.send(f"Grades for {categoryName} do not exist")
            return

        if not points:
            await ctx.author.send(f"Assignments for {categoryName} do not exist")
            return

        actualGrades = []
        for grade in grades:
            actualGrades.append(grade[0])

        actualPoints = []
        for point in points:
            actualPoints.append(point[0])

        total = 0
        pointsTotal = 0

        for i in range(len(actualGrades)):
            total = total + (actualGrades[i] / 100) * actualPoints[i]
            pointsTotal = pointsTotal + actualPoints[i]

        pointsNeeded = (
            (int(desiredGrade) / 100) * (pointsTotal + int(pointValue))
        ) - total

        gradeNeeded = (pointsNeeded / int(pointValue)) * 100

        if gradeNeeded < 0:
            await ctx.author.send(
                f"Grade on next assignment needed to keep {desiredGrade}% in {categoryName}: 0%"
            )
            return

        await ctx.author.send(
            f"Grade on next assignment needed to keep {desiredGrade}% in {categoryName}: {gradeNeeded:.2f}%"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: graderequired_error(self, ctx, error)
    #    Description: prints error message for graderequired command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @graderequired.error
    async def graderequired_error(self, ctx, error):
        """Error handling of graderequired function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the graderequired command, do: $graderequired <categoryname> <pointsvalue> <desiredgrade>\n ( For example: $graderequired tests 200 90 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: graderequiredforclass(self, ctx, categoryName, pointValue, desiredGrade)
    #    Description: This command lets a student get the grade they need on the next assignment to keep a desired grade
    #    in the class
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryName: the name of the category the next assignment will fall in
    #    - pointValue: the amount of points the next assignment will be worth
    #    - desiredGrade: the grade desired for the class
    #    Outputs: The necessary grade on the next assignment to maintain a desired grade in the class
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="graderequiredforclass",
        help="get your grade required on the next assignment to keep a desired grade $graderequiredforclass CATEGORY POINTS GRADE",
    )
    async def graderequiredforclass(
        self, ctx, categoryName: str, pointValue: str, desiredGrade: str
    ):
        """Lets a student calculate the grade required on the next assignment to keep an overall desired class grade"""
        memberName = ctx.author.name

        categories = db.query(
            "SELECT category_name, category_weight FROM grade_categories WHERE guild_id = %s ORDER BY category_weight DESC",
            (ctx.guild.id,),
        )

        classTotal = 0

        for category_name, category_weight in categories:
            if categoryName == category_name:
                categoryWeight = category_weight
                break

            grades = db.query(
                "SELECT grades.grade FROM grades INNER JOIN assignments ON grades.assignment_id = assignments.id INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE grades.guild_id = %s AND grades.member_name = %s AND grade_categories.category_name = %s ORDER BY grades.assignment_id",
                (ctx.guild.id, memberName, category_name),
            )

            points = db.query(
                "SELECT assignments.points FROM assignments INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE assignments.guild_id = %s AND grade_categories.category_name = %s ORDER BY assignments.id",
                (ctx.guild.id, category_name),
            )

            if not grades:
                await ctx.author.send(f"Grades for {category_name} do not exist")
                return

            if not points:
                await ctx.author.send(f"Assignments for {categoryName} do not exist")
                return

            actualGrades = []
            for grade in grades:
                actualGrades.append(grade[0])

            actualPoints = []
            for point in points:
                actualPoints.append(point[0])

            total = 0
            pointsTotal = 0

            for i in range(len(actualGrades)):
                total = total + (actualGrades[i] / 100) * actualPoints[i]
                pointsTotal = pointsTotal + actualPoints[i]

            average = (total / pointsTotal) * 100

            classTotal = classTotal + average * float(category_weight)

        categoryGradeNeeded = (int(desiredGrade) - classTotal) / float(category_weight)

        if categoryGradeNeeded < 0:
            await ctx.author.send(
                f"Grade on next assignment needed to keep {int(desiredGrade)}%: 0%"
            )
            return

        grades = db.query(
            "SELECT grades.grade FROM grades INNER JOIN assignments ON grades.assignment_id = assignments.id INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE grades.guild_id = %s AND grades.member_name = %s AND grade_categories.category_name = %s ORDER BY grades.assignment_id",
            (ctx.guild.id, memberName, categoryName),
        )

        points = db.query(
            "SELECT assignments.points FROM assignments INNER JOIN grade_categories ON assignments.category_id = grade_categories.id WHERE assignments.guild_id = %s AND grade_categories.category_name = %s ORDER BY assignments.id",
            (ctx.guild.id, categoryName),
        )

        if not grades:
            await ctx.author.send(f"Grades for {categoryName} do not exist")
            return

        if not points:
            await ctx.author.send(f"Assignments for {categoryName} do not exist")
            return

        actualGrades = []
        for grade in grades:
            actualGrades.append(grade[0])

        actualPoints = []
        for point in points:
            actualPoints.append(point[0])

        total = 0
        pointsTotal = 0

        for i in range(len(actualGrades)):
            total = total + (actualGrades[i] / 100) * actualPoints[i]
            pointsTotal = pointsTotal + actualPoints[i]

        # pointsNeeded = ((int(desiredGrade) / 100) * (pointsTotal + int(pointValue))) - total

        pointsNeeded = (
            (categoryGradeNeeded / 100) * (pointsTotal + int(pointValue))
        ) - total

        gradeNeeded = (pointsNeeded / int(pointValue)) * 100

        if gradeNeeded < 0:
            await ctx.author.send(
                f"Grade on next assignment needed to keep {int(desiredGrade)}%: 0%"
            )
            return

        await ctx.author.send(
            f"Grade on next assignment needed to keep {int(desiredGrade)}%: {gradeNeeded:.2f}%"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: graderequiredforclass_error(self, ctx, error)
    #    Description: prints error message for graderequiredforclass command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @graderequiredforclass.error
    async def graderequiredforclass_error(self, ctx, error):
        """Error handling of graderequiredforclass function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the graderequiredforclass command, do: $graderequiredforclass <categoryname> <pointsvalue> <desiredgrade>\n ( For example: $graderequiredforclass tests 200 90 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: categories(self, ctx)
    #    Description: This command lets the user list the categories of grades that are in the system
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: A list of the grade categories in the system
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="categories", help="display all grading categories and weights $categories"
    )
    async def categories(self, ctx):
        """Lets the user list the categories of grades that are in the database"""
        categories = db.query(
            "SELECT category_name, category_weight FROM grade_categories WHERE guild_id = %s ORDER BY category_weight DESC",
            (ctx.guild.id,),
        )

        await ctx.author.send("Category | Weight")
        await ctx.author.send("================")

        for category_name, category_weight in categories:
            await ctx.author.send(f"{category_name} | {category_weight}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: input_grades(self, ctx, assignmentname)
    #    Description: This command allows the instructor to input grades into the system for a given assignment
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context, including the attached csv file
    #    - assignmentname: the assignment that  grades are being input for
    #    Outputs: A report on how the grades in the system were altered
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(name="inputgrades", help="Insert grades using a csv file")
    async def input_grades(self, ctx, assignmentname: str, test="False", path=""):
        """Lets the instructor input grades into the system for a given assignment"""
        print(assignmentname)
        assignment = db.query(
            "SELECT id FROM assignments WHERE guild_id = %s AND assignment_name = %s",
            (ctx.guild.id, assignmentname),
        )

        if not assignment:
            await ctx.send(f"Assignment with name {assignmentname} does not exist")
            return
        if len(ctx.message.attachments) != 1 and test == "False":
            await ctx.send("Must have exactly one attachment")
            return
        if (
            test == "False"
            and ctx.message.attachments[0].content_type != "text/csv; charset=utf-8"
        ):
            await ctx.send("Invalid filetype")
        data = None
        if test == "False":
            attachmenturl = ctx.message.attachments[0].url
            response = requests.get(attachmenturl, timeout=10)
            data = StringIO(response.text)
        if test == "TestingTrue":
            data = path
        df = pd.read_csv(data)
        edited = 0
        added = 0
        for i in range(len(df)):
            name = df.loc[i, "name"]
            grade = df.loc[i, "grade"].item()
            if grade < 0 or grade > 100:
                await ctx.send(
                    f"Invalid grade value for student {name}, skipping entry"
                )
                continue
            student = db.query(
                "SELECT username FROM name_mapping WHERE username = %s", (name,)
            )
            if not student:
                await ctx.send(f"Invalid student name {name}, skipping entry")
                continue
            existing = db.query(
                "SELECT member_name FROM grades WHERE assignment_id = %s AND member_name = %s",
                (assignment[0], name),
            )

            if existing:
                edited += 1
                db.query(
                    "UPDATE grades SET grade = %s WHERE assignment_id = %s AND member_name = %s",
                    (grade, assignment[0], name),
                )
            else:
                added += 1
                db.query(
                    "INSERT INTO grades (guild_id, member_name, assignment_id, grade) VALUES (%s, %s, %s, %s)",
                    (ctx.guild.id, name, assignment[0], grade),
                )
        await ctx.send(
            f"Entered grades for {assignmentname}, {added} new grades entered, {edited} grades edited"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: input_grades_error(self, ctx, error)
    #    Description: prints error message for inputgrades command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @input_grades.error
    async def input_grades_error(self, ctx, error):
        """Error handling for inputgrades command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the inputgrades command, do: $inputgrades <assignmentname> and add your csv file attachment\n ( For example: $editgradecategory test1 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_grade_category(self, ctx, categoryname, weight)
    #    Description: This command lets the instructor add a grade category, and set the weight for it
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryname: the name of the grade category
    #    - weight: the weight of the category, must be greater than 0
    #    Outputs: Whether or not the add was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="addgradecategory",
        help="add a grading category and weight $addgradecategory NAME WEIGHT",
    )
    async def add_grade_category(self, ctx, categoryname: str, weight: str):
        """Lets the instructor add a grade category with a specified weight"""
        try:
            categoryweight = float(weight)
        except ValueError:
            await ctx.author.send("Weight could not be parsed")
            return
        if categoryweight < 0:
            await ctx.author.send("Weight must be greater than 0")
            return
        if categoryweight > 1:
            await ctx.author.send("Weight must be less than 1")
            return

        existing = db.query(
            "SELECT id FROM grade_categories WHERE guild_id = %s AND category_name = %s",
            (ctx.guild.id, categoryname),
        )
        if existing:
            await ctx.author.send("This category has already been added..!!")
            return

        current_weight_sum = db.query(
            """SELECT SUM(category_weight)
            FROM grade_categories
            WHERE guild_id = %s""",
            (ctx.guild.id,),
        )[0][0]

        if (
            current_weight_sum is not None
            and float(current_weight_sum) + categoryweight > 1
        ):
            await ctx.author.send(
                "This category weight would make the total weight more than 1..!!"
            )
            return

        db.query(
            "INSERT INTO grade_categories (guild_id, category_name, category_weight) VALUES (%s, %s, %s)",
            (ctx.guild.id, categoryname, weight),
        )
        await ctx.send(
            f"A grading category has been added for: {categoryname}  with weight: {weight} "
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_grade_category_error(self, ctx, error)
    #    Description: prints error message for addgradecategory command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @add_grade_category.error
    async def add_grade_category_error(self, ctx, error):
        """Error handling for add_grade_category command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the gradecategory command, do: $gradecategory <categoryname> <weight> \n ( For example: $gradecategory tests .5 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: edit_grade_category(self, ctx, categoryname, weight)
    #    Description: This command lets the instructor edit a grade category, and set a new weight for it
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryname: the name of the grade category
    #    - weight: the weight of the category, must be greater than 0
    #    Outputs: Whether or not the edit was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="editgradecategory",
        help="edit a grading category and weight $editgradecategory NAME WEIGHT",
    )
    async def edit_grade_category(self, ctx, categoryname: str, weight: str):
        """Lets the instructor edit a grade category and weight"""
        try:
            categoryweight = float(weight)
        except ValueError:
            await ctx.send("Weight could not be parsed")
            return
        if categoryweight < 0:
            await ctx.send("Weight must be greater than 0")
            return
        existing = db.query(
            "SELECT id FROM grade_categories WHERE guild_id = %s AND category_name = %s",
            (ctx.guild.id, categoryname),
        )
        if existing:
            db.query(
                "UPDATE grade_categories SET category_weight = %s WHERE id = %s",
                (weight, existing[0]),
            )
            await ctx.send(
                f"{categoryname} category has been updated with weight:{weight} "
            )
        else:
            await ctx.send("This category does not exist")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: edit_grade_category_error(self, ctx, error)
    #    Description: prints error message for editgradecategory command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @edit_grade_category.error
    async def edit_grade_category_error(self, ctx, error):
        """Error handling for edit_grade_category command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the editgradecategory command, do: $editgradecategory <categoryname> <weight> \n ( For example: $editgradecategory tests .5 )"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: delete_grade_category(self, ctx, categoryname)
    #    Description: This command lets the instructor delete a grade category
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - categoryname: the name of the grade category
    #    Outputs: Whether or not the delete was a success
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deletegradecategory",
        help="delete a grading category $deletegradecategory NAME",
    )
    async def delete_grade_category(self, ctx, categoryname: str):
        """Lets the user delete a grade category from the database"""
        existing = db.query(
            "SELECT id FROM grade_categories WHERE guild_id = %s AND category_name = %s",
            (ctx.guild.id, categoryname),
        )
        if existing:
            db.query("DELETE FROM grade_categories WHERE id = %s", (existing[0]))
            await ctx.send(f"{categoryname} category has been deleted ")
        else:
            await ctx.send("This category does not exist")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: delete_grade_category_error(self, ctx, error)
    #    Description: prints error message for deletegradecategory command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @delete_grade_category.error
    async def delete_grade_category_error(self, ctx, error):
        """Error handling for delete_grade_category command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the deletegradecategory command, do: $deletegradecategory <categoryname> \n ( For example: $deletegradecategory tests)"
            )
            await ctx.message.delete()
        else:
            await ctx.author.send(error)
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: grade_report_category(self, ctx)
    #    Description: This command lets the instructor generate a report on the average, low, and high score on each category
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: A breakdown on the performance of each category
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="gradereportcategory",
        help="Report on the classes scores all grade categories",
    )
    async def grade_report_category(self, ctx):
        """Lets the instructor generate a report on the average, low, and high score for each category"""
        result = db.query(
            """SELECT category_name, AVG(grade_percent), MAX(grade_percent), MIN(grade_percent)
                    FROM (SELECT category_name, CAST(grade AS float) / CAST(points AS float) AS grade_percent
                        FROM grade_categories AS categ JOIN
                            (SELECT category_id, grade, points
                                FROM grades AS grades JOIN assignments AS assign ON grades.assignment_id = assign.id) AS grades
                        ON grades.category_id = categ.id) AS grade_percents
                GROUP BY category_name"""
        )

        await ctx.author.send("Grade Breakdown by Category")
        for category_name, avg, maxgrade, mingrade in result:
            await ctx.author.send(
                f"{category_name} | Average: {avg:.2f}, Max: {maxgrade:.2f}, Min: {mingrade:.2f}"
            )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: grade_report_assignment(self, ctx)
    #    Description: This command lets the instructor generate a report on the average, low, and high score on each assignment
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: A breakdown on the performance of each assignment
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="gradereportassignment",
        help="Report on the classes scores all assignments",
    )
    async def grade_report_assignment(self, ctx):
        """Lets the instructor generate a report on the average, low, and high score for each assignment"""
        result = db.query(
            """SELECT assignment_name, AVG(grade_percent), MAX(grade_percent), MIN(grade_percent)
                FROM (SELECT assignment_name, CAST(grade AS float) / CAST(points AS float) AS grade_percent
                    FROM grades AS grades JOIN assignments AS assign
                        ON grades.assignment_id = assign.id) AS assignment_grades
                GROUP BY assignment_name;"""
        )

        await ctx.author.send("Grade Breakdown by Assignment")
        for assignment_name, avg, maxgrade, mingrade in result:
            await ctx.author.send(
                f"{assignment_name} | Average: {avg:.2f}, Max: {maxgrade:.2f}, Min: {mingrade:.2f}"
            )


# -------------------------------------
# add the file to the bot's cog system
# -------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Grades(bot))

</document_content>
</document>
<document index="12">
<source>/Users/malcolm/dev/ClassMateBot/cogs/groups.py</source>
<document_content>
# Copyright (c) 2021 War-Keeper
import os
import sys

import discord
from discord.ext import commands
from discord.utils import get

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# -----------------------------------------------------------
# This File contains commands for joining a group, leaving a group,
# and displaying which groups are available
# -----------------------------------------------------------
class Groups(commands.Cog):
    student_pool = {}

    # -----------------------------------------------------------
    # initialize
    # -----------------------------------------------------------
    def __init__(self, bot):
        self.bot = bot

    # -------------------------------------------------------------------------------------------------------
    #    Function: reset(self, ctx)
    #    Description: deletes all group roles in the server
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: confirms role deletion
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="reset", help="Resets group channels and roles. DO NOT USE IN PRODUCTION!"
    )
    async def reset(self, ctx):
        """Deletes all group roles in the server"""
        await ctx.send("Deleting all roles...")

        for i in range(100):
            role_name = "group_" + str(i)
            role = get(ctx.message.guild.roles, name=role_name)
            if role is None:
                continue
            await role.delete()

        await ctx.author.send("Roles deleted!")
        print("Roles deleted!")

    # -------------------------------------------------------------------------------------------------------
    #    Function: reset_error(self, ctx, error)
    #    Description: prints error message for reset command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @reset.error
    async def reset_error(self, ctx, error):
        """Error handling for reset command"""
        await ctx.author.send(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: customizegroups(self, ctx, total_groups, max_members)
    #    Description: customize group settings
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - total_groups: total number of groups
    #    - max_members: maximum members per group
    #    Outputs: creates customized settings for groups
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="customizegroups",
        help="To use the customizegroups command, do: $customizegroups <Num> <Num> \n \
    ( For example: $customizegroups 4 5)",
        pass_context=True,
    )
    async def customizegroups(self, ctx, total_groups: int, max_members: int):
        """Customize group settings"""
        db.query(
            "INSERT INTO group_settings (guild_id, total_groups, max_members) VALUES (%s, %s, %s)",
            (ctx.guild.id, total_groups, max_members),
        )
        await ctx.send(
            f"Group settings have been set with {total_groups} total groups, {max_members} maximum members"
        )

    # -------------------------------------------------------------------------------------------------------
    #    Function: customizegroups_error(self, ctx, error)
    #    Description: prints error message for customizegroups command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @customizegroups.error
    async def customizegroups_error(self, ctx, error):
        """Error handling for customizegroups command"""
        await ctx.author.send(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: startupgroups(self, ctx)
    #    Description: creates roles for the groups
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: creates roles for groups
    # -------------------------------------------------------------------------------------------------------
    @commands.command(name="startupgroups", help="Creates group roles for members")
    async def startupgroups(self, ctx):
        """Creates roles for the groups"""
        await ctx.send("Creating roles....")

        total_groups = (
            db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )[0][0]
            if db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )
            else 99
        )

        for i in range(total_groups):
            role_name = "group_" + str(i)
            existing_role = get(ctx.guild.roles, name=role_name)
            print(i)
            if existing_role is None:
                await ctx.guild.create_role(name=role_name)

        print("Roles created successfully!")

    # -------------------------------------------------------------------------------------------------------
    #    Function: startupgroups_error(self, ctx, error)
    #    Description: prints error message for startupgroups command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @startupgroups.error
    async def startupgroups_error(self, ctx, error):
        """Error handling for startupgroups command"""
        await ctx.author.send(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: connect(self, ctx)
    #    Description: connects all users with their groups
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: creates a private text channel for all groups
    # -------------------------------------------------------------------------------------------------------
    @commands.command(name="connect", help="Creates group roles for members")
    async def connect(self, ctx):
        """Retrieve total groups"""
        total_groups = (
            db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )[0][0]
            if db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )
            else 99
        )

        # Connects all users with their groups
        for i in range(total_groups):
            group_name = "group-" + str(i)
            existing_channel = get(ctx.guild.text_channels, name=group_name)
            if existing_channel is not None:
                await existing_channel.delete()

        groups = db.query(
            "SELECT group_num, array_agg(member_name) "
            "FROM group_members WHERE guild_id = %s GROUP BY group_num ORDER BY group_num",
            (ctx.guild.id,),
        )

        for group_num, *_ in groups:
            role_string = "group_" + str(group_num)
            user_role = get(ctx.guild.roles, name=role_string)

            overwrites = {
                ctx.guild.default_role: discord.PermissionOverwrite(
                    read_messages=False
                ),
                ctx.author: discord.PermissionOverwrite(read_messages=True),
                user_role: discord.PermissionOverwrite(read_messages=True),
            }
            group_channel_name = "group-" + str(group_num)
            await ctx.guild.create_text_channel(
                group_channel_name, overwrites=overwrites
            )

    # -------------------------------------------------------------------------------------------------------
    #    Function: connect_error(self, ctx, error)
    #    Description: prints error message for connect command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @connect.error
    async def connect_error(self, ctx, error):
        """Error handling for connect command"""
        await ctx.author.send(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: join(self, ctx, group_num='-1')
    #    Description: joins the user to the given group
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - group_num: the number of the group
    #    Outputs: adds the user to the given group or returns an error if the group is invalid or in case of
    #             syntax errors
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="join",
        help="To use the join command, do: $join <Num> \n \
    ( For example: $join 0 )",
        pass_context=True,
    )
    async def join(self, ctx, group_num: int):
        """Joins the user to given group"""
        # get the name of the caller
        member_name = ctx.message.author.display_name.upper()
        member = ctx.message.author

        # Retrieve total groups
        total_groups = (
            db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )[0][0]
            if db.query(
                "SELECT total_groups FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )
            else 99
        )

        if group_num < 0 or group_num > total_groups:
            await ctx.send("Not a valid group")
            await ctx.send(
                "To use the join command, do: $join <Num> "
                "where 0 <= <Num> <= total groups$ \n ( For example: $join 0 )"
            )
            return

        # Retrieve maximum members in a group
        max_members = (
            db.query(
                "SELECT max_members FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )[0][0]
            if db.query(
                "SELECT max_members FROM group_settings WHERE guild_id = %s",
                (ctx.guild.id,),
            )
            else 6
        )

        group_count = db.query(
            "SELECT COUNT(group_num) FROM group_members WHERE guild_id = %s AND group_num = %s",
            (ctx.guild.id, group_num),
        )

        if group_count == max_members:
            await ctx.send(f"A group cannot have more than {max_members} people!")
            return

        current_group_num = db.query(
            "SELECT group_num FROM group_members WHERE guild_id = %s AND member_name = %s",
            (ctx.guild.id, member_name),
        )

        if current_group_num:
            await ctx.send(f"You are already in Group {current_group_num[0][0]}")
            return

        db.query(
            "INSERT INTO group_members (guild_id, group_num, member_name) VALUES (%s, %s, %s)",
            (ctx.guild.id, group_num, member_name),
        )
        identifier = "group_" + str(group_num)
        role = get(ctx.guild.roles, name=identifier)

        if role is None:
            await ctx.guild.create_role(name=identifier)
            role = get(ctx.guild.roles, name=identifier)

        await member.add_roles(role)

        await ctx.send(
            f"You are now in Group {group_num}! There are now {group_count[0][0] + 1}/{max_members} members."
        )

    # -------------------------------------------------------------------------------------------------------
    #    Function: join_error(self, ctx, error)
    #    Description: prints error message for join command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @join.error
    async def join_error(self, ctx, error):
        """Error handling for join command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the join command, do: $join <Num> \n ( For example: $join 0 )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: leave(self, ctx)
    #    Description: removes the user from the given group
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: removes the user from the given group or returns an error if the group is invalid or in
    #             case of syntax errors
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="leave",
        help="To use the leave command, do: $leave \n \
    ( For example: $leave )",
        pass_context=True,
    )
    async def leave(self, ctx):
        """Removes the user from the given group"""
        # get the name of the caller
        member_name = ctx.message.author.display_name.upper()
        member = ctx.message.author

        current_group_num = db.query(
            "SELECT group_num FROM group_members WHERE guild_id = %s AND member_name = %s",
            (ctx.guild.id, member_name),
        )

        if current_group_num:
            db.query(
                "DELETE FROM group_members WHERE guild_id = %s AND member_name = %s",
                (ctx.guild.id, member_name),
            )
            await ctx.send(
                f"You have been removed from Group {current_group_num[0][0]}!"
            )

            identifier = "group_" + str(current_group_num[0][0])
            role = get(ctx.guild.roles, name=identifier)
            await member.remove_roles(role)

        else:
            await ctx.send("You are not in a group!")

    # -------------------------------------------------------------------------------------------------------
    #    Function: leave_error(self, ctx, error)
    #    Description: prints error message for leave command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @leave.error
    async def leave_error(self, ctx, error):
        """Error handling for leave command"""
        await ctx.author.send(error)
        # await ctx.message.delete()
        print(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: group(self, ctx)
    #    Description: prints the list of groups
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: prints the list of groups
    # -------------------------------------------------------------------------------------------------------
    @commands.command(name="groups", help="prints group counts", pass_context=True)
    # @commands.dm_only()
    # TODO maybe include channel where all groups displayed
    async def groups(self, ctx):
        """Prints the list of groups"""
        # load groups csv
        groups = db.query(
            "SELECT group_num, array_agg(member_name) "
            "FROM group_members WHERE guild_id = %s GROUP BY group_num ORDER BY group_num",
            (ctx.guild.id,),
        )

        # create embedded objects
        embed = discord.Embed(title="Group List", color=discord.Color.teal())
        embed.set_thumbnail(
            url="https://i.pinimg.com/474x/e7/e3/bd/e7e3bd1b5628510a4e9d7a9a098b7be8.jpg"
        )

        for group_num, members in groups:
            embed.add_field(
                name=f"Group {group_num}", value=str(len(members)), inline=True
            )

        # print the embedded objects
        embed.set_footer(text="Number Represents the Group Size")
        await ctx.send(embed=embed)

    # -------------------------------------------------------------------------------------------------------
    #    Function: groups_error(self, ctx, error)
    #    Description: prints error message for groups command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @groups.error
    async def groups_error(self, ctx, error):
        """Error handling for groups command"""
        await ctx.author.send(error)
        # await ctx.message.delete()
        print(error)

        # -------------------------------------------------------------------------------------------------------

    #    Function: group(self, ctx, group_num)
    #    Description: prints the members of the group, or the current members group if they have a group
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - group_num: the group number to list names for
    #    Outputs: prints the name of people in the group
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="group",
        help="print names of members in a group, or current groups members \n \
    ( For example: $group or $group 8 )",
        pass_context=True,
    )
    # @commands.dm_only()
    # TODO maybe include channel where all groups displayed
    async def group(self, ctx, group_num: int = -1):
        """Prints the members of the group, or the current member's group if they have joined one"""
        if group_num == -1:
            member_name = ctx.message.author.display_name.upper()

            group_num = db.query(
                "SELECT group_num FROM group_members WHERE guild_id = %s and member_name = %s",
                (ctx.guild.id, member_name),
            )

            if not group_num:
                await ctx.send("You are not in a group!")
                return

            group_num = group_num[0][0]

        # load groups csv
        group = db.query(
            "SELECT member_name FROM group_members WHERE guild_id = %s and group_num = %s",
            (ctx.guild.id, group_num),
        )

        # create embedded objects
        embed = discord.Embed(title="Group Members", color=discord.Color.teal())
        embed.set_thumbnail(
            url="https://i.pinimg.com/474x/e7/e3/bd/e7e3bd1b5628510a4e9d7a9a098b7be8.jpg"
        )

        members = ""

        for member in group:
            members += member[0] + "\n"

        if members == "":
            members = "None"

        embed.add_field(name=f"Group {group_num}: ", value=members, inline=True)

        # print the embedded objects
        await ctx.send(embed=embed)

    # -------------------------------------------------------------------------------------------------------
    #    Function: group_error(self, ctx, error)
    #    Description: prints error message for group command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -------------------------------------------------------------------------------------------------------
    @group.error
    async def group_error(self, ctx, error):
        """Error handling for group command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the group command, do: $group <Num> \n ( For example: $group 0 )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------
    # This is a testing arg, not really used for anything else but adding to the csv file
    # -----------------------------------------------------------
    # @commands.command(name='test_name', help='add a name to the name_mapping.csv', pass_context=True)
    # async def test_name(self, ctx, arg, arg2):
    #     student_pool = load_pool()
    #     display_name = ctx.message.author.display_name
    #     display_name_upper = display_name.upper()
    #
    #     if student_pool.get(display_name_upper) is None:
    #         student_pool[display_name_upper] = arg.upper() + ' ' + arg2.upper()
    #     else:
    #         member_name = student_pool[display_name_upper]
    #         await ctx.send('You have already registered with the name: ' + member_name.title())
    #
    #     print_pool(student_pool)


# # ------------------------------------------------------------
# # Used to load the members from the csv file into a dictionary
# # ------------------------------------------------------------
# def load_pool() -> dict:
#     dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
#     os.chdir(dir)
#     os.chdir('data')
#     os.chdir('server_data')
#     with open('name_mapping.csv', mode='r') as infile:
#         reader = csv.reader(infile)
#         student_pools = {rows[0].upper(): rows[1].upper() for rows in reader}
#     return student_pools


# # -----------------------------------------------------------
# # Used to print the members to the csv file
# # -----------------------------------------------------------
# def print_pool(pools):
#     dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
#     os.chdir(dir)
#     os.chdir('data')
#     os.chdir('server_data')
#     with open('name_mapping.csv', mode='w', newline="") as outfile:
#         writer = csv.writer(outfile)
#         for key, value in pools.items():
#             writer.writerow([key, value])


# -----------------------------------------------------------
# add the file to the bot's cog system
# -----------------------------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Groups(bot))

</document_content>
</document>
<document index="13">
<source>/Users/malcolm/dev/ClassMateBot/cogs/newComer.py</source>
<document_content>
# This file contains functionality related to new student verification
import os
import sys
import discord
from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# ---------------------------------------------------------------------------------------
# Contains commands for member verification, which is handled with direct DMs to the bot
# ---------------------------------------------------------------------------------------
class NewComer(commands.Cog):
    path = os.path.join("data", "welcome")

    def __init__(self, bot):
        self.bot = bot

    # -------------------------------------------------------------------------------------------------------------
    #    Function: verify(self, ctx, *, name: str = None)
    #    Description: Ask the bot to give the user the verified role in the server
    #    Constraint: only other verified members can use this command
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - *:
    #    - name: name of the user to verify
    #    Outputs: returns a success message if the user is successfully verified or error in case of syntax problems
    # --------------------------------------------------------------------------------------------------------------

    @commands.command(
        name="verify",
        pass_context=True,
        help="User self-verifies by attaching their real name to their discord username in this server: "
        "$verify <FirstName LastName>",
    )
    async def verify(self, ctx, *, name: str = None):
        """Gives the user the `verified` role in the server"""
        member = ctx.message.author

        # check if verified and unverified roles exist
        if (
            discord.utils.get(ctx.guild.roles, name="unverified") is None
            or discord.utils.get(ctx.guild.roles, name="verified") is None
        ):
            await ctx.send(
                "Warning: Please make sure the verified and unverified roles exist in this server!"
            )
            return

        # finds the unverified role in the guild
        unverified = discord.utils.get(ctx.guild.roles, name="unverified")
        verified = discord.utils.get(ctx.guild.roles, name="verified")

        # checks if the user running the command has the verified role
        if verified not in member.roles:
            if name is None:
                await ctx.send(
                    "To use the verify command, do: $verify <FirstName LastName> \n ( For example: $verify Jane Doe )"
                )
            else:
                db.query(
                    "INSERT INTO name_mapping (guild_id, username, real_name) VALUES (%s, %s, %s)",
                    (ctx.guild.id, member.name, name),
                )
                await member.add_roles(verified)  # adding verified role
                await member.remove_roles(unverified)  # removed unverified role
                await ctx.send(
                    f"Thank you for verifying! You can start using {ctx.guild.name}!"
                )
                embed = discord.Embed(
                    description="Click [Here](https://github.com/txt/se23) for the home page of the class Github page"
                )
                await member.send(embed=embed)
        else:  # user has verified role
            db.query(
                "SELECT real_name from name_mapping where guild_id = %s and username = %s",
                (ctx.guild.id, member.name),
            )
            await ctx.send("You are already verified!")
            embed = discord.Embed(
                description="Click [Here](https://github.com/txt/se23) for the home page of the class Github page"
            )
            await member.send(embed=embed)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: verify_error(self, ctx, error)
    #    Description: prints error message for verify command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @verify.error
    async def verify_error(self, ctx, error):
        """Error handling for verify command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the verify command, do: $verify <FirstName LastName> \n ( For example: $verify Jane Doe )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)


# --------------------------------------
# add the file to the bot's cog system
# --------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = NewComer(bot)
    await bot.add_cog(n)


# Copyright (c) 2021 War-Keeper

</document_content>
</document>
<document index="14">
<source>/Users/malcolm/dev/ClassMateBot/cogs/ping.py</source>
<document_content>
# Copyright (c) 2021 War-Keeper
from discord.ext import commands


# ----------------------------------------------------------------------------------------------
# Returns the ping of the bot, useful for testing bot lag and as a simple functionality command
# ----------------------------------------------------------------------------------------------
class Helpful(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -------------------------------------------------------------------------------------------------------
    #    Function: ping(self, ctx)
    #    Description: prints the current ping of the bot, used as a test function
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: prints the current ping of the bot, with an upper bound of 999999999 to avoid float errors
    # -------------------------------------------------------------------------------------------------------
    @commands.command()
    async def ping(self, ctx):
        """Prints the current ping of the bot, used as a test function"""
        # We set an upper bound on the ping of the bot to prevent float_infinity situations which crash testing
        await ctx.send(
            f"Pong! My ping currently is {round(min(999999999, self.bot.latency * 1000))}ms"
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: ping_error(self, ctx, error)
    #    Description: prints error message for ping command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    # @ping.error
    # async def ping_error(self, ctx, error):
    #    await ctx.author.send(error)
    #    print(error)


# -------------------------------------
# add the file to the bot's cog system
# -------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Helpful(bot))

</document_content>
</document>
<document index="15">
<source>/Users/malcolm/dev/ClassMateBot/cogs/pinning.py</source>
<document_content>
# TODO privately pin a message based on copying a message link from a channel
# Copyright (c) 2021 War-Keeper
# This functionality lets the students pin the messages they want to.
# The bot personally pins the messages, i.e. the user can only see his pinned messages and not of others.
# The messages could be arranged on the basis of tags which the user can himself/herself give to the messages.
import os
import sys

from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


class Pinning(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # Test command to check if the bot is working
    @commands.command()
    async def helpful3(self, ctx):
        """Test command to chheck if the bot it working"""
        await ctx.send(f"Pong! My ping currently is {round(self.bot.latency * 1000)}ms")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: addMessage(self, ctx, tagname: str, *, description: str)
    #    Description: Used to pin a message by the user. The message gets stored in a JSON file in the required format.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - tagname: a tag given by the user to their pinned message.
    #    - description: description of the pinned message given by the user.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="pin",
        help="Pin a message by adding a tagname (single word) "
        "and a description(can be multi word). EX: $pin Homework Resources for HW2",
    )
    async def addMessage(self, ctx, tagname: str, *, description: str):
        """Used to pin a message by the user"""
        author = ctx.message.author

        db.query(
            "INSERT INTO pinned_messages (guild_id, author_id, tag, description) VALUES (%s, %s, %s, %s)",
            (ctx.guild.id, author.id, tagname, description),
        )

        await ctx.send(
            f"A new message has been pinned with tag: {tagname} and description: {description} by {author}."
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: addMessage_error(self, ctx, error)
    #    Description: prints error message for pin command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @addMessage.error
    async def addMessage_error(self, ctx, error):
        """Error handling for pin(addMessage) command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the pin command, do: $pin TAGNAME DESCRIPTION \n ( For example: $pin HW8 https://"
                "discordapp.com/channels/139565116151562240/139565116151562240/890813190433292298 HW8 reminder )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteMessage(self, ctx, tagname: str, *)
    #    Description: This command unpins the pinned messages with the provided tagname.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - tagname: the tag used to identify which pinned messages are to be deleted.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="unpin", help="Unpin a message by passing the tagname.")
    async def deleteMessage(self, ctx, tagname: str):
        """Unpins the pinned messages with provided tagname"""
        author = ctx.message.author

        rows_deleted = db.query(
            "SELECT * FROM pinned_messages WHERE guild_id = %s AND tag = %s AND author_id = %s",
            (ctx.guild.id, tagname, author.id),
        )
        db.query(
            "DELETE FROM pinned_messages WHERE guild_id = %s AND tag = %s AND author_id = %s",
            (ctx.guild.id, tagname, author.id),
        )

        if len(rows_deleted) == 0:
            await ctx.send(
                f"No message found with the combination of tagname: {tagname}, and author: {author}."
            )
        else:
            await ctx.send(
                f"{len(rows_deleted)} pinned message(s) has been deleted with tag: {tagname}."
            )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteMessage_error(self, ctx, error)
    #    Description: prints error message for unpin command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @deleteMessage.error
    async def deleteMessage_error(self, ctx, error):
        """Error handling for unpin(deleteMessage) command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the unpin command, do: $unpin TAGNAME \n ( For example: $unpin HW8 )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # ----------------------------------------------------------------------------------
    #    Function: retrieveMessages(self, ctx, tagname: str)
    #    Description: This command is used to retrieve all the pinned messages under a
    #                 given tagname by a particular user, or all messages if tag is empty.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - tagname: the tag used to identify which pinned messages are to be retrieved.
    # ----------------------------------------------------------------------------------
    @commands.command(
        name="pinnedmessages",
        help="Retrieve the pinned messages by a particular tag or all messages.",
    )
    async def retrieveMessages(self, ctx, tagname: str = ""):
        """Retrieves all pinned messages under a given tagname by either everyone or a particular user"""
        author = ctx.message.author

        if tagname == "":
            messages = db.query(
                "SELECT tag, description FROM pinned_messages WHERE guild_id = %s AND author_id = %s",
                (ctx.guild.id, author.id),
            )
        else:
            messages = db.query(
                "SELECT tag, description FROM pinned_messages WHERE guild_id = %s AND author_id = %s AND tag = %s",
                (ctx.guild.id, author.id, tagname),
            )

        if len(messages) == 0:
            await ctx.send(
                "No messages found with the given tagname and author combination"
            )
        for tag, description in messages:
            await ctx.send(f"Tag: {tag}, Description: {description}")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: retrieveMessages_error(self, ctx, error)
    #    Description: prints error message for pinnedmessages command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @retrieveMessages.error
    async def retrieveMessages_error(self, ctx, error):
        """Error handling for retrievemessages function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the pinnedmessages command, do: $pinnedmessages:"
                " TAGNAME \n ( For example: $pinnedmessages HW8 )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)

    # ----------------------------------------------------------------------------------------------------------
    #    Function: updatePinnedMessage(self, ctx, tagname: str, *, description: str)
    #    Description: This is used to update a pinned message with a given tagname. Deletes old messages for the tag.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - tagname: tag to be updated
    #    - description: new description
    # ----------------------------------------------------------------------------------------------------------
    @commands.command(
        name="updatepin",
        help="Update a previously pinned message by passing the "
        "tagname and old description in the same order",
    )
    async def updatePinnedMessage(self, ctx, tagname: str, *, description: str):
        """Updates a pinned message with a given tagname, deletes old messages for the tag"""
        await ctx.invoke(self.bot.get_command("unpin"), tagname)
        await ctx.invoke(
            self.bot.get_command("pin"), tagname=tagname, description=description
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: updatePinnedMessage_error(self, ctx, error)
    #    Description: prints error message for updatepin command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @updatePinnedMessage.error
    async def updatePinnedMessage_error(self, ctx, error):
        """Error handling for updatepinnedmessage function"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the updatepin command, do: $pin TAGNAME DESCRIPTION \n ( $updatepin HW8 https://discordapp"
                ".com/channels/139565116151562240/139565116151562240/890814489480531969 HW8 reminder )"
            )
        else:
            await ctx.author.send(error)
            # await ctx.message.delete()
            print(error)


# -------------------------------------
# add the file to the bot's cog system
# -------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = Pinning(bot)
    await bot.add_cog(n)

</document_content>
</document>
<document index="16">
<source>/Users/malcolm/dev/ClassMateBot/cogs/plagiarism.py</source>
<document_content>
import requests
import json
import os
import sys

from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# -----------------------------------------------------------------------------------------------------------------
#    Function: plagiarism(text: str) -> dict
#    Description: Uses papersowl API free service to check for plagiarism in a string by providing a percent
#    plagiarism score and links to the most common online webpages.
#    Inputs:
#    - text: used to access parameters passed to the class through the constructor
#    Outputs: Result of plagiarism screen in a JSON format.
# -----------------------------------------------------------------------------------------------------------------
def plagiarism(text: str) -> dict:
    plag_checker_url = "https://papersowl.com:443/plagiarism-checker-send-data"
    cookies = {
        "PHPSESSID": "qjc72e3vvacbtn4jd1af1k5qn1",
        "first_interaction_user": "%7B%22referrer%22%3A%22https%3A%5C%2F%5C%2Fwww.google.com%5C%2F%22%2C%22intern"
        + "al_url%22%3A%22%5C%2Ffree-plagiarism-checker%22%2C%22utm_source%22%3Anull%2C%22utm_medium%22%3Anull%2C%2"
        + "2utm_campaign%22%3Anull%2C%22utm_content%22%3Anull%2C%22utm_term%22%3Anull%2C%22gclid%22%3Anull%2C%22msc"
        + "lkid%22%3Anull%2C%22adgroupid%22%3Anull%2C%22targetid%22%3Anull%2C%22appsflyer_id%22%3Anull%2C%22appsfly"
        + "er_cuid%22%3Anull%2C%22cta_btn%22%3Anull%7D",
        "first_interaction_order": "%7B%22referrer%22%3A%22https%3A%5C%2F%5C%2Fwww.google.com%5C%2F%22%2C%22inter"
        + "nal_url%22%3A%22%5C%2Ffree-plagiarism-checker%22%2C%22utm_source%22%3Anull%2C%22utm_medium%22%3Anull%2C%"
        + "22utm_campaign%22%3Anull%2C%22utm_content%22%3Anull%2C%22utm_term%22%3Anull%2C%22gclid%22%3Anull%2C%22ms"
        + "clkid%22%3Anull%2C%22adgroupid%22%3Anull%2C%22targetid%22%3Anull%2C%22appsflyer_id%22%3Anull%2C%22appsfl"
        + "yer_cuid%22%3Anull%2C%22cta_btn%22%3Anull%7D",
        "affiliate_user": "a%3A3%3A%7Bs%3A9%3A%22affiliate%22%3Bs%3A9%3A%22papersowl%22%3Bs%3A6%3A%22medium%22%3B"
        + "s%3A9%3A%22papersowl%22%3Bs%3A8%3A%22campaign%22%3Bs%3A9%3A%22papersowl%22%3B%7D",
        "sbjs_migrations": "1418474375998%3D1",
        "sbjs_current_add": "fd%3D2022-05-24%2019%3A01%3A22%7C%7C%7Cep%3Dhttps%3A%2F%2Fpapersowl.com%2Ffree-plagi"
        + "arism-checker%7C%7C%7Crf%3Dhttps%3A%2F%2Fwww.google.com%2F",
        "sbjs_first_add": "fd%3D2022-05-24%2019%3A01%3A22%7C%7C%7Cep%3Dhttps%3A%2F%2Fpapersowl.com%2Ffree-plagiar"
        + "ism-checker%7C%7C%7Crf%3Dhttps%3A%2F%2Fwww.google.com%2F",
        "sbjs_current": "typ%3Dorganic%7C%7C%7Csrc%3Dgoogle%7C%7C%7Cmdm%3Dorganic%7C%7C%7Ccmp%3D%28none%29%7C%7C%"
        + "7Ccnt%3D%28none%29%7C%7C%7Ctrm%3D%28none%29",
        "sbjs_first": "typ%3Dorganic%7C%7C%7Csrc%3Dgoogle%7C%7C%7Cmdm%3Dorganic%7C%7C%7Ccmp%3D%28none%29%7C%7C%7C"
        + "cnt%3D%28none%29%7C%7C%7Ctrm%3D%28none%29",
        "sbjs_udata": "vst%3D1%7C%7C%7Cuip%3D%28none%29%7C%7C%7Cuag%3DMozilla%2F5.0%20%28Windows%20NT%206.3%3B%20"
        + "Win64%3B%20x64%3B%20rv%3A100.0%29%20Gecko%2F20100101%20Firefox%2F100.0",
        "sbjs_session": "pgs%3D1%7C%7C%7Ccpg%3Dhttps%3A%2F%2Fpapersowl.com%2Ffree-plagiarism-checker",
        "_ga_788D7MTZB4": "GS1.1.1653411683.1.0.1653411683.0",
        "_ga": "GA1.1.1828699233.1653411683",
        "trustedsite_visit": "1",
        "trustedsite_tm_float_seen": "1",
        "AppleBannercookie_hide_header_banner": "1",
        "COOKIE_PLAGIARISM_CHECKER_TERMS": "1",
        "plagiarism_checker_progress_state": "1",
    }
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:100.0)Gecko/20100101 Firefox/100.0",
        "Accept": "*/*",
        "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
        "Accept-Encoding": "gzip, deflate",
        "Referer": "https://papersowl.com/free-plagiarism-checker",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": "https://papersowl.com",
        "Dnt": "1",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Mode": "no-cors",
        "Sec-Fetch-Site": "same-origin",
        "Pragma": "no-cache",
        "Cache-Control": "no-cache",
        "Te": "trailers",
        "Connection": "close",
    }
    request_data = {
        "is_free": "false",
        "plagchecker_locale": "en",
        "product_paper_type": "1",
        "title": "",
        "text": text,
    }

    res = requests.post(
        plag_checker_url,
        headers=headers,
        cookies=cookies,
        data=request_data,
        timeout=10,
    )
    return json.loads(res.text)


class Plagiarism(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: check_plagiarism(self, ctx) -> dict
    #    Description: Uses papersowl API free service to check for plagiarism in a docx or txt file by providing a
    #    percent
    #    plagiarism score and links to the most common online webpages.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Result of plagiarism screen in a JSON format.
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="check_plagiarism", help="check attached txt file for plagiarism"
    )
    async def check_plagiarism(self, ctx, test: str = "false", test_path: str = ""):
        if test == "false":
            if len(ctx.message.attachments) != 1:
                await ctx.send("Must have exactly one attachment")
                return

            attachment_url = ctx.message.attachments[0].url
            response = requests.get(attachment_url, timeout=10)

            res = plagiarism(response.text)
        else:
            with open(test_path, encoding="utf-8") as f:
                text = f.read()
            res = plagiarism(text)

        await ctx.author.send(
            f'Word count: {res["words_count"]}\n'
            + f'Percent plagiarism: {str(100 - float(res["percent"]))}\n'
            + f'Matches: {str(res["matches"])}'
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: check_plagiarism(self, ctx, member_name: str, assignment_name: str,
    #    max_plagiarism_percent: str) -> dict
    #    Description: Uses papersowl API free service to grae for plagiarism in a docx or txt file. Uses percent
    #    plagiarism score to determine whether or not a student should receive a zero for the assignment.
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - member_name: username of student to grade for
    #    - assignment_name: name of assignment to grade for
    #    - max_plagiarism_percent: maximum allowed plagiarism. Anything above receives a zero for the grade
    #    Outputs: Context confirmation (Discord DB).
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(name="grade_for_plagiarism", help="")
    async def grade_for_plagiarism(
        self, ctx, member_name: str, assignment_name: str, max_plagiarism_percent: str
    ):
        max_plagiarism_percent = float(max_plagiarism_percent)

        if len(ctx.message.attachments) != 1:
            await ctx.send("Must have exactly one attachment")
            return

        if max_plagiarism_percent > 1:
            await ctx.send(
                "max_plagiarism_percent is a decimal. Ex: 0.5 represents 50%"
            )
            return

        attachment_url = ctx.message.attachments[0].url
        response = requests.get(attachment_url, timeout=10)

        res = plagiarism(response.text)

        if (100 - float(res["percent"])) > (
            max_plagiarism_percent * 100
        ):  # greater-than or equal to % plagiarized
            grade_exists = (
                db.query(
                    """SELECT COUNT(grade)
                FROM grades
                JOIN assignments ON id = assignment_id
                WHERE assignment_name = %s""",
                    (assignment_name,),
                )[0][0]
                > 0
            )

            if grade_exists:
                # Plagiarized, set exisiting grade to zero
                db.query(
                    """UPDATE grades
                    SET grade = 0
                    FROM assignments
                    WHERE member_name = %s AND assignment_id = id AND assignment_name = %s""",
                    (member_name, assignment_name),
                )
                await ctx.author.send("Assignment was plagiarized, grade set to zero")
            else:
                # Plagiarized, input new grade as zero
                db.query(
                    """INSERT INTO grades
                    SELECT name_mapping.guild_id, %s AS member_name, id, 0 AS some_column
                    FROM name_mapping
                    JOIN assignments ON username = %s AND assignment_name = %s""",
                    (member_name, member_name, assignment_name),
                )
                await ctx.author.send(
                    "Assignment was plagiarized, grade newly inputted to zero"
                )

        else:
            # No plagiarized
            await ctx.author.send(
                "Assignment not was plagiarized. If a grade exists, it was unchanged"
            )


async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Plagiarism(bot))

</document_content>
</document>
<document index="17">
<source>/Users/malcolm/dev/ClassMateBot/cogs/polling.py</source>
<document_content>
# This cog provides functionality for commands related to polls and quizzes.
import discord
from discord.ext import commands
import re


class Poll(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

        self.emojiLetters = [
            "\N{REGIONAL INDICATOR SYMBOL LETTER A}",
            "\N{REGIONAL INDICATOR SYMBOL LETTER B}",
            "\N{REGIONAL INDICATOR SYMBOL LETTER C}",
            "\N{REGIONAL INDICATOR SYMBOL LETTER D}",
            "\N{REGIONAL INDICATOR SYMBOL LETTER E}",
            "\N{REGIONAL INDICATOR SYMBOL LETTER F}",
        ]

    # parses the title, which should be in between curly brackets ('{ title }')
    # def find_title(self, message):
    # this is the index of the first character of the title
    # first = message.find('{') + 1
    # index of the last character of the title
    # last = message.find('}')

    # if first == last: # if the character after '{' is '}' ... does not check for whitespace.
    #    return ""

    # if first == 0 or last == -1:
    #    return ""
    # return message[first:last]

    # parses the options (recursively), which should be in between square brackets ('[ option n ]')
    # def find_options(self, message, options):
    # first index of the first character of the option
    # first = message.find('[') + 1
    # index of the last character of the title
    # last = message.find(']')
    # if (first == 0 or last == -1):
    #    if len(options) < 2:
    #        return "Not using the command correctly"
    #    else:
    #        return options
    # options.append(message[first:last])
    # message = message[last + 1:]
    # return self.find_options(message, options)

    # @commands.Cog.listener()

    # @commands.cooldown(2, 60, BucketType.user)
    # -----------------------------------------------------------------------------------------------------------------
    #    Function: quizpoll(self, ctx, title: str, *, ops)
    #    Description: Allows the user to begin quiz polls; that is, multi-reaction polls with listed options.
    #    Inputs:
    #       - ctx: context of the command
    #       - title: a string enclosed in double quotes; the quiz title
    #       - ops: up to six options, each in brackets
    #    Outputs:
    #       - an embedded quiz
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="quizpoll",
        help='Create a multi reaction poll by typing \n$poll "TITLE" [option 1] ... [option 6]\n '
        "Be sure to enclose title with quotes and options with brackets!\n"
        'EX: $quizpoll "I am a poll" [Vote for me!] [I am option 2]',
    )
    async def quizpoll(self, ctx, title: str, *, ops):
        """Allows the user to begin quiz polls; that is, multi-reaction polls with listed questions"""
        # message = ctx.message
        # messageContent = message.clean_content

        # title = self.find_title(messageContent)
        # options = self.find_options(messageContent, [])

        # if title is blank, whitespace only, or just too short!
        if not title or title.isspace():
            await ctx.author.send("Please enter a valid title.")
            await ctx.message.delete()
            return

        if len(title) <= 2:
            await ctx.author.send("Title too short.")
            await ctx.message.delete()
            return

        # regex: extracts every string between brackets
        options = re.findall(r"\[([^[\]]*)\]", ops)

        if len(options) < 2:
            await ctx.author.send("Polls need at least two options.")
            await ctx.message.delete()
            return

        if len(options) > 6:
            await ctx.author.send("Polls cannot have more than six options.")
            await ctx.message.delete()
            return

        try:
            pollMessage = ""
            i = 0
            for choice in options:
                if not choice or choice.isspace():  # if empty or whitespace only
                    await ctx.author.send("Options cannot be blank or whitespace only.")
                    await ctx.message.delete()
                    return
                if not i == len(options):
                    pollMessage = (
                        pollMessage + "\n\n" + self.emojiLetters[i] + "     " + choice
                    )
                i += 1

            ads = [""]

            e = discord.Embed(
                title="**" + title + "**",
                description=pollMessage + ads[0],
                colour=0x83BAE3,
            )
            pollMessage = await ctx.send(embed=e)
            i = 0
            # final_options = []  # There is a better way to do this for sure, but it also works that way
            for choice in options:
                if not i == len(options) and not options[i] == "":
                    # final_options.append(choice)
                    await pollMessage.add_reaction(self.emojiLetters[i])
                i += 1
        except KeyError:
            await ctx.author.send(
                'To use the quizpoll command, do: $quizpoll "TITLE" [option1] [option2] ... [option6]\n '
                "Be sure to enclose title with quotes and options with brackets!\n"
                'EX: $quizpoll "I am a poll" [Vote for me!] [I am option 2]'
            )
            await ctx.message.delete()
            return
        # else delete user message
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: quizpoll_error(self, ctx, error)
    #    Description: prints error message for quizpoll command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @quizpoll.error
    async def quizpoll_error(self, ctx, error):
        """Error handling for quizpoll command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                'To use the quizpoll command, do: $quizpoll "TITLE" [option1] [option2] ... [option6]\n '
                "Be sure to enclose title with quotes and options with brackets!\n"
                'EX: $quizpoll "I am a poll" [Vote for me!] [I am option 2]'
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: poll(self, ctx, qs)
    #    Description: Allows the user to create a simple reaction poll with thumbs up, thumbs down, and unsure.
    #    Inputs:
    #       - ctx: context of the command
    #       - qs: question string; the poll question
    #    Outputs:
    #       - an embedded reaction poll
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="poll",
        help="Create a reaction poll by typing $poll QUESTION\n"
        "EX: $poll What do you think about cats?",
    )
    async def poll(self, ctx, *, qs=""):
        """Allows the user to create a simple reaction poll with thumbs up, thumbs down, and unsure"""
        if qs == "":
            await ctx.author.send("Please enter a question for your poll.")
            # await ctx.send(
            #'To use the poll command, do: $poll QUESTION\n'
            #'EX: $poll Is this a good idea?')
            await ctx.message.delete()
            return

        # if using qs:str instead of *; checks for empty and whitespace only strings
        # if not qs or qs.isspace():
        #    await ctx.author.send("Please enter a question for your poll.")
        # await ctx.send(
        #    'To use the poll command, do: $poll QUESTION\n'
        #    'EX: $poll Is this a good idea?')
        # await ctx.message.delete()
        #    return

        if len(qs) <= 2:
            await ctx.author.send("Poll question too short.")
            await ctx.message.delete()
            return

        # can make it anonymous or not, is anonymous by default.
        if "instructor" in [y.name.lower() for y in ctx.author.roles]:
            author = "Instructor"
        else:
            author = "Student"

        # author = ctx.message.author.id
        # author_str = (await self.bot.fetch_user(author)).name

        # create a poll, post to channel, and add reactions.
        # pollmsg = f"**POLL by {author_str}**\n\n{pollstr}\n** **"
        pollmsg = f"**POLL by {author}**\n\n{qs}\n** **"
        message = await ctx.send(pollmsg)

        # TODO: ADD POLL ID TO DATABASE.
        # Need to check for deleted IDs when fetching poll results later.

        await message.add_reaction("👍")
        await message.add_reaction("👎")
        await message.add_reaction("🤷")

        # delete original message
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: poll_error(self, ctx, error)
    #    Description: prints error message for poll command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @poll.error
    async def poll_error(self, ctx, error):
        """Error handling for poll command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the poll command, do: $poll QUESTION\n"
                "EX: $poll Is this a good idea?"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()


async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = Poll(bot)
    await bot.add_cog(n)

</document_content>
</document>
<document index="18">
<source>/Users/malcolm/dev/ClassMateBot/cogs/qanda.py</source>
<document_content>
# This functionality provides mechanism for students to ask and answer questions
# Students and instructors can choose ask and answer questions anonymously or have their names displayed
from discord import NotFound
from discord.ext import commands
import db
import re


class Qanda(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: askQuestion(self, ctx, qs: str, anonymous)
    #    Description: takes question from user and reposts anonymously and numbered
    #    Inputs:
    #       - ctx: context of the command
    #       - qs: question text
    #       - anonymous: option if user wants their question to be shown anonymously
    #    Outputs:
    #       - User question in new post
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="ask",
        help="Ask question. Please put question text in quotes. Add *anonymous* or *anon* if desired."
        'EX: $ask /"When is the exam?/" anonymous',
    )
    async def askQuestion(self, ctx, qs: str, anonymous=""):
        """Takes question from the user the reposts it anonymously and numbered"""
        # make sure to check that this is actually being asked in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send("Please send questions to the #q-and-a channel.")
            await ctx.message.delete()
            return

        if not qs or qs.isspace():
            await ctx.author.send("Please enter a valid question.")
            await ctx.message.delete()
            return

        if len(qs) <= 2:
            await ctx.author.send("Question too short.")
            await ctx.message.delete()
            return

        # get author
        if anonymous == "":
            author = ctx.message.author.id
        elif anonymous == "anonymous":
            author = None
        elif anonymous == "anon":
            author = None
        else:
            await ctx.author.send(
                "Unknown input for *anonymous* option. Please type **anonymous**, **anon**, or leave blank."
            )
            await ctx.message.delete()
            return

        # get number of questions + 1
        num = (
            db.query(
                "SELECT COUNT(*) FROM questions WHERE guild_id = %s", (ctx.guild.id,)
            )[0][0]
            + 1
        )

        # format question
        author_str = (
            "anonymous" if author is None else (await self.bot.fetch_user(author)).name
        )
        q_str = f"Q{num}: {qs} by {author_str}"

        message = await ctx.send(q_str)

        # add to db
        db.query(
            "INSERT INTO questions (guild_id, number, question, author_id, msg_id) VALUES (%s, %s, %s, %s, %s)",
            (ctx.guild.id, num, qs, author, message.id),
        )

        # delete original question
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: ask_error(self, ctx, error)
    #    Description: prints error message for ask command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @askQuestion.error
    async def ask_error(self, ctx, error):
        """Error handling for ask command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                'To use the ask command, do: $ask "QUESTION" anonymous*<optional>* \n '
                '(For example: $ask "What class is this?" anonymous)'
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    # Function: answer
    # Description: adds user answer to specific question and post anonymously
    # Inputs:
    #      - ctx: context of the command
    #      - num: question number being answered
    #      - ans: answer text to question specified in num
    #      - anonymous: option if user wants their question to be shown anonymously
    # Outputs:
    #      - User answer added to question post
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="answer",
        help="Answer question. Please put answer text in quotes. Add *anonymous* or *anon* if desired."
        'EX: $answer 1 /"Oct 12/" anonymous',
    )
    async def answer(self, ctx, num, ans: str, anonymous=""):
        """Adds user to specific question and post anonymously"""
        # make sure to check that this is actually being asked in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send("Please send answers to the #q-and-a channel.")
            await ctx.message.delete()
            return

        if not ans or ans.isspace():
            await ctx.author.send("Please enter a valid answer.")
            await ctx.message.delete()
            return

        #        if len(ans) == 0:
        #            await ctx.author.send('Answer too short.')
        #            await ctx.message.delete()
        #            return

        # get author
        if anonymous == "":
            author = ctx.message.author.id
        elif anonymous == "anonymous":
            author = None
        elif anonymous == "anon":
            author = None
        else:
            await ctx.author.send(
                "Unknown input for *anonymous* option. Please type **anonymous**, **anon**, or leave blank."
            )
            await ctx.message.delete()
            return

        # to stop SQL from freezing. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                'Please include a valid question number. EX: $answer 1 /"Oct 12/" anonymous'
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, question, author_id, msg_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("No such question with the number: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return
        q = q[0]

        # if is_ghost is true:
        if q[4]:
            await ctx.author.send("You can't answer a ghost!")
            await ctx.message.delete()
            return

        # check if message exists
        try:
            message = await ctx.fetch_message(q[3])
        except NotFound:
            nf_str = f"Question {num} not found. It's a zombie!"
            await ctx.author.send(nf_str)
            # delete user msg
            await ctx.message.delete()
            return

        # add answer to db
        if "instructor" in [y.name.lower() for y in ctx.author.roles]:
            role = "Instructor"
        else:
            role = "Student"
        db.query(
            "INSERT INTO answers (guild_id, q_number, answer, author_id, author_role) VALUES (%s, %s, %s, %s, %s)",
            (ctx.guild.id, num, ans, author, role),
        )

        # generate and edit msg with answer
        q_author_str = (
            "anonymous" if q[2] is None else (await self.bot.fetch_user(q[2])).name
        )
        new_answer = f"Q{q[0]}: {q[1]} by {q_author_str}\n"

        # get all answers for question and add to msg
        answers = db.query(
            "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )
        for answer, author, role in answers:
            a_author = (
                "anonymous"
                if author is None
                else (await self.bot.fetch_user(author)).name
            )
            new_answer += f"{a_author} ({role}) Ans: {answer}\n"

        # edit message
        try:
            await message.edit(content=new_answer)
        except NotFound:
            nf_str = f"Question {num} not found. It's a zombie!"
            await ctx.author.send(nf_str)
            # await ctx.author.send('Invalid question number: ' + str(num))

        # delete user msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: answer_error(self, ctx, error)
    #    Description: prints error message for answer command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @answer.error
    async def answer_error(self, ctx, error):
        """Error handling for answer command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                'To use the answer command, do: $answer QUESTION_NUMBER "ANSWER" anonymous*<optional>*\n '
                '(For example: $answer 2 "Yes")'
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteAllAnswersFor
    #    Description: Deletes all answers for a question. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #       - num: question number
    #    Outputs:
    #       -
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="DALLAF",
        help="(PLACEHOLDER NAME) Delete all answers for a question.\n"
        "EX: $DALLAF 1\n"
        "THIS ACTION IS IRREVERSIBLE.\n"
        "Before deletion, archive the question and its answers with\n"
        "$getAnswersFor QUESTION_NUMBER",
    )
    async def deleteAllAnsFor(self, ctx, num):
        """Lets instructor delete all answers for a question"""
        # make sure to check that this is actually being asked in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # to stop SQL from freezing. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                "Please include a valid question number. EX: $DALLAF 1"
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, question, author_id, msg_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("No such question with the number: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return
        q = q[0]

        # retrieve question msg
        q_author_str = (
            "anonymous" if q[2] is None else (await self.bot.fetch_user(q[2])).name
        )
        qstr = f"Q{q[0]}: {q[1]} by {q_author_str}\n"

        rows_deleted = db.query(
            "SELECT * FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )

        rd = len(rows_deleted)

        # Delete all answers for question
        db.query(
            "DELETE FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )

        if rd == 0:
            await ctx.author.send(f"No answers exist for Q{num}")
        else:
            await ctx.author.send(f"deleted {rd} answers for Q{num}")

        # if it's a ghost, return.
        if q[4]:
            ghost = f"Q{num} is a ghost!"
            await ctx.author.send(ghost)
            await ctx.message.delete()
            return

        # check if message exists on the channel. If it does, restore the question!
        try:
            message = await ctx.fetch_message(q[3])
        except NotFound:
            nf_str = f"Q{num} is a zombie!"
            await ctx.author.send(nf_str)
            # delete user msg
            await ctx.message.delete()
            return

        await message.edit(content=qstr)
        # delete user msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteAllAnswersFor_error(self, ctx, error)
    #    Description: prints error message for deleteAllAnswersFor command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @deleteAllAnsFor.error
    async def deleteAllAnsFor_error(self, ctx, error):
        """Error handling for deleteAllAnswersFor command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the deleteAllAnswersFor command, do: $DALLAF QUESTION_NUMBER\n "
                "(Example: $DALLAF 1)"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: getAllAnsFor
    #    Description: gets all answers for a question and DMs them to the user.
    #    Inputs:
    #       - ctx: context of the command
    #       - num: question number
    #    Outputs:
    #       - All answers for a question, if any
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="getAnswersFor",
        help="Get a question and all its answers\n" "EX: $getAnswersFor 1",
    )
    async def getAllAnsFor(self, ctx, num):
        """Gets all answers for a question and DMs them to the user"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # to stop SQL from screaming. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                "Please include a valid question number. EX: $getAnswersFor 1"
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, question, author_id, msg_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("No such question with the number: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return

        q = q[0]

        # if the question is a ghost, return.
        if q[4]:
            nf_str = f"Q{q[0]} is a ghost!"
            await ctx.author.send(nf_str)
            await ctx.message.delete()
            return
        # check if message exists on channel
        try:
            await ctx.fetch_message(q[3])
        except NotFound:
            nf_str = f"Question {num} not found. It's a zombie!"
            await ctx.author.send(nf_str)
            # delete user msg
            await ctx.message.delete()
            return

        # retrieve question msg
        q_author_str = (
            "anonymous" if q[2] is None else (await self.bot.fetch_user(q[2])).name
        )
        qstr = f"Q{q[0]}: {q[1]} by {q_author_str}\n"

        # get all answers for question and add to msg
        answers = db.query(
            "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )

        # if there are no answers, return
        if len(answers) == 0:
            qstr += f"No answers for Q{q[0]}\n"
            await ctx.author.send(qstr)
            await ctx.message.delete()
            return

        for answer, author, role in answers:
            a_author = (
                "anonymous"
                if author is None
                else (await self.bot.fetch_user(author)).name
            )
            qstr += f"{a_author} ({role}) Ans: {answer}\n"

        # send the question and answers to user
        await ctx.author.send(qstr)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: getAllAnsFor_error(self, ctx, error)
    #    Description: prints error message for getAnswersFor command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @getAllAnsFor.error
    async def getAllAnsFor_error(self, ctx, error):
        """Error handling for getAllAnswersFor command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the getAnswersFor command, do: $getAnswersFor QUESTION_NUMBER\n "
                "(Example: $getAnswersFor 1)"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: archiveQA
    #    Description: DM all questions and their answers to the user.
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - DMs all questions and answers to the user
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="archiveQA",
        help="(PLACEHOLDER NAME) DM all questions and their answers\n" "EX: $archiveQA",
    )
    async def archiveQA(self, ctx):
        """DM all questions and their answers to the user"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # get questions
        q = db.query(
            "SELECT number, question, author_id, msg_id, is_ghost FROM questions WHERE guild_id = %s ORDER BY number ASC",
            (ctx.guild.id,),
        )
        if len(q) == 0:
            await ctx.author.send("No questions found in database.")
            # delete user msg
            await ctx.message.delete()
            return

        for number, question, author_id, msg_id, is_ghost in q:
            # prevent receiving any hidden questions.
            if is_ghost:
                nf_str = f"Q{number} is a ghost!"
                await ctx.author.send(nf_str)
                # go to next question
                continue

            # prevent receiving any deleted questions.
            try:
                await ctx.fetch_message(msg_id)
            except NotFound:
                if not is_ghost:
                    nf_str = f"Q{number} was deleted. It's a zombie!"
                    await ctx.author.send(nf_str)
                    # go to next question
                    continue

            q_author_str = (
                "anonymous"
                if author_id is None
                else (await self.bot.fetch_user(author_id)).name
            )
            qstr = f"Q{number}: {question} by {q_author_str}\n"

            # get all answers for question and add to msg
            answers = db.query(
                "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
                (ctx.guild.id, number),
            )

            if len(answers) == 0:
                qstr += f"No answers for Q{number}\n"
            else:
                for answer, author, role in answers:
                    a_author = (
                        "anonymous"
                        if author is None
                        else (await self.bot.fetch_user(author)).name
                    )
                    qstr += f"{a_author} ({role}) Ans: {answer}\n"

            # send the question and answers to user
            await ctx.author.send(qstr)

        # delete msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: archiveqa_error(self, ctx, error)
    #    Description: prints error message for archiveQA command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @archiveQA.error
    async def archiveqa_error(self, ctx, error):
        """Error handling for archiveQA command"""
        await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteAllQAs
    #    Description: Deletes all questions and answers from the database and channel.
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       -
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deleteAllQA",
        help="Delete all questions and answers from the database and channel.\n"
        "EX: $deleteAllQA\n"
        "THIS COMMAND IS IRREVERSIBLE.\n"
        "BE SURE TO ARCHIVE ALL QUESTIONS BEFORE DELETION.\n"
        "To archive, use the $unearthZombies command followed by $allChannelGhosts,"
        " and then use $archiveQA.",
    )
    async def deleteAllQAs(self, ctx):
        """Deletes all quetsions and answers from the database and channel"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # get questions
        q = db.query(
            "SELECT msg_id, is_ghost FROM questions WHERE guild_id = %s",
            (ctx.guild.id,),
        )

        numqs = len(q)
        if numqs == 0:
            await ctx.author.send("No questions found in database.")
            return

        # Zombies are questions that were manually deleted from the channel. They need to be
        # assigned new message IDs in order to be restored--that is, they need to be reposted.
        # Ghosts are questions that were deleted (or hidden) with the deleteQuestion command.
        # Because their message IDs remain the same, their contents can just be unhidden.

        # track ghosts and zombies, and delete messages in the channel
        zombies = 0
        ghosts = 0
        for msg_id, is_ghost in q:
            if is_ghost:
                ghosts += 1
            try:
                message = await ctx.fetch_message(msg_id)
            except NotFound:
                if not is_ghost:
                    zombies += 1
                continue
            else:
                await message.delete()

        # count ghosts
        # spooks = db.query(
        #    'SELECT * FROM questions WHERE guild_id = %s AND is_ghost IS TRUE',
        #    (ctx.guild.id,)
        # )

        # spooky = len(spooks)

        # Delete all questions
        db.query("DELETE FROM questions WHERE guild_id = %s", (ctx.guild.id,))

        # Delete all answers
        db.query("DELETE FROM answers WHERE guild_id = %s", (ctx.guild.id,))

        report = f"Deleted {numqs} questions from the database, including {zombies} zombies and {ghosts} ghosts."
        await ctx.author.send(report)

        # delete user msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteAllQAs_error(self, ctx, error)
    #    Description: prints error message for deleteAllQA command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @deleteAllQAs.error
    async def deleteAllQAs_error(self, ctx, error):
        """Error handling for deleteAllQA command"""
        await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteOneQuestion
    #    Description: Delete one question but leave answers untouched. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #       - num: number of the question to delete
    #    Outputs:
    #       -
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deleteQuestion",
        help="Delete (hide) one question but leave answers untouched."
        " Leaves database ghosts.\n"
        "EX: $deleteQuestion QUESTION_NUMBER\n",
    )
    async def deleteOneQuestion(self, ctx, num):
        """Lets the instructor delete one question, but leave the answers untouched"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # to stop SQL from freezing. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                "Please include a valid question number. EX: $deleteQuestion 1"
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, msg_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("Question number not in database: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return

        q = q[0]

        # if is_ghost is false, set to true
        if not q[2]:
            db.query(
                "UPDATE questions SET is_ghost = NOT is_ghost WHERE guild_id = %s AND number = %s",
                (ctx.guild.id, num),
            )
        else:
            sendme = f"Q{q[0]} is already a ghost!"
            await ctx.author.send(sendme)
            return

        # check if message exists on channel.
        try:
            msg = await ctx.fetch_message(q[1])
        except NotFound:
            nf_str = f"Q{q[0]} was not found in channel. To restore it, use: $reviveGhost {q[0]}"
            await ctx.author.send(nf_str)
        else:
            cstr = f"Q{q[0]}: _hidden_"
            await msg.edit(content=cstr)
            haunt = f"Q{q[0]} is now a ghost. To restore it, use: $reviveGhost {q[0]}"
            await ctx.author.send(haunt)

        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: deleteOneQuestion_error(self, ctx, error)
    #    Description: prints error message for deleteQuestion command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @deleteOneQuestion.error
    async def deleteOneQuestion_error(self, ctx, error):
        """Error handling for deleteQuestion command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the deleteQuestion command, do: $deleteQuestion QUESTION_NUMBER\n "
                "(Example: $deleteQuestion 1"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: channelOneGhost
    #    Description: Gets a specific ghost question. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #       - num: question number
    #    Outputs:
    #       - All answers for a ghost question, if any
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="channelGhost",
        help="Gets a specific ghost (question deleted with command) and all its answers.\n"
        "EX: $channelGhost 1",
    )
    async def channelOneGhost(self, ctx, num):
        """Lets the instructor get a specific ghost question"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # to stop SQL from screaming. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                "Please include a valid question number. EX: $channelGhost 1"
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, question, author_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("No such question with the number: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return

        q = q[0]

        if not q[3]:
            await ctx.author.send("This question is not a ghost. Fetching anyway. . .")

        # retrieve question msg
        q_author_str = (
            "anonymous" if q[2] is None else (await self.bot.fetch_user(q[2])).name
        )
        qstr = f"Q{q[0]}: {q[1]} by {q_author_str}\n"

        # get all answers for question and add to msg
        answers = db.query(
            "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )

        # if there are no answers, return
        if len(answers) == 0:
            qstr += f"No answers for Q{q[0]}\n"
            await ctx.author.send(qstr)
            await ctx.message.delete()
            return

        for answer, author, role in answers:
            a_author = (
                "anonymous"
                if author is None
                else (await self.bot.fetch_user(author)).name
            )
            qstr += f"{a_author} ({role}) Ans: {answer}\n"

        # send the question and answers to user
        await ctx.author.send(qstr)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: channelOneGhost_error(self, ctx, error)
    #    Description: prints error message for channelGhost command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @channelOneGhost.error
    async def channelOneGhost_error(self, ctx, error):
        """Error handling for channelGhost command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the channelGhost command, do: $channelGhost QUESTION_NUMBER\n "
                "(Example: $channelGhost 1)"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: channelGhostQs
    #    Description: Get the questions that are in the database but not in the channel. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       -
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="allChannelGhosts",
        help="Get all the questions that are in the database but "
        "not in the channel. Does not detect zombies.\n"
        "EX: $allChannelGhosts\n"
        "To detect zombies and convert them to ghosts, use $unearthZombies",
    )
    async def channelGhostQs(self, ctx):
        """Lets the instructor get the questions that are in the database but not inthe channel"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # get questions
        q = db.query(
            "SELECT number, question, author_id FROM questions WHERE guild_id = %s AND is_ghost IS TRUE ORDER BY number ASC",
            (ctx.guild.id,),
        )
        if len(q) == 0:
            await ctx.author.send("No ghosts found in database.")
            # delete user msg
            await ctx.message.delete()
            return

        for number, question, author_id in q:
            q_author_str = (
                "anonymous"
                if author_id is None
                else (await self.bot.fetch_user(author_id)).name
            )
            qstr = f"Q{number}: {question} by {q_author_str}\n"

            # get all answers for question and add to msg
            answers = db.query(
                "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
                (ctx.guild.id, number),
            )

            if len(answers) == 0:
                qstr += f"No answers for Q{number}\n"
            else:
                for answer, author, role in answers:
                    a_author = (
                        "anonymous"
                        if author is None
                        else (await self.bot.fetch_user(author)).name
                    )
                    qstr += f"{a_author} ({role}) Ans: {answer}\n"

            # send the question and answers to user
            await ctx.author.send(qstr)

        # delete msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: channelGhostQs_error(self, ctx, error)
    #    Description: prints error message for allChannelGhosts command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @channelGhostQs.error
    async def channelGhostQs_error(self, ctx, error):
        """Error handling for allChannelGhosts command"""
        await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: unearthZombieQs
    #    Description: Assign ghost status to all manually deleted questions in case there is a
    #                 need to restore them. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       -
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="unearthZombies",
        help="Assign ghost status to all manually deleted questions "
        "in case there is a need to restore them.\n"
        "EX: $unearthZombies\n",
    )
    async def unearthZombieQs(self, ctx):
        """Assigns ghost status to all manually deleted questions in case there is a need to restore them"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # get questions
        q = db.query(
            "SELECT number, msg_id FROM questions WHERE guild_id = %s AND is_ghost IS FALSE",
            (ctx.guild.id,),
        )
        if len(q) == 0:
            await ctx.author.send("No zombies detected.")
            # delete user msg
            await ctx.message.delete()
            return

        zombies = 0
        for number, msg_id in q:
            try:
                await ctx.fetch_message(msg_id)
            except NotFound:
                zombies += 1
                db.query(
                    "UPDATE questions SET is_ghost = NOT is_ghost WHERE guild_id = %s AND number = %s",
                    (ctx.guild.id, number),
                )

        if zombies == 0:
            await ctx.author.send("No zombies detected.")
        else:
            zomstr = f"Found {zombies} zombies and assigned them ghost status.\n"
            zomstr += "To view them, use: $allChannelGhosts\n"
            zomstr += "To restore a question, use: $reviveGhost QUESTION_NUMBER"
            await ctx.author.send(zomstr)

        # delete msg
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: unearthZombieQss_error(self, ctx, error)
    #    Description: prints error message for unearthZombies command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @unearthZombieQs.error
    async def unearthZombieQs_error(self, ctx, error):
        """Error handling for unearthZombies command"""
        await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: restoreGhost
    #    Description: Restores a ghost or deleted question to the channel. Instructor only.
    #    Inputs:
    #       - ctx: context of the command
    #       - num: question number
    #    Outputs:
    #       - All answers for a ghost question, if any
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="reviveGhost",
        help="Restores a ghost or deleted/hidden question to the channel.\n"
        "EX: $reviveGhost 1",
    )
    async def restoreGhost(self, ctx, num):
        """Restores a ghost of deleted question to the channel"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        # to stop SQL from screaming. Only allows valid numbers.
        if not re.match(r"^([1-9]\d*|0)$", num):
            await ctx.author.send(
                "Please include a valid question number. EX: $reviveGhost 1"
            )
            await ctx.message.delete()
            return

        # check if question number exists
        q = db.query(
            "SELECT number, question, author_id, msg_id, is_ghost FROM questions WHERE guild_id = %s AND number = %s",
            (ctx.guild.id, num),
        )
        if len(q) == 0:
            await ctx.author.send("No such question with the number: " + str(num))
            # delete user msg
            await ctx.message.delete()
            return

        q = q[0]

        # retrieve question msg
        q_author_str = (
            "anonymous" if q[2] is None else (await self.bot.fetch_user(q[2])).name
        )
        qstr = f"Q{q[0]}: {q[1]} by {q_author_str}\n"

        # get all answers for question and add to msg
        answers = db.query(
            "SELECT answer, author_id, author_role FROM answers WHERE guild_id = %s AND q_number = %s",
            (ctx.guild.id, num),
        )

        # if there are answers, restore them
        if len(answers) != 0:
            for answer, author, role in answers:
                a_author = (
                    "anonymous"
                    if author is None
                    else (await self.bot.fetch_user(author)).name
                )
                qstr += f"{a_author} ({role}) Ans: {answer}\n"

        try:
            msg = await ctx.fetch_message(q[3])
        except NotFound:
            # if the question was manually deleted, post it again (with all its answers)!
            message = await ctx.send(qstr)
            db.query(
                "UPDATE questions SET msg_id = %s WHERE guild_id = %s AND number = %s",
                (message.id, ctx.guild.id, num),
            )
        else:
            # restore the question
            await msg.edit(content=qstr)

        # if is_ghost is true, set to false
        if q[4]:
            db.query(
                "UPDATE questions SET is_ghost = NOT is_ghost WHERE guild_id = %s AND number = %s",
                (ctx.guild.id, num),
            )

        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: restoreGhost_error(self, ctx, error)
    #    Description: prints error message for reviveGhost command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @restoreGhost.error
    async def restoreGhost_error(self, ctx, error):
        """Error handling for reviveGhost command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.author.send(
                "To use the reviveGhost command, do: $reviveGhost QUESTION_NUMBER\n "
                "(Example: $reviveGhost 1)"
            )
        else:
            await ctx.author.send(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: countGhosts
    #    Description: Counts the number of ghost and zombie questions in the channel. Just for fun, but may be useful
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - The number of ghost questions
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(name="spooky", help="Is this channel haunted?\n" "EX: $spooky")
    async def countGhosts(self, ctx):
        """Counts the number of ghost and zombie questions in the channel. Mainly for fun but could be useful"""
        # make sure to check that this is actually being used in the Q&A channel
        if not ctx.channel.name == "q-and-a":
            await ctx.author.send(
                "Please use this command inside the #q-and-a channel."
            )
            await ctx.message.delete()
            return

        q = db.query(
            "SELECT msg_id, is_ghost FROM questions WHERE guild_id = %s",
            (ctx.guild.id,),
        )
        # if database is empty
        if len(q) == 0:
            await ctx.author.send("This channel isn't haunted.")
            await ctx.message.delete()
            return

        zombies = 0
        ghosts = 0
        for msg_id, is_ghost in q:
            # if it is a ghost, it doesn't matter if it isn't found.
            if is_ghost:
                ghosts += 1
                continue
            # if the message isn't found and it isn't a ghost, it's a zombie.
            try:
                await ctx.fetch_message(msg_id)
            except NotFound:
                zombies += 1

        if zombies == 0 and ghosts == 0:
            await ctx.author.send("This channel isn't haunted.")
            await ctx.message.delete()
            return

        spookstr = f"This channel is haunted by {ghosts} ghosts and {zombies} zombies."
        await ctx.author.send(spookstr)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: countGhosts_error(self, ctx, error)
    #    Description: prints error message for spooky command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @countGhosts.error
    async def countGhosts_error(self, ctx, error):
        """Error handling for spooky command"""
        await ctx.author.send(error)
        await ctx.message.delete()


async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = Qanda(bot)
    await bot.add_cog(n)

</document_content>
</document>
<document index="19">
<source>/Users/malcolm/dev/ClassMateBot/cogs/resource.py</source>
<document_content>
import os
import sys

import discord
from discord.ext import commands
from discord.utils import get

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# -----------------------------------------------------------
# This File contains commands for Managing Resources, Adding Deleting and Retriving Resource,
# -----------------------------------------------------------
class Resource(commands.Cog):
    # -----------------------------------------------------------
    # initialize
    # -----------------------------------------------------------
    def __init__(self, bot):
        self.bot = bot

    # -------------------------------------------------------------------------------------------------------
    #    Function: addResource(self, ctx, topic, resource_link):
    #    Description: This function is used to add the topic and the link the of resource of this topic
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - topic : used to provide the name of a topic
    #    - resource_link : used to provide the topic's resource link
    #    Outputs: It will add a new rosource in the list of course material resource
    # -------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="addResource",
        help="To use the addResource command, do: $addResource <topic_name> <resource_link>  \n \
        ( For example: $addResource Ethical_Software_Engineering, https://github.com/txt/se23/blob/main/docs/ethics.md  )",
    )
    async def addResource(self, ctx, topic, resource_link):
        db.query(
            "INSERT INTO resources (guild_id, topic_name, resource_link) VALUES (%s, %s, %s)",
            (ctx.guild.id, topic, resource_link),
        )
        await ctx.send(f"Resource successfully added to the topic {topic}")
        return

    @addResource.error
    async def addResource_error(self, ctx, error):
        """Error handling for resource add"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the addResource command, do: $addResource <topic_name> <resource_link>  \n \
            ( For example: $addResource Ethical_Software_Engineering, https://github.com/txt/se23/blob/main/docs/ethics.md  )"
            )

    # -------------------------------------------------------------------------------------------------------
    #    Function: showAllResource(self, ctx):
    #    Description: This function is used to get the resources
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Return the list of resources
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="showAllResource",
        help="To use the showAllResource command, do: $showAllResource",
    )
    async def showAllResource(self, ctx):
        result = db.query("SELECT * FROM resources")

        if not result:
            await ctx.send("No resources found.")
            return
        embed = discord.Embed(title="List of Resources", color=0x00FF00)

        for row in result:
            topic = row[1]
            resource_link = row[2]
            embed.add_field(
                name=f"Topic: {topic}",
                value=f"Resource Link: {resource_link}",
                inline=False,
            )
        await ctx.send(embed=embed)
        return

    @showAllResource.error
    async def showAllResource_error(self, ctx, error):
        """Error handling for getting resource"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send0("To use the showAllResource command, do: $showAllResource")

    # -------------------------------------------------------------------------------------------------------
    #    Function: showResourceByTopic(self, ctx, topic_name):
    #    Description: This function is used to get the resources of a sprcific topic
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Return the list of resources of a specific Topic
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="showResourceByTopic",
        help="To use the showResourceByTopic command, do: $showResourceByTopic <Topic Name> \n \
        To see the Topic List, use $showTopicList",
    )
    async def showResourceByTopic(self, ctx, topic_name):
        result = db.query(
            "SELECT * FROM resources WHERE topic_name = %s", (topic_name,)
        )

        if not result:
            await ctx.send("No resources found.")
            return

        embed = discord.Embed(
            title=f"List of Resources for topic {topic_name}", color=0x00FF00
        )

        for row in result:
            topic = row[1]
            resource_link = row[2]
            embed.add_field(name="", value=f"Resource: {resource_link}", inline=False)

        await ctx.send(embed=embed)
        return

    @showResourceByTopic.error
    async def showResourceByTopic_error(self, ctx, error):
        """Error handling for getting resource"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the showResourceByTopic command, do: $showResourceByTopic <Topic Name> \n \
            To see the Topic List, use $showTopicList"
            )
        else:
            print(error)

    # -------------------------------------------------------------------------------------------------------
    #    Function: deleteResource(self, ctx, topic, resource_link):
    #    Description: This function will delete a resource from the resource list
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - topic : used to provide the name of a topic
    #    - resource_link : used to provide the resource topic's link
    #    Outputs: It will add a new rosource under a topic
    # -------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="deleteResource",
        help="To use the deleteResource command, do: $deleteResource <topic_name> <resource_link>  \n \
        ( For example: $deleteResource Ethical_Software_Engineering, https://github.com/txt/se23/blob/main/docs/ethics.md  ) \n \
        To see all the resource use $showAllResource",
    )
    async def deleteResource(self, ctx, topic, resource_link):
        result = db.query(
            "SELECT * FROM resources WHERE guild_id = %s AND topic_name = %s AND resource_link = %s",
            (ctx.guild.id, topic, resource_link),
        )
        if not result:
            await ctx.send(
                "No matching element found.To see all the resouce use $showAllResource"
            )
            return
        db.query(
            "DELETE FROM resources WHERE topic_name = %s AND resource_link = %s",
            (topic, resource_link),
        )
        await ctx.send("The Resource has been deleted successfully.")
        return

    @deleteResource.error
    async def deleteResource_error(self, ctx, error):
        """Error handling for resource add"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                "To use the deleteResource command, do: $deleteResource <topic_name> <resource_link>  \n \
            ( For example: $DeleteResource Ethical_Software_Engineering, https://github.com/txt/se23/blob/main/docs/ethics.md  ) \n \
            To see all the resource use $showAllResource"
            )

    # -------------------------------------------------------------------------------------------------------
    #    Function: showTopicList(self, ctx):
    #    Description: This function is used to get the resources
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: Return the list of topics
    # -------------------------------------------------------------------------------------------------------
    @commands.command(
        name="showTopicList",
        help="To use the showTopicList command, do: $showTopicList",
    )
    async def showTopicList(self, ctx):
        result = db.query("SELECT DISTINCT topic_name FROM resources")
        if not result:
            await ctx.send("No topic has been created yet.")
            return

        topic_list = [row[0] for row in result]

        formatted_topic_list = "\n".join(topic_list)

        await ctx.send(f"List of Topics:\n{formatted_topic_list}")
        return

    @showTopicList.error
    async def showTopicList_error(self, ctx, error):
        """Error handling for getting resource"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send("To use the showTopicList command, do: $showTopicList")


async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Resource(bot))

</document_content>
</document>
<document index="20">
<source>/Users/malcolm/dev/ClassMateBot/cogs/reviewQs.py</source>
<document_content>
# This functionality provides mechanism for instructors to post a random review question from the databse
from discord.ext import commands
import db


class ReviewQs(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: getQuestion(self, ctx)
    #    Description: prints a random question from the database
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - a random question from the database (in user guild) is sent by the bot
    # -----------------------------------------------------------------------------------------------------------------
    @commands.command(
        name="getQuestion", help="Get a review question. EX: $getQuestion"
    )
    async def getQuestion(self, ctx):
        """Prints a random question from the database"""
        # get random question from db
        rand = db.query(
            "SELECT question, answer FROM review_questions WHERE guild_id = %s ORDER BY RANDOM() LIMIT 1",
            (ctx.guild.id,),
        )

        # send question to guild
        for q, a in rand:
            await ctx.send(f"{q} \n ||{a}||")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: get_question_error(self, ctx, error)
    #    Description: prints error message for getQuestion command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @getQuestion.error
    async def get_question_error(self, ctx, error):
        """Error handling for getQuestion command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send("To use the getQuestion command, do: $getQuestion \n")
        else:
            await ctx.author.send(error)
        print(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: addQuestion(self, ctx, qs, ans)
    #    Description: allow instructors to add review question
    #    Inputs:
    #       - ctx: context of the command
    #       - qs: review question to add
    #       - ans: answer to review question
    #    Outputs:
    #       - success message
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="addQuestion",
        help="Add a review question. "
        'EX: $addQuestion "What class is this?" "Software Engineering"',
    )
    async def addQuestion(self, ctx, qs: str, ans: str):
        """Allows instructors to add review questions"""
        # add question to database
        db.query(
            "INSERT INTO review_questions (guild_id, question, answer) VALUES (%s, %s, %s)",
            (ctx.guild.id, qs, ans),
        )

        await ctx.send(
            f"A new review question has been added! Question: {qs} and Answer: {ans}."
        )

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: add_question_error(self, ctx, error)
    #    Description: prints error message for addQuestion command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @addQuestion.error
    async def add_question_error(self, ctx, error):
        """Error handling for addQuestion command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(
                'To use the addQuestion command, do: $addQuestion "Question" "Answer" \n'
                '(For example: $addQuestion "What class is this?" "CSC510")'
            )
        else:
            await ctx.author.send(error)
        print(error)
        await ctx.message.delete()


async def setup(bot):
    """Adds the file to the bot's cog system"""
    n = ReviewQs(bot)
    await bot.add_cog(n)

</document_content>
</document>
<document index="21">
<source>/Users/malcolm/dev/ClassMateBot/cogs/voting.py</source>
<document_content>
# Copyright (c) 2021 War-Keeper
import os
import sys

from discord.ext import commands

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import db


# -----------------------------------------------------------
# This File contains commands for voting on projects,
# displaying which groups have signed up for which project
# -----------------------------------------------------------
class Voting(commands.Cog):
    # -----------
    # initialize
    # -----------
    def __init__(self, bot):
        self.bot = bot

    # ----------------------------------------------------------------------------------------------------------
    #    Function: vote(self, ctx, arg2='-1')
    #    Description: "votes" for the given project by adding the users group to it
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    - project_num: the number of the project to vote for with group
    #    Outputs: adds the user to the given project, switching if already in a project
    #             or returns an error if the project is invalid or the user is not in a valid group
    # ----------------------------------------------------------------------------------------------------------
    @commands.command(
        name="vote",
        help="Used for voting for Projects, \
    To use the vote command, do: $vote <Num> \n \
    (For example: $vote 0)",
        pass_context=True,
    )
    async def vote(self, ctx, project_num: int):
        """Used for voting for projects. "Votes" for the given project by adding the user's group to it"""
        # get the name of the caller
        member_name = ctx.message.author.display_name.upper()

        if project_num < 0 or project_num > 99:
            await ctx.send("A valid project number is 1-99.")
            return

        group = db.query(
            "SELECT group_num FROM group_members WHERE guild_id = %s AND member_name = %s",
            (ctx.guild.id, member_name),
        )

        # error handle if member is not in a group
        if len(group) == 0:
            await ctx.send(
                "You are not in a group. You must join a group before voting on a project."
            )
            return

        group = group[0][0]

        num_groups = db.query(
            "SELECT COUNT(*) FROM project_groups WHERE guild_id = %s AND project_num = %s",
            (ctx.guild.id, project_num),
        )[0]

        # check if project has more than 6 groups voting on it
        if num_groups == 3:
            await ctx.send(
                "Projects are limited to 3 groups, please select another project."
            )
            return

        voted_for = db.query(
            "SELECT project_num FROM project_groups WHERE guild_id = %s AND group_num = %s",
            (ctx.guild.id, group),
        )

        if voted_for:
            voted_for = voted_for[0][0]
            if voted_for == project_num:
                await ctx.send(f"You already voted for Project {voted_for}")
                return

            db.query(
                "DELETE FROM project_groups WHERE guild_id = %s AND group_num = %s",
                (ctx.guild.id, group),
            )
            await ctx.send(f"Group {group} removed vote for Project {voted_for}")

        # add the group to the project list
        db.query(
            "INSERT INTO project_groups (guild_id, project_num, group_num) VALUES (%s, %s, %s)",
            (ctx.guild.id, project_num, group),
        )
        await ctx.send(f"Group {group} has voted for Project {project_num}!")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: vote_error(self, ctx, error)
    #    Description: prints error message for vote command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @vote.error
    async def vote_error(self, ctx, error):
        """Error handling for vote command"""
        if isinstance(error, commands.UserInputError):
            await ctx.send(
                "To join a project, use the join command, do: $vote <Num> \n"
                "( For example: $vote 0 )"
            )
        else:
            await ctx.author.send(error)
        # await ctx.message.delete()

    # ----------------------------------------------------------------------------------
    #    Function: projects(self, ctx)
    #    Description: prints the list of current projects
    #    Inputs:
    #    - self: used to access parameters passed to the class through the constructor
    #    - ctx: used to access the values passed through the current context
    #    Outputs: prints the list of current projects
    # ----------------------------------------------------------------------------------
    @commands.command(
        name="projects",
        help="print projects with groups assigned to them",
        pass_context=True,
    )
    # @commands.dm_only()
    async def projects(self, ctx):
        """Prints the list of current projects"""
        projects = db.query(
            "SELECT project_num, string_agg(group_num::text, ', ') AS group_members "
            "FROM project_groups WHERE guild_id = %s GROUP BY project_num",
            (ctx.guild.id,),
        )

        if len(projects) > 0:
            await ctx.send(
                "\n".join(
                    f"Project {project_num}: Group(s) {group_members}"
                    for project_num, group_members in projects
                )
            )
        else:
            await ctx.send("There are currently no votes for any project numbers.")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: project_error(self, ctx, error)
    #    Description: prints error message for projects command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @projects.error
    async def project_error(self, ctx, error):
        """Error handling for projects command"""
        await ctx.author.send(error)


# -----------------------------------------------------------
# add the file to the bot's cog system
# -----------------------------------------------------------
async def setup(bot):
    """Adds the file to the bot's cog system"""
    await bot.add_cog(Voting(bot))

</document_content>
</document>
<document index="22">
<source>/Users/malcolm/dev/ClassMateBot/cogs/wordfilter.py</source>
<document_content>
# This functionality provides functionality for profanity filter management.
# TODO THIS WHOLE THING MAY NEED TO BE MOVED INTO BOT.PY TO ACCESS profanity_helper
import os

from discord import NotFound
from discord.ext import commands
import db

# import profanity_helper


class WordFilter(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # TODO
    # whitelistWord
    # remove from white list
    # clear whitelist
    # load whitelist
    # add custom word
    # remove custom word
    # clear custom words
    # load custom words
    # reset filter (doesn't clear any saved lists. It just prevents better-profanity from using any saved lists.)
    # prevent commands from being blacklisted

    # custom_badwords = ['happy', 'jolly', 'merry']
    # profanity.add_censor_words(custom_badwords)

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: whitelistWord
    #    Description: allow instructors to add words to censor whitelist
    #    Inputs:
    #       - ctx: context of the command
    #       - word: the word to whitelist
    #    Outputs:
    #       - success message
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="whitelisttest",
        help='Add a word to the censor whitelist. Enclose in quotation marks. EX: $whitelist "WORD"',
    )
    async def whitelistWordTest(self, ctx, word: str = ""):
        """Allows instructors to add words to censor whitelist"""
        # if not ctx.channel.name == 'instructor-commands':
        #    await ctx.author.send('Please use this command inside #instructor-commands')
        #    await ctx.message.delete()
        #    return

        await ctx.send(f"_{word}_ has been added to the whitelist. TODO")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: whitelistWord_error(self, ctx, error)
    #    Description: prints error message for whitelist command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @whitelistWordTest.error
    async def whitelistWord_error(self, ctx, error):
        """Error handling for whitelist command"""
        if isinstance(error, commands.MissingRequiredArgument):
            await ctx.send("Todo")
        else:
            await ctx.send(error)
        print(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: clearwhitelist
    #    Description: allow instructors to clear their saved whitelist
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - success message
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="clearWhitelist",
        help="Clears all words from the saved whitelist. EX: $clearwhitelist",
    )
    async def clearWhitelist(self, ctx):
        """Allows instructors to clea their saved whitelist"""
        if not ctx.channel.name == "instructor-commands":
            await ctx.author.send("Please use this command inside #instructor-commands")
            await ctx.message.delete()
            return

        # clear whitelist and reconstruct.

        await ctx.send("Whitelist has been cleared. TODO")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: whitelistWord_error(self, ctx, error)
    #    Description: prints error message for whitelist command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @clearWhitelist.error
    async def clearWhitelist_error(self, ctx, error):
        """Error handling for whitelist command"""
        print(error)
        await ctx.message.delete()

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: loadWhitelist
    #    Description: allow instructors to load their saved whitelist
    #    Inputs:
    #       - ctx: context of the command
    #    Outputs:
    #       - success message
    # -----------------------------------------------------------------------------------------------------------------
    @commands.has_role("Instructor")
    @commands.command(
        name="loadWhitelist",
        help="Adds all words in the saved whitelist to the censor whitelist. EX: $loadWhitelist",
    )
    async def loadWhitelist(self, ctx):
        """Allows instructors to load their saved whitelist"""
        if not ctx.channel.name == "instructor-commands":
            await ctx.author.send("Please use this command inside #instructor-commands")
            await ctx.message.delete()
            return

        await ctx.send("Whitelist has been loaded. TODO")

    # -----------------------------------------------------------------------------------------------------------------
    #    Function: loadWhitelist_error(self, ctx, error)
    #    Description: prints error message for loadWhitelist command
    #    Inputs:
    #       - ctx: context of the command
    #       - error: error message
    #    Outputs:
    #       - Error details
    # -----------------------------------------------------------------------------------------------------------------
    @loadWhitelist.error
    async def loadWhitelist_error(self, ctx, error):
        """Error handling for loadWhitelist command"""
        print(error)
        await ctx.message.delete()


async def setup(bot):
    """Adds the file the bot's cog system"""
    n = WordFilter(bot)
    await bot.add_cog(n)

</document_content>
</document>
</documents>
