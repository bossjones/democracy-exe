<documents>
<document index="1">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/insights/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="3">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/insights/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot Insights Cog
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio

# Own modules
import koalabot
from koala.cogs.insights import cog

# Constants

# Variables


@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await cog.setup(bot)
    mock1.assert_called()


@pytest_asyncio.fixture
async def insights_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    insights_cog = cog.Insights(bot)
    await bot.add_cog(insights_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return insights_cog


@pytest.mark.asyncio
@pytest.mark.parametrize("members,guilds", [(0, 0), (10, 10), (100, 100), (1000, 1000)])
async def test_insights(bot, insights_cog, members, guilds):
    for x in range(members):
        await dpytest.member_join(0, name=f"TestUser{x}", discrim={x})

    for x in range(guilds):
        guild = dpytest.backend.make_guild(name=f"FakeGuild{x}")
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    total_guilds = 1 + guilds
    total_members = 2 + guilds + members

    await dpytest.message(koalabot.COMMAND_PREFIX + "insights")

    expected_message = f"Insights:\nThis bot is in a total of {total_guilds} servers." +\
                       f"\nThere are a total of {total_members} members across these servers."

    assert dpytest.verify().message().content(expected_message)


@pytest.mark.asyncio
@pytest.mark.parametrize("total_servers", [0, 50, 500, 1000])
async def test_list_servers(bot, insights_cog, total_servers):
    for x in range(total_servers):
        guild = dpytest.backend.make_guild(name=f"{x}")
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    await dpytest.message(koalabot.COMMAND_PREFIX + "servers")

    if total_servers > 0:
        expected_partial_message = "Test Guild 0"
        for x in range(total_servers):
            int_length = len(str(x))
            if len(expected_partial_message) + int_length + 2 > 2000:
                assert dpytest.verify().message().content(expected_partial_message)
                expected_partial_message = str(x)
            else:
                expected_partial_message += f", {x}"
        assert dpytest.verify().message().content(expected_partial_message)
    else:
        assert dpytest.verify().message().content("Test Guild 0")


@pytest.mark.asyncio
@pytest.mark.parametrize("filter_term, expected", [("", "Test Guild 0, this, is, a, list, of, servers"),
                                                   ("s", "Test Guild 0, this, is, list, servers"),
                                                   ("is", "this, is, list"),
                                                   ("hello", """No servers found containing the string "hello".""")])
async def test_list_servers_with_filter(bot, insights_cog, filter_term, expected):
    server_list_names = ["this", "is", "a", "list", "of", "servers"]
    for x in server_list_names:
        guild = dpytest.backend.make_guild(name=x)
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    await dpytest.message(koalabot.COMMAND_PREFIX + "servers " + filter_term)

    assert dpytest.verify().message().content(expected)

</document_content>
</document>
<document index="4">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/announce/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="5">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/announce/test_cog.py</source>
<document_content>
import time

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs import announce
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: discord.ext.commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def announce_cog(bot: discord.ext.commands.Bot):
    announce_cog = announce.Announce(bot)
    await bot.add_cog(announce_cog)
    dpytest.configure(bot, 2, 1, 2)
    logger.info("Tests starting")
    return announce_cog


def make_message(guild: discord.Guild, announce_cog):
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               guild.icon)
    announce_cog.roles[guild.id] = []


def test_has_active_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    assert (guild.id in announce_cog.messages.keys()) == announce_cog.has_active_msg(guild.id)
    make_message(guild, announce_cog)
    assert (guild.id in announce_cog.messages.keys()) == announce_cog.has_active_msg(guild.id)


def test_has_no_active_message_initial(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    assert not announce_cog.has_active_msg(guild.id)


# testing creating messages
@pytest.mark.asyncio
async def test_create_legal_message(bot: discord.Client, announce_cog):
    guild: discord.Guild = bot.guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""


# tests dm guild with members who cannot receive dms
@pytest.mark.asyncio
async def test_create_message_to_no_dm_user(bot: discord.Client, announce_cog):
    guild: discord.Guild = bot.guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)

    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""
        # sending the message
        with mock.patch('discord.Member.send',
                        mock.Mock(side_effect=Exception('AttributeError'))):
            with pytest.raises(discord.ext.commands.errors.CommandInvokeError) as e_info:
                await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send', channel=channel)


@pytest.mark.asyncio
async def test_create_illegal_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    long_content = ""
    for i in range(2001):
        long_content = long_content + "a"
    long_msg_mock: discord.Message = dpytest.back.make_message(long_content, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=long_msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(
            "The content is more than 2000 characters long, and exceeds the limit")
        assert not announce_cog.has_active_msg(guild.id)


@pytest.mark.asyncio
async def test_create_multiple_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""

        msg2_mock: discord.Message = dpytest.back.make_message('testMessage2', author, channel)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg2_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                                  channel=channel)
            assert dpytest.verify().message().content(
                "There is currently an active announcement being created, you can use 'k!announce cancel' "
                "or 'k!announce send' to complete it")
            assert announce_cog.has_active_msg(guild.id)
            assert announce_cog.messages[guild.id].description == "testMessage"
            assert announce_cog.messages[guild.id].title == ""


@pytest.mark.asyncio
async def test_create_message_after_send_before_30_days(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""
        # sending the message
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        # try creating another announcement immediately
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                                  channel=channel)
            assert dpytest.verify().message().content(
                "You have recently sent an announcement and cannot use this function for 30 days")
            assert not announce_cog.has_active_msg(guild.id)


@pytest.mark.asyncio
async def test_create_message_timeout():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content("Okay, I'll cancel the command.")


@pytest.mark.parametrize("command_word, prompt_message",
                         [("changeTitle", "Please enter the new title, I'll wait for 60 seconds, no rush."),
                          ("changeContent", "Please enter the new message, I'll wait for 60 seconds, no rush."),
                          ("addRole",
                           "Please enter the roles you want to tag separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("add",
                           "Please enter the roles you want to tag separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("remove",
                           "Please enter the roles you want to remove separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("removeRole",
                           "Please enter the roles you want to remove separated by space, "
                           "I'll wait for 60 seconds, no rush.")])
@pytest.mark.asyncio
async def test_other_timeout(command_word, prompt_message, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce ' + command_word,
                              channel=channel)
        assert dpytest.verify().message().content(prompt_message)
        assert dpytest.verify().message().content("Okay, I'll cancel the command.")


# testing functions with no active message
@pytest.mark.parametrize("command_word",
                         ["changeTitle", "changeContent", "addRole", "add", "remove", "removeRole", "preview", "send",
                          "cancel"])
@pytest.mark.asyncio
async def test_functions_no_active(command_word):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce ' + command_word,
                          channel=channel)
    assert dpytest.verify().message().content("There is currently no active announcement")


# testing functions with active message
@pytest.mark.asyncio
async def test_change_title(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name
    msg_mock: discord.Message = dpytest.back.make_message('testTitle', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeTitle',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new title, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == "testTitle"


@pytest.mark.asyncio
async def test_change_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name
    msg_mock: discord.Message = dpytest.back.make_message('testMessage2', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeContent',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage2"
        assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name


@pytest.mark.asyncio
async def test_change_long_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    msg = ""
    for i in range(2001):
        msg = msg + 'a'
    msg_mock: discord.Message = dpytest.back.make_message(msg, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeContent',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(
            "The content is more than 2000 characters long, and exceeds the limit")
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"


@pytest.mark.parametrize("number_of_roles", [0, 1])
@pytest.mark.asyncio
async def test_add_possible_role(number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list


@pytest.mark.asyncio
@pytest.mark.parametrize("number_of_roles", [0, 1])
async def test_send_announce_roles(bot: discord.Client, number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")


@pytest.mark.asyncio
@pytest.mark.parametrize("number_of_roles", [0, 1])
async def test_send_announce_roles_with_no_dm_user(bot: discord.Client, number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list
        # sending the message
        with mock.patch('discord.Member.send',
                        mock.Mock(side_effect=Exception('AttributeError'))):
            with pytest.raises(discord.ext.commands.errors.CommandInvokeError) as e_info:
                await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send', channel=channel)


@pytest.mark.asyncio
async def test_add_non_existent_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message("12345", author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_add_same_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    role_list = str(roles[0].id) + " " + str(roles[0].id)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == [roles[0].id]


@pytest.mark.asyncio
async def test_remove_role_from_none(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[0].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message("12345", author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_remove_existing_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [roles[0].id]
    assert announce_cog.roles[guild.id] == [roles[0].id]
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[0].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_remove_non_existent_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    await guild.create_role(name="testrole")
    assert len(guild.roles) == 2
    roles = guild.roles
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [roles[0].id]
    assert announce_cog.roles[guild.id] == [roles[0].id]
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[1].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == [roles[0].id]


def test_embed_consistent(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               guild.icon)
    embed: discord.Embed = announce_cog.construct_embed(guild)
    assert embed.title == f"This announcement is from {guild.name}"
    assert embed.description == "testMessage"
    assert not embed.thumbnail.url


def test_embed_consistent_with_url(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               "test_url")
    embed: discord.Embed = announce_cog.construct_embed(guild)
    assert embed.title == f"This announcement is from {guild.name}"
    assert embed.description == "testMessage"
    assert embed.thumbnail.url == "test_url"


@pytest.mark.asyncio
async def test_preview_consistent(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    embed: discord.Embed = announce_cog.construct_embed(guild)
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce preview',
                          channel=channel)
    assert dpytest.verify().message().embed(embed=embed)
    assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_cancel(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [123, 234]
    assert guild.id in announce_cog.messages.keys()
    assert guild.id in announce_cog.roles.keys()
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce cancel',
                          channel=channel)
    assert dpytest.verify().message().content("The announcement was cancelled successfully")
    assert guild.id not in announce_cog.messages.keys()
    assert guild.id not in announce_cog.roles.keys()


def test_receiver_msg(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    make_message(guild, announce_cog)
    assert announce_cog.receiver_msg(
        guild) == f"You are currently sending to Everyone and there are {str(len(guild.members))} receivers"
    announce_cog.roles[guild.id] = [guild.roles[0].id]
    assert announce_cog.receiver_msg(
        guild) == f"You are currently sending to {announce_cog.get_role_names(guild.id, guild.roles)} and there are {str(len(announce_cog.get_receivers(guild.id, guild.roles)))} receivers "


@mock.patch("time.time", mock.MagicMock(return_value=1621679835.9347742))
@pytest.mark.asyncio
async def test_announce_db_first_creation(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        assert int(time.time()) == announce_cog.announce_database_manager.get_last_use_date(guild.id)


@mock.patch("time.time", mock.MagicMock(return_value=1621679123.9347742))
@pytest.mark.asyncio
async def test_announce_db_update_time_from_legal_use(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    announce_cog.announce_database_manager.set_last_use_date(guild.id, int(
        time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1)
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == int(
        time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == int(
            time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        assert int(time.time()) == announce_cog.announce_database_manager.get_last_use_date(guild.id)


@mock.patch("time.time", mock.MagicMock(return_value=1621679124.9347742))
@pytest.mark.asyncio
async def test_announce_db_no_update_time_from_illegal_use(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    current_time = int(time.time())
    announce_cog.announce_database_manager.set_last_use_date(guild.id, current_time)
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content(
            "You have recently sent an announcement and cannot use this function for 30 days")
        assert not announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        assert dpytest.verify().message().content("There is currently no active announcement")
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time

</document_content>
</document>
<document index="6">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="7">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/conftest.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import pytest
from sqlalchemy import delete

# Own modules
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions, VoteTargetRoles
from koala.db import session_manager


@pytest.fixture(autouse=True)
def clear_tables():
    with session_manager() as session:
        session.execute(delete(Votes))
        session.execute(delete(VoteTargetRoles))
        session.execute(delete(VoteOptions))
        session.execute(delete(VoteSent))
        session.commit()

</document_content>
</document>
<document index="8">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select

# Own modules
import koalabot
from koala.cogs import Voting
from koala.cogs.voting.models import Votes
from koala.db import session_manager, insert_extension
from tests.log import logger


@pytest_asyncio.fixture(autouse=True)
async def cog(bot: commands.Bot):
    cog = Voting(bot)
    insert_extension("Vote", 0, True, True)
    await bot.add_cog(cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return cog


@pytest.mark.asyncio
async def test_discord_create_vote():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
        assert dpytest.verify().message().content(
            f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote`"
            f" to see how to configure it.")
        in_db = session.execute(select(Votes.author_id, Votes.guild_id)).first()
        assert in_db
        assert in_db[0] == guild.members[0].id
        assert in_db[1] == guild.id


@pytest.mark.asyncio
async def test_discord_create_vote_wrong():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        session.add(Votes(vote_id=111, author_id=guild.members[0].id, guild_id=guild.id, title="Test Vote"))
        session.commit()
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
        assert dpytest.verify().message().content("You already have a vote with title Test Vote sent!")
        await dpytest.message(
            f"{koalabot.COMMAND_PREFIX}vote create aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
            f"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
            f"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        assert dpytest.verify().message().content("Title too long")
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote 2")
        assert dpytest.verify().message().content(
            f"Vote titled `Test Vote 2` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` "
            f"to see how to configure it.")
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote 3")
        assert dpytest.verify().message().content(
            f"You already have an active vote in {guild.name}. Please send that with `{koalabot.COMMAND_PREFIX}vote "
            f"send` before creating a new one.")


@pytest.mark.asyncio
async def test_discord_vote_add_and_remove_role(cog):
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addRole {guild.roles[0].id}")
    assert dpytest.verify().message().content(f"Vote will be sent to those with the {guild.roles[0].name} role")
    vote = cog.vote_manager.get_configuring_vote(guild.members[0].id)
    assert guild.roles[0].id in vote.target_roles
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote removeRole {guild.roles[0].id}")
    assert dpytest.verify().message().content(
        f"Vote will no longer be sent to those with the {guild.roles[0].name} role")
    assert guild.roles[0].id not in vote.target_roles


@pytest.mark.asyncio
async def test_discord_set_chair():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote setChair {guild.members[0].id}")
    assert dpytest.verify().message().content(f"You have been selected as the chair for vote titled Test Vote")
    assert dpytest.verify().message().content(f"Set chair to {guild.members[0].name}")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote setChair")
    assert dpytest.verify().message().content("Results will be sent to the channel vote is closed in")


@pytest.mark.asyncio
async def test_discord_add_remove_option():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addOption test+test")
    assert dpytest.verify().message().content("Option test with description test added to vote")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addOption testtest")
    assert dpytest.verify().message().content("Example usage: k!vote addOption option title+option description")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote removeOption 1")
    assert dpytest.verify().message().content("Option number 1 removed")


@pytest.mark.asyncio
async def test_discord_cancel_vote():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote cancel Test Vote")
    assert dpytest.verify().message().content("Vote Test Vote has been cancelled.")

</document_content>
</document>
<document index="9">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_db.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
from sqlalchemy import select

# Own modules
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions
from koala.cogs.voting.option import Option
from koala.db import session_manager
from .utils import populate_vote_tables, vote_manager


def test_votemanager_generate_opt_id():
    with session_manager() as session:
        session.add(VoteOptions(vote_id=123, opt_id=100000000000000001, option_title="test", option_desc="option"))
        session.commit()
        opt_id = vote_manager.generate_unique_opt_id()
        assert opt_id != 100000000000000001


def test_votemanager_load_from_db():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.vote_lookup[(222, "Test Vote 1")] == 111
        vote = vote_manager.sent_votes[111]
        assert vote.target_roles == [999]
        assert vote.options[1].id == 888
        assert vote.options[1].head == "vote1opt"
        assert vote.options[1].body == "vote1body"
        assert vote.sent_to[777] == 666


def test_votemanager_get_vote_from_id():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote = vote_manager.get_vote_from_id(111)
        assert vote.id == 111
        assert vote.options[1].id == 888
        assert vote.title == "Test Vote 1"


def test_votemanager_get_configuring_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote = vote_manager.get_configuring_vote(223)
        assert vote.title == "Test Vote 2"


def test_votemanager_has_active_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.has_active_vote(223)


def test_votemanager_create_vote():
    with session_manager() as session:
        vote = vote_manager.create_vote(123, 456, "Create Vote Test", session=session)
        assert vote.title == "Create Vote Test"
        in_db = session.execute(select(Votes).filter_by(author_id=123, title="Create Vote Test")).all()
        assert in_db


def test_votemanager_cancel_sent_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote_manager.cancel_sent_vote(111, session=session)
        assert 111 not in vote_manager.sent_votes.keys()
        in_db = session.execute(select(Votes).filter_by(vote_id=111)).all()
        assert not in_db


def test_votemanager_cancel_configuring_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote_manager.cancel_configuring_vote(223, session=session)
        assert 223 not in vote_manager.configuring_votes.keys()
        in_db = session.execute(select(Votes).filter_by(vote_id=112)).all()
        assert not in_db


def test_votemanager_sent_to():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.was_sent_to(666)


def test_vote_set_chair():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Set Chair Vote Test", session=session)
        vote.set_chair(555)
        assert vote.chair == 555
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert in_db.chair_id == 555
        vote.set_chair(session=session)
        assert not vote.chair
        session.expire(in_db)
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert not in_db.chair_id == 555


def test_vote_set_vc():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Set Chair Vote Test", session=session)
        vote.set_vc(555, session=session)
        assert vote.target_voice_channel == 555
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert in_db.voice_id == 555
        vote.set_vc(session=session)
        assert not vote.target_voice_channel
        session.expire(in_db)
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert not in_db.voice_id == 555


def test_vote_add_option():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Add Option Test", session=session)
        vote.add_option(Option("head", "body", 123), session=session)
        assert vote.options[0].head == "head"
        assert vote.options[0].body == "body"
        in_db = session.execute(select(VoteOptions).filter_by(opt_id=123)).all()
        assert in_db


def test_vote_remove_option():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Remove Option Test", session=session)
        vote.add_option(Option("head", "body", 123), session=session)
        vote.remove_option(0, session=session)
        in_db = session.execute(select(VoteOptions).filter_by(opt_id=123)).all()
        assert not in_db


def test_vote_register_sent():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Register Sent Test", session=session)
        vote.register_sent(555, 666, session=session)
        assert vote.sent_to[555] == 666
        in_db = session.execute(select(VoteSent).filter_by(vote_receiver_message=666)).all()
        assert in_db

</document_content>
</document>
<document index="10">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_option.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs

# Own modules
from koala.cogs.voting.option import Option


def test_option():
    opt = Option("test", "option", 123456789)
    assert opt.id == 123456789
    assert opt.head == "test"
    assert opt.body == "option"

</document_content>
</document>
<document index="11">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_two_way.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
# Libs

# Own modules
from koala.cogs.voting.two_way import TwoWay


def test_two_way():
    def test_asserts(f, *args, **kwargs):
        try:
            f(*args, **kwargs)
        except AssertionError:
            return
        raise AssertionError

    # test internal asserts don't false positive
    t = TwoWay({1: 2, 3: 4})
    t2 = TwoWay({1: 2, 2: 1, 4: 3})
    assert t == t2

    # test an invalid dict cannot be made
    test_asserts(TwoWay, {1: 2, 2: 3})

    def ta2():
        t = TwoWay()
        t[1] = 2
        t[2] = 3
        test_asserts(ta2)

</document_content>
</document>
<document index="12">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_vote.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
from sqlalchemy import select

# Own modules
from koala.cogs.voting.models import VoteTargetRoles
from koala.cogs.voting.option import Option
from koala.cogs.voting.vote import Vote
from koala.db import session_manager


def test_vote_is_ready():
    vote = Vote(111, "Test Vote", 222, 333)
    vote.add_option(Option("head", "body", 111))
    assert not vote.is_ready()
    vote.add_option(Option("head", "body", 122))
    assert vote.is_ready()


def test_vote_add_role():
    with session_manager() as session:
        vote = Vote(111, "Test Vote", 222, 333)
        vote.add_role(777, session=session)
        assert 777 in vote.target_roles
        in_db = session.execute(select(VoteTargetRoles).filter_by(vote_id=111, role_id=777))
        assert in_db


def test_vote_remove_role():
    with session_manager() as session:
        vote = Vote(111, "Test Vote", 222, 333)
        vote.add_role(777, session=session)
        vote.remove_role(777, session=session)
        assert 777 not in vote.target_roles
        in_db = session.execute(select(VoteTargetRoles).filter_by(vote_id=111, role_id=777)).all()
        assert not in_db

</document_content>
</document>
<document index="13">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs

# Own modules
from koala.cogs.voting.db import VoteManager
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions, VoteTargetRoles


class Fake:
    def __getattr__(self, item):
        setattr(self, item, Fake())
        return getattr(self, item)


ctx = Fake()
ctx.author.id = 1234
ctx.guild.id = 4567
cog = None
vote_manager = VoteManager()


def populate_vote_tables(session):
    session.add(Votes(vote_id=111, author_id=222, guild_id=333, title="Test Vote 1"))
    session.add(VoteTargetRoles(vote_id=111, role_id=999))
    session.add(VoteOptions(vote_id=111, opt_id=888, option_title="vote1opt", option_desc="vote1body"))
    session.add(VoteOptions(vote_id=111, opt_id=887, option_title="vote1opt2", option_desc="vote1body"))
    session.add(VoteSent(vote_id=111, vote_receiver_id=777, vote_receiver_message=666))
    session.add(Votes(vote_id=112, author_id=223, guild_id=334, title="Test Vote 2", chair_id=555, voice_id=666))
    session.add(VoteOptions(vote_id=112, opt_id=888, option_title="vote1opt", option_desc="vote1body"))
    session.commit()

</document_content>
</document>
<document index="14">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="15">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/conftest.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import delete

# Own modules
from koala.cogs import ReactForRole
from koala.cogs.react_for_role.models import GuildRFRRequiredRoles, GuildRFRMessages, RFRMessageEmojiRoles
from koala.db import session_manager
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Constants

# Variables


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def rfr_cog(bot: commands.Bot):
    rfr_cog = ReactForRole(bot)
    await bot.add_cog(rfr_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return rfr_cog


@pytest_asyncio.fixture(scope='function', autouse=True)
async def setup_clean_db():
    with session_manager() as session:
        session.execute(delete(GuildRFRRequiredRoles))
        session.execute(delete(RFRMessageEmojiRoles))
        session.execute(delete(GuildRFRMessages))
        session.commit()

</document_content>
</document>
<document index="16">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_api.py</source>
<document_content>
from http.client import OK

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web

from koala.cogs.react_for_role.api import RfrEndpoint, MESSAGE, REQUIRED_ROLES


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = RfrEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


async def test_message_post_partial(api_client):
    resp = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert "message_id" in resp_json.keys()


async def test_message_post_full(api_client):
    resp = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff",
        "thumbnail": "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png",
        "inline": "true",
        "roles": [{
            "role_id": dpytest.get_config().guilds[0].roles[0].id,
            "emoji": "<:discordmod:1030226250884722809>"
        }]
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert "message_id" in resp_json.keys()


async def test_message_get(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    message_id = (await resp1.json())["message_id"]

    resp = await api_client.get('/{}?message_id={}&guild_id={}&channel_id={}'
                                .format(MESSAGE,
                                        message_id,
                                        dpytest.get_config().guilds[0].id,
                                        dpytest.get_config().guilds[0].channels[0].id))

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#0000ff"


async def test_message_put(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()
    post_response["colour"] = "#ffffff"
    post_response["title"] = "test2"
    post_response["description"] = "desc2"
    assert post_response["thumbnail"] == "https://cdn.discordapp.com/attachments/737280260541907015/752024535985029240/discord1.png"
    post_response["thumbnail"] = "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert post_response["inline"] is False
    post_response["inline"] = True
    assert post_response["roles"] == []
    post_response["roles"] = [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]
    resp = await api_client.put('/{}'.format(MESSAGE), json=post_response)

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#ffffff"
    assert resp_json.get("title") == "test2"
    assert resp_json.get("description") == "desc2"
    assert resp_json["thumbnail"] == "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert resp_json["inline"] is True
    assert resp_json["roles"] == [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]


async def test_message_patch_partial(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    patch_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "description": "desc2"
                 }
    resp = await api_client.patch('/{}'.format(MESSAGE), json=patch_body)

    assert resp.status == OK
    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message.embeds[0].description == "desc2"
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#0000ff"
    assert resp_json.get("description") == "desc2"


async def test_message_patch_full(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    patch_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "test2",
        "description": "desc2",
        "colour": "#000fff",
        "thumbnail": "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png",
        "inline": "true",
        "roles": [{
            "role_id": dpytest.get_config().guilds[0].roles[0].id,
            "emoji": "<:discordmod:1030226250884722809>"
        }]
    }
    resp = await api_client.patch('/{}'.format(MESSAGE), json=patch_body)

    assert resp.status == OK
    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message.embeds[0].description == "desc2"
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#000fff"
    assert resp_json.get("title") == "test2"
    assert resp_json.get("description") == "desc2"
    assert resp_json["thumbnail"] == "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert resp_json["inline"] is True
    assert resp_json["roles"] == [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]


async def test_message_delete(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message is not None
    assert message.embeds[0].description == "desc"

    delete_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id
    }
    resp = await api_client.delete('/{}'.format(MESSAGE), json=delete_body)

    assert resp.status == OK
    with pytest.raises(discord.NotFound):
        await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    resp_json: dict = await resp.json()
    assert resp_json.get("status") == "DELETED"
    assert resp_json.get("message_id") == post_response["message_id"]


# /REQUIRED_ROLES

async def test_required_roles_put(api_client):
    resp = await api_client.put('/{}'.format(REQUIRED_ROLES), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "role_ids": [dpytest.get_config().guilds[0].roles[0].id]
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("role_ids") == [dpytest.get_config().guilds[0].roles[0].id]
    assert resp_json.get("guild_id") == dpytest.get_config().guilds[0].id


async def test_required_roles_get(api_client):
    await api_client.put('/{}'.format(REQUIRED_ROLES), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "role_ids": [dpytest.get_config().guilds[0].roles[0].id]
    })

    resp = await api_client.get('/{}?guild_id={}'.format(REQUIRED_ROLES, dpytest.get_config().guilds[0].id))

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("role_ids") == [dpytest.get_config().guilds[0].roles[0].id]
    assert resp_json.get("guild_id") == dpytest.get_config().guilds[0].id

</document_content>
</document>
<document index="17">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports
import random

# Libs
import aiohttp
import discord
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands
from discord.ext.test import factories as dpyfactory
from discord.http import MultipartParameters

import koalabot
from koala.cogs import ReactForRole
# Own modules
from koala.cogs.react_for_role import core
from koala.cogs.react_for_role.db import *
from koala.colours import KOALA_GREEN
from tests.log import logger
from tests.tests_utils import utils as testutils
from .utils import independent_get_guild_rfr_message, independent_get_guild_rfr_required_role


# Constants

# Variables

@pytest.mark.asyncio
async def test_get_rfr_message_from_prompts(bot, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = bot.guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    member: discord.Member = bot.guilds[0].members[0]
    msg: discord.Message = dpytest.back.make_message(".", member, channel)
    channel_id = msg.channel.id
    msg_id = msg.id

    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(546542131)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=None)):
            with pytest.raises(commands.CommandError) as exc:
                await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert str(exc.value) == "Invalid Message ID given."
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(msg_id)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=msg)):
            with pytest.raises(commands.CommandError) as exc:
                await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert str(
                exc.value) == "Message ID given is not that of a react for role message."
    add_rfr_message(msg.guild.id, channel_id, msg_id)
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(msg_id)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=msg)):
            rfr_msg, rfr_msg_channel = await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert rfr_msg.id == msg.id
            assert rfr_msg_channel.id == channel_id


@pytest.mark.parametrize("num_rows", [0, 1, 2, 20, 100, 250])
@pytest.mark.asyncio
async def test_parse_emoji_and_role_input_str(num_rows, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    for i in range(5):
        input_str = ""
        expected_emoji_list = []
        expected_role_list = []
        for j in range(num_rows):
            fake_emoji = random.choice(
                [testutils.fake_guild_emoji(guild), testutils.fake_unicode_emoji()])
            expected_emoji_list.append(str(fake_emoji))
            if isinstance(fake_emoji, discord.Emoji):
                fake_emoji_str = random.choice(
                    [fake_emoji.id, fake_emoji.name])
            else:
                fake_emoji_str = fake_emoji
            fake_role = testutils.fake_guild_role(guild)
            expected_role_list.append(fake_role)
            fake_role_str = random.choice([fake_role.id, fake_role.name,
                                           fake_role.mention])
            input_str += f"{fake_emoji_str}, {fake_role_str}\n\r"
        emoji_roles_list = await rfr_cog.parse_emoji_and_role_input_str(ctx, input_str, 20)
        for emoji_role in emoji_roles_list:
            assert str(emoji_role[0]) == str(
                expected_emoji_list[emoji_roles_list.index(emoji_role)])
            assert emoji_role[1] == expected_role_list[emoji_roles_list.index(
                emoji_role)]


@pytest.mark.skip("dpytest has non-implemented functionality for construction of guild custom emojis")
@pytest.mark.parametrize("num_rows", [0, 1, 2, 20])
@pytest.mark.asyncio
async def test_parse_emoji_or_roles_input_str(num_rows, utils_cog, rfr_cog):
    import emoji
    image = discord.File("utils/discord.png", filename="discord.png")
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    input_str = ""
    expected_list = []
    for j in range(num_rows):
        if random.choice([True, False]):
            if random.choice([True, False]):
                fake_emoji = testutils.fake_emoji_unicode()
                input_str += fake_emoji + "\n\r"
                expected_list.append(fake_emoji)
                logger.debug(f"Unicode emoji {j} in test {num_rows}: {emoji.emojize(fake_emoji)}")
            else:
                fake_emoji_name = testutils.fake_custom_emoji_name_str()
                fake_emoji = await guild.create_custom_emoji(name=fake_emoji_name, image=testutils.random_image())
                expected_list.append(fake_emoji)
                input_str += str(fake_emoji) + "\n\r"
                logger.debug(f"Custom emoji {j} in test {num_rows}: {str(fake_emoji)}")
        else:
            role_name = testutils.fake_custom_emoji_name_str()
            await guild.create_role(name=role_name, mentionable=True, hoist=True)
            fake_role: discord.Role = discord.utils.get(guild.roles, name=role_name)
            expected_list.append(fake_role)
            role_str = str(random.choice([fake_role.name, fake_role.id, fake_role.mention]))
            input_str += role_str + "\n\r"
            logger.debug(f"Role {j} in test {num_rows}: {fake_role}")

    logger.debug(f"Test {num_rows} input_str")
    logger.debug(input_str)
    result_list = await rfr_cog.parse_emoji_or_roles_input_str(ctx, input_str)
    for k in range(len(expected_list)):
        assert str(expected_list[k]) == str(result_list[k])


@pytest.mark.parametrize("msg_content", [None, "", "something", " "])
@pytest.mark.asyncio
async def test_prompt_for_input_str(msg_content, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await dpytest.empty_queue()
    if not msg_content:
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=None)):
            result = await rfr_cog.prompt_for_input(ctx, "test")
            assert dpytest.verify().message().content(
                "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
            assert dpytest.verify().message().content("Okay, I'll cancel the command.")
            assert not result
    else:
        msg: discord.Message = dpytest.back.make_message(content=msg_content, author=author, channel=channel)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg)):
            result = await rfr_cog.prompt_for_input(ctx, "test")
            assert dpytest.verify().message().content(
                "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
            assert result == msg_content


@pytest.mark.asyncio
async def test_prompt_for_input_attachment(rfr_cog, utils_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await dpytest.empty_queue()
    attach: discord.Attachment = discord.Attachment(state=dpytest.back.get_state(),
                                                    data=dpytest.back.facts.make_attachment_dict("test.jpg", 15112122,
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 height=1000,
                                                                                                 width=1000))
    message_dict = dpytest.back.facts.make_message_dict(channel, author, attachments=[attach])
    message: discord.Message = discord.Message(state=dpytest.back.get_state(), channel=channel, data=message_dict)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=message)):
        result = await rfr_cog.prompt_for_input(ctx, "test")
        assert dpytest.verify().message().content(
            "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
        assert isinstance(result, discord.Attachment)
        assert result.url == attach.url


@pytest.mark.asyncio
async def test_overwrite_channel_add_reaction_perms(rfr_cog: ReactForRole):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    bot: discord.Client = config.client
    with mock.patch('discord.ext.test.backend.FakeHttp.edit_channel_permissions') as mock_edit_channel_perms:
        for i in range(15):
            await guild.create_role(name=f"TestRole{i}", permissions=discord.Permissions.all())
        role: discord.Role = discord.utils.get(guild.roles, id=guild.id)
        # await core.setup_rfr_reaction_permissions(guild, channel, bot)
        await rfr_cog.overwrite_channel_add_reaction_perms(guild, channel)
        calls = [mock.call(channel.id, role.id, '0', '64', discord.abc._Overwrites.ROLE, reason=None),
                 mock.call(channel.id, config.client.user.id, '64', '0', discord.abc._Overwrites.MEMBER,
                           reason=None)]  # assert it's called the role perms change first, then the member change
        mock_edit_channel_perms.assert_has_calls(calls)


@pytest.mark.asyncio
async def test_is_user_alive(utils_cog, rfr_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        alive: bool = await rfr_cog.is_user_alive(ctx)
        assert not alive
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value="a")):
        alive: bool = await rfr_cog.is_user_alive(ctx)
        assert alive


@pytest.mark.asyncio
async def test_get_embed_from_message(rfr_cog, bot: commands.Bot):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed = discord.Embed(title="title", description="descr", type="rich", url="https://www.google.com")
    await channel.send(embed=embed)
    sent_msg: discord.Message = await dpytest.sent_queue.get()
    msg_mock: discord.Message = dpytest.back.make_message('a', author, channel)
    result = core.get_embed_from_message(None)
    assert result is None
    result = core.get_embed_from_message(msg_mock)
    assert result is None
    result = core.get_embed_from_message(sent_msg)
    assert dpytest.embed_eq(result, sent_msg.embeds[0])


@pytest.mark.asyncio
async def test_get_number_of_embed_fields(rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    test_embed_dict: dict = {'title': 'title', 'description': 'descr', 'type': 'rich', 'url': 'https://www.google.com'}
    bot: discord.Client = config.client
    await bot.http.send_message(channel.id, params=MultipartParameters({"embeds": [test_embed_dict]}, None, None))
    sent_msg: discord.Message = await dpytest.sent_queue.get()
    test_embed: discord.Embed = sent_msg.embeds[0]
    num_fields = 0
    for i in range(20):
        test_embed.add_field(name=f'field{i}', value=f'num{i}')
        num_fields += 1
        assert core.get_number_of_embed_fields(embed=test_embed) == num_fields


@pytest.mark.skip('dpytest currently has non-implemented functionality for construction of guild custom emojis')
@pytest.mark.asyncio
async def test_get_first_emoji_from_str(bot, utils_cog, rfr_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    guild_emoji = testutils.fake_guild_emoji(guild)
    guild_emoji = discord.Emoji(guild=guild, state=None,
                                data={'name': "AAA", 'image': None, 'id': dpyfactory.make_id(),
                                      'require_colons': True, 'managed': False})
    guild._state.store_emoji(guild=guild,
                             data={'name': "AAA", 'image': None, 'id': dpyfactory.make_id(),
                                   'require_colons': True, 'managed': False})
    assert guild_emoji in guild.emojis

    author: discord.Member = config.members[0]
    channel: discord.TextChannel = guild.text_channels[0]
    msg: discord.Message = dpytest.back.make_message(str(guild_emoji), author, channel)
    result = await core.get_first_emoji_from_str(bot, guild, msg.content)
    logger.debug(result)
    assert isinstance(result, discord.Emoji), msg.content
    assert guild_emoji == result


@pytest.mark.asyncio
async def test_rfr_create_message(bot):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed_channel: discord.TextChannel = dpytest.back.make_text_channel('EmbedChannel', guild)
    author: discord.Member = config.members[0]
    test_embed = discord.Embed(title="React for Role", description="Roles below!", colour=KOALA_GREEN)
    test_embed.set_footer(text="ReactForRole")
    test_embed.set_thumbnail(
        url=koalabot.KOALA_IMAGE_URL)
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    mock.AsyncMock(return_value=embed_channel.mention)):
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=None)):
            with mock.patch('koala.cogs.ReactForRole.is_user_alive', mock.AsyncMock(return_value=True)):
                with mock.patch(
                        'koala.cogs.ReactForRole.overwrite_channel_add_reaction_perms') as mock_edit_channel_perms:
                    with mock.patch('discord.Message.delete') as mock_delete:
                        await dpytest.message(koalabot.COMMAND_PREFIX + "rfr createMessage")
                        mock_edit_channel_perms.assert_called_once_with(guild, embed_channel)
                        assert dpytest.verify().message().content(
                            "Okay, this will create a new react for role message in a channel of your choice."
                            "\nNote: The channel you specify will have its permissions edited to make it such that the "
                            "@ everyone role is unable to add new reactions to messages, they can only reaction with "
                            "existing ones. Please keep this in mind, or setup another channel entirely for this.")
                        assert dpytest.verify().message().content("This should be a thing sent in the right channel.")
                        assert dpytest.verify().message().content(
                            "Okay, what would you like the title of the react for role message to be? Please enter within 60 seconds.")
                        assert dpytest.verify().message().content(
                            "Okay, didn't receive a title. Do you actually want to continue? Send anything to confirm this.")
                        assert dpytest.verify().message().content(
                            "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr edit commands.")
                        assert dpytest.verify().message().content(
                            "Okay, the title of the message will be \"React for Role\". What do you want the description to be? I'll wait 60 seconds, don't worry")
                        assert dpytest.verify().message().content(
                            "Okay, didn't receive a description. Do you actually want to continue? Send anything to confirm this.")
                        assert dpytest.verify().message().content(
                            "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr edit command.")
                        assert dpytest.verify().message().content(
                            "Okay, the description of the message will be \"Roles below!\".\n Okay, I'll create the react for role message now.")
                        assert dpytest.verify().message()
                        msg = dpytest.sent_queue.get_nowait()
                        assert "You can use the other k!rfr subcommands to change the message and add functionality as required." in msg.content
                        mock_delete.assert_called_once()


@pytest.mark.asyncio
async def test_rfr_delete_message():
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        guild: discord.Guild = config.guilds[0]
        channel: discord.TextChannel = guild.text_channels[0]
        message: discord.Message = await dpytest.message("rfr")
        msg_id = message.id
        add_rfr_message(guild.id, channel.id, msg_id)
        await dpytest.empty_queue()
        with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                        mock.AsyncMock(return_value=(message, channel))):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', mock.AsyncMock(return_value="Y")):
                with mock.patch('discord.Message.delete') as mock_msg_delete:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr deleteMessage")
                    mock_msg_delete.assert_called_once()
                    assert dpytest.verify().message().content(
                        "Okay, this will delete an existing react for role message. I'll need some details first though.")
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert not independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id)


@pytest.mark.asyncio
async def test_rfr_edit_description():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.description == 'description'
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                        mock.AsyncMock(side_effect=["new description", "Y"])):
            with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
                await dpytest.message(koalabot.COMMAND_PREFIX + "rfr edit description")
                assert embed.description == 'new description'
                assert dpytest.verify().message()
                assert dpytest.verify().message()
                assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_rfr_edit_title():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.title == 'title'
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                        mock.AsyncMock(side_effect=["new title", "Y"])):
            with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
                await dpytest.message(koalabot.COMMAND_PREFIX + "rfr edit title")
                assert embed.title == 'new title'
                assert dpytest.verify().message()
                assert dpytest.verify().message()
                assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_rfr_edit_thumbnail_attach():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    attach: discord.Attachment = discord.Attachment(state=dpytest.back.get_state(),
                                                    data=dpytest.back.facts.make_attachment_dict("test.jpg", -1,
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 height=1000,
                                                                                                 width=1000,
                                                                                                 content_type="image/jpeg"))
    msg_id = message.id
    bad_attach = "something that's not an attachment"
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=attach):
                await dpytest.message("k!rfr edit image")
                assert embed.thumbnail.url == "https://media.discordapp.net/attachments/some_number/random_number/test.jpg"
            embed.set_thumbnail(
                url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")


@pytest.mark.parametrize("attach", ["", "1", "not an attachment", "http://www.google.com", "https://www.google.com",
                                    "https://cdn.discordapp.com/attachments/734739036564095026/832375039650299954/9-24_EUW1-4321454326_01.webm"])
@pytest.mark.asyncio
async def test_rfr_edit_thumbnail_bad_attach(attach):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=attach):
                with pytest.raises((aiohttp.ClientError, aiohttp.InvalidURL, commands.BadArgument,
                                    commands.CommandInvokeError)) as exc:
                    await dpytest.message("k!rfr edit thumbnail")

                    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"


@pytest.mark.asyncio
@pytest.mark.parametrize("image_url", [
    "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg",
    "https://images-ext-1.discordapp.net/external/to2H6kvblcjDUm5Smwx4rSqwCPTP-UDFdWp1ToEXJQM/https/cdn.weeb.sh/images/Hk9GpT_Pb.png?width=864&height=660",
    "https://cdn.weeb.sh/images/Hk9GpT_Pb.png",
    "https://cdn.discordapp.com/attachments/611574654502699010/828026462552457266/unknown.png"])
async def test_rfr_edit_thumbnail_links(image_url):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=image_url):
                assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"
                await dpytest.message("k!rfr edit image")
                assert embed.thumbnail.url != "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"


# @pytest.mark.skip("Unsupported API Calls")
@pytest.mark.parametrize("arg", ["Y", "N"])
@pytest.mark.asyncio
async def test_rfr_edit_inline_all(arg):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed1: discord.Embed = discord.Embed(title="title", description="description")
    embed1.add_field(name="field1", value="value1", inline=True)
    embed2: discord.Embed = discord.Embed(title="title2", description="description2")
    embed2.add_field(name="field2", value="value2", inline=False)
    message1: discord.Message = await dpytest.message("rfr")
    message2: discord.Message = await dpytest.message("rfr")
    msg1_id = message1.id
    msg2_id = message2.id
    add_rfr_message(guild.id, channel.id, msg1_id)
    add_rfr_message(guild.id, channel.id, msg2_id)
    # await dpytest.sent_queue.empty()
    calls = [mock.call(0, name="field1", value="value1", inline=(arg == "Y")),
             mock.call(0, name="field2", value="value2", inline=(arg == "Y"))]
    with mock.patch("koala.cogs.ReactForRole.prompt_for_input", side_effect=["all", arg]):
        with mock.patch("discord.abc.Messageable.fetch_message", side_effect=[message1, message2]):
            with mock.patch("koala.cogs.react_for_role.core.get_embed_from_message", side_effect=[embed1, embed2]):
                with mock.patch('discord.Embed.set_field_at') as mock_call:
                    await dpytest.message("k!rfr edit inline")
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert dpytest.verify().message().content(
                        "Keep in mind that this process may take a while if you have a lot of RFR messages on your server.")
                    assert dpytest.verify().message().content("Okay, the process should be finished now. Please check.")


@pytest.mark.skip("Unsupported API Calls")
async def test_rfr_edit_inline_specific():
    assert False


@pytest.mark.asyncio
async def test_rfr_add_roles_to_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_list = []
    ro_list = []
    for i in range(5):
        em = testutils.fake_unicode_emoji()
        ro = testutils.fake_guild_role(guild)
        input_em_ro_content += f"{str(em)}, {ro.id}\n\r"
        em_list.append(em)
        ro_list.append(ro.mention)
    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr addRoles")
                    calls = []
                    for i in range(5):
                        calls.append(mock.call(name=str(em_list[i]), value=ro_list[i], inline=False))
                    add_field.has_calls(calls)

@pytest.mark.asyncio
async def test_rfr_add_flag_roles_to_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_list = []
    ro_list = []
    for i in range(5):
        em = testutils.fake_flag_emoji()
        ro = testutils.fake_guild_role(guild)
        input_em_ro_content += f"{str(em)}, {ro.id}\n\r"
        em_list.append(em)
        ro_list.append(ro.mention)
    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr addRoles")
                    calls = []
                    for i in range(5):
                        calls.append(mock.call(name=str(em_list[i]), value=ro_list[i], inline=False))
                    add_field.has_calls(calls)



@pytest.mark.asyncio
async def test_rfr_remove_roles_from_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_ro_list = []
    for i in range(5):
        em = testutils.fake_unicode_emoji()
        ro = testutils.fake_guild_role(guild)
        x = random.choice([str(em), str(ro.id)])
        input_em_ro_content += f"{x}\n\r"
        em_ro_list.append(x)
        embed.add_field(name=str(em), value=ro.mention, inline=False)
        add_rfr_message_emoji_role(1, str(em), ro.id)

    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    with mock.patch(
                            'koala.cogs.react_for_role.db.remove_rfr_message_emoji_role') as remove_emoji_role:
                        add_field.reset_mock()
                        await dpytest.message(koalabot.COMMAND_PREFIX + "rfr removeRoles")
                        add_field.assert_not_called()
                        calls = []
                        for i in range(5):
                            calls.append((1, em_ro_list[i]))
                        remove_emoji_role.has_calls(calls)


# role-check tests
@pytest.mark.parametrize("num_roles, num_required",
                         [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5)])
@pytest.mark.asyncio
async def test_can_have_rfr_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        guild: discord.Guild = config.guilds[0]
        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(guild)
            r_list.append(role)
        required = random.sample(list(r_list), num_required)
        for r in required:
            add_guild_rfr_required_role(guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, guild.id, r.id) is not None
        for i in range(num_roles):
            mem_roles = []
            member: discord.Member = await dpytest.member_join()
            for j in range(i):
                mem_roles.append(r_list[j])
                await member.add_roles(r_list[j])

            assert len(mem_roles) == i
            if len(required) == 0:
                assert rfr_cog.can_have_rfr_role(member)
            else:
                assert rfr_cog.can_have_rfr_role(member) == any(
                    x in required for x in member.roles), f"\n\r{member.roles}\n\r{required}"


@pytest.mark.asyncio
async def test_get_first_emoji_from_str():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]

    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)

    emoji: discord.Emoji = testutils.fake_guild_emoji(guild)
    role: discord.Role = testutils.fake_guild_role(guild)

    assert core.get_first_emoji_from_str(koalabot, guild, emoji)

    uni_emoji = testutils.fake_unicode_emoji()
    assert core.get_first_emoji_from_str(koalabot, guild, uni_emoji)

</document_content>
</document>
<document index="18">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import random

# Libs
import discord
import discord.ext.test as dpytest
import emoji
import mock
import pytest
from discord.ext.test import factories as dpyfactory

from koala.cogs.react_for_role.db import *
from tests.log import logger
# Own modules
from tests.tests_utils import utils as testutils
from .utils import independent_get_guild_rfr_message, independent_get_rfr_message_emoji_role, \
    independent_get_guild_rfr_required_role, get_rfr_reaction_role_by_role_id


# Constants

# Variables


@pytest.mark.asyncio
async def test_rfr_db_functions_guild_rfr_messages():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        channel: discord.TextChannel = dpytest.get_config().channels[0]
        msg_id = dpyfactory.make_id()
        # Test when no messages exist
        expected_full_list: List[Tuple[int, int, int, int]] = []
        assert independent_get_guild_rfr_message(
            session, guild.id, channel.id, msg_id) == expected_full_list
        assert independent_get_guild_rfr_message(session) == expected_full_list
        # Test on adding first message, 1 message, 1 channel, 1 guild
        add_rfr_message(guild.id, channel.id, msg_id)
        expected_full_list.append((guild.id, channel.id, msg_id, 1))
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id) == [
            expected_full_list[0]]
        # 2 guilds, 1 channel each, 2 messages
        guild2: discord.Guild = dpytest.back.make_guild("TestGuild2")
        channel2: discord.TextChannel = dpytest.back.make_text_channel(
            "TestGuild2Channel1", guild2)
        msg_id = dpyfactory.make_id()
        dpytest.get_config().guilds.append(guild2)
        add_rfr_message(guild2.id, channel2.id, msg_id)
        expected_full_list.append((guild2.id, channel2.id, msg_id, 2))
        assert independent_get_guild_rfr_message(session, guild2.id, channel2.id, msg_id) == [
            expected_full_list[1]]
        assert independent_get_guild_rfr_message(session, guild2.id, channel2.id, msg_id)[
                   0] == get_rfr_message(guild2.id,
                                         channel2.id,
                                         msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        # 1 guild, 2 channels with 1 message each
        guild1channel2: discord.TextChannel = dpytest.back.make_text_channel(
            "TestGuild1Channel2", guild)
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, guild1channel2.id, msg_id)
        expected_full_list.append((guild.id, guild1channel2.id, msg_id, 3))
        assert independent_get_guild_rfr_message(
            session, guild.id, guild1channel2.id, msg_id) == [expected_full_list[2]]
        assert independent_get_guild_rfr_message(session, guild.id, guild1channel2.id, msg_id)[
                   0] == get_rfr_message(
            guild.id, guild1channel2.id, msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session,
                                                 guild.id) == [expected_full_list[0], expected_full_list[2]]
        # 1 guild, 1 channel, with 2 messages
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg_id)
        expected_full_list.append((guild.id, channel.id, msg_id, 4))
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id) == [
            expected_full_list[3]]
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id)[0] == get_rfr_message(
            guild.id,
            channel.id,
            msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session, guild.id, channel.id) == [
            expected_full_list[0], expected_full_list[3]]
        # remove all messages
        guild_rfr_messages = independent_get_guild_rfr_message(session)
        for guild_rfr_message in guild_rfr_messages:
            assert guild_rfr_message in guild_rfr_messages
            remove_rfr_message(
                guild_rfr_message[0], guild_rfr_message[1], guild_rfr_message[2])
            assert guild_rfr_message not in independent_get_guild_rfr_message(session)
        assert independent_get_guild_rfr_message(session) == []


@pytest.mark.asyncio
async def test_rfr_db_functions_rfr_message_emoji_roles():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        channel: discord.TextChannel = dpytest.get_config().channels[0]
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg_id)
        guild_rfr_message = independent_get_guild_rfr_message(session)[0]
        expected_full_list: List[Tuple[int, str, int]] = []
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        # 1 unicode, 1 role
        fake_emoji_1 = testutils.fake_unicode_emoji()
        fake_role_id_1 = dpyfactory.make_id()
        expected_full_list.append((1, fake_emoji_1, fake_role_id_1))
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_1)
        assert independent_get_rfr_message_emoji_role(
            session) == expected_full_list, get_rfr_message_emoji_roles(1)
        assert independent_get_rfr_message_emoji_role(session, 1) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session, guild_rfr_message[3], fake_emoji_1,
                                                      fake_role_id_1) == [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_1)]
        # 1 unicode, 1 custom, trying to get same role
        fake_emoji_2 = testutils.fake_custom_emoji_str_rep()
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_2, fake_role_id_1)
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      guild_rfr_message[3]) == get_rfr_message_emoji_roles(
            guild_rfr_message[3])
        assert [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_2, fake_role_id_1)] == [None]
        # 2 roles, with 1 emoji trying to give both roles
        fake_role_id_2 = dpyfactory.make_id()
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_2)
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      guild_rfr_message[3]) == get_rfr_message_emoji_roles(
            guild_rfr_message[3])
        assert [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_2)] == [None]

        # 2 roles, 2 emojis, 1 message. split between them
        fake_emoji_2 = testutils.fake_custom_emoji_str_rep()
        fake_role_id_2 = dpyfactory.make_id()
        expected_full_list.append((1, fake_emoji_2, fake_role_id_2))
        add_rfr_message_emoji_role(*expected_full_list[1])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      1, fake_emoji_1) == [(1, fake_emoji_1, fake_role_id_1)]
        assert independent_get_rfr_message_emoji_role(session,
                                                      1, fake_emoji_2) == [(1, fake_emoji_2, fake_role_id_2)]
        assert independent_get_rfr_message_emoji_role(session, 1, fake_emoji_1)[0][
                   2] == get_rfr_reaction_role_by_emoji_str(1,
                                                            fake_emoji_1)
        assert independent_get_rfr_message_emoji_role(session,
                                                      1) == get_rfr_message_emoji_roles(1)
        assert independent_get_rfr_message_emoji_role(session, 1, role_id=fake_role_id_2)[0][
                   2] == get_rfr_reaction_role_by_role_id(session, emoji_role_id=1, role_id=fake_role_id_2)

        # 2 roles 2 emojis, 2 messages. duplicated messages
        msg2_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg2_id)
        assert independent_get_guild_rfr_message(session
                                                 ) == [guild_rfr_message, (guild.id, channel.id, msg2_id, 2)]
        guild_rfr_message_2 = independent_get_guild_rfr_message(session)[1]
        add_rfr_message_emoji_role(
            guild_rfr_message_2[3], fake_emoji_1, fake_role_id_1)
        add_rfr_message_emoji_role(
            guild_rfr_message_2[3], fake_emoji_2, fake_role_id_2)
        expected_full_list.extend([(guild_rfr_message_2[3], fake_emoji_1, fake_role_id_1),
                                   (guild_rfr_message_2[3], fake_emoji_2, fake_role_id_2)])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      2) == get_rfr_message_emoji_roles(2)
        assert independent_get_rfr_message_emoji_role(session,
                                                      1) == get_rfr_message_emoji_roles(1)

        # 2 roles 2 emojis 2 messages. Swapped
        msg3_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg3_id)
        assert independent_get_guild_rfr_message(session) == [guild_rfr_message, (guild.id, channel.id, msg2_id, 2),
                                                              (guild.id, channel.id, msg3_id, 3)]
        guild_rfr_message_3 = independent_get_guild_rfr_message(session)[2]
        add_rfr_message_emoji_role(
            guild_rfr_message_3[3], fake_emoji_1, fake_role_id_2)
        add_rfr_message_emoji_role(
            guild_rfr_message_3[3], fake_emoji_2, fake_role_id_1)
        expected_full_list.extend([(guild_rfr_message_3[3], fake_emoji_1, fake_role_id_2),
                                   (guild_rfr_message_3[3], fake_emoji_2, fake_role_id_1)])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      3) == get_rfr_message_emoji_roles(3)
        assert [x[2] for x in independent_get_rfr_message_emoji_role(session, emoji_raw=fake_emoji_1)] == [
            get_rfr_reaction_role_by_emoji_str(1, fake_emoji_1),
            get_rfr_reaction_role_by_emoji_str(2, fake_emoji_1),
            get_rfr_reaction_role_by_emoji_str(3, fake_emoji_1)]
        assert [x[2] for x in independent_get_rfr_message_emoji_role(session, emoji_raw=fake_emoji_2)] == [
            get_rfr_reaction_role_by_emoji_str(1, fake_emoji_2),
            get_rfr_reaction_role_by_emoji_str(2, fake_emoji_2),
            get_rfr_reaction_role_by_emoji_str(3, fake_emoji_2)]
        # test deletion works from rfr message
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 3)
        remove_rfr_message(guild.id, channel.id, msg3_id)
        for row in rfr_message_emoji_roles:
            assert row not in independent_get_rfr_message_emoji_role(session
                                                                     ), independent_get_guild_rfr_message(session)
        # test deleting just emoji role combos
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 2)
        remove_rfr_message_emoji_roles(2)
        for row in rfr_message_emoji_roles:
            assert row not in independent_get_rfr_message_emoji_role(session
                                                                     ), independent_get_guild_rfr_message(session)
        # test deleteing specific
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 1)
        remove_rfr_message_emoji_role(
            1, emoji_raw=rfr_message_emoji_roles[0][1])
        assert (rfr_message_emoji_roles[0][0], rfr_message_emoji_roles[0][1],
                rfr_message_emoji_roles[0][2]) not in independent_get_rfr_message_emoji_role(session)
        remove_rfr_message_emoji_role(
            1, role_id=rfr_message_emoji_roles[1][2])
        assert (rfr_message_emoji_roles[1][0], rfr_message_emoji_roles[1][1],
                rfr_message_emoji_roles[1][2]) not in independent_get_rfr_message_emoji_role(session)


@pytest.mark.asyncio
async def test_rfr_db_functions_guild_rfr_required_roles():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        roles = []
        for i in range(50):
            role: discord.Role = testutils.fake_guild_role(guild)
            roles.append(role)
            add_guild_rfr_required_role(guild.id, role.id)
            assert [x[1] for x in independent_get_guild_rfr_required_role(session)] == [x.id for x in roles], i
            assert [x[1] for x in
                    independent_get_guild_rfr_required_role(session)] == get_guild_rfr_required_roles(
                guild.id), i

        while len(roles) > 0:
            role: discord.Role = roles.pop()
            remove_guild_rfr_required_role(guild.id, role.id)
            assert [x[1] for x in independent_get_guild_rfr_required_role(session)] == [x.id for x in roles], len(roles)
            assert [x[1] for x in
                    independent_get_guild_rfr_required_role(session)] == get_guild_rfr_required_roles(
                guild.id), len(roles)


@pytest.mark.parametrize("num_roles, num_required",
                         [(1, 1), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5), (100, 20), (200, 20)])
@pytest.mark.asyncio
async def test_rfr_without_req_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        test_guild: discord.Guild = config.guilds[0]

        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(test_guild)
            r_list.append(role)
        required = random.sample(list(r_list), num_required)
        for r in required:
            add_guild_rfr_required_role(test_guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, test_guild.id, r.id) is not None

        member: discord.Member = await dpytest.member_join()
        await member.add_roles(*[r for r in r_list if r not in required])
        mem_roles = member.roles
        role_to_add = testutils.fake_guild_role(test_guild)

        # Create RFR message for test
        rfr_message = dpytest.back.make_message("FakeContent", config.client.user, test_guild.text_channels[0])
        add_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        assert get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id) is not None

        # Add emoji role combo to db
        _, _, _, er_id = get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        react_emoji: str = testutils.fake_unicode_emoji()
        add_rfr_message_emoji_role(er_id, emoji.demojize(react_emoji), role_to_add.id)

        with mock.patch("koala.cogs.ReactForRole.get_role_member_info",
                        mock.AsyncMock(return_value=(member, role_to_add))):
            with mock.patch("discord.Member.add_roles", mock.AsyncMock()) as add_role_mock:
                await dpytest.add_reaction(member, rfr_message, react_emoji)
                assert all([m in member.roles for m in mem_roles])
                add_role_mock.assert_not_called()
                assert role_to_add not in member.roles


@pytest.mark.parametrize("num_roles, num_required",
                         [(1, 1), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5), (100, 20), (200, 20)])
@pytest.mark.asyncio
async def test_rfr_with_req_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        test_guild: discord.Guild = config.guilds[0]

        # Create RFR message for test
        rfr_message = dpytest.back.make_message("FakeContent", config.client.user, test_guild.text_channels[0])
        add_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        assert get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id) is not None

        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(test_guild)
            r_list.append(role)
        required = random.sample(r_list, num_required)
        role_to_add = testutils.fake_guild_role(test_guild)

        # Add emoji role combo to db
        _, _, _, er_id = get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        react_emoji: str = testutils.fake_unicode_emoji()
        add_rfr_message_emoji_role(er_id, emoji.demojize(react_emoji), role_to_add.id)

        for r in required:
            add_guild_rfr_required_role(test_guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, test_guild.id, r.id) is not None

        member: discord.Member = await dpytest.member_join()
        await member.add_roles(*(random.sample(r_list, random.randint(1, num_roles))))
        logger.debug(f"required = {[r.name for r in required]}, mem_roles pre-add are {[member.roles]}")
        if not any([r in required for r in member.roles]):
            x = random.choice(required)
            await member.add_roles(x)
            logger.debug(f"added role {x.name} to {member.display_name}")
        mem_roles = member.roles
        with mock.patch("koala.cogs.ReactForRole.get_role_member_info",
                        mock.AsyncMock(return_value=(member, role_to_add))):
            await dpytest.add_reaction(member, rfr_message, react_emoji)
            assert all([m in member.roles for m in mem_roles])
            assert role_to_add in member.roles

</document_content>
</document>
<document index="19">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
from typing import *

# Libs
import sqlalchemy.orm
from sqlalchemy import select

# Own modules
from koala.cogs.react_for_role.models import GuildRFRRequiredRoles, GuildRFRMessages, RFRMessageEmojiRoles


def independent_get_guild_rfr_message(session: sqlalchemy.orm.Session, guild_id=None, channel_id=None, message_id=None
                                      ) -> List[Tuple[int, int, int, int]]:
    sql_select = select(GuildRFRMessages)
    if guild_id is not None:
        sql_select = sql_select.filter_by(guild_id=guild_id)
    if channel_id is not None:
        sql_select = sql_select.filter_by(channel_id=channel_id)
    if message_id is not None:
        sql_select = sql_select.filter_by(message_id=message_id)
    rows = session.execute(sql_select).scalars()
    return [row.old_format() for row in rows]


def independent_get_rfr_message_emoji_role(session: sqlalchemy.orm.Session, emoji_role_id=None, emoji_raw=None,
                                           role_id=None) -> List[
    Tuple[int, str, int]]:
    sql_select = select(RFRMessageEmojiRoles)
    if emoji_role_id is not None:
        sql_select = sql_select.filter_by(emoji_role_id=emoji_role_id)
    if emoji_raw is not None:
        sql_select = sql_select.filter_by(emoji_raw=emoji_raw)
    if role_id is not None:
        sql_select = sql_select.filter_by(role_id=role_id)

    rows = session.execute(sql_select).scalars().all()
    return [(row.emoji_role_id, row.emoji_raw, row.role_id) for row in rows]


def independent_get_guild_rfr_required_role(session: sqlalchemy.orm.Session, guild_id=None, role_id=None
                                            ) -> List[Tuple[int, int]]:
    sql_select = select(GuildRFRRequiredRoles)
    if guild_id is not None:
        sql_select = sql_select.filter_by(guild_id=guild_id)
    if role_id is not None:
        sql_select = sql_select.filter_by(role_id=role_id)
    rows = session.execute(sql_select).scalars().all()

    return [(row.guild_id, row.role_id) for row in rows]


def get_rfr_reaction_role_by_role_id(session: sqlalchemy.orm.Session, emoji_role_id: int, role_id: int
                                     ) -> Optional[int]:
    row = session.execute(select(RFRMessageEmojiRoles.role_id)
                          .filter_by(emoji_role_id=emoji_role_id, role_id=role_id)).one_or_none()
    if row:
        return row.role_id
    else:
        return

</document_content>
</document>
<document index="20">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="21">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

import random
import re
from typing import List

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs import ColourRole
from koala.cogs import colour_role
from koala.cogs.colour_role.utils import COLOUR_ROLE_NAMING
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog
from .utils import make_list_of_roles, make_list_of_custom_colour_roles, make_list_of_protected_colour_roles, \
    random_colour, independent_get_protected_colours, independent_get_colour_change_roles, DBManager


# Built-in/Generic Imports

# Constants

# Variables


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def role_colour_cog(bot: commands.Bot):
    role_colour_cog = ColourRole(bot)
    await bot.add_cog(role_colour_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return role_colour_cog


@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_no_guild_roles(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    assert not colour_role.cog.is_allowed_to_change_colour(ctx)

@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_false(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_roles(ctx.guild, 1)
    role = roles[0]
    DBManager.add_colour_change_role_perms(ctx.guild.id, role.id)
    assert not colour_role.cog.is_allowed_to_change_colour(ctx)


@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_true(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_roles(ctx.guild, 1)
    role = roles[0]
    member: discord.Member = ctx.author
    DBManager.add_colour_change_role_perms(ctx.guild.id, role.id)
    await member.add_roles(role)
    assert colour_role.cog.is_allowed_to_change_colour(ctx)


@pytest.mark.parametrize("hex_str, value",
                         [("000000", 0), ("111111", 1118481), ("228822", 2263074), ("ff82ae", 16745134),("#000000", 0), ("#111111", 1118481), ("#228822", 2263074), ("#ff82ae", 16745134)])
@pytest.mark.asyncio
async def test_get_colour_from_hex_str(hex_str, value, role_colour_cog):
    colour: discord.Colour = role_colour_cog.get_colour_from_hex_str(hex_str)
    assert colour.value == value, str(colour.r) + " " + str(colour.g) + " " + str(colour.b) + " " + str(colour.value)


@pytest.mark.asyncio
@pytest.mark.parametrize("colour_str, expected",
                         [("", False), (".", False), (" ", False), ("223", False), ("a", False), ("ffgeaa", False),
                          ("FFeehu", False), ("FFee66", True), ("ffeea7", True), ("ABCDEF", True), ("#ABCDEF", True), ("#123456", True), ("#", False), ("#123", False)])
async def test_is_valid_colour_str(colour_str, expected, role_colour_cog):
    assert role_colour_cog.is_valid_colour_str(colour_str.upper()) == expected


@pytest.mark.parametrize("colour1_str, colour2_str, expected",
                         [("ffffff", "ffffff", 0), ("FFFFFF", "ffffff", 0), ("ffffff", "000000", 764.8339663572415),
                          ("ff74aa", "6900ff", 362.23060571789074), ("223636", "363636", 29.47456530637899),("#ffffff", "#ffffff", 0), ("#FFFFFF", "#ffffff", 0), ("#ffffff", "000000", 764.8339663572415),
                           ("#ff74aa", "#6900ff", 362.23060571789074), ("#223636", "#363636", 29.47456530637899)])
@pytest.mark.asyncio
async def test_get_rgb_colour_distance(colour1_str, colour2_str, expected, role_colour_cog):
    colour1 = role_colour_cog.get_colour_from_hex_str(colour1_str)
    colour2 = role_colour_cog.get_colour_from_hex_str(colour2_str)
    dist = role_colour_cog.get_rgb_colour_distance(colour1, colour2)
    assert dist == expected


@pytest.mark.asyncio
async def test_role_already_exists(role_colour_cog, utils_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    role_exists = role_colour_cog.role_already_exists(ctx, "ffae14")
    assert not role_exists
    await guild.create_role(name="KoalaBot[0xffae14]")
    role_exists = role_colour_cog.role_already_exists(ctx, "ffae14")
    assert role_exists


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_protected_roles(num_roles, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_roles)
    for role in roles:
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    return_roles = role_colour_cog.get_protected_roles(guild)
    assert set(roles) == set(return_roles)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_custom_colour_allowed_roles(num_roles, role_colour_cog, utils_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    for role in roles:
        DBManager.add_colour_change_role_perms(guild.id, role.id)
    return_roles = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert set(roles) == set(return_roles)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_prune_guild_empty_colour_roles(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    assert set(roles).issubset(guild.roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await role_colour_cog.prune_guild_empty_colour_roles(ctx)
    assert not any(roles) in guild.roles


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_prune_author_old_colour_roles(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    assert set(roles).issubset(guild.roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await role_colour_cog.prune_author_old_colour_roles(ctx)
    author: discord.Member = ctx.author
    assert not any(roles) in author.roles


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_calculate_custom_colour_role_position(num_roles, role_colour_cog: ColourRole):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles: List[discord.Role] = await make_list_of_roles(guild, 5)
    # add num_roles roles to the protected roles
    chosen = random.sample(roles, k=num_roles)
    lowest_protected = 2000000000
    for r in chosen:
        DBManager.add_guild_protected_colour_role(guild.id, r.id)
        if r.position < lowest_protected:
            lowest_protected = r.position
    if lowest_protected == 2000000000 or lowest_protected == 1:
        expected = 1
    else:
        expected = lowest_protected
    assert role_colour_cog.calculate_custom_colour_role_position(guild) == expected, num_roles
    for role in roles:
        await role.delete()


@pytest.mark.asyncio
async def test_create_custom_colour_role(role_colour_cog: ColourRole, utils_cog: LastCtxCog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    colour: discord.Colour = discord.Colour.from_rgb(16, 16, 16)
    colour_str = "101010"
    with mock.patch('koala.cogs.ColourRole.calculate_custom_colour_role_position', return_value=2) as mock_calc:
        await guild.create_role(name="TestRole1")
        role = await role_colour_cog.create_custom_colour_role(colour, colour_str, ctx)
        assert role in guild.roles
        assert re.match(COLOUR_ROLE_NAMING, role.name), role.name
        assert role.colour.value == colour.value
        assert role.position == 2
        mock_calc.assert_called_once_with(guild)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_guild_protected_colours(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    colours = [role.colour for role in roles]
    with mock.patch('koala.cogs.ColourRole.get_protected_roles', return_value=roles) as mock_roles:
        with mock.patch('koala.cogs.ColourRole.get_role_colours', return_value=colours) as mock_colours:
            result = role_colour_cog.get_guild_protected_colours(ctx)
            mock_roles.assert_called_once_with(guild)
            mock_colours.assert_called_once_with(roles)
            assert result == colours


@pytest.mark.parametrize("num_total, num_protected",
                         [(0, 0), (1, 0), (2, 0), (1, 1), (2, 1), (5, 0), (5, 1), (5, 2), (50, 5), (50, 1), (50, 2),
                          (50, 0)])
@pytest.mark.asyncio
async def test_list_protected_roles(num_total, num_protected):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_total)
    expected = "Roles whose colour is protected are:\r"
    if num_total == 0 or num_protected == 0:
        protected = []
        expected = expected[:-1]
    elif num_protected == num_total:
        protected = roles.copy()
    else:
        protected = random.sample(list(roles), 2)
    for r in protected:
        DBManager.add_guild_protected_colour_role(guild.id, r.id)

    await dpytest.message(koalabot.COMMAND_PREFIX + "list_protected_role_colours")
    msg: discord.Message = await dpytest.sent_queue.get()
    assert expected in msg.content
    for r in protected:
        assert r.mention in msg.content, r.mention + " " + msg.content


@pytest.mark.parametrize("num_total, num_protected",
                         [(0, 0), (1, 0), (2, 0), (1, 1), (2, 1), (5, 0), (5, 1), (5, 2), (50, 5), (50, 1), (50, 2),
                          (50, 0)])
@pytest.mark.asyncio
async def test_list_custom_colour_allowed_roles(num_total, num_protected):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_total)
    expected = "Roles allowed to have a custom colour are:\r"
    if num_total == 0 or num_protected == 0:
        allowed = []
        expected = expected[:-1]
    elif num_protected == num_total:
        allowed = roles.copy()
    else:
        allowed = random.sample(list(roles), 2)
    for r in allowed:
        DBManager.add_colour_change_role_perms(guild.id, r.id)

    await dpytest.message(koalabot.COMMAND_PREFIX + "list_custom_colour_allowed_roles")
    msg: discord.Message = await dpytest.sent_queue.get()
    assert expected in msg.content
    for r in allowed:
        assert r.mention in msg.content, r.mention + " " + msg.content


@pytest.mark.asyncio
async def test_on_guild_role_delete(utils_cog, role_colour_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, 2)
    await role_list[0].delete()
    assert role_list[0] not in guild.roles
    role_list = await make_list_of_roles(guild, 2)
    await role_colour_cog.add_protected_role_colour(ctx, role_str=str(role_list[0].id))
    protected = role_colour_cog.get_protected_roles(guild)
    assert role_list[0] in protected
    await role_list[0].delete()
    protected = role_colour_cog.get_protected_roles(guild)
    assert role_list[0] not in protected
    role_list = await make_list_of_roles(guild, 2)
    await role_colour_cog.add_custom_colour_allowed_role(ctx, role_str=str(role_list[0].id))
    custom_colour_allowed = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert role_list[0] in custom_colour_allowed
    await role_list[0].delete()
    custom_colour_allowed = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert role_list[0] not in custom_colour_allowed


@pytest.mark.parametrize("num_total, num_protected, test_colour",
                         [(0, 0, random_colour()), (1, 0, random_colour()), (2, 0, random_colour()),
                          (5, 0, random_colour()), (1, 1, random_colour()), (2, 1, random_colour()),
                          (5, 1, random_colour()), (2, 2, random_colour()), (5, 2, random_colour())])
@pytest.mark.asyncio
async def test_is_valid_custom_colour(num_total, num_protected, test_colour, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await make_list_of_roles(guild, num_total - num_protected)
    protected_roles = await make_list_of_protected_colour_roles(guild, num_protected)
    protected_colours = [role.colour for role in protected_roles]
    lowest_colour_dist = 1000
    for colour in protected_colours:
        d = role_colour_cog.get_rgb_colour_distance(colour, test_colour)
        logger.debug(f"\r\ndist={str(d)}. lowest dist={str(lowest_colour_dist)}. {hex(colour.value)} is protected. "
              f"{hex(test_colour.value)} is custom")
        if d < lowest_colour_dist:
            lowest_colour_dist = d
    assert role_colour_cog.is_valid_custom_colour(test_colour, protected_colours)[0] != (lowest_colour_dist < 38.4)


@pytest.mark.parametrize("num_members", [0, 1, 2, 5, 50])
@pytest.mark.asyncio
async def test_prune_member_old_colour_roles(num_members, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    colour_role = (await make_list_of_custom_colour_roles(guild, 1))[0]
    test_members = []
    for i in range(num_members):
        member: discord.Member = await dpytest.member_join(name=f"TestMemberWithRole{i}", discrim=i + 1)
        await member.add_roles(colour_role)
        test_members.append(member)
    val = await role_colour_cog.prune_members_old_colour_roles(dpytest.get_config().members)
    assert val
    for member in dpytest.get_config().members:
        assert colour_role not in member.roles


@pytest.mark.asyncio
async def test_add_protected_role_colour():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = await make_list_of_roles(guild, 1)
    assert independent_get_protected_colours(guild.id) == []
    await dpytest.message(koalabot.COMMAND_PREFIX + "add_protected_role_colour " + str(role[0].id))
    assert independent_get_protected_colours(guild.id) == [role[0].id]


@pytest.mark.asyncio
async def test_add_custom_colour_allowed_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = await make_list_of_roles(guild, 1)
    assert independent_get_colour_change_roles(guild.id) == []
    await dpytest.message(koalabot.COMMAND_PREFIX + "add_custom_colour_allowed_role " + str(role[0].id))
    assert independent_get_colour_change_roles(guild.id) == [role[0].id]


@pytest.mark.asyncio
async def test_remove_protected_role_colour():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    assert independent_get_protected_colours(guild.id) == []
    DBManager.add_guild_protected_colour_role(guild.id, role.id)
    assert independent_get_protected_colours(guild.id) == [role.id]
    await dpytest.message(koalabot.COMMAND_PREFIX + "remove_protected_role_colour " + str(role.id))
    assert independent_get_protected_colours(guild.id) == []


@pytest.mark.asyncio
async def test_remove_custom_colour_allowed_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    assert independent_get_colour_change_roles(guild.id) == []
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    assert independent_get_colour_change_roles(guild.id) == [role.id]
    await dpytest.message(koalabot.COMMAND_PREFIX + "remove_custom_colour_allowed_role " + str(role.id))
    assert independent_get_colour_change_roles(guild.id) == []


@pytest.mark.asyncio
async def test_custom_colour_check_failure():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour ab1234")
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no")
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_no_allowed_role():
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour ab1234")
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().guilds[0].roles]
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().members[0].roles]
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no")
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().guilds[0].roles]
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_no_no_colour_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no", member=0)
    assert dpytest.verify().message().content("Okay, removing your old custom colour role then, if you have one.")
    assert dpytest.verify().message().content(f"{member.mention} you don't have any colour roles to remove.")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_colour_is_protected():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    fail_colour = discord.Colour.from_rgb(255, 255, 255)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour FEFEFE", member=0)
    assert dpytest.verify().message().content(
        f"Colour chosen was too close to an already protected colour {hex(fail_colour.value)}. Please choose a different colour.")
    assert "KoalaBot[0xFEFEFE]" not in [role.name for role in guild.roles]


@pytest.mark.asyncio
async def test_custom_colour_invalid_colour_str():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour s34a21", member=0)
    assert dpytest.verify().message().content(
        f"Invalid colour string specified, make sure it's a valid colour hex.")
    assert len(member.roles) == 2


@pytest.mark.asyncio
async def test_custom_colour_valid():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour e34a21", member=0)
    colour_role = discord.utils.get(guild.roles, name=f"KoalaBot[0xE34A21]")
    assert dpytest.verify().message().content(
        f"Your new custom role colour is #E34A21, with the role {colour_role.mention}")
    assert dpytest.verify().message().nothing()
    assert "KoalaBot[0xE34A21]" in [role.name for role in guild.roles]
    assert "KoalaBot[0xE34A21]" in [role.name for role in member.roles]




</document_content>
</document>
<document index="22">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from sqlalchemy import delete

from koala.cogs.colour_role.models import GuildColourChangePermissions, GuildInvalidCustomColourRoles
# Own modules
from koala.db import session_manager
from .utils import make_list_of_roles, independent_get_colour_change_roles, independent_get_protected_colours, \
    DBManager


# Constants

# Variables


@pytest.mark.parametrize("length", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_cr_db_functions_protected_colour_roles(length):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, length)
    # Test dbmanager add protected role
    for role in role_list:
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    protected_role_list = independent_get_protected_colours(guild.id)
    assert protected_role_list == [protected_role.id for protected_role in role_list], [guild_role.id for guild_role in
                                                                                        guild.roles]
    # Test dbmanager get protected roles
    db_get_list = DBManager.get_protected_colour_roles(guild.id)
    assert set(protected_role_list) == set(db_get_list)
    # Test dbmanager remove protected role and teardown test
    for role in role_list:
        DBManager.remove_guild_protected_colour_role(guild.id, role.id)
    assert independent_get_protected_colours(guild.id) == []


@pytest.mark.parametrize("length", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_cr_db_functions_colour_change_roles(length):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, length)
    # Test dbmanager add colour change role
    for role in role_list:
        DBManager.add_colour_change_role_perms(guild.id, role.id)
    colour_change_role_list = independent_get_colour_change_roles(guild.id)
    assert colour_change_role_list == [colour_change_role.id for colour_change_role in role_list], [guild_role.id for
                                                                                                    guild_role in
                                                                                                    guild.roles]
    # Test dbmanager get colour change roles
    db_get_list = DBManager.get_colour_change_roles(guild.id)
    assert set(colour_change_role_list) == set(db_get_list)
    # Test dbmanager remove colour change role and teardown test
    for role in role_list:
        DBManager.remove_colour_change_role_perms(guild.id, role.id)
    assert independent_get_colour_change_roles(guild.id) == []

@pytest.fixture(scope='session', autouse=True)
def setup_db():
    with session_manager() as session:
        session.execute(delete(GuildColourChangePermissions))
        session.execute(delete(GuildInvalidCustomColourRoles))
        session.commit()
</document_content>
</document>
<document index="23">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
from typing import List

import discord
# Libs
from sqlalchemy import select

from koala.cogs.colour_role.db import ColourRoleDBManager
from koala.cogs.colour_role.models import GuildColourChangePermissions, GuildInvalidCustomColourRoles
# Own modules
from koala.db import session_manager

# Constants

# Variables
DBManager = ColourRoleDBManager()


async def make_list_of_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr: List[discord.Role] = []
    for i in range(length):
        role = await guild.create_role(name=f"TestRole{i}")
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
    for i in range(len(arr)):
        arr[i] = guild.get_role(arr[i].id)
    return arr


def random_colour_str():
    import random
    return hex(random.randint(0, 16777216))


def random_colour() -> discord.Colour:
    import random
    r = random.randint(0, 255)
    g = random.randint(0, 255)
    b = random.randint(0, 255)
    return discord.Colour.from_rgb(r, g, b)


def make_list_of_colours(num: int) -> List[discord.Colour]:
    arr: List[discord.Colour] = []
    for i in range(num):
        arr.append(random_colour())
    return arr


async def make_list_of_custom_colour_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr = []
    for i in range(length):
        role = await guild.create_role(name=f"KoalaBot[{random_colour_str().upper()}]", colour=random_colour())
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
    return arr


async def make_list_of_protected_colour_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr = []
    for i in range(length):
        role = await guild.create_role(name=f"TestProtectedRole{i}", colour=random_colour())
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    return arr


def independent_get_protected_colours(guild_id):
    with session_manager() as session:
        rows = session.execute(select(GuildInvalidCustomColourRoles.role_id).filter_by(guild_id=guild_id)).all()
        return [row.role_id for row in rows]


def independent_get_colour_change_roles(guild_id):
    with session_manager() as session:
        rows = session.execute(select(GuildColourChangePermissions.role_id).filter_by(guild_id=guild_id)).all()
        return [row.role_id for row in rows]

</document_content>
</document>
<document index="24">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="25">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/conftest.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest_asyncio
# Own modules
from discord.ext import commands

from koala.cogs import IntroCog
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def intro_cog(bot: commands.Bot):
    intro_cog = IntroCog(bot)
    await bot.add_cog(intro_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return intro_cog

</document_content>
</document>
<document index="26">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import asyncio

# Libs
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.db import get_guild_welcome_message
from koala.cogs.intro_cog.utils import DEFAULT_WELCOME_MESSAGE, BASE_LEGAL_MESSAGE, wait_for_message

# Constants
fake_guild_id = 1000
non_existent_guild_id = 9999

# Variables


@pytest.mark.asyncio
async def test_wait_for_message(utils_cog):
    bot = dpytest.get_config().client
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()

    import threading
    t2 = threading.Timer(interval=0.2, function=dpytest.message, args=("y"))
    t2.start()
    fut = wait_for_message(bot, ctx)
    t2.join()
    assert fut, dpytest.sent_queue


@pytest.mark.asyncio
async def test_wait_for_message_timeout(utils_cog):
    bot = dpytest.get_config().client
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()
    with pytest.raises(asyncio.TimeoutError):
        await wait_for_message(bot, ctx, 0.2)


@pytest.mark.asyncio
async def test_send_welcome_message():
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
    assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
    assert dpytest.verify().message().content("Okay, sending out the welcome message now.")
    assert dpytest.verify().message().content(f"{DEFAULT_WELCOME_MESSAGE}\r\n{BASE_LEGAL_MESSAGE}")


@pytest.mark.asyncio
async def test_send_welcome_message_cancelled():
    msg_mock = dpytest.back.make_message('n', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
    assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
    assert dpytest.verify().message().content("Okay, I won't send out the welcome message then.")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_send_welcome_message_timeout():
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
        assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
        assert dpytest.verify().message().content('Timed out.')
        assert dpytest.verify().message().content("Okay, I won't send out the welcome message then.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_cancel_update_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    msg_mock = dpytest.back.make_message('n', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Okay, I won't update the welcome message then.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message


@pytest.mark.asyncio
async def test_update_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Okay, updating the welcome message of the guild in the database now.")
    assert dpytest.verify().message().content(
        "Updated in the database, your new welcome message is this is a non default message.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) == new_message


@pytest.mark.asyncio
async def test_update_welcome_message_too_long():
    import random, string
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "".join(random.choice(string.ascii_letters) for _ in range(1800))
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)
    assert dpytest.verify().message().content(
        "Your welcome message is too long to send, sorry. The maximum character limit is 1600.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message


@pytest.mark.asyncio
async def test_update_welcome_message_no_args():
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message")
    assert dpytest.verify().message().content("Please put in a welcome message to update to.")


@pytest.mark.asyncio
async def test_view_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    await dpytest.message(koalabot.COMMAND_PREFIX + "welcomeViewMsg ")
    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")


@pytest.mark.asyncio
async def test_update_welcome_message_timeout():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    # msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Timed out.")
    assert dpytest.verify().message().content("Okay, I won't update the welcome message then.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message

</document_content>
</document>
<document index="27">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_db.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import asyncio

# Libs
import discord.ext.test as dpytest
import pytest
# Own modules
from sqlalchemy import text

from koala import db as koala_db
from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.utils import DEFAULT_WELCOME_MESSAGE, BASE_LEGAL_MESSAGE, get_non_bot_members
from tests.log import logger
from .utils import fake_guild_id, non_existent_guild_id, add_fake_guild_to_db


# Constants

# Variables

# Welcome Message Database Manager Tests


@pytest.mark.parametrize("guild_id, expected", [(101,
                                                 "fake guild welcome message"),
                                                (non_existent_guild_id, None)])
@pytest.mark.asyncio
async def test_db_manager_fetch_welcome_message(guild_id, expected):
    await add_fake_guild_to_db(101)
    val = intro_db.fetch_guild_welcome_message(guild_id)
    assert val == expected, str(guild_id) + f": {val}"


@pytest.mark.parametrize("guild_id, new_message, expected", [(111, "non-default message", "non-default message"), (
        222, "you're here! you're gonna have fun", "you\'re here! you\'re gonna have fun"), (333, '', ''),
                                                             (444, None, None)])
@pytest.mark.asyncio
async def test_db_manager_update_welcome_message(guild_id, new_message, expected):
    await add_fake_guild_to_db(guild_id)
    intro_db.update_guild_welcome_message(guild_id, new_message)
    await asyncio.sleep(0.2)
    val = intro_db.fetch_guild_welcome_message(guild_id)
    assert val == expected, intro_db.fetch_guild_welcome_message(guild_id)


@pytest.mark.asyncio
async def test_db_manager_new_guild_welcome_message():
    val = intro_db.new_guild_welcome_message(fake_guild_id)
    assert val == DEFAULT_WELCOME_MESSAGE


@pytest.mark.parametrize("guild_id, expected", [(fake_guild_id, 1), (non_existent_guild_id, 0)])
@pytest.mark.asyncio
async def test_db_manager_remove_guild_welcome_message(guild_id, expected):
    count = intro_db.remove_guild_welcome_message(guild_id)
    assert count == expected


@pytest.mark.asyncio
async def test_on_guild_join():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = dpytest.back.make_guild('TestGuildJoin', id_num=1250)
    test_config.guilds.append(guild)
    await dpytest.member_join(1, client.user)
    await asyncio.sleep(0.3)
    val = intro_db.fetch_guild_welcome_message(1250)
    assert val == DEFAULT_WELCOME_MESSAGE


@pytest.mark.asyncio
async def test_on_guild_remove(bot):
    test_config = dpytest.get_config()
    guild = test_config.guilds[0]
    client = test_config.client
    bot_member = test_config.guilds[0].get_member(client.user.id)
    dpytest.backend.delete_member(bot_member)
    val = intro_db.fetch_guild_welcome_message(guild.id)
    assert val is None


@pytest.mark.parametrize("guild_id, expected",
                         [(101, f"fake guild welcome message"), (1250, DEFAULT_WELCOME_MESSAGE),
                          (9999, DEFAULT_WELCOME_MESSAGE)])
@pytest.mark.asyncio
async def test_get_guild_welcome_message(guild_id, expected):
    val = intro_db.get_guild_welcome_message(guild_id)
    assert val == f"{expected}\r\n{BASE_LEGAL_MESSAGE}", val


@pytest.mark.asyncio
async def test_get_non_bot_members():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = test_config.guilds[0]
    assert len(get_non_bot_members(guild)) == 1, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    await dpytest.member_join()
    assert len(get_non_bot_members(guild)) == 2, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    for i in range(3):
        await dpytest.member_join(name=f'TestUser{str(i)}')
    assert len(get_non_bot_members(guild)) == 5, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    logger.debug(
        [str(non_bot_member) + " " + str(non_bot_member.bot) for non_bot_member in get_non_bot_members(guild)])
    dpytest.backend.delete_member(guild.get_member(client.user.id))
    assert len(get_non_bot_members(guild)) == 5, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    logger.debug(
        [str(non_bot_member) + " " + str(non_bot_member.bot) for non_bot_member in get_non_bot_members(guild)])


@pytest.mark.asyncio
async def test_on_member_join():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = dpytest.back.make_guild('TestMemberJoin', id_num=1234)
    test_config.guilds.append(guild)
    await dpytest.member_join(1, client.user)
    await asyncio.sleep(0.25)
    welcome_message = intro_db.get_guild_welcome_message(guild.id)
    await dpytest.member_join(1)
    assert dpytest.verify().message().content(welcome_message)
    intro_db.update_guild_welcome_message(guild.id, 'This is an updated welcome message.')
    await asyncio.sleep(0.25)
    welcome_message = intro_db.get_guild_welcome_message(guild.id)
    await dpytest.member_join(1)
    assert dpytest.verify().message().content(welcome_message)


@pytest.fixture(scope='session', autouse=True)
def setup_db():
    with koala_db.session_manager() as session:
        for table in koala_db.fetch_all_tables():
            session.execute(text(f"DELETE FROM {table};"))
        session.commit()

</document_content>
</document>
<document index="28">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest

# Own modules
from koala.cogs.intro_cog.utils import ask_for_confirmation, confirm_message


@pytest.mark.parametrize("msg_content, is_invalid, expected",
                         [('y', False, True), ('n', False, False), ('Y', False, True), ('N', False, False),
                          ('x', True, False), (' ', True, False), ('', True, False), ('yy', True, False)])
@pytest.mark.asyncio
async def test_ask_for_confirmation(msg_content, is_invalid, expected):
    author = dpytest.get_config().members[0]
    channel = dpytest.get_config().channels[0]
    message = dpytest.back.make_message(author=author, content=msg_content, channel=channel)
    x = await ask_for_confirmation(message, channel)
    assert x == expected
    if is_invalid:
        assert dpytest.verify().message()


@pytest.mark.parametrize("msg_content, expected",
                         [('y', True), ('n', False), ('Y', True), ('N', False), ('', None), (' ', None),
                          ('y ', True), (' n', False)])
@pytest.mark.asyncio
async def test_confirm_message(msg_content, expected):
    author = dpytest.get_config().members[0]
    channel = dpytest.get_config().channels[0]
    message = dpytest.back.make_message(author=author, content=msg_content, channel=channel)
    x = await confirm_message(message)
    assert x is expected

</document_content>
</document>
<document index="29">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test.factories as dpyfactory

from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.models import GuildWelcomeMessages
# Own modules
from koala.db import session_manager

# Constants
fake_guild_id = 1000
non_existent_guild_id = 9999

# Variables


async def add_fake_guild_to_db(id=-1):
    with session_manager() as session:
        if id == 9999:
            return -1
        if id == -1:
            id = dpyfactory.make_id()
        intro_db.remove_guild_welcome_message(id)
        session.add(GuildWelcomeMessages(guild_id=id, welcome_message='fake guild welcome message'))
        session.commit()
        return id

</document_content>
</document>
<document index="30">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="31">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_api.py</source>
<document_content>
from http.client import OK, BAD_REQUEST

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web

from koala.cogs.verification.api import VerifyEndpoint, CONFIG_ENDPOINT, REVERIFY_ENDPOINT

TEST_EMAIL = 'verify_test@koalabot.uk'
TEST_EMAIL_DOMAIN = 'koalabot.uk'


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = VerifyEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


async def test_get_verify_config_empty(api_client):
    guild_id = dpytest.get_config().guilds[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [
        ]
    }

    assert expected_result == result


async def test_get_verify_config(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result


async def test_put_verify_config(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []


async def test_put_verify_config_clear(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": []
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": []
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

async def test_put_verify_config_clear(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": []
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": []
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []


async def test_post_reverify_nothing(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.post('/{}'.format(REVERIFY_ENDPOINT), json={
        "guild_id": guild_id,
        "role_id": role_id})

    assert resp.status == BAD_REQUEST
    result: dict = await resp.json()
    assert result["error"] == "VerifyException"
    assert result["message"] == "Verification is not enabled for that role"


async def test_post_reverify(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })

    resp = await api_client.post('/{}'.format(REVERIFY_ENDPOINT), json={
        "guild_id": guild_id,
        "role_id": role_id})

    assert resp.status == OK
    result: dict = await resp.json()
    assert result["role_id"] == role_id

</document_content>
</document>
<document index="32">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_cog.py</source>
<document_content>
#!/usr/bin/env python
# TODO Test rig broken, restart from beginning and fix.
"""
Testing KoalaBot Verification
Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import asyncio

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, delete

# Own modules
import koalabot
from koala.cogs import Verification
from koala.cogs.verification.models import VerifiedEmails, ToReVerify, NonVerifiedEmails, Roles, VerifyBlacklist
from koala.db import session_manager
from tests.log import logger

# Constants
TEST_EMAIL = 'verify_test@koalabot.uk'
TEST_EMAIL_DOMAIN = 'koalabot.uk'

# Variables


@pytest_asyncio.fixture(autouse=True)
async def cog(bot: commands.Bot):
    cog = Verification(bot)
    await bot.add_cog(cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return cog


@pytest.fixture(autouse=True)
def delete_tables(session):
    session.execute(delete(VerifiedEmails))
    session.execute(delete(ToReVerify))
    session.execute(delete(NonVerifiedEmails))
    session.execute(delete(Roles))
    session.execute(delete(VerifyBlacklist))
    session.commit()


@pytest.mark.asyncio
async def test_member_join_no_verify():
    await dpytest.member_join()
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_member_join_verif_enabled():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = dpytest.back.make_guild("testMemberJoin", id_num=1234)
        test_config.guilds.append(guild)
        dpytest.back.make_role("testRole", guild, id_num=555)
        test_role = Roles(s_id=1234, r_id=555, email_suffix=TEST_EMAIL_DOMAIN)
        session.add(test_role)
        session.commit()
        welcome_message = f"""Welcome to testMemberJoin. This guild has verification enabled.
Please verify one of the following emails to get the appropriate role using `{koalabot.COMMAND_PREFIX}verify your_email@example.com`.
This email is stored so you don't need to verify it multiple times across servers.
`{TEST_EMAIL_DOMAIN}` for `@testRole`"""
        await dpytest.member_join(1)
        await asyncio.sleep(0.25)
        assert dpytest.verify().message().content(welcome_message)
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_member_join_already_verified(bot: commands.Bot):
    with session_manager() as session:
        guild = dpytest.back.make_guild("testMemberJoin", id_num=1234)
        bot._connection._guilds[guild.id] = guild

        test_user = dpytest.back.make_user("TestUser", 1234, id_num=999)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        test_verified_email = VerifiedEmails(u_id=999, email=f'egg@{TEST_EMAIL_DOMAIN}')
        test_role = Roles(s_id=1234, r_id=555, email_suffix=TEST_EMAIL_DOMAIN)
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        await dpytest.member_join(guild, test_user)
        await asyncio.sleep(0.25)
        welcome_message = f"""Welcome to testMemberJoin. This guild has verification enabled.
Please verify one of the following emails to get the appropriate role using `{koalabot.COMMAND_PREFIX}verify your_email@example.com`.
This email is stored so you don't need to verify it multiple times across servers.
`{TEST_EMAIL_DOMAIN}` for `@testRole`"""
        assert dpytest.verify().message().content(welcome_message)
        member = guild.get_member(test_user.id)
        assert role in member.roles

        session.delete(test_verified_email)
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_enable_verification():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")
        entry = session.execute(select(Roles).filter_by(s_id=guild.id, r_id=role.id)).all()
        assert entry
        session.execute(delete(Roles).filter_by(s_id=guild.id))
        session.commit()


@pytest.mark.asyncio
async def test_disable_verification():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        session.add(Roles(s_id=guild.id, r_id=555, email_suffix="egg.com"))
        session.commit()
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeVerification egg.com testRole")
        assert dpytest.verify().message().content("Emails ending with egg.com no longer give testRole")
        entry = session.execute(select(Roles).filter_by(s_id=guild.id, r_id=role.id)).all()
        assert not entry


@pytest.mark.asyncio
async def test_full_flow():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles


@pytest.mark.asyncio
async def test_blacklist():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklist {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will no longer receive testRole upon verifying with this email suffix")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role not in member.roles


@pytest.mark.asyncio
async def test_blacklist_remove():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklist {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will no longer receive testRole upon verifying with this email suffix")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklistRemove {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will now be able to receive testRole upon verifying with this email suffix")

        assert role in member.roles


@pytest.mark.asyncio
async def test_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        member = guild.members[0]
        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")
        entry = session.execute(select(NonVerifiedEmails).filter_by(u_id=member.id, email=TEST_EMAIL)).all()
        assert entry


@pytest.mark.asyncio
async def test_verify_twice():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

    dm = await member.create_dm()

    msg_mock: discord.Message = dpytest.back.make_message("n", member, dm)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "verify test@egg.com", dm)
    assert dpytest.verify().message().content(
        "This email is already assigned to your account. Would you like to verify anyway? (y/n)")
    assert dpytest.verify().message().content("Okay, you will not be verified with test@egg.com")


@pytest.mark.asyncio
async def test_verify_alternate_account_no():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        member2 = await dpytest.member_join(guild)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles
        assert role not in member2.roles

        dm2 = await member2.create_dm()

        msg_mock: discord.Message = dpytest.back.make_message("n", member2, dm2)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm2, member2)
        assert dpytest.verify().message().content(
            "This email is already assigned to a different account. Would you like to verify anyway? (y/n)")
        assert dpytest.verify().message().content(
            f"Okay, you will not be verified with {TEST_EMAIL}")


@pytest.mark.asyncio
async def test_verify_alternate_account_yes():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        member2 = await dpytest.member_join(guild)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles
        assert role not in member2.roles

        dm2 = await member2.create_dm()

        msg_mock: discord.Message = dpytest.back.make_message("y", member2, dm2)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm2, member2)
        assert dpytest.verify().message().content(
            "This email is already assigned to a different account. Would you like to verify anyway? (y/n)")
        assert dpytest.verify().message().content(
            "Please verify yourself using the command you have been emailed")

        assert role not in member.roles

        token2 = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member2.id, email=TEST_EMAIL)).scalar()

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token2}", dm2, member2)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member2.roles


@pytest.mark.asyncio
async def test_verify_list():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyList")

        expected_embeds = discord.Embed(title=f"Current verification setup for {guild.name}")
        expected_embeds.add_field(name=TEST_EMAIL_DOMAIN, value=f"@{role}")

        assert dpytest.verify().message().embed(expected_embeds)




@pytest.mark.asyncio
async def test_confirm():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        test_role = Roles(s_id=guild.id, r_id=555, email_suffix="egg.com")
        test_verified_email = NonVerifiedEmails(u_id=member.id, email='test@egg.com', token='testtoken')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + "confirm testtoken", dm)
        verified = session.execute(select(VerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        exists = session.execute(select(NonVerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        assert verified
        assert not exists
        await asyncio.sleep(0.5)
        assert role in member.roles
        assert dpytest.verify().message().content("Your email has been verified, thank you")
        session.delete(test_role)
        session.execute(delete(VerifiedEmails).filter_by(u_id=member.id))
        session.commit()


@pytest.mark.asyncio
async def test_un_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + "unVerify test@egg.com", dm)
        assert dpytest.verify().message().content(
            "test@egg.com has been un-verified and relevant roles have been removed")
        entry = session.execute(select(VerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        assert not entry
        assert role not in member.roles
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_get_emails():
    with session_manager() as session:
        test_verified_email = VerifiedEmails(u_id=123, email=TEST_EMAIL)
        session.add(test_verified_email)
        session.commit()
    await dpytest.message(koalabot.COMMAND_PREFIX + "getEmails 123")
    assert dpytest.verify().message().content(f"""This user has registered with:\n{TEST_EMAIL}""")
    with session_manager() as session:
        session.delete(test_verified_email)
        session.commit()


@pytest.mark.asyncio
async def test_re_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555555555555555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        await dpytest.message(koalabot.COMMAND_PREFIX + "reVerify <@&555555555555555>")
        assert role not in member.roles
        blacklisted = session.execute(select(ToReVerify).filter_by(u_id=member.id)).all()
        assert blacklisted
        assert dpytest.verify().message().content(
            "That role has now been removed from all users and they will need to re-verify the associated email.")
        session.delete(test_verified_email)
        session.delete(test_role)
        session.execute(delete(ToReVerify).filter_by(u_id=member.id))
        session.commit()

@pytest.mark.asyncio
async def test_re_verify_duplicate():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555555555555555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        test_re_verify = ToReVerify(u_id=member.id, r_id=role.id)
        session.add(test_verified_email)
        session.add(test_role)
        session.add(test_re_verify)
        session.commit()

        await dpytest.message(koalabot.COMMAND_PREFIX + "reVerify <@&555555555555555>")
        assert role not in member.roles
        blacklisted = session.execute(select(ToReVerify).filter_by(u_id=member.id)).all()
        assert blacklisted
        assert dpytest.verify().message().content(
            "That role has now been removed from all users and they will need to re-verify the associated email.")
        session.delete(test_verified_email)
        session.delete(test_role)
        session.execute(delete(ToReVerify).filter_by(u_id=member.id))
        session.commit()


</document_content>
</document>
<document index="33">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_core.py</source>
<document_content>
import pytest

import discord.ext.test as dpytest
from sqlalchemy import select
from sqlalchemy.orm import Session

from koala.cogs.verification import core
from koala.cogs.verification.models import ToReVerify, VerifiedEmails, NonVerifiedEmails, Roles, VerifyBlacklist


@pytest.mark.asyncio
async def test_confirm_reverify(bot, session: Session):
    await dpytest.get_config().guilds[0].create_role(name="emailRole")

    guild = dpytest.get_config().guilds[0]
    user_id = guild.members[0].id
    role_id = guild.roles[1].id
    email_suffix = "@gmail.com"
    email = "testemail"+email_suffix
    token = "12345"

    session.add(ToReVerify(u_id=user_id, r_id=role_id))
    session.add(VerifiedEmails(u_id=user_id, email=email))
    session.add(NonVerifiedEmails(u_id=user_id, email=email, token=token))
    session.add(Roles(s_id=guild.id, r_id=role_id, email_suffix=email_suffix))

    await core.email_verify_confirm(user_id, token, bot, session=session)

    assert session.execute(select(ToReVerify)).all() == []
    assert session.execute(select(NonVerifiedEmails)).all() == []
    assert len(session.execute(select(VerifiedEmails)).all()) == 1


def test_grouped_list_blacklist(bot, session):
    guild = dpytest.get_config().guilds[0]
    user = guild.members[0]
    role = guild.roles[0]

    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test.com"))

    blacklist_map = core.grouped_list_blacklist(guild.id, bot, session=session)

    assert blacklist_map == {user.name: [role.mention+" / @test.com"]}


def test_grouped_list_blacklist_multiple(bot, session):
    guild = dpytest.get_config().guilds[0]
    user = guild.members[0]
    role = guild.roles[0]

    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test.com"))
    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test2.com"))

    blacklist_map = core.grouped_list_blacklist(guild.id, bot, session=session)

    assert blacklist_map == {user.name: [role.mention+" / @test.com", role.mention+" / @test2.com"]}


</document_content>
</document>
<document index="34">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="35">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_cog.py</source>
<document_content>
# Futures

# Built-in/Generic Imports
import asyncio

import discord
# Libs
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, and_

# Own modules
import koalabot
from koala.cogs import twitch_alert
from koala.cogs.twitch_alert import cog
from koala.cogs.twitch_alert.models import UserInTwitchAlert
from koala.colours import KOALA_GREEN
from koala.db import session_manager
from tests.tests_utils.last_ctx_cog import LastCtxCog

# Constants
DB_PATH = "Koala.db"


# Variables

@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await cog.setup(bot)
    mock1.assert_called()


@pytest_asyncio.fixture
async def twitch_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    twitch_cog = cog.TwitchAlert(bot)
    await bot.add_cog(twitch_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return twitch_cog


@mock.patch("koalabot.check_guild_has_ext", mock.MagicMock(return_value=True))
def test_twitch_is_enabled_true(twitch_cog):
    assert cog.twitch_is_enabled(None)


@mock.patch("koalabot.is_dm_channel", mock.MagicMock(return_value=True))
def test_twitch_is_enabled_dm():
    assert not cog.twitch_is_enabled(None)


@mock.patch("koalabot.is_dm_channel", mock.MagicMock(return_value=False))
@mock.patch("koalabot.is_dpytest", False)
@pytest.mark.asyncio
async def test_twitch_is_enabled_false(twitch_cog: cog.TwitchAlert):
    last_ctx_cog = LastCtxCog(bot=twitch_cog.bot)
    await twitch_cog.bot.add_cog(last_ctx_cog)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx", channel=-1)
    ctx: commands.Context = last_ctx_cog.get_last_ctx()

    assert not cog.twitch_is_enabled(ctx)


# @mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7357))
@pytest.mark.order(1)
@pytest.mark.asyncio
async def test_edit_default_message_default_from_none(twitch_cog):
    this_channel = dpytest.get_config().channels[0]
    assert_embed = discord.Embed(title="Default Message Edited",
                                 description=f"Guild: {dpytest.get_config().guilds[0].id}\n"
                                             f"Channel: {this_channel.id}\n"
                                             f"Default Message: {twitch_alert.utils.DEFAULT_MESSAGE}")

    await dpytest.message(koalabot.COMMAND_PREFIX + f"twitch editMsg {this_channel.id}")
    assert dpytest.verify().message().embed(embed=assert_embed)


# @mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7357))
@pytest.mark.order(2)
@pytest.mark.asyncio
async def test_edit_default_message_existing(twitch_cog):
    this_channel = dpytest.get_config().channels[0]
    assert_embed = discord.Embed(title="Default Message Edited",
                                 description=f"Guild: {dpytest.get_config().guilds[0].id}\n"
                                             f"Channel: {this_channel.id}\n"
                                             "Default Message: {user} is bad")

    await dpytest.message(koalabot.COMMAND_PREFIX + "twitch editMsg " + str(this_channel.id) + " {user} is bad")
    assert dpytest.verify().message().embed(embed=assert_embed)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert(twitch_cog):
    assert_embed = discord.Embed(title="Added User to Twitch Alert",
                                 description=f"Channel: {dpytest.get_config().channels[0].id}\n"
                                             f"User: monstercat\n"
                                             f"Message: {twitch_alert.utils.DEFAULT_MESSAGE}",
                                 colour=KOALA_GREEN)

    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {dpytest.get_config().channels[0].id}")
    assert dpytest.verify().message().embed(embed=assert_embed)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert_wrong_guild(twitch_cog: twitch_alert.cog.TwitchAlert):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().guilds[0].channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {dpytest.get_config().guilds[0].channels[0].id}",
        channel=-1, member=member)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert_custom_message(twitch_cog: twitch_alert.cog.TwitchAlert):
    test_custom_message = "We be live gamers!"

    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    assert_embed = discord.Embed(title="Added User to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"User: monstercat\n"
                                             f"Message: {test_custom_message}",
                                 colour=KOALA_GREEN)

    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {channel.id} {test_custom_message}", channel=-1,
        member=member)
    assert dpytest.verify().message().embed(embed=assert_embed)

    sql_check_updated_server = select(UserInTwitchAlert.custom_message).where(
        and_(UserInTwitchAlert.twitch_username == 'monstercat', UserInTwitchAlert.channel_id == channel.id))
    with session_manager() as session:
        result = session.execute(sql_check_updated_server).one()
    assert result.custom_message == test_custom_message


@pytest.mark.asyncio()
async def test_remove_user_from_twitch_alert_with_message(twitch_cog: twitch_alert.cog.TwitchAlert):
    test_custom_message = "We be live gamers!"

    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    # Creates Twitch Alert
    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {channel.id} {test_custom_message}", channel=-1,
        member=member)

    sql_check_updated_server = select(UserInTwitchAlert.custom_message).where(and_(UserInTwitchAlert.twitch_username == 'monstercat', UserInTwitchAlert.channel_id == channel.id))
    with session_manager() as session:
        result_before = session.execute(sql_check_updated_server).one()

        assert result_before.custom_message == test_custom_message
        await dpytest.empty_queue()
        # Removes Twitch Alert
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch remove monstercat {channel.id}", channel=-1,
                              member=member)
        new_embed = discord.Embed(title="Removed User from Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel.id}\n"
                                              f"User: monstercat")
        assert dpytest.verify().message().embed(new_embed)
        result_after = session.execute(sql_check_updated_server).one_or_none()
        assert result_after is None

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_remove_user_from_twitch_alert_wrong_guild(twitch_cog):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch remove monstercat {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    assert_embed = discord.Embed(title="Added Team to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"Team: faze\n"
                                             f"Message: {twitch_alert.utils.DEFAULT_MESSAGE}",
                                 colour=KOALA_GREEN)
    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id}", channel=-1,
                          member=member)
    assert dpytest.verify().message().embed(assert_embed)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert_with_message(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    assert_embed = discord.Embed(title="Added Team to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"Team: faze\n"
                                             f"Message: wooo message",
                                 colour=KOALA_GREEN)
    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id} wooo message",
                          channel=-1, member=member)
    assert dpytest.verify().message().embed(assert_embed)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert_wrong_guild(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    # Creates Twitch Alert
    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
async def test_remove_team_from_twitch_alert_with_message(twitch_cog):
    test_custom_message = "We be live gamers!"

    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id} {test_custom_message}",
                          channel=-1, member=member)
    await dpytest.empty_queue()
    # Removes Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch removeTeam faze {channel.id}", channel=-1,
                          member=member)
    new_embed = discord.Embed(title="Removed Team from Twitch Alert", colour=KOALA_GREEN,
                              description=f"Channel: {channel.id}\n"
                                          f"Team: faze")
    assert dpytest.verify().message().embed(new_embed)
    pass

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_remove_team_from_twitch_alert_wrong_guild(twitch_cog):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
@pytest.mark.first
async def test_on_ready(twitch_cog: twitch_alert.cog.TwitchAlert):
    with mock.patch.object(twitch_alert.cog.TwitchAlert, 'start_loops') as mock1:
        await twitch_cog.on_ready()
    mock1.assert_called_with()


@mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7363))
@mock.patch("cogs.twitch_alert.TwitchAPIHandler.get_streams_data",
            mock.MagicMock(return_value={'id': '3215560150671170227', 'user_id': '27446517',
                                         "user_name": "Monstercat", 'game_id': "26936", 'type': 'live',
                                         'title': 'Music 24/7'}))
@pytest.mark.skip(reason="Issues with testing inside asyncio event loop, not implemented")
@pytest.mark.asyncio
async def test_loop_check_live(twitch_cog: twitch_alert.cog.TwitchAlert):
    this_channel = dpytest.get_config().channels[0]
    expected_embed = discord.Embed(colour=koalabot.KOALA_GREEN,
                                   title="<:twitch:734024383957434489>  Monstercat is now streaming!",
                                   description="https://twitch.tv/monstercat")
    expected_embed.add_field(name="Stream Title", value="Non Stop Music - Monstercat Radio :notes:")
    expected_embed.add_field(name="Playing", value="Music & Performing Arts")
    expected_embed.set_thumbnail(url="https://static-cdn.jtvnw.net/jtv_user_pictures/"
                                     "monstercat-profile_image-3e109d75f8413319-300x300.jpeg")

    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch add monstercat 7363")
    await dpytest.empty_queue()
    twitch_cog.start_loop()
    await asyncio.sleep(10)
    assert dpytest.verify().message().embed(expected_embed)


@pytest.mark.skip(reason="Issues with testing inside asyncio event loop, not implemented")
@pytest.mark.asyncio
async def test_loop_check_team_live(twitch_cog):
    assert False, "Not Implemented"



</document_content>
</document>
<document index="36">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot twitch_alert

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import discord
# Libs
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, update, insert, delete, and_, or_
from twitchAPI.object import Stream

from koala.cogs.twitch_alert import utils
# Own modules
from koala.cogs.twitch_alert.cog import TwitchAlert
from koala.cogs.twitch_alert.db import TwitchAlertDBManager
from koala.cogs.twitch_alert.models import TwitchAlerts, TeamInTwitchAlert, UserInTwitchTeam, UserInTwitchAlert
from koala.db import session_manager

# Constants
DB_PATH = "Koala.db"


# Variables

@pytest_asyncio.fixture
async def twitch_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    twitch_cog = TwitchAlert(bot)
    await bot.add_cog(twitch_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return twitch_cog


@pytest_asyncio.fixture
async def twitch_alert_db_manager(twitch_cog: TwitchAlert):
    twitch_alert_db_manager = TwitchAlertDBManager(twitch_cog.bot)
    await twitch_alert_db_manager.setup_twitch_handler()
    return twitch_alert_db_manager


@pytest.fixture(autouse=True)
def twitch_alert_db_manager_tables(twitch_alert_db_manager):
    with session_manager() as session:
        session.execute(delete(TwitchAlerts))
        session.execute(delete(TeamInTwitchAlert))
        session.execute(delete(UserInTwitchAlert))
        session.execute(delete(UserInTwitchTeam))
        session.commit()
        return twitch_alert_db_manager


def test_create_tables():
    tables = ['TwitchAlerts', 'UserInTwitchAlert', 'TeamInTwitchAlert', 'UserInTwitchTeam']
    sql_check_table_exists = "SELECT name FROM sqlite_master " \
                             "WHERE type='table' AND " \
                             "name IN ('TwitchAlerts', 'UserInTwitchAlert', 'TeamInTwitchAlert', 'UserInTwitchTeam');"
    with session_manager() as session:
        tables_found = session.execute(sql_check_table_exists).all()
    for table in tables_found:
        assert table.name in tables


def test_new_ta(twitch_alert_db_manager_tables):
    assert utils.DEFAULT_MESSAGE == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=2345)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 2345)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == utils.DEFAULT_MESSAGE


def test_new_ta_message(twitch_alert_db_manager_tables):
    test_message = "Test message"
    assert test_message == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=23456,
                                                                 default_message=test_message)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 23456)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == test_message


def test_new_ta_replace(twitch_alert_db_manager_tables):
    test_message = "Test message2"
    test_new_ta_message(twitch_alert_db_manager_tables=twitch_alert_db_manager_tables)
    assert test_message == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=23456,
                                                                 default_message=test_message, replace=True)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 23456)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == test_message


def test_add_user_to_ta_default_message(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.new_ta(1234, 1234567891, None)
    twitch_alert_db_manager_tables.add_user_to_ta(1234567891, "monstercat", None, 1234)

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567891, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_find_twitch_alert).fetchone()
    assert result.twitch_username == 'monstercat'
    assert result.custom_message is None


def test_add_user_to_ta_custom_message(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.new_ta(1234, 1234567892, None)
    twitch_alert_db_manager_tables.add_user_to_ta(1234567892, "monstercat", "FiddleSticks {user} is live!", 1234)

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567892, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_find_twitch_alert).fetchone()
    assert result.twitch_username == 'monstercat'
    assert result.custom_message == "FiddleSticks {user} is live!"


@pytest.mark.asyncio()
async def test_remove_user_from_ta(twitch_alert_db_manager_tables):
    test_add_user_to_ta_default_message(twitch_alert_db_manager_tables)
    await twitch_alert_db_manager_tables.remove_user_from_ta(1234567891, "monstercat")

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567891, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        assert session.execute(sql_find_twitch_alert).one_or_none() is None


@pytest.mark.asyncio()
async def test_delete_message(twitch_alert_db_manager_tables, session):
    with mock.patch.object(discord.TextChannel, 'fetch_message') as mock1:
        await twitch_alert_db_manager_tables.delete_message(1234, dpytest.get_config().channels[0].id, session=session)
    mock1.assert_called_with(1234)


def test_add_team_to_ta(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.add_team_to_ta(channel_id=566, twitch_team="faze", custom_message=None, guild_id=568)

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 566, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        result: TeamInTwitchAlert = session.execute(sql_select_team).fetchone()

    assert result.custom_message is None


def test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=573, guild_id=574):
    twitch_alert_db_manager_tables.add_team_to_ta(channel_id=channel_id, twitch_team="faze",
                                                  custom_message="Message here", guild_id=guild_id)

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == channel_id, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        result: TeamInTwitchAlert = session.execute(sql_select_team).fetchone()

    assert result.custom_message == "Message here"


@pytest.mark.asyncio()
async def test_remove_team_from_ta(twitch_alert_db_manager_tables):
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    await twitch_alert_db_manager_tables.remove_team_from_ta(590, "faze")

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 590, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        assert session.execute(sql_select_team).one_or_none() is None


@pytest.mark.asyncio()
async def test_remove_team_from_ta_duplicate(twitch_alert_db_manager_tables):
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    await twitch_alert_db_manager_tables.remove_team_from_ta(590, "faze")

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 590, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        assert session.execute(sql_select_team).one_or_none() is not None


@pytest.mark.asyncio()
async def test_remove_team_from_ta_invalid(twitch_alert_db_manager_tables):
    with pytest.raises(AttributeError,
                       match="Team name not found"):
        await twitch_alert_db_manager_tables.remove_team_from_ta(590, 590)


@pytest.mark.asyncio()
async def test_remove_team_from_ta_deletes_messages(twitch_alert_db_manager_tables):
    await test_update_team_members(twitch_alert_db_manager_tables)

    test = update(UserInTwitchTeam)\
        .where(and_(UserInTwitchTeam.team_twitch_alert_id == 604,
                    UserInTwitchTeam.twitch_username == 'monstercat')).values(message_id=1)
    with session_manager() as session:
        session.execute(test)
        session.commit()

    with mock.patch.object(TwitchAlertDBManager, 'delete_message') as mock1:
        await twitch_alert_db_manager_tables.remove_team_from_ta(605, "monstercat")
    mock1.assert_called_with(1, 605, session=mock.ANY)


@pytest.mark.asyncio()
async def test_update_team_members(twitch_alert_db_manager_tables):
    sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
        team_twitch_alert_id=604, channel_id=605, twitch_team_name='monstercat')
    with session_manager() as session:
        session.execute(sql_insert_monstercat_team)
        session.commit()

        await twitch_alert_db_manager_tables.update_team_members(604, "monstercat")

        sql_select_monstercat_team = select(UserInTwitchTeam).where(and_(UserInTwitchTeam.team_twitch_alert_id == 604,
                                                                         UserInTwitchTeam.twitch_username == 'monstercat'))

        result = session.execute(sql_select_monstercat_team)
        assert result.one_or_none() is not None


@pytest.mark.asyncio()
async def test_update_all_teams_members(twitch_alert_db_manager_tables):
    sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
        team_twitch_alert_id=614, channel_id=615, twitch_team_name='monstercat')
    with session_manager() as session:
        session.execute(sql_insert_monstercat_team)

        sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
            team_twitch_alert_id=616, channel_id=617, twitch_team_name='monstercat')
        session.execute(sql_insert_monstercat_team)
        session.commit()

        await twitch_alert_db_manager_tables.update_all_teams_members()

        sql_select_monstercats_team = select(UserInTwitchTeam.twitch_username).where(and_(
                or_(UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
                UserInTwitchTeam.twitch_username == 'monstercat'))

        result = session.execute(sql_select_monstercats_team).all()
        assert len(result) == 2


@pytest.mark.asyncio()
async def test_delete_all_offline_streams(twitch_alert_db_manager_tables, bot: discord.ext.commands.Bot):
    message_id = (await dpytest.message("test_msg", bot.guilds[0].channels[0])).id
    sql_add_message = insert(UserInTwitchAlert).values(
        channel_id=bot.guilds[0].channels[0].id,
        twitch_username='monstercat',
        custom_message=None,
        message_id=message_id)
    with session_manager() as session:
        session.execute(sql_add_message)
        session.commit()

        await twitch_alert_db_manager_tables.delete_all_offline_streams(['monstercat'], session=session)

        sql_select_messages = select(UserInTwitchAlert).where(and_(
            UserInTwitchAlert.twitch_username == 'monstercat',
            UserInTwitchAlert.channel_id == bot.guilds[0].channels[0].id))
        result = session.execute(sql_select_messages).scalars().one_or_none()

        assert result is not None
        assert result.message_id is None
        with pytest.raises(discord.errors.NotFound,
                           match="Unknown Message"):
            await bot.guilds[0].channels[0].fetch_message(message_id)


@pytest.mark.asyncio()
async def test_delete_all_offline_streams_team(twitch_alert_db_manager_tables, bot: discord.ext.commands.Bot):
    await test_update_all_teams_members(twitch_alert_db_manager_tables)

    sql_add_message = update(UserInTwitchTeam).where(and_(or_(
        UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
        UserInTwitchTeam.twitch_username == 'monstercat')).values(message_id=1)
    with session_manager() as session:
        session.execute(sql_add_message)
        session.commit()

        await twitch_alert_db_manager_tables.delete_all_offline_team_streams(['monstercat'], session=session)

        sql_select_messages = select(UserInTwitchTeam.message_id, UserInTwitchTeam.twitch_username).where(
            and_(or_(UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
                 UserInTwitchTeam.twitch_username == 'monstercat'))
        result = session.execute(sql_select_messages).fetchall()

        assert len(result) == 2
        assert result[0].message_id is None
        assert result[1].message_id is None


@pytest.mark.asyncio
async def test_create_alert_embed(twitch_alert_db_manager_tables):
    stream_data = Stream(id='3215560150671170227', user_id='27446517', user_name="Monstercat", user_login="monstercat",
                         game_id="26936", type='live', title='Music 24/7')

    assert type(await twitch_alert_db_manager_tables.create_alert_embed(stream_data, None)) is discord.Embed

</document_content>
</document>
<document index="37">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_twitch_handler.py</source>
<document_content>
import pytest
import pytest_asyncio

from koala.cogs.twitch_alert.env import TWITCH_KEY, TWITCH_SECRET
from koala.cogs.twitch_alert.twitch_handler import TwitchAPIHandler


@pytest_asyncio.fixture
async def twitch_api_handler():
    twitch_api_handler = TwitchAPIHandler()
    await twitch_api_handler.setup(TWITCH_KEY, TWITCH_SECRET)
    return twitch_api_handler


@pytest.mark.asyncio
async def test_get_streams_data(twitch_api_handler):
    usernames = ['monstercat', 'jaydwee']
    streams_data = await twitch_api_handler.get_streams_data(usernames)
    assert streams_data is not None


@pytest.mark.asyncio
async def test_get_user_data(twitch_api_handler):
    assert await twitch_api_handler.get_user_data('monstercat') is not None


@pytest.mark.asyncio
async def test_get_game_data(twitch_api_handler):
    assert 'music' in (await twitch_api_handler.get_game_data('26936')).name.lower()


@pytest.mark.asyncio
async def test_get_team_users(twitch_api_handler):
    # assumes uosvge is in the team called uosvge
    members = await twitch_api_handler.get_team_users('uosvge')
    for member in members:
        if member.user_login == 'uosvge':
            assert True
            return
    assert False

</document_content>
</document>
<document index="38">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_utils.py</source>
<document_content>
# Futures

# Built-in/Generic Imports

import discord
# Libs
import discord.ext.test as dpytest
from twitchAPI.object import Stream, TwitchUser, Game

# Own modules
from koala.cogs.twitch_alert import utils
from koala.colours import KOALA_GREEN

# Constants
DB_PATH = "Koala.db"


# Variables


def test_create_live_embed():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="TestGame")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")
    game_info = Game(name="TestGame")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, game_info, "")
    assert dpytest.embed_eq(result, expected)


def test_create_live_embed_with_message():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test", description="Hello Message")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="TestGame")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")
    game_info = Game(name="TestGame")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, game_info, "Hello Message")
    assert dpytest.embed_eq(result, expected)


def test_create_live_embed_without_game():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test", description="Hello Message")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="No Category")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, None, "Hello Message")
    assert dpytest.embed_eq(result, expected)


def test_split_to_100s_small():
    assert len(utils.split_to_100s(list(range(1,99)))) == 1


def test_split_to_100s_medium():
    assert len(utils.split_to_100s(list(range(1,150)))) == 2


def test_split_to_100s_large():
    result = utils.split_to_100s(list(range(1, 1501)))
    assert len(result) == 16
    for res in result:
        assert len(res) <= 100


def test_split_to_100s_empty():
    result = utils.split_to_100s([])
    assert result == []

</document_content>
</document>
<document index="39">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="40">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot TextFilter
"""

# Libs
import discord
import discord.ext.test as dpytest
import pytest
import pytest_asyncio
from sqlalchemy import select, delete

# Own modules
import koalabot
from koala.cogs import BaseCog
from koala.cogs import TextFilter as TextFilterCog
from koala.cogs.text_filter.db import TextFilterDBManager
from koala.cogs.text_filter.models import TextFilter, TextFilterModeration
from koala.colours import KOALA_GREEN
from koala.db import session_manager
from koala.utils import is_int
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Variables


@pytest_asyncio.fixture(scope="function", autouse=True)
async def utils_cog(bot: discord.ext.commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def base_cog(bot: discord.ext.commands.Bot):
    base_cog = BaseCog(bot)
    await bot.add_cog(base_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return base_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def tf_cog(bot: discord.ext.commands.Bot):
    tf_cog = TextFilterCog(bot)
    await bot.add_cog(tf_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return tf_cog


def assert_banned_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " has been deleted by KoalaBot.")


def assert_risky_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " contains a 'risky' word. This is a warning.")


def assert_email_warning(word):
    assert dpytest.verify().message().content(
        "Be careful! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " includes personal information and has been deleted by KoalaBot.")


def assert_filtered_confirmation(word, type):
    assert dpytest.verify().message().content("*" + word + "* has been filtered as **" + type + "**.")


def assert_new_ignore(id):
    assert dpytest.verify().message().content("New ignore added: " + id)


def assert_remove_ignore(id):
    assert dpytest.verify().message().content("Ignore removed: " + id)


def create_new_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Added"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def list_mod_channel_embed(channels):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for channel in channels:
        embed.add_field(name="Name & Channel ID", value=channel.mention + " " + str(channel.id), inline=False)
    return embed


def list_ignored_embed(ignored):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Ignored Users/Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for ig in ignored:
        embed.add_field(name="Name & ID", value=ig.mention + " " + str(ig.id))
    return embed


def remove_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Removed"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def create_filtered_string(text):
    create_text_string = ""
    for current in text:
        create_text_string += current + "\n"
    return create_text_string


def filtered_words_embed(words, filter, regex):
    word_string = create_filtered_string(words)
    filter_string = create_filtered_string(filter)
    regex_string = create_filtered_string(regex)
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Banned Words", value=word_string)
    embed.add_field(name="Filter Types", value=filter_string)
    embed.add_field(name="Is Regex?", value=regex_string)
    return embed

def no_filtered_words_embed():
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="No words found", value="For more help with using the Text Filter try k!help TextFilter")
    return embed


def cleanup(guild_id, tf_cog, session):
    session.execute(delete(TextFilter).filter_by(guild_id=guild_id))


@pytest.mark.asyncio()
async def test_filter_new_word_correct_database(tf_cog):
    with session_manager() as session:
        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word no",
                              channel=dpytest.get_config().guilds[0].channels[0])
        assert_filtered_confirmation("no", "banned")
        assert len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all()) == old + 1
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_filter_empty_word():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word")


@pytest.mark.asyncio()
async def test_filter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word a b c d e f g")


@pytest.mark.asyncio()
async def test_filter_risky_word(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word yup risky")
        assert_filtered_confirmation("yup", "risky")

        await dpytest.message("yup test")
        assert_risky_warning("yup test")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unrecognised_filter_type():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word testy unknown")


@pytest.mark.asyncio()
async def test_filter_email_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_invalid_regex(tf_cog):
    with session_manager() as session:
        with pytest.raises(Exception):
            await dpytest.message(koalabot.COMMAND_PREFIX + "filter_regex [")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_normal_filter_does_not_recognise_regex():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter \"^verify [a-zA-Z0-9]+@soton.ac.uk$\"")
    assert_filtered_confirmation("^verify [a-zA-Z0-9]+@soton.ac.uk$", "banned")

    await dpytest.message("verify abc@soton.ac.uk")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio()
async def test_filter_various_emails_with_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")

        # Should delete and warn
        await dpytest.message("hey stefan@herts.ac.uk")
        assert_banned_warning("hey stefan@herts.ac.uk")

        # Should delete and warn
        await dpytest.message("hey stefan.c.27.abc@herts.ac.uk")
        assert_banned_warning("hey stefan.c.27.abc@herts.ac.uk")

        # Should not warn
        await dpytest.message("hey herts.ac.uk")
        assert dpytest.verify().message().nothing()

        # Should not warn
        await dpytest.message("hey stefan@herts")
        assert dpytest.verify().message().nothing()

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_word_correct_database(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word unfilterboi")
        assert_filtered_confirmation("unfilterboi", "banned")

        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text='unfilterboi')).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word unfilterboi")

        assert len(session.execute(select(TextFilter.filtered_text)
                                   .filter_by(filtered_text='unfilterboi')).all()) == old - 1
        assert dpytest.verify().message().content("*unfilterboi* has been unfiltered.")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word")


@pytest.mark.asyncio()
async def test_unfilter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word a b c d e")


@pytest.mark.asyncio()
async def test_list_filtered_words(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing1")
        assert_filtered_confirmation("listing1", "banned")
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing2 risky")
        assert_filtered_confirmation("listing2", "risky")

        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = filtered_words_embed(['listing1', 'listing2'], ['banned', 'risky'], ['0', '0'])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_filtered_words_empty(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = no_filtered_words_embed()
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.fixture
def text_filter_db_manager():
    return TextFilterDBManager(dpytest.get_config())


@pytest.mark.asyncio()
async def test_add_mod_channel_tag(text_filter_db_manager, tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel <#" + str(channel.id) + ">")
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        result = session.execute(select(TextFilterModeration.channel_id).filter_by(guild_id=channel.guild.id)).all()
        assert is_int(result[0][0])
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel")


@pytest.mark.asyncio()
async def test_add_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel 123")


@pytest.mark.asyncio()
async def test_add_mod_channel_too_many_arguments():
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
    dpytest.get_config().channels.append(channel)
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id) + " a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        channel_id = str(channel.id)
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + channel_id)
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel " + channel_id)
        assert_embed = remove_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_remove_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel")


@pytest.mark.asyncio()
async def test_remove_mod_channel_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_list_channels(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_multiple_channels(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])
        channel2 = dpytest.backend.make_text_channel(name="TestChannel2", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel1)
        dpytest.get_config().channels.append(channel2)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel1.id))
        assert_embed = create_new_mod_channel_embed(channel1)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel2.id))
        assert_embed = create_new_mod_channel_embed(channel2)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel1, channel2])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_channel(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])

        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreme")
        assert_filtered_confirmation("ignoreme", "banned")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreChannel " + channel1.mention)
        assert_new_ignore(channel1.mention)

        # Should be ignored
        await dpytest.message("ignoreme", channel=channel1)

        # Should be deleted and warned
        await dpytest.message("ignoreme")
        assert_banned_warning("ignoreme")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_user(tf_cog):
    with session_manager() as session:
        message = await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
        assert_filtered_confirmation("ignoreuser", "banned")

        # Should be deleted and warned
        await dpytest.message("ignoreuser")
        assert_banned_warning("ignoreuser")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + message.author.mention)
        assert_new_ignore(message.author.mention)

        # Should be ignored
        await dpytest.message("ignoreuser")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_empty_user():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser")


@pytest.mark.asyncio()
async def test_unignore_channel():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
    assert_filtered_confirmation("ignoreuser", "banned")

    await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be ignored
    await dpytest.message("ignoreuser")

    await dpytest.message(koalabot.COMMAND_PREFIX + "unignore " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_remove_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be deleted and warned
    await dpytest.message("ignoreuser")
    assert_banned_warning("ignoreuser")


@pytest.mark.asyncio()
async def test_list_ignored():
    mes = await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + mes.author.mention)
    assert_new_ignore(mes.author.mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "listIgnored")
    assert list_ignored_embed([dpytest.get_config().guilds[0].channels[0], mes.author])

</document_content>
</document>
<document index="41">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="42">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/conftest.py</source>
<document_content>
import pytest
from aiohttp import web
from discord.ext.commands import Bot
from sqlalchemy import delete

from koala.cogs.base.api import BaseEndpoint
from koala.cogs.base.models import ScheduledActivities
from koala.models import KoalaExtensions, GuildExtensions


@pytest.fixture(autouse=True)
def delete_tables(session):
    session.execute(delete(KoalaExtensions))
    session.execute(delete(GuildExtensions))
    session.execute(delete(ScheduledActivities))
    session.commit()

@pytest.fixture(autouse=True)
def setup_attributes(bot: Bot):
    app = web.Application()
    endpoint = BaseEndpoint(bot)
    endpoint.register(app)
    setattr(bot, "koala_web_app", app)
</document_content>
</document>
<document index="43">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_api.py</source>
<document_content>
from http.client import BAD_REQUEST, CREATED, OK

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web
from mock import mock

import koalabot
from koala.cogs.base.api import BaseEndpoint


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = BaseEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


'''

GET /activity

'''


async def test_get_activities(api_client):
    resp = await api_client.get('/scheduled-activity?show_all=False')
    assert resp.status == OK
    text = await resp.text()
    assert text == '[]'


async def test_get_activities_bad_param(api_client):
    resp = await api_client.get('/scheduled-activity?invalid_arg=abc')
    assert resp.status == BAD_REQUEST


async def test_get_activities_missing_param(api_client):
    resp = await api_client.get('/scheduled-activity')
    assert resp.status == BAD_REQUEST


'''

PUT /scheduled-activity

'''


async def test_put_schedule_activity(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == CREATED
    text = await resp.text()
    assert text == '{"message": "Activity scheduled"}'


async def test_put_schedule_activity_missing_param(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'end_time'}"


async def test_put_schedule_activity_bad_activity(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'invalidActivity',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Invalid activity type'


async def test_put_schedule_activity_bad_start_time(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': 'invalid_time',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Bad start / end time'


async def test_put_schedule_activity_bad_end_time(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'invalidActivity',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2026-01-01 00:00:00',
        'end_time': 'invalidTime'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Bad start / end time'


'''

PUT /activity

'''


async def test_put_set_activity(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'playing',
        'name': 'test',
        'url': 'test.com'
    })
    assert resp.status == CREATED
    text = await resp.text()
    assert text == '{"message": "Activity set"}'
    assert dpytest.verify().activity().matches(
        discord.Activity(type=discord.ActivityType.playing, name="test", url="test.com"))


async def test_put_set_activity_bad_req(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'invalidActivity',
        'name': 'test',
        'url': 'test.com'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error setting activity: Invalid activity type'


async def test_put_set_activity_missing_param(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'invalidActivity',
        'url': 'test.com'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'name'}"


'''

GET /ping

'''


async def test_get_ping(api_client):
    with mock.patch('discord.client.Client.latency', new_callable=mock.PropertyMock) as mock_last_transaction:
        mock_last_transaction.return_value = 0.42
        resp = await api_client.get('/ping')
        assert resp.status == OK
        text = (await resp.json())['message']
        assert "Pong! 420ms" in text


'''

GET /version

'''


async def test_get_version(api_client):
    resp = await api_client.get('/version')
    text = (await resp.json())['message']
    assert f"version: {koalabot.__version__}" in text


'''

GET /support

'''


async def test_get_support_link(api_client):
    resp = await api_client.get('/support')
    text = (await resp.json())['message']
    assert "Join our support server for more help! https://discord.gg/5etEjVd" in text


'''

POST /load-cog

'''


async def test_post_load_cog(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog loaded"


async def test_post_load_base_cog(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'base',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog loaded"


async def test_post_load_cog_bad_req(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'invalidCog',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error loading cog: Invalid extension'


async def test_post_load_cog_missing_param(api_client):
    resp = await api_client.post('/load-cog', json={})
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'extension'}"


async def test_post_load_cog_already_loaded(api_client):
    await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })

    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error loading cog: Already loaded'


'''

POST /unload-cog

'''


async def test_post_unload_cog(api_client):
    await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })

    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog unloaded"


async def test_post_unload_cog_not_loaded(api_client):
    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error unloading cog: Extension not loaded'


async def test_post_unload_cog_missing_param(api_client):
    resp = await api_client.post('/unload-cog', json={})
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'extension'}"


async def test_post_unload_base_cog(api_client):
    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'BaseCog',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error unloading cog: Sorry, you can't unload the base cog"


'''

POST /enable-extension

'''


@mock.patch("koalabot.ENABLED_COGS", ["announce"])
async def test_post_enable_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/enable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })

    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Extension enabled"


async def test_post_enable_extension_bad_req(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]

    resp = await api_client.post('/enable-extension', json=
    {
        'guild_id': guild.id,
        'koala_ext': 'Invalid Extension'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error enabling extension: Invalid extension"


async def test_post_enable_extension_missing_param(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/enable-extension', json=
    {
        'guild_id': guild.id
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'koala_ext'}"


'''

POST /disable-extension

'''


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
async def test_post_disable_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    setup = await api_client.post('/enable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert setup.status == OK

    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert resp.status == OK
    text = await resp.text()
    assert text == '{"message": "Extension disabled"}'


async def test_post_disable_extension_not_enabled(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error disabling extension: Extension not enabled"


async def test_post_disable_extension_missing_param(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'koala_ext'}"


async def test_post_disable_extension_bad_req(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]

    resp = await api_client.post('/disable-extension', json=
    {
        'guild_id': guild.id,
        'koala_ext': 'Invalid Extension'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error disabling extension: Extension not enabled"


'''

GET /extensions

'''


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
async def test_get_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.get('/extensions?guild_id={}'.format(guild.id))
    assert resp.status == OK
    text = await resp.text()
    assert text == '["Announce"]'


async def test_get_extension_bad_param(api_client):
    resp = await api_client.get('/extensions?invalid-arg=abc')
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'guild_id'}"


async def test_get_extension_missing_param(api_client):
    resp = await api_client.get('/extensions')
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'guild_id'}"

</document_content>
</document>
<document index="44">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs.base.cog import setup as setup_cog, BaseCog
from koala.colours import KOALA_GREEN


# Constants

# Variables


@pytest.fixture(scope='session', autouse=True)
def setup_is_dpytest():
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False


@pytest_asyncio.fixture(scope='function', autouse=True)
async def base_cog(bot: commands.Bot):
    """ setup any state specific to the execution of the given module."""
    cog = BaseCog(bot)
    await bot.add_cog(cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return cog


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ["greetings_cog"])
@pytest.mark.asyncio
async def test_list_koala_ext_disabled(bot, base_cog):
    await koalabot.load_all_cogs(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "listExt")
    expected_embed = discord.Embed()
    expected_embed.title = "Enabled extensions"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":negative_squared_cross_mark: Disabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_enable_koala_ext(bot, base_cog):
    await koalabot.load_all_cogs(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "enableExt Greetings")
    expected_embed = discord.Embed()
    expected_embed.title = "Greetings enabled"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":white_check_mark: Enabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_disable_koala_ext(bot, base_cog):
    await test_enable_koala_ext(bot, base_cog)
    await dpytest.message(koalabot.COMMAND_PREFIX + "disableExt Greetings")
    expected_embed = discord.Embed()
    expected_embed.title = "Greetings disabled"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":negative_squared_cross_mark: Disabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@pytest.mark.asyncio
async def test_on_ready(base_cog: BaseCog):
    await base_cog.on_ready()
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.playing,
                                                                name=koalabot.COMMAND_PREFIX + "help koalabot.uk"))


@pytest.mark.asyncio
async def test_activity():
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity set watching you")
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you"))
    assert dpytest.verify().message().content("I am now watching you")


@pytest.mark.asyncio
async def test_invalid_activity():
    with pytest.raises(commands.BadArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "activity set oof you")


@pytest.mark.asyncio
async def test_schedule_activity():
    await dpytest.message(koalabot.COMMAND_PREFIX +
                          "activity schedule playing test \"2020-01-01 00:00:00\" \"2020-01-01 01:00:00\"")
    assert dpytest.verify().message().content("Activity saved")


@pytest.mark.asyncio
async def test_schedule_activity_invalid_date():
    with pytest.raises(commands.BadArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "activity schedule playing test abc abc")


@pytest.mark.asyncio
async def test_list_activity():
    await test_schedule_activity()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list")
    assert dpytest.verify().message().content("Activities:")


@pytest.mark.asyncio
async def test_list_activity_show_all():
    await test_schedule_activity()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list true")
    assert dpytest.verify().message().content("Activities:"
                                              "\n1, playing, None, test, 2020-01-01 00:00:00, 2020-01-01 01:00:00")


@pytest.mark.asyncio
async def test_remove_activity():
    await test_list_activity_show_all()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity remove 1")
    assert dpytest.verify().message().content("Removed:"
                                              "\n1, playing, None, test, 2020-01-01 00:00:00, 2020-01-01 01:00:00")
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list true")
    assert dpytest.verify().message().content("Activities:")


@mock.patch("builtins.round", mock.MagicMock(return_value=4))
@pytest.mark.asyncio
async def test_ping(base_cog: BaseCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "ping")
    assert dpytest.verify().message().content("Pong! 4ms")


@pytest.mark.asyncio
async def test_support():
    await dpytest.message(koalabot.COMMAND_PREFIX + "support")
    assert dpytest.verify().message().content("Join our support server for more help! https://discord.gg/5etEjVd")


@pytest.mark.asyncio
async def test_default_clear():
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear")
    mock1.assert_called_with(limit=2)


@pytest.mark.asyncio
async def test_clear():
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear 4")
    mock1.assert_called_with(limit=5)


@pytest.mark.asyncio
async def test_invalid_clear(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.BadArgument,
                       match="Converting to \"int\" failed for parameter \"amount\"."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear a")


@pytest.mark.asyncio
async def test_load_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog base")
    mock1.assert_called_with(".base", package="koala.cogs")


@pytest.mark.asyncio
async def test_invalid_load_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.CommandInvokeError,
                       match=r".* Extension 'koala.cogs.FakeCog' could not be loaded."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog FakeCog")


@pytest.mark.asyncio
async def test_unload_base_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.CommandInvokeError, match="Sorry, you can't unload the base cog"):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog BaseCog")


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@pytest.mark.asyncio
async def test_load_valid_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@pytest.mark.asyncio
async def test_load_and_unload_valid_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")

    with mock.patch.object(discord.ext.commands.bot.Bot, 'unload_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")


@pytest.mark.asyncio
async def test_invalid_unload_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.CommandInvokeError,
                       match="Command raised an exception: ExtensionNotLoaded:"
                             " Extension 'koala.cogs.FakeCog' has not been loaded."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog FakeCog")


@pytest.mark.asyncio
async def test_version(base_cog: BaseCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "version")
    assert dpytest.verify().message().content("version: " + koalabot.__version__)


@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await setup_cog(bot)
    mock1.assert_called()

</document_content>
</document>
<document index="45">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_core.py</source>
<document_content>
import datetime

import discord
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands

import koalabot
from koala.cogs.base import core


@pytest.fixture
def reset_extensions(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    core.disable_extension(bot, guild.id, "All")


def test_activity_clear_current():
    core.current_activity = "test"
    assert core.current_activity
    core.activity_clear_current()
    assert not core.current_activity


@pytest.mark.asyncio
async def test_activity_set(bot: commands.Bot):
    await core.activity_set(discord.ActivityType.watching, "you", None, bot)
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you"))


@pytest.mark.asyncio
async def test_activity_set_current_scheduled(bot: commands.Bot, session):
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    await core.activity_set_current_scheduled(bot, session=session)
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you2"))


def test_activity_list():
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    schedule = core.activity_list(True)
    assert schedule[0].activity_id == 1
    assert schedule[0].activity_type == discord.ActivityType.watching
    assert schedule[0].message == "you2"


async def test_remove_scheduled_activity():
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    assert core.activity_list(True)[0].activity_id == 1

    core.activity_remove(1)
    assert not core.activity_list(True)


@pytest.mark.asyncio
async def test_ping(bot: commands.Bot):
    with mock.patch('discord.client.Client.latency', new_callable=mock.PropertyMock) as mock_last_transaction:
        mock_last_transaction.return_value = 0.42
        resp = await core.ping(bot)
        assert "Pong! 420ms" in resp


def test_support_link():
    resp = core.support_link()
    assert "Join our support server for more help! https://discord.gg/5etEjVd" in resp


def test_version():
    resp = core.get_version()
    assert f"version: {koalabot.__version__}" in resp


@pytest.mark.asyncio
async def test_purge(bot: commands.Bot):
    channel: discord.TextChannel = dpytest.get_config().channels[0]
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await core.purge(bot, channel.id, 2)
    mock1.assert_called_with(limit=3)

# Load cogs

@mock.patch("koalabot.ENABLED_COGS", ['announce'])
@pytest.mark.asyncio
async def test_load_cog(bot: commands.Bot):
    resp = await core.load_cog(bot, "announce")
    assert resp == "announce Cog Loaded"


@pytest.mark.asyncio
async def test_load_base_cog(bot: commands.Bot):
    resp = await core.load_cog(bot, "base")
    assert resp == "base Cog Loaded"


@pytest.mark.asyncio
async def test_load_invalid_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotFound, match="Extension 'koala.cogs.FakeCog' could not be loaded."):
        await core.load_cog(bot, "FakeCog")


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
@pytest.mark.asyncio
async def test_load_already_loaded_cog(bot: commands.Bot):
    await core.load_cog(bot, "announce")
    with pytest.raises(discord.ext.commands.errors.ExtensionAlreadyLoaded, match="Extension 'koala.cogs.announce' is already loaded"):
        await core.load_cog(bot, "announce")

# Unload cogs

@pytest.mark.asyncio
async def test_unload_cog(bot: commands.Bot):
    await core.load_cog(bot, "announce")
    resp = await core.unload_cog(bot, "announce")
    assert resp == "announce Cog Unloaded"


@pytest.mark.asyncio
async def test_unload_base_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionError, match="Sorry, you can't unload the base cog"):
        await core.unload_cog(bot, "base")


@pytest.mark.asyncio
async def test_unload_not_loaded_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotLoaded, match="Extension 'koala.cogs.announce' has not been loaded."):
        await core.unload_cog(bot, "announce")


@pytest.mark.asyncio
async def test_unload_invalid_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotLoaded, match="Extension 'koala.cogs.FakeCog' has not been loaded."):
        await core.unload_cog(bot, "FakeCog")

# Enable extensions

@mock.patch("koalabot.ENABLED_COGS", ["Announce"])
@pytest.mark.asyncio
async def test_enable_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_load_cog(bot)
    embed = await core.enable_extension(bot, guild.id, "Announce")
    assert embed.title == "Announce enabled"


@pytest.mark.asyncio
async def test_enable_extension_all(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    embed = await core.enable_extension(bot, guild.id, "All")
    assert embed.title == "All extensions enabled"


@pytest.mark.asyncio
async def test_enable_invalid_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    with pytest.raises(NotImplementedError, match="InvalidExtension is not a valid extension"):
        await core.enable_extension(bot, guild.id, "InvalidExtension")

# Disable extensions

@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_disable_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension(bot)
    embed = await core.disable_extension(bot, guild.id, "Announce")
    assert embed.title == "Announce disabled"


@pytest.mark.asyncio
async def test_disable_extension_all(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension_all(bot)
    embed = await core.disable_extension(bot, guild.id, "All")
    assert embed.title == "All disabled"


@pytest.mark.asyncio
async def test_disable_extension_not_enabled(bot: commands.Bot):
    with pytest.raises(NotImplementedError, match="Announce is not an enabled extension"):
        guild: discord.Guild = dpytest.get_config().guilds[0]
        await core.disable_extension(bot, guild.id, "Announce")


@pytest.mark.asyncio
async def test_disable_invalid_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    with pytest.raises(NotImplementedError, match="InvalidExtension is not an enabled extension"):
        await core.disable_extension(bot, guild.id, "InvalidExtension")

# List enabled extensions

@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_list_enabled_extensions(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension(bot)
    embed = await core.list_enabled_extensions(guild.id)
    assert embed.fields[0].name == ":white_check_mark: Enabled"
    assert "Announce" in embed.fields[0].value

# Get available extensions

@mock.patch("koalabot.COGS_PACKAGE", koalabot.COGS_PACKAGE)
@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_get_extensions(bot: commands.Bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = core.get_all_available_guild_extensions(guild.id)
    print(resp)
    assert resp[0] == "Announce"
</document_content>
</document>
<document index="46">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_db.py</source>
<document_content>
import datetime

import discord
from sqlalchemy import select

from koala.cogs.base import db
from koala.cogs.base.models import ScheduledActivities


def test_add_scheduled_activity(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = "https://twitch.tv/thenuel"
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    results = session.execute(select(ScheduledActivities)).scalars().all()
    assert len(results) == 1
    result = results[0]
    assert result.message == "NUEL finals"
    assert result.time_end == time_end


def test_add_scheduled_activity_no_url(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    results = session.execute(select(ScheduledActivities)).scalars().all()
    assert len(results) == 1
    result = results[0]
    assert result.message == "NUEL finals"
    assert result.stream_url is None


def test_get_scheduled_activities(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    assert len(db.get_scheduled_activities(False, False)) == 1


def test_remove_scheduled_activities(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    db.remove_scheduled_activities(1)

    assert len(db.get_scheduled_activities(False, False)) == 0


</document_content>
</document>
<document index="47">
<source>/Users/malcolm/dev/KoalaBot/tests/conftest.py</source>
<document_content>
"""
A configuration file for methods useful in all testing with pytest
"""
# Futures

# Built-in/Generic Imports
import shutil

import discord
import discord.ext.test as dpytest
# Libs
import pytest
import pytest_asyncio

import koala.db as db
# Own modules
import koalabot
from koala.db import session_manager
from tests.log import logger

# Constants

pytest_plugins = 'aiohttp.pytest_plugin'


@pytest.fixture(scope='session', autouse=True)
def teardown_config():

    # yield, to let all tests within the scope run
    yield

    # tear_down: then clear table at the end of the scope
    logger.info("Tearing down session")

    from koala.env import CONFIG_PATH

    shutil.rmtree(CONFIG_PATH, ignore_errors=True)


@pytest_asyncio.fixture
async def bot():
    import koalabot
    intents = discord.Intents.default()
    intents.members = True
    intents.guilds = True
    intents.messages = True
    intents.message_content = True
    b = koalabot.KoalaBot(koalabot.COMMAND_PREFIX, intents=intents)
    await b._async_setup_hook()
    await dpytest.empty_queue()
    dpytest.configure(b)
    return b


@pytest.fixture(autouse=True)
def setup_is_dpytest():
    db.__create_sqlite_tables()
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False


@pytest_asyncio.fixture
async def session():
    with session_manager() as session:
        yield session

</document_content>
</document>
<document index="48">
<source>/Users/malcolm/dev/KoalaBot/tests/test_koalabot.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot Base Code

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.db import clear_all_tables, fetch_all_tables
from tests.tests_utils.last_ctx_cog import LastCtxCog
from tests.tests_utils.utils import FakeAuthor

# Constants

# Variables
utils_cog = None


@pytest_asyncio.fixture(autouse=True)
async def test_ctx(bot: commands.Bot):
    global utils_cog
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    return utils_cog.get_last_ctx()


@pytest.fixture(scope='session', autouse=True)
def setup_db():
    clear_all_tables(fetch_all_tables())


@pytest_asyncio.fixture(scope='function', autouse=True)
async def setup_clean_messages():
    await dpytest.empty_queue()
    yield dpytest


def test_test_user_is_owner(test_ctx):
    assert koalabot.is_owner(test_ctx)


def test_invalid_test_user_is_owner(test_ctx):
    for i in range(len(koalabot.BOT_OWNER)):
        test_ctx.author = FakeAuthor(id=koalabot.BOT_OWNER[i] + 1)
        koalabot.is_dpytest = False
        assert not koalabot.is_owner(test_ctx)
        koalabot.is_dpytest = True


def test_owner_is_owner(test_ctx):
    for i in range(len(koalabot.BOT_OWNER)):
        test_ctx.author = FakeAuthor(id=(koalabot.BOT_OWNER[i]))
        assert koalabot.is_owner(test_ctx)


def test_test_user_is_admin(test_ctx):
    assert koalabot.is_admin(test_ctx)


def test_invalid_test_user_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(id=int(koalabot.BOT_OWNER[0]) + 2)
    koalabot.is_dpytest = False
    assert not koalabot.is_admin(test_ctx)
    koalabot.is_dpytest = True


def test_admin_test_user_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(name="TestUser#0001", all_permissions=True)
    assert koalabot.is_admin(test_ctx)


def test_admin_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(name="TestUser#0002", all_permissions=True)
    assert koalabot.is_admin(test_ctx)


def test_not_admin_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(all_permissions=False)
    koalabot.is_dpytest = False
    assert not koalabot.is_admin(test_ctx)
    koalabot.is_dpytest = True


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_load_all_cogs(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await koalabot.load_all_cogs(bot)
    mock1.assert_called_with(".greetings_cog", package="tests.tests_utils.fake_load_all_cogs")


@pytest.mark.asyncio
async def test_dm_single_group_message():
    test_message = 'default message'
    test_member = dpytest.get_config().members[0]
    x = await koalabot.dm_group_message([test_member], test_message)
    assert dpytest.verify().message().content(test_message)
    assert x == 1


@pytest.mark.asyncio
async def test_dm_plural_group_message():
    test_message = 'default message'
    test_member = dpytest.get_config().members[0]
    test_member_2 = await dpytest.member_join()
    await dpytest.empty_queue()
    x = await koalabot.dm_group_message([test_member, test_member_2], test_message)
    assert dpytest.verify().message().content(test_message)
    assert dpytest.verify().message().content(test_message)
    assert x == 2


@pytest.mark.asyncio
async def test_dm_empty_group_message():
    test_message = 'this should not be sent'
    x = await koalabot.dm_group_message([], test_message)
    assert dpytest.verify().message().nothing()
    assert x == 0


@pytest.fixture(scope='session', autouse=True)
def setup_is_dpytest():
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False

</document_content>
</document>
<document index="49">
<source>/Users/malcolm/dev/KoalaBot/tests/test_utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot Utils

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.utils import __parse_args, format_config_path, wait_for_message
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Constants

# Variables


def test_parse_args_config():
    assert "/config/" == vars(__parse_args(["--config", "/config/"])).get("config")


def test_parse_args_invalid():
    assert vars(__parse_args(["--test", "/test/"])).get("config") is None


@mock.patch("os.name", "posix")
def test_format_db_path_linux_absolute():
    db_path = format_config_path("/test_dir/", "test.db")
    assert db_path == "/test_dir/test.db"


@mock.patch("os.name", "nt")
def test_format_db_path_windows():
    db_path = format_config_path("/test_dir/", "windows_test.db")
    assert db_path == "\\test_dir\\windows_test.db"


@pytest.mark.parametrize("msg_content", [" ", "something"])
@pytest.mark.asyncio
async def test_wait_for_message_not_none(msg_content, utils_cog: LastCtxCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    bot: discord.Client = config.client
    import threading
    t2 = threading.Timer(interval=0.1, function=dpytest.message, args=(msg_content))
    t2.start()
    fut = await wait_for_message(bot, ctx, 0.2)
    t2.join()
    assert fut, dpytest.sent_queue


@pytest.mark.asyncio
async def test_wait_for_message_none(utils_cog: LastCtxCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    bot: discord.Client = config.client
    msg, channel = await wait_for_message(bot, ctx, 0.2)
    assert not msg
    assert channel == ctx.channel


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog
</document_content>
</document>
<document index="50">
<source>/Users/malcolm/dev/KoalaBot/tests/tests_utils/__init__.py</source>
<document_content>
from . import fake_load_all_cogs, last_ctx_cog, utils
</document_content>
</document>
<document index="51">
<source>/Users/malcolm/dev/KoalaBot/tests/tests_utils/last_ctx_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing utilities Cog for KoalaBot tests

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
from discord.ext import commands

# Own modules
import koalabot


# Constants

# Variables


class LastCtxCog(commands.Cog):
    """
    A discord cog that can be used when testing
    """

    def __init__(self, bot):
        """
        Initialises the class variables of this cog
        :param bot: The client of the bot being used
        """
        self.bot = bot
        self._last_member = None
        self.last_ctx = None

    @commands.command()
    async def store_ctx(self, ctx):
        """
        Takes the context when this command is used and stores it in this object
        :param ctx: the discord context of the command
        """
        self.last_ctx = ctx

    def get_last_ctx(self):
        """
        A getter for the last ctx got from store_ctx
        :return: last_ctx
        """
        return self.last_ctx


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(LastCtxCog(bot))

</document_content>
</document>
<document index="52">
<source>/Users/malcolm/dev/KoalaBot/tests/tests_utils/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing utilities for KoalaBot tests

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import random
from string import ascii_letters

# Libs
import discord
import emoji
from discord.ext.test import factories as dpyfactory

# Own modules

# Constants
unicode_emojis = list(dict(emoji.UNICODE_EMOJI.get('en')).values())
flag_emojis = list([":regional_indicator_a:", ":regional_indicator_b:", ":regional_indicator_c:"])
emoji_unicodes = list(dict(emoji.EMOJI_UNICODE.get('en')).values())


# Variables


def assert_activity(activity: discord.Activity, application_id=None, name=None, url=None,
                    type=None, state=None, details=None, emoji=None, start=None, end=None,
                    large_image_url=None, small_image_url=None, large_image_text=None, small_image_text=None):
    """
    A method that asserts all activity properties of the given activity are as provided

    :param activity: The outcome to be tested against
    :param application_id: assert the application ID of the activity is the same as this
    :param name: assert the name of the activity is the same as this
    :param url: assert the url of the activity is the same as this
    :param type: assert the type of the activity is the same as this
    :param state: assert the state of the activity is the same as this
    :param details: assert the details of the activity is the same as this
    :param emoji: assert the emoji of the activity is the same as this
    :param start: assert the start of the activity is the same as this
    :param end: assert the end of the activity is the same as this
    :param large_image_url: assert the large_image_url of the activity is the same as this
    :param small_image_url: assert the small_image_url of the activity is the same as this
    :param large_image_text: assert the large_image_text of the activity is the same as this
    :param small_image_text: assert the small_image_text of the activity is the same as this
    """
    # TODO: Add timestamps, assets, party
    assert activity.application_id == application_id \
           and activity.name == name \
           and activity.url == url \
           and activity.type == type \
           and activity.state == state \
           and activity.details == details \
           and activity.emoji == emoji \
           and activity.start == start \
           and activity.end == end \
           and activity.large_image_url == large_image_url \
           and activity.small_image_url == small_image_url \
           and activity.large_image_text == large_image_text \
           and activity.small_image_text == small_image_text


def fake_guild_emoji(guild: discord.Guild) -> discord.Emoji:
    fake_emoji = discord.Emoji(guild=guild, state=None,
                               data={'require_colons': True, 'managed': False, 'animated': False,
                                     'name': fake_custom_emoji_name_str(), 'id': fake_id_str(), 'available': True})
    return fake_emoji


def fake_partial_emoji() -> discord.PartialEmoji:
    if random.choice([True, False]):
        fake_emoji = discord.PartialEmoji(name=fake_custom_emoji_name_str(), animated=random.choice([True, False]),
                                          id=dpyfactory.make_id)
    else:
        fake_emoji = discord.PartialEmoji(name=fake_unicode_emoji())
    return fake_emoji


def fake_guild_role(guild: discord.Guild) -> discord.Role:
    fake_role = discord.Role(guild=guild, state=None,
                             data={'id': dpyfactory.make_id(), 'name': fake_custom_emoji_name_str(),
                                   'mentionable': True, 'hoist': True, 'managed': False,
                                   'colour': random.randint(0, 16777215), 'permissions': 8})
    guild._add_role(fake_role)
    return fake_role


def fake_custom_emoji_str_rep() -> str:
    """
    Creates a fake string representation of a discord custom emoji.
    :return:
    """
    emoji_str = ""
    emoji_str += random.choice(["<a:", "<:"])
    emoji_str += ''.join(random.choice(ascii_letters) for i in range(random.randint(4, 12)))
    emoji_str += f":{dpyfactory.make_id()}>"
    return emoji_str


def fake_custom_emoji_name_str() -> str:
    return ''.join(random.choice(ascii_letters) for i in range(random.randint(4, 12)))


def fake_unicode_emoji() -> str:
    """
    Creates a fake unicode emoji (the string representation with colons)
    :return:
    """
    return random.choice(unicode_emojis)


def fake_flag_emoji() -> str:
    """
    Creates a fake unicode emoji (the string representation with colons)
    :return:
    """
    return random.choice(flag_emojis)


def fake_emoji_unicode() -> str:
    """
    Returns a random unicode emoji's unicode codepoint
    """
    return random.choice(emoji_unicodes)


def fake_role_mention() -> str:
    """
    Creates a fake role mention string.
    :return:
    """
    return "<@&" + str(dpyfactory.make_id()) + ">"


def fake_id_str() -> str:
    """
    Creates a fake id string, e.g. message ID, role ID, etc.
    :return:
    """
    return str(dpyfactory.make_id())


class FakeAuthor:
    """
    A class that acts as a discord.Member to replace the ctx.author on a context (ctx)
    """

    def __init__(self, name="FakeUser#0001", id=-1, all_permissions=False):
        """
        Initialises class variables and creates a random id if not specified
        :param name: the name of the user including identifier (e.g. KoalaBotUK#1075)
        :param id: The discord ID of the user
        :param all_permissions: If the user should be given all permissions (admin etc) or none
        :param roles: The role IDs of the user's roles
        """
        self.name = name
        if id == -1:
            self.id = dpyfactory.make_id()
        else:
            self.id = id
        self.allPermissions = all_permissions

    def __str__(self):
        """
        The string of this class is the name
        :return: name
        """
        return self.name

    @property
    def guild_permissions(self):
        """
        Imitates discord.Member.guild_permissions and redirects according to allPermissions
        :return: discord permissions (all or none)
        """
        if self.allPermissions:
            return discord.Permissions.all()
        else:
            return discord.Permissions.none()

</document_content>
</document>
<document index="53">
<source>/Users/malcolm/dev/KoalaBot/tests/tests_utils/fake_load_all_cogs/__init__.py</source>
<document_content>
from . import greetings_cog
</document_content>
</document>
<document index="54">
<source>/Users/malcolm/dev/KoalaBot/tests/tests_utils/fake_load_all_cogs/greetings_cog.py</source>
<document_content>
"""
A test Cog to only be used for testing koalabot.load_all_cogs

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
from discord.ext import commands

# Own modules
import koalabot
from koala.db import insert_extension


# Constants

# Variables


class Greetings(commands.Cog):
    """
    A cog used for tests that greets the user
    """

    def __init__(self, bot):
        """
        Initialises class variables
        :param bot: The client of the bot being used
        """
        self.bot = bot
        self._last_member = None
        insert_extension("Greetings", 0, True, True)

    @commands.command()
    async def hello(self, ctx, *, member: discord.Member = None):
        """
        Says hello to the user
        :param ctx: context
        :param member: the member who sent the message
        """
        member = member or ctx.author
        if self._last_member is None or self._last_member.id != member.id:
            await ctx.send('Hello {0.name}~'.format(member))
        else:
            await ctx.send('Hello {0.name}... This feels familiar.'.format(member))
        self._last_member = member

    @commands.command()
    async def hi(self, ctx):
        """
        Says hi to the user
        :param ctx: The context of the message
        """
        await ctx.send(f'Hi {ctx.author}')


async def setup(bot: koalabot) -> None:
    """
    Loads this cog into the selected bot
    :param bot: The client of the KoalaBot
    """
    await bot.add_cog(Greetings(bot))

</document_content>
</document>
<document index="55">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="56">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot TextFilter
"""

# Libs
import discord
import discord.ext.test as dpytest
import pytest
import pytest_asyncio
from sqlalchemy import select, delete

# Own modules
import koalabot
from koala.cogs import BaseCog
from koala.cogs import TextFilter as TextFilterCog
from koala.cogs.text_filter.db import TextFilterDBManager
from koala.cogs.text_filter.models import TextFilter, TextFilterModeration
from koala.colours import KOALA_GREEN
from koala.db import session_manager
from koala.utils import is_int
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Variables


@pytest_asyncio.fixture(scope="function", autouse=True)
async def utils_cog(bot: discord.ext.commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def base_cog(bot: discord.ext.commands.Bot):
    base_cog = BaseCog(bot)
    await bot.add_cog(base_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return base_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def tf_cog(bot: discord.ext.commands.Bot):
    tf_cog = TextFilterCog(bot)
    await bot.add_cog(tf_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return tf_cog


def assert_banned_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " has been deleted by KoalaBot.")


def assert_risky_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " contains a 'risky' word. This is a warning.")


def assert_email_warning(word):
    assert dpytest.verify().message().content(
        "Be careful! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " includes personal information and has been deleted by KoalaBot.")


def assert_filtered_confirmation(word, type):
    assert dpytest.verify().message().content("*" + word + "* has been filtered as **" + type + "**.")


def assert_new_ignore(id):
    assert dpytest.verify().message().content("New ignore added: " + id)


def assert_remove_ignore(id):
    assert dpytest.verify().message().content("Ignore removed: " + id)


def create_new_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Added"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def list_mod_channel_embed(channels):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for channel in channels:
        embed.add_field(name="Name & Channel ID", value=channel.mention + " " + str(channel.id), inline=False)
    return embed


def list_ignored_embed(ignored):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Ignored Users/Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for ig in ignored:
        embed.add_field(name="Name & ID", value=ig.mention + " " + str(ig.id))
    return embed


def remove_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Removed"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def create_filtered_string(text):
    create_text_string = ""
    for current in text:
        create_text_string += current + "\n"
    return create_text_string


def filtered_words_embed(words, filter, regex):
    word_string = create_filtered_string(words)
    filter_string = create_filtered_string(filter)
    regex_string = create_filtered_string(regex)
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Banned Words", value=word_string)
    embed.add_field(name="Filter Types", value=filter_string)
    embed.add_field(name="Is Regex?", value=regex_string)
    return embed

def no_filtered_words_embed():
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="No words found", value="For more help with using the Text Filter try k!help TextFilter")
    return embed


def cleanup(guild_id, tf_cog, session):
    session.execute(delete(TextFilter).filter_by(guild_id=guild_id))


@pytest.mark.asyncio()
async def test_filter_new_word_correct_database(tf_cog):
    with session_manager() as session:
        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word no",
                              channel=dpytest.get_config().guilds[0].channels[0])
        assert_filtered_confirmation("no", "banned")
        assert len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all()) == old + 1
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_filter_empty_word():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word")


@pytest.mark.asyncio()
async def test_filter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word a b c d e f g")


@pytest.mark.asyncio()
async def test_filter_risky_word(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word yup risky")
        assert_filtered_confirmation("yup", "risky")

        await dpytest.message("yup test")
        assert_risky_warning("yup test")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unrecognised_filter_type():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word testy unknown")


@pytest.mark.asyncio()
async def test_filter_email_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_invalid_regex(tf_cog):
    with session_manager() as session:
        with pytest.raises(Exception):
            await dpytest.message(koalabot.COMMAND_PREFIX + "filter_regex [")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_normal_filter_does_not_recognise_regex():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter \"^verify [a-zA-Z0-9]+@soton.ac.uk$\"")
    assert_filtered_confirmation("^verify [a-zA-Z0-9]+@soton.ac.uk$", "banned")

    await dpytest.message("verify abc@soton.ac.uk")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio()
async def test_filter_various_emails_with_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")

        # Should delete and warn
        await dpytest.message("hey stefan@herts.ac.uk")
        assert_banned_warning("hey stefan@herts.ac.uk")

        # Should delete and warn
        await dpytest.message("hey stefan.c.27.abc@herts.ac.uk")
        assert_banned_warning("hey stefan.c.27.abc@herts.ac.uk")

        # Should not warn
        await dpytest.message("hey herts.ac.uk")
        assert dpytest.verify().message().nothing()

        # Should not warn
        await dpytest.message("hey stefan@herts")
        assert dpytest.verify().message().nothing()

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_word_correct_database(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word unfilterboi")
        assert_filtered_confirmation("unfilterboi", "banned")

        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text='unfilterboi')).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word unfilterboi")

        assert len(session.execute(select(TextFilter.filtered_text)
                                   .filter_by(filtered_text='unfilterboi')).all()) == old - 1
        assert dpytest.verify().message().content("*unfilterboi* has been unfiltered.")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word")


@pytest.mark.asyncio()
async def test_unfilter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word a b c d e")


@pytest.mark.asyncio()
async def test_list_filtered_words(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing1")
        assert_filtered_confirmation("listing1", "banned")
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing2 risky")
        assert_filtered_confirmation("listing2", "risky")

        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = filtered_words_embed(['listing1', 'listing2'], ['banned', 'risky'], ['0', '0'])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_filtered_words_empty(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = no_filtered_words_embed()
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.fixture
def text_filter_db_manager():
    return TextFilterDBManager(dpytest.get_config())


@pytest.mark.asyncio()
async def test_add_mod_channel_tag(text_filter_db_manager, tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel <#" + str(channel.id) + ">")
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        result = session.execute(select(TextFilterModeration.channel_id).filter_by(guild_id=channel.guild.id)).all()
        assert is_int(result[0][0])
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel")


@pytest.mark.asyncio()
async def test_add_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel 123")


@pytest.mark.asyncio()
async def test_add_mod_channel_too_many_arguments():
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
    dpytest.get_config().channels.append(channel)
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id) + " a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        channel_id = str(channel.id)
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + channel_id)
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel " + channel_id)
        assert_embed = remove_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_remove_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel")


@pytest.mark.asyncio()
async def test_remove_mod_channel_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_list_channels(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_multiple_channels(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])
        channel2 = dpytest.backend.make_text_channel(name="TestChannel2", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel1)
        dpytest.get_config().channels.append(channel2)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel1.id))
        assert_embed = create_new_mod_channel_embed(channel1)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel2.id))
        assert_embed = create_new_mod_channel_embed(channel2)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel1, channel2])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_channel(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])

        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreme")
        assert_filtered_confirmation("ignoreme", "banned")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreChannel " + channel1.mention)
        assert_new_ignore(channel1.mention)

        # Should be ignored
        await dpytest.message("ignoreme", channel=channel1)

        # Should be deleted and warned
        await dpytest.message("ignoreme")
        assert_banned_warning("ignoreme")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_user(tf_cog):
    with session_manager() as session:
        message = await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
        assert_filtered_confirmation("ignoreuser", "banned")

        # Should be deleted and warned
        await dpytest.message("ignoreuser")
        assert_banned_warning("ignoreuser")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + message.author.mention)
        assert_new_ignore(message.author.mention)

        # Should be ignored
        await dpytest.message("ignoreuser")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_empty_user():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser")


@pytest.mark.asyncio()
async def test_unignore_channel():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
    assert_filtered_confirmation("ignoreuser", "banned")

    await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be ignored
    await dpytest.message("ignoreuser")

    await dpytest.message(koalabot.COMMAND_PREFIX + "unignore " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_remove_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be deleted and warned
    await dpytest.message("ignoreuser")
    assert_banned_warning("ignoreuser")


@pytest.mark.asyncio()
async def test_list_ignored():
    mes = await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + mes.author.mention)
    assert_new_ignore(mes.author.mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "listIgnored")
    assert list_ignored_embed([dpytest.get_config().guilds[0].channels[0], mes.author])

</document_content>
</document>
<document index="57">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/__init__.py</source>
<document_content>
from . import utils, db, models
from .cog import TextFilter, setup

</document_content>
</document>
<document index="58">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports
import re

import discord
# Libs
from discord.ext import commands

# Own modules
import koalabot
from koala.colours import KOALA_GREEN
from koala.db import insert_extension
from koala.utils import extract_id
from .db import TextFilterDBManager
from .utils import type_exists, build_word_list_embed, build_moderation_channel_embed, \
    create_default_embed, build_moderation_deleted_embed


def text_filter_is_enabled(ctx):
    """
    A command used to check if the guild has enabled TextFilter
    e.g. @commands.check(koalabot.is_admin)

    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "TextFilter")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class TextFilter(commands.Cog, name="TextFilter"):
    """
    A discord.py cog with commands pertaining to the a Text Filter for admins to monitor their server
    """

    def __init__(self, bot):
        self.bot = bot
        insert_extension("TextFilter", 0, True, True)
        self.tf_database_manager = TextFilterDBManager(bot)

    @commands.command(name="filter", aliases=["filter_word"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def filter_new_word(self, ctx, word, filter_type="banned", too_many_arguments=None):
        """
        Adds a new word to the filtered text list

        :param ctx: The discord context
        :param word: The first argument and word to be filtered
        :param filter_type: The filter type (banned or risky)
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Something has gone wrong, your word may already be filtered or you have entered the
                command incorrectly. Try again with: `k!filter [filtered_text] [[risky] or [banned]]`"""
        if too_many_arguments is None and type_exists(filter_type):
            await self.filter_text(ctx, word, filter_type, False)
            await ctx.channel.send("*" + word + "* has been filtered as **" + filter_type + "**.")
            return
        raise Exception(error)

    @commands.command(name="filterRegex", aliases=["filter_regex"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def filter_new_regex(self, ctx, regex, filter_type="banned", too_many_arguments=None):
        """
        Adds a new regex to the filtered text list

        :param ctx: The discord context
        :param regex: The first argument and regex to be filtered
        :param filter_type: The filter type (banned or risky)
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = r"""Something has gone wrong, your regex may be invalid, this regex may already be filtered
                or you have entered the command incorrectly. Try again with: `k!filterRegex
                [filtered_regex] [[risky] or [banned]]`. One example for a regex could be to block emails
                with: [a-zA-Z0-9\._]+@herts\.ac\.uk where EMAIL is the university type (e.g herts)"""
        if too_many_arguments is None and type_exists(filter_type):
            try:
                re.compile(regex)
                await self.filter_text(ctx, regex, filter_type, True)
                await ctx.channel.send("*" + regex + "* has been filtered as **" + filter_type + "**.")
                return
            except:
                raise Exception(error)
        raise Exception(error)

    @commands.command(name="unfilter", aliases=["unfilter_word"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def unfilter_word(self, ctx, word, too_many_arguments=None):
        """
        Remove an existing word/test from the filter list

        :param ctx: The discord context
        :param word: The first argument and word to be filtered
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = "Too many arguments, please try again using the following arguments: `k!unfilter [filtered_word]`"
        if too_many_arguments is None:
            await self.unfilter_text(ctx, word)
            await ctx.channel.send("*" + word + "* has been unfiltered.")
            return
        raise Exception(error)

    @commands.command(name="filterList", aliases=["check_filtered_words", "checkFilteredWords"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def check_filtered_words(self, ctx):
        """
        Get a list of filtered words on the current guild.

        :param ctx: The discord context
        :return:
        """
        all_words_and_types = self.get_list_of_words(ctx)
        await ctx.channel.send(embed=build_word_list_embed(ctx, all_words_and_types[0], all_words_and_types[1],
                                                           all_words_and_types[2]))

    @commands.command(name="modChannelAdd", aliases=["setup_mod_channel", "setupModChannel",
                                                     "add_mod_channel", "addModChannel"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def setup_mod_channel(self, ctx, channel_id, too_many_arguments=None):
        """
        Add a mod channel to the current guild

        :param ctx: The discord context
        :param channel_id: The designated channel id for message details
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = "Channel not found or too many arguments, please try again: `k!setupModChannel [channel_id]`"
        channel = self.bot.get_channel(int(extract_id(channel_id)))
        if channel is not None and too_many_arguments is None:
            self.tf_database_manager.new_mod_channel(ctx.guild.id, channel.id)
            await ctx.channel.send(embed=build_moderation_channel_embed(ctx, channel, "Added"))
            return
        raise (Exception(error))

    @commands.command(name="modChannelRemove", aliases=["remove_mod_channel", "deleteModChannel", "removeModChannel"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def remove_mod_channel(self, ctx, channel_id, too_many_arguments=None):
        """
        Remove a mod channel from the guild

        :param ctx: The discord context
        :param channel_id: The designated channel id to be removed
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Channel ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        channel = self.bot.get_channel(int(extract_id(channel_id)))
        if channel is not None and too_many_arguments is None:
            self.tf_database_manager.remove_mod_channel(ctx.guild.id, channel.id)
            await ctx.channel.send(embed=build_moderation_channel_embed(ctx, channel, "Removed"))
            return
        raise Exception(error)

    @commands.command(name="modChannelList", aliases=["list_mod_channels", "listModChannels"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def list_mod_channels(self, ctx):
        """
        Get a list of filtered mod channels in the guild

        :param ctx: The discord context
        :return:
        """
        channels = self.tf_database_manager.get_mod_channel(ctx.guild.id)
        await ctx.channel.send(embed=self.build_channel_list_embed(ctx, channels))

    @commands.command(name="ignoreUser")
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def ignore_user(self, ctx, user, too_many_arguments=None):
        """
        Add a new ignored user to the database

        :param ctx: The discord context
        :param user: The discord mention of the User
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Ignore ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        ignore_id = ctx.message.mentions[0].id
        ignore_exists = self.bot.get_user(int(ignore_id))
        if ignore_exists is not None:
            self.tf_database_manager.new_ignore(ctx.guild.id, 'user', ignore_id)
            await ctx.channel.send("New ignore added: " + user)
            return
        raise (Exception(error))

    @commands.command(name="ignoreChannel")
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def ignore_channel(self, ctx, channel: discord.TextChannel, too_many_arguments=None):
        """
        Add a new ignored channel to the database

        :param ctx: The discord context
        :param channel: The discord mention of the Channel
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Ignore ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        ignore_id = channel.id
        ignore_exists = self.bot.get_channel(int(ignore_id))
        if ignore_exists is not None:
            self.tf_database_manager.new_ignore(ctx.guild.id, 'channel', ignore_id)
            await ctx.channel.send(f"New ignore added: {channel.mention}")
            return
        raise (Exception(error))

    @commands.command(name="unignore", aliases=["remove_ignore", "removeIgnore"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def remove_ignore(self, ctx, ignore, too_many_arguments=None):
        """
        Remove an ignore from the guild

        :param ctx: The discord context
        :param ignore: the ignoreId to be removed
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        if len(ctx.message.mentions) > 0:
            ignore_id = ctx.message.mentions[0].id
        elif len(ctx.message.channel_mentions) > 0:
            ignore_id = ctx.message.channel_mentions[0].id
        else:
            raise Exception("No ignore mention found")
        self.tf_database_manager.remove_ignore(ctx.guild.id, ignore_id)
        await ctx.channel.send("Ignore removed: " + str(ignore))
        return

    @commands.command(name="ignoreList", aliases=["list_ignored", "listIgnored"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def list_ignored(self, ctx):
        """
        Get a list all ignored users/channels

        :param ctx: The discord context
        :return:
        """
        ignored = self.tf_database_manager.get_all_ignored(ctx.guild.id)
        await ctx.channel.send(embed=self.build_ignore_list_embed(ctx, ignored))

    @commands.Cog.listener()
    async def on_message(self, message):
        """
        Upon receiving a message, it is checked for filtered text and is deleted.

        :param message: The newly received message
        :return:
        """
        if message.author.bot:
            return
        if message.content.startswith(koalabot.COMMAND_PREFIX + "filter") or \
                message.content.startswith(koalabot.COMMAND_PREFIX + "unfilter") or \
                message.content.startswith(koalabot.OPT_COMMAND_PREFIX + "filter") or \
                message.content.startswith(koalabot.OPT_COMMAND_PREFIX + "unfilter"):
            return
        elif str(message.channel.type) == 'text' and message.channel.guild is not None:
            censor_list = self.tf_database_manager.get_filtered_text_for_guild(message.channel.guild.id)
            for word, filter_type, is_regex in censor_list:
                if (word in message.content or (
                        is_regex == '1' and re.search(word, message.content))) and not self.is_ignored(message):
                    if filter_type == "risky":
                        await message.author.send("Watch your language! Your message: '*" + message.content + "*' in " +
                                                  message.channel.mention + " contains a 'risky' word. "
                                                                            "This is a warning.")
                        return
                    elif filter_type == "banned":
                        await message.author.send("Watch your language! Your message: '*" + message.content + "*' in " +
                                                  message.channel.mention + " has been deleted by KoalaBot.")
                        await self.send_to_moderation_channels(message)
                        await message.delete()
                        return

    def build_channel_list(self, channels, embed):
        """
        Builds a list of mod channels and adds them to the embed

        :param channels: list of mod channels
        :param embed: The pre-existing embed to add the channel list fields to
        :return embed: the updated embed with the list of channels appended to
        """
        for channel in channels:
            details = self.bot.get_channel(int(channel[0]))
            if details is not None:
                embed.add_field(name="Name & Channel ID", value=details.mention + " " + str(details.id), inline=False)
            else:
                embed.add_field(name="Channel ID", value=channel[0], inline=False)
        return embed

    def build_channel_list_embed(self, ctx, channels):
        """
        Builds the embed that is sent to list all the mod channels

        :param ctx: The discord context
        :param channels: List of channels in the guild
        :return embed with list of mod channels:
        """
        embed = create_default_embed(ctx)
        embed.colour = KOALA_GREEN
        embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
        embed.title = "Koala Moderation - Mod Channels"
        embed = self.build_channel_list(channels, embed)
        return embed

    def is_ignored(self, message):
        """
        Checks if the user/channel should be ignored

        :param message: The newly received message
        :return boolean if should be ignored or not:
        """
        ignore_list_users = self.tf_database_manager.get_ignore_list_users(message.guild.id)
        ignore_list_channels = self.tf_database_manager.get_ignore_list_channels(message.guild.id)
        return message.channel.id in ignore_list_channels or message.author.id in ignore_list_users

    async def filter_text(self, ctx, text, filter_type, is_regex):
        """
        Calls to the datbase to filter a word

        :param ctx: the discord context
        :param text: the word to be filtered
        :param filter_type: the filter_type of the word to be added
        :param is_regex: boolean of if the text is regex
        """
        self.tf_database_manager.new_filtered_text(ctx.guild.id, text, filter_type, is_regex)

    async def unfilter_text(self, ctx, word):
        """
        Calls to the database to unfilter a word

        :param ctx: The discord context
        :param word: The word to be unfiltered
        """
        self.tf_database_manager.remove_filter_text(ctx.guild.id, word)

    def is_moderation_channel_available(self, guild_id):
        """
        Checks if any mod channels exist to be sent to

        :param guild_id: The guild to retrieve mod channels from
        :return: boolean true if mod channel exists, false otherwise
        """
        channels = self.tf_database_manager.get_mod_channel(guild_id)
        return len(channels) > 0

    async def send_to_moderation_channels(self, message):
        """
        Send details about deleted message to mod channels

        :param message: The message in question which is being deleted
        """
        if self.is_moderation_channel_available(message.guild.id):
            channels = self.tf_database_manager.get_mod_channel(message.guild.id)
            for each_channel in channels:
                channel = self.bot.get_channel(int(each_channel[0]))
                await channel.send(embed=build_moderation_deleted_embed(message))

    def get_list_of_words(self, ctx):
        """
        Gets a list of filtered words and corresponding types in a guild

        :param ctx: the discord context
        :return [all_words, all_types]: a list containing two lists of filtered words and types
        """
        all_words, all_types, all_regex = "", "", ""
        for word, filter_type, regex in self.tf_database_manager.get_filtered_text_for_guild(ctx.guild.id):
            all_words += word + "\n"
            all_types += filter_type + "\n"
            all_regex += regex + "\n"
        return [all_words, all_types, all_regex]

    def build_ignore_list(self, ignored, embed):
        """
        Builds a formatted list of ignored users/channels

        :param ignored: list of ignored users/channels
        :param embed: The pre-existing embed to add the channel list fields to
        :return embed: the updated embed with the list of channels appended to
        """
        for ig in ignored:
            if ig[2] == 'channel':
                details = self.bot.get_channel(int(ig[3]))
            else:
                details = self.bot.get_user(int(ig[3]))
            if details is not None:
                embed.add_field(name="Name & ID", value=details.mention + " " + str(details.id), inline=False)
            else:
                embed.add_field(name="ID", value=ig[3], inline=False)
        return embed

    def build_ignore_list_embed(self, ctx, channels):
        """
        Builds the embed to list all ignored

        :param ctx: The discord context
        :param channels: List of ignored users/channels
        :return embed with list of mod channels:
        """
        embed = create_default_embed(ctx)
        embed.colour = KOALA_GREEN
        embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
        embed.title = "Koala Moderation - Ignored Users/Channels"
        embed = self.build_ignore_list(channels, embed)
        return embed


async def setup(bot: koalabot) -> None:
    """
    Loads this cog into the selected bot

    :param  bot: The client of the KoalaBot
    """
    await bot.add_cog(TextFilter(bot))

</document_content>
</document>
<document index="59">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/db.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports

# Libs
import discord
from sqlalchemy import select, delete

# Own modules
from koala.db import session_manager
from .models import TextFilter, TextFilterModeration, TextFilterIgnoreList


class TextFilterDBManager:
    """
    A class for interacting with the Koala text filter database
    """

    def __init__(self, bot_client: discord.client):
        """
        Initialises local variables

        :param bot_client:
        """
        self.bot = bot_client


    def new_mod_channel(self, guild_id, channel_id):
        """
        Adds new filtered word for a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param channel_id: The new channel for moderation
        :return:
        """
        with session_manager() as session:
            session.add(TextFilterModeration(channel_id=channel_id, guild_id=guild_id))
            session.commit()

    def new_filtered_text(self, guild_id, filtered_text, filter_type, is_regex):
        """
        Adds new filtered word for a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param filtered_text: The new word to be filtered
        :param filter_type: The filter type (banned or risky)
        :param is_regex: Boolean if filtered text is regex
        :return:
        """
        with session_manager() as session:
            ft_id = str(guild_id) + filtered_text
            if not self.does_word_exist(ft_id):
                session.add(TextFilter(filtered_text_id=ft_id,
                                       guild_id=guild_id,
                                       filtered_text=filtered_text,
                                       filter_type=filter_type,
                                       is_regex=is_regex))
                session.commit()
                return
            raise Exception("Filtered word already exists")

    def remove_filter_text(self, guild_id, filtered_text):
        """
        Remove filtered word from a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param filtered_text: The new word to be filtered
        :return:
        """
        with session_manager() as session:
            ft_id = str(guild_id) + filtered_text
            if self.does_word_exist(ft_id):
                session.execute(delete(TextFilter).filter_by(filtered_text_id=ft_id))
                session.commit()
                return
            raise Exception("Filtered word does not exist")

    def new_ignore(self, guild_id, ignore_type, ignore):
        """
        Add new ignore to database

        :param guild_id: Guild ID to associate ignore to
        :param ignore_type: The type of ignore to add
        :param ignore: Ignore ID to be added
        """
        with session_manager() as session:
            ignore_id = str(guild_id) + str(ignore)
            if not self.does_ignore_exist(ignore_id):
                session.add(TextFilterIgnoreList(ignore_id=ignore_id, guild_id=guild_id,
                                                 ignore_type=ignore_type, ignore=ignore))
                session.commit()
                return
            raise Exception("Ignore already exists")

    def remove_ignore(self, guild_id, ignore):
        """
        Remove ignore from database

        :param guild_id: The guild_id to delete the ignore from
        :param ignore: the ignore id to be deleted
        """
        with session_manager() as session:
            ignore_id = str(guild_id) + str(ignore)
            if self.does_ignore_exist(ignore_id):
                session.execute(delete(TextFilterIgnoreList).filter_by(ignore_id=ignore_id))
                session.commit()
                return
            raise Exception("Ignore does not exist")

    def get_filtered_text_for_guild(self, guild_id):
        """
        Retrieves all filtered words for a specific guild and formats into a nice list of words

        :param guild_id: Guild ID to retrieve filtered words from:
        :return: list of filtered words
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilter).filter_by(guild_id=guild_id)).scalars()
            return [(row.filtered_text, row.filter_type, str(int(row.is_regex))) for row in rows]

    def get_ignore_list_channels(self, guild_id):
        """
        Get lists of ignored channels

        :param guild_id: The guild id to get the list from
        :return: list of ignored channels
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="channel")).all()
            return [row[0] for row in rows]

    def get_ignore_list_users(self, guild_id):
        """
        Get lists of ignored users

        :param guild_id: The guild id to get the list from
        :return: list of ignored users
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="user")).all()
            return [row[0] for row in rows]

    def get_all_ignored(self, guild_id):
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore_id, TextFilterIgnoreList.guild_id,
                                          TextFilterIgnoreList.ignore_type, TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="channel")).all()
            rows += session.execute(select(TextFilterIgnoreList.ignore_id, TextFilterIgnoreList.guild_id,
                                          TextFilterIgnoreList.ignore_type, TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="user")).all()
            return rows

    def get_mod_channel(self, guild_id):
        """
        Gets specific mod channels given a guild id

        :param guild_id: Guild ID to retrieve mod channel from
        :return: list of mod channels
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterModeration.channel_id)
                                   .filter_by(guild_id=guild_id)).all()
            return rows

    def remove_mod_channel(self, guild_id, channel_id):
        """
        Removes a specific mod channel in a guild

        :param guild_id: Guild ID to remove mod channel from
        :param channel_id: Mod channel to be removed
        :return:
        """
        with session_manager() as session:
            session.execute(delete(TextFilterModeration)
                            .filter_by(guild_id=guild_id, channel_id=channel_id))
            session.commit()

    def does_word_exist(self, ft_id):
        """
        Checks if word exists in database given an ID

        :param ft_id: filtered text id of word to be removed
        :return boolean of whether the word exists or not:
        """
        with session_manager() as session:
            return len(session.execute(select(TextFilter)
                                       .filter_by(filtered_text_id=ft_id)).all()) > 0

    def does_ignore_exist(self, ignore_id):
        """
        Checks if ignore exists in database given an ID

        :param ignore_id: ignore id of ignore to be removed
        :return boolean of whether the ignore exists or not:
        """
        with session_manager() as session:
            return len(session.execute(select(TextFilterIgnoreList)
                                       .filter_by(ignore_id=ignore_id)).all()) > 0

</document_content>
</document>
<document index="60">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="61">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/models.py</source>
<document_content>
from sqlalchemy import Column, VARCHAR, BOOLEAN

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class TextFilter:
    __tablename__ = 'TextFilter'
    filtered_text_id = Column(VARCHAR(100, collation="utf8mb4_unicode_520_ci"), primary_key=True)
    guild_id = Column(DiscordSnowflake)
    filtered_text = Column(VARCHAR(100, collation="utf8mb4_unicode_520_ci"))
    filter_type = Column(VARCHAR(10))
    is_regex = Column(BOOLEAN)

    def __repr__(self):
        return "<TextFilter(%s, %s, %s, %s, %s)>" % \
               (self.filtered_text_id, self.guild_id, self.filtered_text, self.filter_type, self.is_regex)


@mapper_registry.mapped
class TextFilterModeration:
    __tablename__ = 'TextFilterModeration'
    channel_id = Column(DiscordSnowflake, primary_key=True)
    guild_id = Column(DiscordSnowflake)

    def __repr__(self):
        return "<TextFilterModeration(%s, %s)>" % \
               (self.channel_id, self.guild_id)


@mapper_registry.mapped
class TextFilterIgnoreList:
    __tablename__ = 'TextFilterIgnoreList'
    ignore_id = Column(VARCHAR(40), primary_key=True)
    guild_id = Column(DiscordSnowflake)
    ignore_type = Column(VARCHAR(10))
    ignore = Column(DiscordSnowflake)

    def __repr__(self):
        return "<TextFilterIgnoreList(%s, %s, %s, %s)>" % \
               (self.ignore_id, self.guild_id, self.ignore_type, self.ignore)

</document_content>
</document>
<document index="62">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports

# Libs
import discord

# Own modules
from koala.colours import KOALA_GREEN


def type_exists(filter_type):
    """
    Validates the inputted filter_type

    :param filter_type: The filter type to be checked
    :return: boolean checking if the filter type can be handled by the system, checks for risky, banned or email
    """
    return filter_type == "risky" or filter_type == "banned"


def build_moderation_channel_embed(ctx, channel, action):
    """
    Builds a moderation embed which display some information about the mod channel being created/removed

    :param ctx: The discord context
    :param channel: The channel to be created/removed
    :param action: either "Added" or "Removed" to tell the user what happened to the mod channel
    :return embed: The moderation embed to be sent to the user
    """
    embed = create_default_embed(ctx)
    embed.title = "Koala Moderation - Mod Channel " + action
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=channel.id)
    return embed


def build_word_list_embed(ctx, all_words, all_types, all_regex):
    """
    Builds the embed that is sent to list all the filtered words

    :param ctx: The discord context
    :param all_words: List of all the filtered words in the guild
    :param all_types: List of all the corresponding filter types for the words in the guild
    :param all_regex: List of all regex in the guild
    :return embed with information about the deleted message:
    """
    embed = create_default_embed(ctx)
    embed.title = "Koala Moderation - Filtered Words"
    if not all_words and not all_types and not all_regex:
        embed.add_field(name="No words found", value="For more help with using the Text Filter try k!help TextFilter")
    else:
        embed.add_field(name="Banned Words", value=all_words)
        embed.add_field(name="Filter Types", value=all_types)
        embed.add_field(name="Is Regex?", value=all_regex)
    return embed


def create_default_embed(ctx):
    """
    Creates a default embed that all embeds share

    :param ctx: The discord context
    :return embed with basic information which should be built upon:
    """
    embed = discord.Embed()
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
    return embed


def build_moderation_deleted_embed(message):
    """
    Builds the embed that is sent after a message is deleted for containing a banned word

    :param message: the message object to be deleted
    :return embed with information about the deleted message:
    """
    embed = create_default_embed(message)
    embed.title = "Koala Moderation - Message Deleted"
    embed.add_field(name="Reason", value="Contained banned word")
    embed.add_field(name="User", value=message.author.mention)
    embed.add_field(name="Channel", value=message.channel.mention)
    embed.add_field(name="Message", value=message.content)
    embed.add_field(name="Timestamp", value=message.created_at)
    return embed

</document_content>
</document>
<document index="63">
<source>/Users/malcolm/dev/KoalaBot/koalabot.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Code
Run this to start the Bot

Commented using reStructuredText (reST)
"""
__author__ = "KoalaBotUK"
__copyright__ = "Copyright (c) 2020 KoalaBotUK"
__credits__ = ["See full list of developers at: https://koalabot.uk/"]
__license__ = "MIT License"
__version__ = "1.0.0"
__maintainer__ = "Jack Draper"
__status__ = "Production"  # "Prototype", "Development", or "Production"

# Futures
# Built-in/Generic Imports
import asyncio
import time

import discord
# Libs
from aiohttp import web
import aiohttp_cors
from discord.ext import commands

from koala import env
# Own modules
from koala.db import extension_enabled
from koala.env import BOT_TOKEN, BOT_OWNER, API_PORT
from koala.errors import KoalaException
from koala.log import logger
from koala.utils import error_embed

# Constants
COMMAND_PREFIX = "k!"
OPT_COMMAND_PREFIX = "K!"
STREAMING_URL = "https://twitch.tv/thenuel"
COGS_PACKAGE = "koala.cogs"
TEST_USER = "TestUser#0001"  # Test user for dpytest
TEST_BOT_USER = "FakeApp#0001"  # Test bot user for dpytest
KOALA_GREEN = discord.Colour.from_rgb(0, 170, 110)
PERMISSION_ERROR_TEXT = "This guild does not have this extension enabled, go to http://koalabot.uk, " \
                        "or use `k!help enableExt` to enable it"
KOALA_IMAGE_URL = "https://cdn.discordapp.com/attachments/737280260541907015/752024535985029240/discord1.png"
ENABLED_COGS = ["base", "announce", "colour_role", "insights", "intro_cog", "react_for_role", "text_filter",
                "twitch_alert", "verification", "voting"]

# Variables
intent = discord.Intents.default()
intent.guilds = True        # on_guild_join, on_guild_remove
intent.members = True       # on_member_join
intent.reactions = True     # on_raw_reaction_add
intent.messages = True      # on_message
intent.message_content = True
is_dpytest = False


class KoalaBot(commands.Bot):
    """
    The commands.Bot subclass for Koala
    """
    async def setup_hook(self) -> None:
        """
        To perform asynchronous setup after the bot is logged in but before it has connected to the Websocket.
        """
        logger.debug("hook setup")
        await self.tree.sync()

    async def on_command_error(self, ctx, error: Exception):
        if ctx.guild is None:
            guild_id = "UNKNOWN"
            logger.warn("Unknown guild ID threw exception", exc_info=error)
        else:
            guild_id = ctx.guild.id

        if error.__class__ in [KoalaException,
                               commands.MissingRequiredArgument,
                               commands.CommandNotFound]:
            await ctx.send(embed=error_embed(description=error))
        if error.__class__ in [commands.CheckFailure]:
            await ctx.send(embed=error_embed(error_type=str(type(error).__name__),
                                             description=str(
                                                 error) + "\nPlease ensure you have administrator permissions, "
                                                          "and have enabled this extension."))
        elif isinstance(error, commands.CommandOnCooldown):
            await ctx.send(embed=error_embed(description=f"{ctx.author.mention}, this command is still on cooldown for "
                                                         f"{str(error.retry_after)}s."))
        elif isinstance(error, commands.errors.ChannelNotFound):
            await ctx.send(
                embed=error_embed(description=f"The channel ID provided is either invalid, or not in this server."))
        elif isinstance(error, commands.CommandInvokeError):
            logger.error("CommandInvokeError(%s), guild_id: %s, message: %s", error.original, guild_id, ctx.message,
                         exc_info=error)
            await ctx.send(embed=error_embed(description=error.original))
        else:
            logger.error(f"Unexpected Error in guild %s : %s", guild_id, error, exc_info=error)
            await ctx.send(embed=error_embed(
                description=f"An unexpected error occurred, please contact an administrator Timestamp: {time.time()}"))  # FIXME: better timestamp
            raise error


def is_owner(ctx: commands.Context):
    """
    A command used to check if the user of a command is the owner, or the testing bot.
    The command also allows Senior Devs of KoalaBot to use owner only commands (as given by Admin role in the dev portal)
    e.g. @commands.check(koalabot.is_owner)
    :param ctx: The context of the message
    :return: True if owner or test, False otherwise
    """
    if is_dm_channel(ctx):
        return False
    elif BOT_OWNER is not None:
        return ctx.author.id in BOT_OWNER or is_dpytest
    else:
        return ctx.bot.is_owner(ctx.author) or is_dpytest


def is_admin(ctx):
    """
    A command used to check if the user of a command is the admin, or the testing bot
    e.g. @commands.check(koalabot.is_admin)
    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    if is_dm_channel(ctx):
        return False
    else:
        return ctx.author.guild_permissions.administrator or is_dpytest


def is_dm_channel(ctx):
    return isinstance(ctx.channel, discord.channel.DMChannel)


def is_guild_channel(ctx):
    return ctx.guild is not None


async def load_all_cogs(bot):
    """
    Loads all cogs in ENABLED_COGS into the client
    """

    for cog in ENABLED_COGS:
        try:
            await bot.load_extension("."+cog, package=COGS_PACKAGE)
        except commands.errors.ExtensionAlreadyLoaded:
            await bot.reload_extension("."+cog, package=COGS_PACKAGE)

    logger.info("All cogs loaded")


async def dm_group_message(members: [discord.Member], message: str):
    """
    DMs members in a list of members
    :param members: list of members to DM
    :param message: The message to send to the group
    :return: how many were dm'ed successfully.
    """
    count = 0
    for member in members:
        try:
            await member.send(message)
            count = count + 1
        except Exception:  # In case of user dms being closed
            pass
    return count


def check_guild_has_ext(ctx, extension_id):
    """
    A check for if a guild has a given koala extension
    :param ctx: A discord context
    :param extension_id: The koala extension ID
    :return: True if has ext
    """
    if is_dm_channel(ctx):
        return False
    if (not extension_enabled(ctx.message.guild.id, extension_id)) and (not is_dpytest):
        raise PermissionError(PERMISSION_ERROR_TEXT)
    return True


async def run_bot():
    app = web.Application()

    bot = KoalaBot(command_prefix=[COMMAND_PREFIX, OPT_COMMAND_PREFIX], intents=intent)
    setattr(bot, "koala_web_app", app)
    await load_all_cogs(bot)

    cors = aiohttp_cors.setup(app, defaults={
        env.FRONTEND_URL: aiohttp_cors.ResourceOptions(
                expose_headers="*", allow_headers="*")
    })
    for route in list(app.router.routes()):
        cors.add(route)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', API_PORT)
    await site.start()

    try:
        async with bot:
            await bot.start(BOT_TOKEN)

    except Exception:
        bot.close(),
        raise

    finally:
        await runner.cleanup()

if __name__ == '__main__': # pragma: no cover
    # loop = asyncio.get_event_loop()
    asyncio.run(run_bot())

</document_content>
</document>
<document index="64">
<source>/Users/malcolm/dev/KoalaBot/koala/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Cog code and additional base cog functions

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import argparse
import datetime
import typing
from pathlib import PurePath
# Libs
from typing import Tuple, Optional

import discord
from discord.ext import commands
from discord.ext.commands import BadArgument

# Own modules
from koala.colours import ERROR_RED

# Constants
ID_LENGTH = 18
TIMEOUT_TIME = 60


# Variables

# Koala Constants


def error_embed(description, error_type=None):
    """
    Creates a discord embed for error messages
    :param description: The description of the error
    :param error_type: The error type (e.g. FileNotFoundError)
    :return: The completed embed
    """
    if isinstance(description, BaseException) and error_type is None:
        return discord.Embed(title=str(type(description).__name__), description=str(description), colour=ERROR_RED)
    elif error_type is None:
        return discord.Embed(title="Error", description=str(description), colour=ERROR_RED)
    else:
        return discord.Embed(title=error_type, description=str(description), colour=ERROR_RED)


def is_channel_in_guild(bot: discord.client, guild_id, channel_id):
    return bot.get_channel(int(channel_id)) in bot.get_guild(guild_id).channels


def is_int(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


def extract_id(raw_id):
    if type(raw_id) is str and raw_id[0] == "<":
        while not is_int(raw_id[0]):
            raw_id = raw_id[1:]
        return int(raw_id[:-1])
    elif is_int(raw_id):
        return int(raw_id)
    else:
        raise TypeError("ID given is not a valid ID")


async def wait_for_message(bot: discord.Client, ctx: commands.Context, timeout: float = TIMEOUT_TIME) \
        -> Tuple[Optional[discord.Message], Optional[discord.TextChannel]]:
    """
        Wraps bot.wait_for with message event, checking that message author is the original context author. Has default
        timeout of 60 seconds.
        :param bot: Koala Bot client
        :param ctx: Context of the original command
        :param timeout: Time to wait before raising TimeoutError
        :return: If a message (msg) was received, returns a tuple (msg, None). Else returns (None, ctx.channel)
        """
    try:
        msg = await bot.wait_for('message', timeout=timeout, check=lambda message: message.author == ctx.author)
    except (Exception, TypeError):
        return None, ctx.channel
    if not msg:
        return msg, ctx.channel
    return msg, None


def format_config_path(directory: str, *filename: str):
    """
    Format the path to be used by the database.

    This will be parsed directly into sqlite3 create connection.

    :param directory: The directory for the database file
    :param filename: The filename of the given database
    """
    if not directory:
        directory = ""

    return str(PurePath(directory, *filename))


def __parse_args(args):
    """
    Uses argparse to return a parser of all given arguments when running koalabot.py

    :param args: sys.argv[1:]
    :return: parsed argparse
    """
    parser = argparse.ArgumentParser(description='Start the KoalaBot Discord bot')
    parser.add_argument('--config', help="Config & database directory")
    args, unknown = parser.parse_known_args(args)
    return args


def convert_iso_datetime(argument):
    try:
        return datetime.datetime.fromisoformat(argument)
    except ValueError:
        raise BadArgument('Invalid ISO format "%s", instead use the format "2020-01-01 00:00:00"' % argument)



def cast(type_class, value):
    if isinstance(value, dict):
        return type_class(**value)
    elif typing.get_origin(type_class) == list:
        return [cast(type_class.__args__[0], v) for v in list(value)]
    if typing.get_origin(type_class) == dict:
        return {cast(type_class.__args__[0], k): cast(type_class.__args__[1], v) for k, v in dict(value)}
    if typing.get_origin(type_class) is not None:
        return typing.get_origin(type_class)(type_class)
    else:
        return type_class(value)


</document_content>
</document>
</documents>
