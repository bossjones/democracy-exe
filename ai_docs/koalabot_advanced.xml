<documents>
<document index="1">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/insights/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="3">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/insights/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot Insights Cog
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio

# Own modules
import koalabot
from koala.cogs.insights import cog

# Constants

# Variables


@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await cog.setup(bot)
    mock1.assert_called()


@pytest_asyncio.fixture
async def insights_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    insights_cog = cog.Insights(bot)
    await bot.add_cog(insights_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return insights_cog


@pytest.mark.asyncio
@pytest.mark.parametrize("members,guilds", [(0, 0), (10, 10), (100, 100), (1000, 1000)])
async def test_insights(bot, insights_cog, members, guilds):
    for x in range(members):
        await dpytest.member_join(0, name=f"TestUser{x}", discrim={x})

    for x in range(guilds):
        guild = dpytest.backend.make_guild(name=f"FakeGuild{x}")
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    total_guilds = 1 + guilds
    total_members = 2 + guilds + members

    await dpytest.message(koalabot.COMMAND_PREFIX + "insights")

    expected_message = f"Insights:\nThis bot is in a total of {total_guilds} servers." +\
                       f"\nThere are a total of {total_members} members across these servers."

    assert dpytest.verify().message().content(expected_message)


@pytest.mark.asyncio
@pytest.mark.parametrize("total_servers", [0, 50, 500, 1000])
async def test_list_servers(bot, insights_cog, total_servers):
    for x in range(total_servers):
        guild = dpytest.backend.make_guild(name=f"{x}")
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    await dpytest.message(koalabot.COMMAND_PREFIX + "servers")

    if total_servers > 0:
        expected_partial_message = "Test Guild 0"
        for x in range(total_servers):
            int_length = len(str(x))
            if len(expected_partial_message) + int_length + 2 > 2000:
                assert dpytest.verify().message().content(expected_partial_message)
                expected_partial_message = str(x)
            else:
                expected_partial_message += f", {x}"
        assert dpytest.verify().message().content(expected_partial_message)
    else:
        assert dpytest.verify().message().content("Test Guild 0")


@pytest.mark.asyncio
@pytest.mark.parametrize("filter_term, expected", [("", "Test Guild 0, this, is, a, list, of, servers"),
                                                   ("s", "Test Guild 0, this, is, list, servers"),
                                                   ("is", "this, is, list"),
                                                   ("hello", """No servers found containing the string "hello".""")])
async def test_list_servers_with_filter(bot, insights_cog, filter_term, expected):
    server_list_names = ["this", "is", "a", "list", "of", "servers"]
    for x in server_list_names:
        guild = dpytest.backend.make_guild(name=x)
        dpytest.get_config().guilds.append(guild)
        await dpytest.member_join(guild, dpytest.get_config().client.user)

    await dpytest.message(koalabot.COMMAND_PREFIX + "servers " + filter_term)

    assert dpytest.verify().message().content(expected)

</document_content>
</document>
<document index="4">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/announce/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="5">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/announce/test_cog.py</source>
<document_content>
import time

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs import announce
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: discord.ext.commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def announce_cog(bot: discord.ext.commands.Bot):
    announce_cog = announce.Announce(bot)
    await bot.add_cog(announce_cog)
    dpytest.configure(bot, 2, 1, 2)
    logger.info("Tests starting")
    return announce_cog


def make_message(guild: discord.Guild, announce_cog):
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               guild.icon)
    announce_cog.roles[guild.id] = []


def test_has_active_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    assert (guild.id in announce_cog.messages.keys()) == announce_cog.has_active_msg(guild.id)
    make_message(guild, announce_cog)
    assert (guild.id in announce_cog.messages.keys()) == announce_cog.has_active_msg(guild.id)


def test_has_no_active_message_initial(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    assert not announce_cog.has_active_msg(guild.id)


# testing creating messages
@pytest.mark.asyncio
async def test_create_legal_message(bot: discord.Client, announce_cog):
    guild: discord.Guild = bot.guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""


# tests dm guild with members who cannot receive dms
@pytest.mark.asyncio
async def test_create_message_to_no_dm_user(bot: discord.Client, announce_cog):
    guild: discord.Guild = bot.guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)

    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""
        # sending the message
        with mock.patch('discord.Member.send',
                        mock.Mock(side_effect=Exception('AttributeError'))):
            with pytest.raises(discord.ext.commands.errors.CommandInvokeError) as e_info:
                await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send', channel=channel)


@pytest.mark.asyncio
async def test_create_illegal_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    long_content = ""
    for i in range(2001):
        long_content = long_content + "a"
    long_msg_mock: discord.Message = dpytest.back.make_message(long_content, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=long_msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(
            "The content is more than 2000 characters long, and exceeds the limit")
        assert not announce_cog.has_active_msg(guild.id)


@pytest.mark.asyncio
async def test_create_multiple_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""

        msg2_mock: discord.Message = dpytest.back.make_message('testMessage2', author, channel)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg2_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                                  channel=channel)
            assert dpytest.verify().message().content(
                "There is currently an active announcement being created, you can use 'k!announce cancel' "
                "or 'k!announce send' to complete it")
            assert announce_cog.has_active_msg(guild.id)
            assert announce_cog.messages[guild.id].description == "testMessage"
            assert announce_cog.messages[guild.id].title == ""


@pytest.mark.asyncio
async def test_create_message_after_send_before_30_days(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == ""
        # sending the message
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        # try creating another announcement immediately
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                                  channel=channel)
            assert dpytest.verify().message().content(
                "You have recently sent an announcement and cannot use this function for 30 days")
            assert not announce_cog.has_active_msg(guild.id)


@pytest.mark.asyncio
async def test_create_message_timeout():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content("Okay, I'll cancel the command.")


@pytest.mark.parametrize("command_word, prompt_message",
                         [("changeTitle", "Please enter the new title, I'll wait for 60 seconds, no rush."),
                          ("changeContent", "Please enter the new message, I'll wait for 60 seconds, no rush."),
                          ("addRole",
                           "Please enter the roles you want to tag separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("add",
                           "Please enter the roles you want to tag separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("remove",
                           "Please enter the roles you want to remove separated by space, "
                           "I'll wait for 60 seconds, no rush."),
                          ("removeRole",
                           "Please enter the roles you want to remove separated by space, "
                           "I'll wait for 60 seconds, no rush.")])
@pytest.mark.asyncio
async def test_other_timeout(command_word, prompt_message, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce ' + command_word,
                              channel=channel)
        assert dpytest.verify().message().content(prompt_message)
        assert dpytest.verify().message().content("Okay, I'll cancel the command.")


# testing functions with no active message
@pytest.mark.parametrize("command_word",
                         ["changeTitle", "changeContent", "addRole", "add", "remove", "removeRole", "preview", "send",
                          "cancel"])
@pytest.mark.asyncio
async def test_functions_no_active(command_word):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce ' + command_word,
                          channel=channel)
    assert dpytest.verify().message().content("There is currently no active announcement")


# testing functions with active message
@pytest.mark.asyncio
async def test_change_title(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name
    msg_mock: discord.Message = dpytest.back.make_message('testTitle', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeTitle',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new title, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"
        assert announce_cog.messages[guild.id].title == "testTitle"


@pytest.mark.asyncio
async def test_change_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name
    msg_mock: discord.Message = dpytest.back.make_message('testMessage2', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeContent',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage2"
        assert announce_cog.messages[guild.id].title == "This announcement is from " + guild.name


@pytest.mark.asyncio
async def test_change_long_message(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.has_active_msg(guild.id)
    assert announce_cog.messages[guild.id].description == "testMessage"
    msg = ""
    for i in range(2001):
        msg = msg + 'a'
    msg_mock: discord.Message = dpytest.back.make_message(msg, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce changeContent',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter the new message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(
            "The content is more than 2000 characters long, and exceeds the limit")
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.messages[guild.id].description == "testMessage"


@pytest.mark.parametrize("number_of_roles", [0, 1])
@pytest.mark.asyncio
async def test_add_possible_role(number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list


@pytest.mark.asyncio
@pytest.mark.parametrize("number_of_roles", [0, 1])
async def test_send_announce_roles(bot: discord.Client, number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")


@pytest.mark.asyncio
@pytest.mark.parametrize("number_of_roles", [0, 1])
async def test_send_announce_roles_with_no_dm_user(bot: discord.Client, number_of_roles, announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    role_list = ""
    role_id_list = []
    for i in range(number_of_roles):
        role_list = role_list + str(roles[i].id) + " "
        role_id_list.append(roles[i].id)
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == role_id_list
        # sending the message
        with mock.patch('discord.Member.send',
                        mock.Mock(side_effect=Exception('AttributeError'))):
            with pytest.raises(discord.ext.commands.errors.CommandInvokeError) as e_info:
                await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send', channel=channel)


@pytest.mark.asyncio
async def test_add_non_existent_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message("12345", author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_add_same_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    role_list = str(roles[0].id) + " " + str(roles[0].id)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message(role_list, author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce add',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == [roles[0].id]


@pytest.mark.asyncio
async def test_remove_role_from_none(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[0].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []
    msg_mock: discord.Message = dpytest.back.make_message("12345", author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_remove_existing_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    roles = guild.roles
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [roles[0].id]
    assert announce_cog.roles[guild.id] == [roles[0].id]
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[0].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == []


@pytest.mark.asyncio
async def test_remove_non_existent_role(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    await guild.create_role(name="testrole")
    assert len(guild.roles) == 2
    roles = guild.roles
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [roles[0].id]
    assert announce_cog.roles[guild.id] == [roles[0].id]
    msg_mock: discord.Message = dpytest.back.make_message(str(roles[1].id), author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce remove',
                              channel=channel)
        assert dpytest.verify().message().content(
            "Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.roles[guild.id] == [roles[0].id]


def test_embed_consistent(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               guild.icon)
    embed: discord.Embed = announce_cog.construct_embed(guild)
    assert embed.title == f"This announcement is from {guild.name}"
    assert embed.description == "testMessage"
    assert not embed.thumbnail.url


def test_embed_consistent_with_url(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    announce_cog.messages[guild.id] = announce.AnnounceMessage(f"This announcement is from {guild.name}",
                                                               "testMessage",
                                                               "test_url")
    embed: discord.Embed = announce_cog.construct_embed(guild)
    assert embed.title == f"This announcement is from {guild.name}"
    assert embed.description == "testMessage"
    assert embed.thumbnail.url == "test_url"


@pytest.mark.asyncio
async def test_preview_consistent(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    embed: discord.Embed = announce_cog.construct_embed(guild)
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce preview',
                          channel=channel)
    assert dpytest.verify().message().embed(embed=embed)
    assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_cancel(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    make_message(guild, announce_cog)
    announce_cog.roles[guild.id] = [123, 234]
    assert guild.id in announce_cog.messages.keys()
    assert guild.id in announce_cog.roles.keys()
    await dpytest.message(koalabot.COMMAND_PREFIX + 'announce cancel',
                          channel=channel)
    assert dpytest.verify().message().content("The announcement was cancelled successfully")
    assert guild.id not in announce_cog.messages.keys()
    assert guild.id not in announce_cog.roles.keys()


def test_receiver_msg(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    make_message(guild, announce_cog)
    assert announce_cog.receiver_msg(
        guild) == f"You are currently sending to Everyone and there are {str(len(guild.members))} receivers"
    announce_cog.roles[guild.id] = [guild.roles[0].id]
    assert announce_cog.receiver_msg(
        guild) == f"You are currently sending to {announce_cog.get_role_names(guild.id, guild.roles)} and there are {str(len(announce_cog.get_receivers(guild.id, guild.roles)))} receivers "


@mock.patch("time.time", mock.MagicMock(return_value=1621679835.9347742))
@pytest.mark.asyncio
async def test_announce_db_first_creation(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        assert int(time.time()) == announce_cog.announce_database_manager.get_last_use_date(guild.id)


@mock.patch("time.time", mock.MagicMock(return_value=1621679123.9347742))
@pytest.mark.asyncio
async def test_announce_db_update_time_from_legal_use(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    announce_cog.announce_database_manager.set_last_use_date(guild.id, int(
        time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1)
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == int(
        time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content("Please enter a message, I'll wait for 60 seconds, no rush.")
        assert dpytest.verify().message().content(f"An announcement has been created for guild {guild.name}")
        assert dpytest.verify().message()
        assert dpytest.verify().message()
        assert announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == int(
            time.time()) - announce.utils.ANNOUNCE_SEPARATION_DAYS * 24 * 60 * 60 - 1
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        for _ in guild.members:
            assert dpytest.verify().message()
        assert dpytest.verify().message().content("The announcement was made successfully")
        assert int(time.time()) == announce_cog.announce_database_manager.get_last_use_date(guild.id)


@mock.patch("time.time", mock.MagicMock(return_value=1621679124.9347742))
@pytest.mark.asyncio
async def test_announce_db_no_update_time_from_illegal_use(announce_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    author: discord.Member = guild.members[0]
    channel: discord.TextChannel = guild.channels[0]
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) is None
    current_time = int(time.time())
    announce_cog.announce_database_manager.set_last_use_date(guild.id, current_time)
    assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time
    msg_mock: discord.Message = dpytest.back.make_message('testMessage', author, channel)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce create',
                              channel=channel)
        assert dpytest.verify().message().content(
            "You have recently sent an announcement and cannot use this function for 30 days")
        assert not announce_cog.has_active_msg(guild.id)
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time
        await dpytest.message(koalabot.COMMAND_PREFIX + 'announce send',
                              channel=channel)
        assert dpytest.verify().message().content("There is currently no active announcement")
        assert announce_cog.announce_database_manager.get_last_use_date(guild.id) == current_time

</document_content>
</document>
<document index="6">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="7">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/conftest.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import pytest
from sqlalchemy import delete

# Own modules
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions, VoteTargetRoles
from koala.db import session_manager


@pytest.fixture(autouse=True)
def clear_tables():
    with session_manager() as session:
        session.execute(delete(Votes))
        session.execute(delete(VoteTargetRoles))
        session.execute(delete(VoteOptions))
        session.execute(delete(VoteSent))
        session.commit()

</document_content>
</document>
<document index="8">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select

# Own modules
import koalabot
from koala.cogs import Voting
from koala.cogs.voting.models import Votes
from koala.db import session_manager, insert_extension
from tests.log import logger


@pytest_asyncio.fixture(autouse=True)
async def cog(bot: commands.Bot):
    cog = Voting(bot)
    insert_extension("Vote", 0, True, True)
    await bot.add_cog(cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return cog


@pytest.mark.asyncio
async def test_discord_create_vote():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
        assert dpytest.verify().message().content(
            f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote`"
            f" to see how to configure it.")
        in_db = session.execute(select(Votes.author_id, Votes.guild_id)).first()
        assert in_db
        assert in_db[0] == guild.members[0].id
        assert in_db[1] == guild.id


@pytest.mark.asyncio
async def test_discord_create_vote_wrong():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        session.add(Votes(vote_id=111, author_id=guild.members[0].id, guild_id=guild.id, title="Test Vote"))
        session.commit()
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
        assert dpytest.verify().message().content("You already have a vote with title Test Vote sent!")
        await dpytest.message(
            f"{koalabot.COMMAND_PREFIX}vote create aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
            f"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
            f"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        assert dpytest.verify().message().content("Title too long")
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote 2")
        assert dpytest.verify().message().content(
            f"Vote titled `Test Vote 2` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` "
            f"to see how to configure it.")
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote 3")
        assert dpytest.verify().message().content(
            f"You already have an active vote in {guild.name}. Please send that with `{koalabot.COMMAND_PREFIX}vote "
            f"send` before creating a new one.")


@pytest.mark.asyncio
async def test_discord_vote_add_and_remove_role(cog):
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addRole {guild.roles[0].id}")
    assert dpytest.verify().message().content(f"Vote will be sent to those with the {guild.roles[0].name} role")
    vote = cog.vote_manager.get_configuring_vote(guild.members[0].id)
    assert guild.roles[0].id in vote.target_roles
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote removeRole {guild.roles[0].id}")
    assert dpytest.verify().message().content(
        f"Vote will no longer be sent to those with the {guild.roles[0].name} role")
    assert guild.roles[0].id not in vote.target_roles


@pytest.mark.asyncio
async def test_discord_set_chair():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote setChair {guild.members[0].id}")
    assert dpytest.verify().message().content(f"You have been selected as the chair for vote titled Test Vote")
    assert dpytest.verify().message().content(f"Set chair to {guild.members[0].name}")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote setChair")
    assert dpytest.verify().message().content("Results will be sent to the channel vote is closed in")


@pytest.mark.asyncio
async def test_discord_add_remove_option():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addOption test+test")
    assert dpytest.verify().message().content("Option test with description test added to vote")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote addOption testtest")
    assert dpytest.verify().message().content("Example usage: k!vote addOption option title+option description")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote removeOption 1")
    assert dpytest.verify().message().content("Option number 1 removed")


@pytest.mark.asyncio
async def test_discord_cancel_vote():
    config = dpytest.get_config()
    guild = config.guilds[0]
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote create Test Vote")
    assert dpytest.verify().message().content(
        f"Vote titled `Test Vote` created for guild {guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how "
        f"to configure it.")
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}vote cancel Test Vote")
    assert dpytest.verify().message().content("Vote Test Vote has been cancelled.")

</document_content>
</document>
<document index="9">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_db.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
from sqlalchemy import select

# Own modules
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions
from koala.cogs.voting.option import Option
from koala.db import session_manager
from .utils import populate_vote_tables, vote_manager


def test_votemanager_generate_opt_id():
    with session_manager() as session:
        session.add(VoteOptions(vote_id=123, opt_id=100000000000000001, option_title="test", option_desc="option"))
        session.commit()
        opt_id = vote_manager.generate_unique_opt_id()
        assert opt_id != 100000000000000001


def test_votemanager_load_from_db():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.vote_lookup[(222, "Test Vote 1")] == 111
        vote = vote_manager.sent_votes[111]
        assert vote.target_roles == [999]
        assert vote.options[1].id == 888
        assert vote.options[1].head == "vote1opt"
        assert vote.options[1].body == "vote1body"
        assert vote.sent_to[777] == 666


def test_votemanager_get_vote_from_id():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote = vote_manager.get_vote_from_id(111)
        assert vote.id == 111
        assert vote.options[1].id == 888
        assert vote.title == "Test Vote 1"


def test_votemanager_get_configuring_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote = vote_manager.get_configuring_vote(223)
        assert vote.title == "Test Vote 2"


def test_votemanager_has_active_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.has_active_vote(223)


def test_votemanager_create_vote():
    with session_manager() as session:
        vote = vote_manager.create_vote(123, 456, "Create Vote Test", session=session)
        assert vote.title == "Create Vote Test"
        in_db = session.execute(select(Votes).filter_by(author_id=123, title="Create Vote Test")).all()
        assert in_db


def test_votemanager_cancel_sent_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote_manager.cancel_sent_vote(111, session=session)
        assert 111 not in vote_manager.sent_votes.keys()
        in_db = session.execute(select(Votes).filter_by(vote_id=111)).all()
        assert not in_db


def test_votemanager_cancel_configuring_vote():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        vote_manager.cancel_configuring_vote(223, session=session)
        assert 223 not in vote_manager.configuring_votes.keys()
        in_db = session.execute(select(Votes).filter_by(vote_id=112)).all()
        assert not in_db


def test_votemanager_sent_to():
    with session_manager() as session:
        populate_vote_tables(session)
        vote_manager.load_from_db()
        assert vote_manager.was_sent_to(666)


def test_vote_set_chair():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Set Chair Vote Test", session=session)
        vote.set_chair(555)
        assert vote.chair == 555
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert in_db.chair_id == 555
        vote.set_chair(session=session)
        assert not vote.chair
        session.expire(in_db)
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert not in_db.chair_id == 555


def test_vote_set_vc():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Set Chair Vote Test", session=session)
        vote.set_vc(555, session=session)
        assert vote.target_voice_channel == 555
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert in_db.voice_id == 555
        vote.set_vc(session=session)
        assert not vote.target_voice_channel
        session.expire(in_db)
        in_db = session.execute(select(Votes).filter_by(vote_id=vote.id)).scalar()
        assert not in_db.voice_id == 555


def test_vote_add_option():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Add Option Test", session=session)
        vote.add_option(Option("head", "body", 123), session=session)
        assert vote.options[0].head == "head"
        assert vote.options[0].body == "body"
        in_db = session.execute(select(VoteOptions).filter_by(opt_id=123)).all()
        assert in_db


def test_vote_remove_option():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Remove Option Test", session=session)
        vote.add_option(Option("head", "body", 123), session=session)
        vote.remove_option(0, session=session)
        in_db = session.execute(select(VoteOptions).filter_by(opt_id=123)).all()
        assert not in_db


def test_vote_register_sent():
    with session_manager() as session:
        vote = vote_manager.create_vote(111, 222, "Register Sent Test", session=session)
        vote.register_sent(555, 666, session=session)
        assert vote.sent_to[555] == 666
        in_db = session.execute(select(VoteSent).filter_by(vote_receiver_message=666)).all()
        assert in_db

</document_content>
</document>
<document index="10">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_option.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs

# Own modules
from koala.cogs.voting.option import Option


def test_option():
    opt = Option("test", "option", 123456789)
    assert opt.id == 123456789
    assert opt.head == "test"
    assert opt.body == "option"

</document_content>
</document>
<document index="11">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_two_way.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
# Libs

# Own modules
from koala.cogs.voting.two_way import TwoWay


def test_two_way():
    def test_asserts(f, *args, **kwargs):
        try:
            f(*args, **kwargs)
        except AssertionError:
            return
        raise AssertionError

    # test internal asserts don't false positive
    t = TwoWay({1: 2, 3: 4})
    t2 = TwoWay({1: 2, 2: 1, 4: 3})
    assert t == t2

    # test an invalid dict cannot be made
    test_asserts(TwoWay, {1: 2, 2: 3})

    def ta2():
        t = TwoWay()
        t[1] = 2
        t[2] = 3
        test_asserts(ta2)

</document_content>
</document>
<document index="12">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/test_vote.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
from sqlalchemy import select

# Own modules
from koala.cogs.voting.models import VoteTargetRoles
from koala.cogs.voting.option import Option
from koala.cogs.voting.vote import Vote
from koala.db import session_manager


def test_vote_is_ready():
    vote = Vote(111, "Test Vote", 222, 333)
    vote.add_option(Option("head", "body", 111))
    assert not vote.is_ready()
    vote.add_option(Option("head", "body", 122))
    assert vote.is_ready()


def test_vote_add_role():
    with session_manager() as session:
        vote = Vote(111, "Test Vote", 222, 333)
        vote.add_role(777, session=session)
        assert 777 in vote.target_roles
        in_db = session.execute(select(VoteTargetRoles).filter_by(vote_id=111, role_id=777))
        assert in_db


def test_vote_remove_role():
    with session_manager() as session:
        vote = Vote(111, "Test Vote", 222, 333)
        vote.add_role(777, session=session)
        vote.remove_role(777, session=session)
        assert 777 not in vote.target_roles
        in_db = session.execute(select(VoteTargetRoles).filter_by(vote_id=111, role_id=777)).all()
        assert not in_db

</document_content>
</document>
<document index="13">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/voting/utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot VoteCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs

# Own modules
from koala.cogs.voting.db import VoteManager
from koala.cogs.voting.models import Votes, VoteSent, VoteOptions, VoteTargetRoles


class Fake:
    def __getattr__(self, item):
        setattr(self, item, Fake())
        return getattr(self, item)


ctx = Fake()
ctx.author.id = 1234
ctx.guild.id = 4567
cog = None
vote_manager = VoteManager()


def populate_vote_tables(session):
    session.add(Votes(vote_id=111, author_id=222, guild_id=333, title="Test Vote 1"))
    session.add(VoteTargetRoles(vote_id=111, role_id=999))
    session.add(VoteOptions(vote_id=111, opt_id=888, option_title="vote1opt", option_desc="vote1body"))
    session.add(VoteOptions(vote_id=111, opt_id=887, option_title="vote1opt2", option_desc="vote1body"))
    session.add(VoteSent(vote_id=111, vote_receiver_id=777, vote_receiver_message=666))
    session.add(Votes(vote_id=112, author_id=223, guild_id=334, title="Test Vote 2", chair_id=555, voice_id=666))
    session.add(VoteOptions(vote_id=112, opt_id=888, option_title="vote1opt", option_desc="vote1body"))
    session.commit()

</document_content>
</document>
<document index="14">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="15">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/conftest.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import delete

# Own modules
from koala.cogs import ReactForRole
from koala.cogs.react_for_role.models import GuildRFRRequiredRoles, GuildRFRMessages, RFRMessageEmojiRoles
from koala.db import session_manager
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Constants

# Variables


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def rfr_cog(bot: commands.Bot):
    rfr_cog = ReactForRole(bot)
    await bot.add_cog(rfr_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return rfr_cog


@pytest_asyncio.fixture(scope='function', autouse=True)
async def setup_clean_db():
    with session_manager() as session:
        session.execute(delete(GuildRFRRequiredRoles))
        session.execute(delete(RFRMessageEmojiRoles))
        session.execute(delete(GuildRFRMessages))
        session.commit()

</document_content>
</document>
<document index="16">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_api.py</source>
<document_content>
from http.client import OK

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web

from koala.cogs.react_for_role.api import RfrEndpoint, MESSAGE, REQUIRED_ROLES


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = RfrEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


async def test_message_post_partial(api_client):
    resp = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert "message_id" in resp_json.keys()


async def test_message_post_full(api_client):
    resp = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff",
        "thumbnail": "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png",
        "inline": "true",
        "roles": [{
            "role_id": dpytest.get_config().guilds[0].roles[0].id,
            "emoji": "<:discordmod:1030226250884722809>"
        }]
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert "message_id" in resp_json.keys()


async def test_message_get(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    message_id = (await resp1.json())["message_id"]

    resp = await api_client.get('/{}?message_id={}&guild_id={}&channel_id={}'
                                .format(MESSAGE,
                                        message_id,
                                        dpytest.get_config().guilds[0].id,
                                        dpytest.get_config().guilds[0].channels[0].id))

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#0000ff"


async def test_message_put(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()
    post_response["colour"] = "#ffffff"
    post_response["title"] = "test2"
    post_response["description"] = "desc2"
    assert post_response["thumbnail"] == "https://cdn.discordapp.com/attachments/737280260541907015/752024535985029240/discord1.png"
    post_response["thumbnail"] = "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert post_response["inline"] is False
    post_response["inline"] = True
    assert post_response["roles"] == []
    post_response["roles"] = [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]
    resp = await api_client.put('/{}'.format(MESSAGE), json=post_response)

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#ffffff"
    assert resp_json.get("title") == "test2"
    assert resp_json.get("description") == "desc2"
    assert resp_json["thumbnail"] == "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert resp_json["inline"] is True
    assert resp_json["roles"] == [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]


async def test_message_patch_partial(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    patch_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "description": "desc2"
                 }
    resp = await api_client.patch('/{}'.format(MESSAGE), json=patch_body)

    assert resp.status == OK
    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message.embeds[0].description == "desc2"
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#0000ff"
    assert resp_json.get("description") == "desc2"


async def test_message_patch_full(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    patch_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "test2",
        "description": "desc2",
        "colour": "#000fff",
        "thumbnail": "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png",
        "inline": "true",
        "roles": [{
            "role_id": dpytest.get_config().guilds[0].roles[0].id,
            "emoji": "<:discordmod:1030226250884722809>"
        }]
    }
    resp = await api_client.patch('/{}'.format(MESSAGE), json=patch_body)

    assert resp.status == OK
    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message.embeds[0].description == "desc2"
    resp_json: dict = await resp.json()
    assert resp_json.get("colour") == "#000fff"
    assert resp_json.get("title") == "test2"
    assert resp_json.get("description") == "desc2"
    assert resp_json["thumbnail"] == "https://koalabot.uk/static/media/KoalaBotLogo-min.78f6a0d317dfdfa7391d.png"
    assert resp_json["inline"] is True
    assert resp_json["roles"] == [{
        "role_id": dpytest.get_config().guilds[0].roles[0].id,
        "emoji": "<:discordmod:1030226250884722809>"
    }]


async def test_message_delete(api_client):
    resp1 = await api_client.post('/{}'.format(MESSAGE), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id,
        "title": "API test",
        "description": "desc",
        "colour": "#0000ff"
    })
    post_response = await resp1.json()

    message = await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    assert message is not None
    assert message.embeds[0].description == "desc"

    delete_body = {
        "message_id": post_response["message_id"],
        "guild_id": dpytest.get_config().guilds[0].id,
        "channel_id": dpytest.get_config().guilds[0].channels[0].id
    }
    resp = await api_client.delete('/{}'.format(MESSAGE), json=delete_body)

    assert resp.status == OK
    with pytest.raises(discord.NotFound):
        await dpytest.get_config().guilds[0].channels[0].fetch_message(post_response["message_id"])
    resp_json: dict = await resp.json()
    assert resp_json.get("status") == "DELETED"
    assert resp_json.get("message_id") == post_response["message_id"]


# /REQUIRED_ROLES

async def test_required_roles_put(api_client):
    resp = await api_client.put('/{}'.format(REQUIRED_ROLES), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "role_ids": [dpytest.get_config().guilds[0].roles[0].id]
    })
    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("role_ids") == [dpytest.get_config().guilds[0].roles[0].id]
    assert resp_json.get("guild_id") == dpytest.get_config().guilds[0].id


async def test_required_roles_get(api_client):
    await api_client.put('/{}'.format(REQUIRED_ROLES), json={
        "guild_id": dpytest.get_config().guilds[0].id,
        "role_ids": [dpytest.get_config().guilds[0].roles[0].id]
    })

    resp = await api_client.get('/{}?guild_id={}'.format(REQUIRED_ROLES, dpytest.get_config().guilds[0].id))

    assert resp.status == OK
    resp_json: dict = await resp.json()
    assert resp_json.get("role_ids") == [dpytest.get_config().guilds[0].roles[0].id]
    assert resp_json.get("guild_id") == dpytest.get_config().guilds[0].id

</document_content>
</document>
<document index="17">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports
import random

# Libs
import aiohttp
import discord
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands
from discord.ext.test import factories as dpyfactory
from discord.http import MultipartParameters

import koalabot
from koala.cogs import ReactForRole
# Own modules
from koala.cogs.react_for_role import core
from koala.cogs.react_for_role.db import *
from koala.colours import KOALA_GREEN
from tests.log import logger
from tests.tests_utils import utils as testutils
from .utils import independent_get_guild_rfr_message, independent_get_guild_rfr_required_role


# Constants

# Variables

@pytest.mark.asyncio
async def test_get_rfr_message_from_prompts(bot, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = bot.guilds[0]
    channel: discord.TextChannel = guild.channels[0]
    member: discord.Member = bot.guilds[0].members[0]
    msg: discord.Message = dpytest.back.make_message(".", member, channel)
    channel_id = msg.channel.id
    msg_id = msg.id

    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(546542131)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=None)):
            with pytest.raises(commands.CommandError) as exc:
                await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert str(exc.value) == "Invalid Message ID given."
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(msg_id)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=msg)):
            with pytest.raises(commands.CommandError) as exc:
                await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert str(
                exc.value) == "Message ID given is not that of a react for role message."
    add_rfr_message(msg.guild.id, channel_id, msg_id)
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    side_effect=[str(channel_id), str(msg_id)]) as mock_input:
        with mock.patch('discord.abc.Messageable.fetch_message', mock.AsyncMock(return_value=msg)):
            rfr_msg, rfr_msg_channel = await rfr_cog.get_rfr_message_from_prompts(ctx)
            assert rfr_msg.id == msg.id
            assert rfr_msg_channel.id == channel_id


@pytest.mark.parametrize("num_rows", [0, 1, 2, 20, 100, 250])
@pytest.mark.asyncio
async def test_parse_emoji_and_role_input_str(num_rows, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    for i in range(5):
        input_str = ""
        expected_emoji_list = []
        expected_role_list = []
        for j in range(num_rows):
            fake_emoji = random.choice(
                [testutils.fake_guild_emoji(guild), testutils.fake_unicode_emoji()])
            expected_emoji_list.append(str(fake_emoji))
            if isinstance(fake_emoji, discord.Emoji):
                fake_emoji_str = random.choice(
                    [fake_emoji.id, fake_emoji.name])
            else:
                fake_emoji_str = fake_emoji
            fake_role = testutils.fake_guild_role(guild)
            expected_role_list.append(fake_role)
            fake_role_str = random.choice([fake_role.id, fake_role.name,
                                           fake_role.mention])
            input_str += f"{fake_emoji_str}, {fake_role_str}\n\r"
        emoji_roles_list = await rfr_cog.parse_emoji_and_role_input_str(ctx, input_str, 20)
        for emoji_role in emoji_roles_list:
            assert str(emoji_role[0]) == str(
                expected_emoji_list[emoji_roles_list.index(emoji_role)])
            assert emoji_role[1] == expected_role_list[emoji_roles_list.index(
                emoji_role)]


@pytest.mark.skip("dpytest has non-implemented functionality for construction of guild custom emojis")
@pytest.mark.parametrize("num_rows", [0, 1, 2, 20])
@pytest.mark.asyncio
async def test_parse_emoji_or_roles_input_str(num_rows, utils_cog, rfr_cog):
    import emoji
    image = discord.File("utils/discord.png", filename="discord.png")
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    input_str = ""
    expected_list = []
    for j in range(num_rows):
        if random.choice([True, False]):
            if random.choice([True, False]):
                fake_emoji = testutils.fake_emoji_unicode()
                input_str += fake_emoji + "\n\r"
                expected_list.append(fake_emoji)
                logger.debug(f"Unicode emoji {j} in test {num_rows}: {emoji.emojize(fake_emoji)}")
            else:
                fake_emoji_name = testutils.fake_custom_emoji_name_str()
                fake_emoji = await guild.create_custom_emoji(name=fake_emoji_name, image=testutils.random_image())
                expected_list.append(fake_emoji)
                input_str += str(fake_emoji) + "\n\r"
                logger.debug(f"Custom emoji {j} in test {num_rows}: {str(fake_emoji)}")
        else:
            role_name = testutils.fake_custom_emoji_name_str()
            await guild.create_role(name=role_name, mentionable=True, hoist=True)
            fake_role: discord.Role = discord.utils.get(guild.roles, name=role_name)
            expected_list.append(fake_role)
            role_str = str(random.choice([fake_role.name, fake_role.id, fake_role.mention]))
            input_str += role_str + "\n\r"
            logger.debug(f"Role {j} in test {num_rows}: {fake_role}")

    logger.debug(f"Test {num_rows} input_str")
    logger.debug(input_str)
    result_list = await rfr_cog.parse_emoji_or_roles_input_str(ctx, input_str)
    for k in range(len(expected_list)):
        assert str(expected_list[k]) == str(result_list[k])


@pytest.mark.parametrize("msg_content", [None, "", "something", " "])
@pytest.mark.asyncio
async def test_prompt_for_input_str(msg_content, utils_cog, rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await dpytest.empty_queue()
    if not msg_content:
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=None)):
            result = await rfr_cog.prompt_for_input(ctx, "test")
            assert dpytest.verify().message().content(
                "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
            assert dpytest.verify().message().content("Okay, I'll cancel the command.")
            assert not result
    else:
        msg: discord.Message = dpytest.back.make_message(content=msg_content, author=author, channel=channel)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg)):
            result = await rfr_cog.prompt_for_input(ctx, "test")
            assert dpytest.verify().message().content(
                "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
            assert result == msg_content


@pytest.mark.asyncio
async def test_prompt_for_input_attachment(rfr_cog, utils_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await dpytest.empty_queue()
    attach: discord.Attachment = discord.Attachment(state=dpytest.back.get_state(),
                                                    data=dpytest.back.facts.make_attachment_dict("test.jpg", 15112122,
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 height=1000,
                                                                                                 width=1000))
    message_dict = dpytest.back.facts.make_message_dict(channel, author, attachments=[attach])
    message: discord.Message = discord.Message(state=dpytest.back.get_state(), channel=channel, data=message_dict)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=message)):
        result = await rfr_cog.prompt_for_input(ctx, "test")
        assert dpytest.verify().message().content(
            "Please enter test so I can progress further. I'll wait 60 seconds, don't worry.")
        assert isinstance(result, discord.Attachment)
        assert result.url == attach.url


@pytest.mark.asyncio
async def test_overwrite_channel_add_reaction_perms(rfr_cog: ReactForRole):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    bot: discord.Client = config.client
    with mock.patch('discord.ext.test.backend.FakeHttp.edit_channel_permissions') as mock_edit_channel_perms:
        for i in range(15):
            await guild.create_role(name=f"TestRole{i}", permissions=discord.Permissions.all())
        role: discord.Role = discord.utils.get(guild.roles, id=guild.id)
        # await core.setup_rfr_reaction_permissions(guild, channel, bot)
        await rfr_cog.overwrite_channel_add_reaction_perms(guild, channel)
        calls = [mock.call(channel.id, role.id, '0', '64', discord.abc._Overwrites.ROLE, reason=None),
                 mock.call(channel.id, config.client.user.id, '64', '0', discord.abc._Overwrites.MEMBER,
                           reason=None)]  # assert it's called the role perms change first, then the member change
        mock_edit_channel_perms.assert_has_calls(calls)


@pytest.mark.asyncio
async def test_is_user_alive(utils_cog, rfr_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=None)):
        alive: bool = await rfr_cog.is_user_alive(ctx)
        assert not alive
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value="a")):
        alive: bool = await rfr_cog.is_user_alive(ctx)
        assert alive


@pytest.mark.asyncio
async def test_get_embed_from_message(rfr_cog, bot: commands.Bot):
    config: dpytest.RunnerConfig = dpytest.get_config()
    author: discord.Member = config.members[0]
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed = discord.Embed(title="title", description="descr", type="rich", url="https://www.google.com")
    await channel.send(embed=embed)
    sent_msg: discord.Message = await dpytest.sent_queue.get()
    msg_mock: discord.Message = dpytest.back.make_message('a', author, channel)
    result = core.get_embed_from_message(None)
    assert result is None
    result = core.get_embed_from_message(msg_mock)
    assert result is None
    result = core.get_embed_from_message(sent_msg)
    assert dpytest.embed_eq(result, sent_msg.embeds[0])


@pytest.mark.asyncio
async def test_get_number_of_embed_fields(rfr_cog):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    test_embed_dict: dict = {'title': 'title', 'description': 'descr', 'type': 'rich', 'url': 'https://www.google.com'}
    bot: discord.Client = config.client
    await bot.http.send_message(channel.id, params=MultipartParameters({"embeds": [test_embed_dict]}, None, None))
    sent_msg: discord.Message = await dpytest.sent_queue.get()
    test_embed: discord.Embed = sent_msg.embeds[0]
    num_fields = 0
    for i in range(20):
        test_embed.add_field(name=f'field{i}', value=f'num{i}')
        num_fields += 1
        assert core.get_number_of_embed_fields(embed=test_embed) == num_fields


@pytest.mark.skip('dpytest currently has non-implemented functionality for construction of guild custom emojis')
@pytest.mark.asyncio
async def test_get_first_emoji_from_str(bot, utils_cog, rfr_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    guild_emoji = testutils.fake_guild_emoji(guild)
    guild_emoji = discord.Emoji(guild=guild, state=None,
                                data={'name': "AAA", 'image': None, 'id': dpyfactory.make_id(),
                                      'require_colons': True, 'managed': False})
    guild._state.store_emoji(guild=guild,
                             data={'name': "AAA", 'image': None, 'id': dpyfactory.make_id(),
                                   'require_colons': True, 'managed': False})
    assert guild_emoji in guild.emojis

    author: discord.Member = config.members[0]
    channel: discord.TextChannel = guild.text_channels[0]
    msg: discord.Message = dpytest.back.make_message(str(guild_emoji), author, channel)
    result = await core.get_first_emoji_from_str(bot, guild, msg.content)
    logger.debug(result)
    assert isinstance(result, discord.Emoji), msg.content
    assert guild_emoji == result


@pytest.mark.asyncio
async def test_rfr_create_message(bot):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed_channel: discord.TextChannel = dpytest.back.make_text_channel('EmbedChannel', guild)
    author: discord.Member = config.members[0]
    test_embed = discord.Embed(title="React for Role", description="Roles below!", colour=KOALA_GREEN)
    test_embed.set_footer(text="ReactForRole")
    test_embed.set_thumbnail(
        url=koalabot.KOALA_IMAGE_URL)
    with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                    mock.AsyncMock(return_value=embed_channel.mention)):
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=None)):
            with mock.patch('koala.cogs.ReactForRole.is_user_alive', mock.AsyncMock(return_value=True)):
                with mock.patch(
                        'koala.cogs.ReactForRole.overwrite_channel_add_reaction_perms') as mock_edit_channel_perms:
                    with mock.patch('discord.Message.delete') as mock_delete:
                        await dpytest.message(koalabot.COMMAND_PREFIX + "rfr createMessage")
                        mock_edit_channel_perms.assert_called_once_with(guild, embed_channel)
                        assert dpytest.verify().message().content(
                            "Okay, this will create a new react for role message in a channel of your choice."
                            "\nNote: The channel you specify will have its permissions edited to make it such that the "
                            "@ everyone role is unable to add new reactions to messages, they can only reaction with "
                            "existing ones. Please keep this in mind, or setup another channel entirely for this.")
                        assert dpytest.verify().message().content("This should be a thing sent in the right channel.")
                        assert dpytest.verify().message().content(
                            "Okay, what would you like the title of the react for role message to be? Please enter within 60 seconds.")
                        assert dpytest.verify().message().content(
                            "Okay, didn't receive a title. Do you actually want to continue? Send anything to confirm this.")
                        assert dpytest.verify().message().content(
                            "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr edit commands.")
                        assert dpytest.verify().message().content(
                            "Okay, the title of the message will be \"React for Role\". What do you want the description to be? I'll wait 60 seconds, don't worry")
                        assert dpytest.verify().message().content(
                            "Okay, didn't receive a description. Do you actually want to continue? Send anything to confirm this.")
                        assert dpytest.verify().message().content(
                            "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr edit command.")
                        assert dpytest.verify().message().content(
                            "Okay, the description of the message will be \"Roles below!\".\n Okay, I'll create the react for role message now.")
                        assert dpytest.verify().message()
                        msg = dpytest.sent_queue.get_nowait()
                        assert "You can use the other k!rfr subcommands to change the message and add functionality as required." in msg.content
                        mock_delete.assert_called_once()


@pytest.mark.asyncio
async def test_rfr_delete_message():
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        guild: discord.Guild = config.guilds[0]
        channel: discord.TextChannel = guild.text_channels[0]
        message: discord.Message = await dpytest.message("rfr")
        msg_id = message.id
        add_rfr_message(guild.id, channel.id, msg_id)
        await dpytest.empty_queue()
        with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                        mock.AsyncMock(return_value=(message, channel))):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', mock.AsyncMock(return_value="Y")):
                with mock.patch('discord.Message.delete') as mock_msg_delete:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr deleteMessage")
                    mock_msg_delete.assert_called_once()
                    assert dpytest.verify().message().content(
                        "Okay, this will delete an existing react for role message. I'll need some details first though.")
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert not independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id)


@pytest.mark.asyncio
async def test_rfr_edit_description():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.description == 'description'
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                        mock.AsyncMock(side_effect=["new description", "Y"])):
            with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
                await dpytest.message(koalabot.COMMAND_PREFIX + "rfr edit description")
                assert embed.description == 'new description'
                assert dpytest.verify().message()
                assert dpytest.verify().message()
                assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_rfr_edit_title():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.title == 'title'
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.ReactForRole.prompt_for_input',
                        mock.AsyncMock(side_effect=["new title", "Y"])):
            with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
                await dpytest.message(koalabot.COMMAND_PREFIX + "rfr edit title")
                assert embed.title == 'new title'
                assert dpytest.verify().message()
                assert dpytest.verify().message()
                assert dpytest.verify().message()


@pytest.mark.asyncio
async def test_rfr_edit_thumbnail_attach():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    attach: discord.Attachment = discord.Attachment(state=dpytest.back.get_state(),
                                                    data=dpytest.back.facts.make_attachment_dict("test.jpg", -1,
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 "https://media.discordapp.net/attachments/some_number/random_number/test.jpg",
                                                                                                 height=1000,
                                                                                                 width=1000,
                                                                                                 content_type="image/jpeg"))
    msg_id = message.id
    bad_attach = "something that's not an attachment"
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=attach):
                await dpytest.message("k!rfr edit image")
                assert embed.thumbnail.url == "https://media.discordapp.net/attachments/some_number/random_number/test.jpg"
            embed.set_thumbnail(
                url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")


@pytest.mark.parametrize("attach", ["", "1", "not an attachment", "http://www.google.com", "https://www.google.com",
                                    "https://cdn.discordapp.com/attachments/734739036564095026/832375039650299954/9-24_EUW1-4321454326_01.webm"])
@pytest.mark.asyncio
async def test_rfr_edit_thumbnail_bad_attach(attach):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=attach):
                with pytest.raises((aiohttp.ClientError, aiohttp.InvalidURL, commands.BadArgument,
                                    commands.CommandInvokeError)) as exc:
                    await dpytest.message("k!rfr edit thumbnail")

                    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"


@pytest.mark.asyncio
@pytest.mark.parametrize("image_url", [
    "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg",
    "https://images-ext-1.discordapp.net/external/to2H6kvblcjDUm5Smwx4rSqwCPTP-UDFdWp1ToEXJQM/https/cdn.weeb.sh/images/Hk9GpT_Pb.png?width=864&height=660",
    "https://cdn.weeb.sh/images/Hk9GpT_Pb.png",
    "https://cdn.discordapp.com/attachments/611574654502699010/828026462552457266/unknown.png"])
async def test_rfr_edit_thumbnail_links(image_url):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    embed.set_thumbnail(
        url="https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg")
    message: discord.Message = await dpytest.message("rfr")
    msg_id = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('koala.cogs.ReactForRole.prompt_for_input', return_value=image_url):
                assert embed.thumbnail.url == "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"
                await dpytest.message("k!rfr edit image")
                assert embed.thumbnail.url != "https://media.discordapp.net/attachments/611574654502699010/756152703801098280/IMG_20200917_150032.jpg"


# @pytest.mark.skip("Unsupported API Calls")
@pytest.mark.parametrize("arg", ["Y", "N"])
@pytest.mark.asyncio
async def test_rfr_edit_inline_all(arg):
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed1: discord.Embed = discord.Embed(title="title", description="description")
    embed1.add_field(name="field1", value="value1", inline=True)
    embed2: discord.Embed = discord.Embed(title="title2", description="description2")
    embed2.add_field(name="field2", value="value2", inline=False)
    message1: discord.Message = await dpytest.message("rfr")
    message2: discord.Message = await dpytest.message("rfr")
    msg1_id = message1.id
    msg2_id = message2.id
    add_rfr_message(guild.id, channel.id, msg1_id)
    add_rfr_message(guild.id, channel.id, msg2_id)
    # await dpytest.sent_queue.empty()
    calls = [mock.call(0, name="field1", value="value1", inline=(arg == "Y")),
             mock.call(0, name="field2", value="value2", inline=(arg == "Y"))]
    with mock.patch("koala.cogs.ReactForRole.prompt_for_input", side_effect=["all", arg]):
        with mock.patch("discord.abc.Messageable.fetch_message", side_effect=[message1, message2]):
            with mock.patch("koala.cogs.react_for_role.core.get_embed_from_message", side_effect=[embed1, embed2]):
                with mock.patch('discord.Embed.set_field_at') as mock_call:
                    await dpytest.message("k!rfr edit inline")
                    assert dpytest.verify().message()
                    assert dpytest.verify().message()
                    assert dpytest.verify().message().content(
                        "Keep in mind that this process may take a while if you have a lot of RFR messages on your server.")
                    assert dpytest.verify().message().content("Okay, the process should be finished now. Please check.")


@pytest.mark.skip("Unsupported API Calls")
async def test_rfr_edit_inline_specific():
    assert False


@pytest.mark.asyncio
async def test_rfr_add_roles_to_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    client: discord.Client = config.client
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_list = []
    ro_list = []
    for i in range(5):
        em = testutils.fake_unicode_emoji()
        ro = testutils.fake_guild_role(guild)
        input_em_ro_content += f"{str(em)}, {ro.id}\n\r"
        em_list.append(em)
        ro_list.append(ro.mention)
    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr addRoles")
                    calls = []
                    for i in range(5):
                        calls.append(mock.call(name=str(em_list[i]), value=ro_list[i], inline=False))
                    add_field.has_calls(calls)

@pytest.mark.asyncio
async def test_rfr_add_flag_roles_to_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_list = []
    ro_list = []
    for i in range(5):
        em = testutils.fake_flag_emoji()
        ro = testutils.fake_guild_role(guild)
        input_em_ro_content += f"{str(em)}, {ro.id}\n\r"
        em_list.append(em)
        ro_list.append(ro.mention)
    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)

    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    await dpytest.message(koalabot.COMMAND_PREFIX + "rfr addRoles")
                    calls = []
                    for i in range(5):
                        calls.append(mock.call(name=str(em_list[i]), value=ro_list[i], inline=False))
                    add_field.has_calls(calls)



@pytest.mark.asyncio
async def test_rfr_remove_roles_from_msg():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]
    embed: discord.Embed = discord.Embed(title="title", description="description")
    author: discord.Member = config.members[0]
    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)
    input_em_ro_content = ""
    em_ro_list = []
    for i in range(5):
        em = testutils.fake_unicode_emoji()
        ro = testutils.fake_guild_role(guild)
        x = random.choice([str(em), str(ro.id)])
        input_em_ro_content += f"{x}\n\r"
        em_ro_list.append(x)
        embed.add_field(name=str(em), value=ro.mention, inline=False)
        add_rfr_message_emoji_role(1, str(em), ro.id)

    input_em_ro_msg: discord.Message = dpytest.back.make_message(input_em_ro_content, author, channel)
    with mock.patch('koala.cogs.ReactForRole.get_rfr_message_from_prompts',
                    mock.AsyncMock(return_value=(message, channel))):
        with mock.patch('koala.cogs.react_for_role.core.get_embed_from_message', return_value=embed):
            with mock.patch('discord.client.Client.wait_for',
                            mock.AsyncMock(return_value=input_em_ro_msg)):
                with mock.patch('discord.Embed.add_field') as add_field:
                    with mock.patch(
                            'koala.cogs.react_for_role.db.remove_rfr_message_emoji_role') as remove_emoji_role:
                        add_field.reset_mock()
                        await dpytest.message(koalabot.COMMAND_PREFIX + "rfr removeRoles")
                        add_field.assert_not_called()
                        calls = []
                        for i in range(5):
                            calls.append((1, em_ro_list[i]))
                        remove_emoji_role.has_calls(calls)


# role-check tests
@pytest.mark.parametrize("num_roles, num_required",
                         [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5)])
@pytest.mark.asyncio
async def test_can_have_rfr_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        guild: discord.Guild = config.guilds[0]
        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(guild)
            r_list.append(role)
        required = random.sample(list(r_list), num_required)
        for r in required:
            add_guild_rfr_required_role(guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, guild.id, r.id) is not None
        for i in range(num_roles):
            mem_roles = []
            member: discord.Member = await dpytest.member_join()
            for j in range(i):
                mem_roles.append(r_list[j])
                await member.add_roles(r_list[j])

            assert len(mem_roles) == i
            if len(required) == 0:
                assert rfr_cog.can_have_rfr_role(member)
            else:
                assert rfr_cog.can_have_rfr_role(member) == any(
                    x in required for x in member.roles), f"\n\r{member.roles}\n\r{required}"


@pytest.mark.asyncio
async def test_get_first_emoji_from_str():
    config: dpytest.RunnerConfig = dpytest.get_config()
    guild: discord.Guild = config.guilds[0]
    channel: discord.TextChannel = guild.text_channels[0]

    message: discord.Message = await dpytest.message("rfr")
    msg_id: int = message.id
    add_rfr_message(guild.id, channel.id, msg_id)

    emoji: discord.Emoji = testutils.fake_guild_emoji(guild)
    role: discord.Role = testutils.fake_guild_role(guild)

    assert core.get_first_emoji_from_str(koalabot, guild, emoji)

    uni_emoji = testutils.fake_unicode_emoji()
    assert core.get_first_emoji_from_str(koalabot, guild, uni_emoji)

</document_content>
</document>
<document index="18">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import random

# Libs
import discord
import discord.ext.test as dpytest
import emoji
import mock
import pytest
from discord.ext.test import factories as dpyfactory

from koala.cogs.react_for_role.db import *
from tests.log import logger
# Own modules
from tests.tests_utils import utils as testutils
from .utils import independent_get_guild_rfr_message, independent_get_rfr_message_emoji_role, \
    independent_get_guild_rfr_required_role, get_rfr_reaction_role_by_role_id


# Constants

# Variables


@pytest.mark.asyncio
async def test_rfr_db_functions_guild_rfr_messages():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        channel: discord.TextChannel = dpytest.get_config().channels[0]
        msg_id = dpyfactory.make_id()
        # Test when no messages exist
        expected_full_list: List[Tuple[int, int, int, int]] = []
        assert independent_get_guild_rfr_message(
            session, guild.id, channel.id, msg_id) == expected_full_list
        assert independent_get_guild_rfr_message(session) == expected_full_list
        # Test on adding first message, 1 message, 1 channel, 1 guild
        add_rfr_message(guild.id, channel.id, msg_id)
        expected_full_list.append((guild.id, channel.id, msg_id, 1))
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id) == [
            expected_full_list[0]]
        # 2 guilds, 1 channel each, 2 messages
        guild2: discord.Guild = dpytest.back.make_guild("TestGuild2")
        channel2: discord.TextChannel = dpytest.back.make_text_channel(
            "TestGuild2Channel1", guild2)
        msg_id = dpyfactory.make_id()
        dpytest.get_config().guilds.append(guild2)
        add_rfr_message(guild2.id, channel2.id, msg_id)
        expected_full_list.append((guild2.id, channel2.id, msg_id, 2))
        assert independent_get_guild_rfr_message(session, guild2.id, channel2.id, msg_id) == [
            expected_full_list[1]]
        assert independent_get_guild_rfr_message(session, guild2.id, channel2.id, msg_id)[
                   0] == get_rfr_message(guild2.id,
                                         channel2.id,
                                         msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        # 1 guild, 2 channels with 1 message each
        guild1channel2: discord.TextChannel = dpytest.back.make_text_channel(
            "TestGuild1Channel2", guild)
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, guild1channel2.id, msg_id)
        expected_full_list.append((guild.id, guild1channel2.id, msg_id, 3))
        assert independent_get_guild_rfr_message(
            session, guild.id, guild1channel2.id, msg_id) == [expected_full_list[2]]
        assert independent_get_guild_rfr_message(session, guild.id, guild1channel2.id, msg_id)[
                   0] == get_rfr_message(
            guild.id, guild1channel2.id, msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session,
                                                 guild.id) == [expected_full_list[0], expected_full_list[2]]
        # 1 guild, 1 channel, with 2 messages
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg_id)
        expected_full_list.append((guild.id, channel.id, msg_id, 4))
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id) == [
            expected_full_list[3]]
        assert independent_get_guild_rfr_message(session, guild.id, channel.id, msg_id)[0] == get_rfr_message(
            guild.id,
            channel.id,
            msg_id)
        assert independent_get_guild_rfr_message(session) == expected_full_list
        assert independent_get_guild_rfr_message(session, guild.id, channel.id) == [
            expected_full_list[0], expected_full_list[3]]
        # remove all messages
        guild_rfr_messages = independent_get_guild_rfr_message(session)
        for guild_rfr_message in guild_rfr_messages:
            assert guild_rfr_message in guild_rfr_messages
            remove_rfr_message(
                guild_rfr_message[0], guild_rfr_message[1], guild_rfr_message[2])
            assert guild_rfr_message not in independent_get_guild_rfr_message(session)
        assert independent_get_guild_rfr_message(session) == []


@pytest.mark.asyncio
async def test_rfr_db_functions_rfr_message_emoji_roles():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        channel: discord.TextChannel = dpytest.get_config().channels[0]
        msg_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg_id)
        guild_rfr_message = independent_get_guild_rfr_message(session)[0]
        expected_full_list: List[Tuple[int, str, int]] = []
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        # 1 unicode, 1 role
        fake_emoji_1 = testutils.fake_unicode_emoji()
        fake_role_id_1 = dpyfactory.make_id()
        expected_full_list.append((1, fake_emoji_1, fake_role_id_1))
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_1)
        assert independent_get_rfr_message_emoji_role(
            session) == expected_full_list, get_rfr_message_emoji_roles(1)
        assert independent_get_rfr_message_emoji_role(session, 1) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session, guild_rfr_message[3], fake_emoji_1,
                                                      fake_role_id_1) == [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_1)]
        # 1 unicode, 1 custom, trying to get same role
        fake_emoji_2 = testutils.fake_custom_emoji_str_rep()
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_2, fake_role_id_1)
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      guild_rfr_message[3]) == get_rfr_message_emoji_roles(
            guild_rfr_message[3])
        assert [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_2, fake_role_id_1)] == [None]
        # 2 roles, with 1 emoji trying to give both roles
        fake_role_id_2 = dpyfactory.make_id()
        add_rfr_message_emoji_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_2)
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      guild_rfr_message[3]) == get_rfr_message_emoji_roles(
            guild_rfr_message[3])
        assert [get_rfr_reaction_role(
            guild_rfr_message[3], fake_emoji_1, fake_role_id_2)] == [None]

        # 2 roles, 2 emojis, 1 message. split between them
        fake_emoji_2 = testutils.fake_custom_emoji_str_rep()
        fake_role_id_2 = dpyfactory.make_id()
        expected_full_list.append((1, fake_emoji_2, fake_role_id_2))
        add_rfr_message_emoji_role(*expected_full_list[1])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      1, fake_emoji_1) == [(1, fake_emoji_1, fake_role_id_1)]
        assert independent_get_rfr_message_emoji_role(session,
                                                      1, fake_emoji_2) == [(1, fake_emoji_2, fake_role_id_2)]
        assert independent_get_rfr_message_emoji_role(session, 1, fake_emoji_1)[0][
                   2] == get_rfr_reaction_role_by_emoji_str(1,
                                                            fake_emoji_1)
        assert independent_get_rfr_message_emoji_role(session,
                                                      1) == get_rfr_message_emoji_roles(1)
        assert independent_get_rfr_message_emoji_role(session, 1, role_id=fake_role_id_2)[0][
                   2] == get_rfr_reaction_role_by_role_id(session, emoji_role_id=1, role_id=fake_role_id_2)

        # 2 roles 2 emojis, 2 messages. duplicated messages
        msg2_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg2_id)
        assert independent_get_guild_rfr_message(session
                                                 ) == [guild_rfr_message, (guild.id, channel.id, msg2_id, 2)]
        guild_rfr_message_2 = independent_get_guild_rfr_message(session)[1]
        add_rfr_message_emoji_role(
            guild_rfr_message_2[3], fake_emoji_1, fake_role_id_1)
        add_rfr_message_emoji_role(
            guild_rfr_message_2[3], fake_emoji_2, fake_role_id_2)
        expected_full_list.extend([(guild_rfr_message_2[3], fake_emoji_1, fake_role_id_1),
                                   (guild_rfr_message_2[3], fake_emoji_2, fake_role_id_2)])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      2) == get_rfr_message_emoji_roles(2)
        assert independent_get_rfr_message_emoji_role(session,
                                                      1) == get_rfr_message_emoji_roles(1)

        # 2 roles 2 emojis 2 messages. Swapped
        msg3_id = dpyfactory.make_id()
        add_rfr_message(guild.id, channel.id, msg3_id)
        assert independent_get_guild_rfr_message(session) == [guild_rfr_message, (guild.id, channel.id, msg2_id, 2),
                                                              (guild.id, channel.id, msg3_id, 3)]
        guild_rfr_message_3 = independent_get_guild_rfr_message(session)[2]
        add_rfr_message_emoji_role(
            guild_rfr_message_3[3], fake_emoji_1, fake_role_id_2)
        add_rfr_message_emoji_role(
            guild_rfr_message_3[3], fake_emoji_2, fake_role_id_1)
        expected_full_list.extend([(guild_rfr_message_3[3], fake_emoji_1, fake_role_id_2),
                                   (guild_rfr_message_3[3], fake_emoji_2, fake_role_id_1)])
        assert independent_get_rfr_message_emoji_role(session) == expected_full_list
        assert independent_get_rfr_message_emoji_role(session,
                                                      3) == get_rfr_message_emoji_roles(3)
        assert [x[2] for x in independent_get_rfr_message_emoji_role(session, emoji_raw=fake_emoji_1)] == [
            get_rfr_reaction_role_by_emoji_str(1, fake_emoji_1),
            get_rfr_reaction_role_by_emoji_str(2, fake_emoji_1),
            get_rfr_reaction_role_by_emoji_str(3, fake_emoji_1)]
        assert [x[2] for x in independent_get_rfr_message_emoji_role(session, emoji_raw=fake_emoji_2)] == [
            get_rfr_reaction_role_by_emoji_str(1, fake_emoji_2),
            get_rfr_reaction_role_by_emoji_str(2, fake_emoji_2),
            get_rfr_reaction_role_by_emoji_str(3, fake_emoji_2)]
        # test deletion works from rfr message
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 3)
        remove_rfr_message(guild.id, channel.id, msg3_id)
        for row in rfr_message_emoji_roles:
            assert row not in independent_get_rfr_message_emoji_role(session
                                                                     ), independent_get_guild_rfr_message(session)
        # test deleting just emoji role combos
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 2)
        remove_rfr_message_emoji_roles(2)
        for row in rfr_message_emoji_roles:
            assert row not in independent_get_rfr_message_emoji_role(session
                                                                     ), independent_get_guild_rfr_message(session)
        # test deleteing specific
        rfr_message_emoji_roles = independent_get_rfr_message_emoji_role(session, 1)
        remove_rfr_message_emoji_role(
            1, emoji_raw=rfr_message_emoji_roles[0][1])
        assert (rfr_message_emoji_roles[0][0], rfr_message_emoji_roles[0][1],
                rfr_message_emoji_roles[0][2]) not in independent_get_rfr_message_emoji_role(session)
        remove_rfr_message_emoji_role(
            1, role_id=rfr_message_emoji_roles[1][2])
        assert (rfr_message_emoji_roles[1][0], rfr_message_emoji_roles[1][1],
                rfr_message_emoji_roles[1][2]) not in independent_get_rfr_message_emoji_role(session)


@pytest.mark.asyncio
async def test_rfr_db_functions_guild_rfr_required_roles():
    with session_manager() as session:
        guild: discord.Guild = dpytest.get_config().guilds[0]
        roles = []
        for i in range(50):
            role: discord.Role = testutils.fake_guild_role(guild)
            roles.append(role)
            add_guild_rfr_required_role(guild.id, role.id)
            assert [x[1] for x in independent_get_guild_rfr_required_role(session)] == [x.id for x in roles], i
            assert [x[1] for x in
                    independent_get_guild_rfr_required_role(session)] == get_guild_rfr_required_roles(
                guild.id), i

        while len(roles) > 0:
            role: discord.Role = roles.pop()
            remove_guild_rfr_required_role(guild.id, role.id)
            assert [x[1] for x in independent_get_guild_rfr_required_role(session)] == [x.id for x in roles], len(roles)
            assert [x[1] for x in
                    independent_get_guild_rfr_required_role(session)] == get_guild_rfr_required_roles(
                guild.id), len(roles)


@pytest.mark.parametrize("num_roles, num_required",
                         [(1, 1), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5), (100, 20), (200, 20)])
@pytest.mark.asyncio
async def test_rfr_without_req_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        test_guild: discord.Guild = config.guilds[0]

        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(test_guild)
            r_list.append(role)
        required = random.sample(list(r_list), num_required)
        for r in required:
            add_guild_rfr_required_role(test_guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, test_guild.id, r.id) is not None

        member: discord.Member = await dpytest.member_join()
        await member.add_roles(*[r for r in r_list if r not in required])
        mem_roles = member.roles
        role_to_add = testutils.fake_guild_role(test_guild)

        # Create RFR message for test
        rfr_message = dpytest.back.make_message("FakeContent", config.client.user, test_guild.text_channels[0])
        add_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        assert get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id) is not None

        # Add emoji role combo to db
        _, _, _, er_id = get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        react_emoji: str = testutils.fake_unicode_emoji()
        add_rfr_message_emoji_role(er_id, emoji.demojize(react_emoji), role_to_add.id)

        with mock.patch("koala.cogs.ReactForRole.get_role_member_info",
                        mock.AsyncMock(return_value=(member, role_to_add))):
            with mock.patch("discord.Member.add_roles", mock.AsyncMock()) as add_role_mock:
                await dpytest.add_reaction(member, rfr_message, react_emoji)
                assert all([m in member.roles for m in mem_roles])
                add_role_mock.assert_not_called()
                assert role_to_add not in member.roles


@pytest.mark.parametrize("num_roles, num_required",
                         [(1, 1), (2, 1), (2, 2), (5, 1), (5, 2), (20, 5), (100, 20), (200, 20)])
@pytest.mark.asyncio
async def test_rfr_with_req_role(num_roles, num_required, rfr_cog):
    with session_manager() as session:
        config: dpytest.RunnerConfig = dpytest.get_config()
        test_guild: discord.Guild = config.guilds[0]

        # Create RFR message for test
        rfr_message = dpytest.back.make_message("FakeContent", config.client.user, test_guild.text_channels[0])
        add_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        assert get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id) is not None

        r_list = []
        for i in range(num_roles):
            role = testutils.fake_guild_role(test_guild)
            r_list.append(role)
        required = random.sample(r_list, num_required)
        role_to_add = testutils.fake_guild_role(test_guild)

        # Add emoji role combo to db
        _, _, _, er_id = get_rfr_message(test_guild.id, rfr_message.channel.id, rfr_message.id)
        react_emoji: str = testutils.fake_unicode_emoji()
        add_rfr_message_emoji_role(er_id, emoji.demojize(react_emoji), role_to_add.id)

        for r in required:
            add_guild_rfr_required_role(test_guild.id, r.id)
            assert independent_get_guild_rfr_required_role(session, test_guild.id, r.id) is not None

        member: discord.Member = await dpytest.member_join()
        await member.add_roles(*(random.sample(r_list, random.randint(1, num_roles))))
        logger.debug(f"required = {[r.name for r in required]}, mem_roles pre-add are {[member.roles]}")
        if not any([r in required for r in member.roles]):
            x = random.choice(required)
            await member.add_roles(x)
            logger.debug(f"added role {x.name} to {member.display_name}")
        mem_roles = member.roles
        with mock.patch("koala.cogs.ReactForRole.get_role_member_info",
                        mock.AsyncMock(return_value=(member, role_to_add))):
            await dpytest.add_reaction(member, rfr_message, react_emoji)
            assert all([m in member.roles for m in mem_roles])
            assert role_to_add in member.roles

</document_content>
</document>
<document index="19">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/react_for_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot ReactForRole Cog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
from typing import *

# Libs
import sqlalchemy.orm
from sqlalchemy import select

# Own modules
from koala.cogs.react_for_role.models import GuildRFRRequiredRoles, GuildRFRMessages, RFRMessageEmojiRoles


def independent_get_guild_rfr_message(session: sqlalchemy.orm.Session, guild_id=None, channel_id=None, message_id=None
                                      ) -> List[Tuple[int, int, int, int]]:
    sql_select = select(GuildRFRMessages)
    if guild_id is not None:
        sql_select = sql_select.filter_by(guild_id=guild_id)
    if channel_id is not None:
        sql_select = sql_select.filter_by(channel_id=channel_id)
    if message_id is not None:
        sql_select = sql_select.filter_by(message_id=message_id)
    rows = session.execute(sql_select).scalars()
    return [row.old_format() for row in rows]


def independent_get_rfr_message_emoji_role(session: sqlalchemy.orm.Session, emoji_role_id=None, emoji_raw=None,
                                           role_id=None) -> List[
    Tuple[int, str, int]]:
    sql_select = select(RFRMessageEmojiRoles)
    if emoji_role_id is not None:
        sql_select = sql_select.filter_by(emoji_role_id=emoji_role_id)
    if emoji_raw is not None:
        sql_select = sql_select.filter_by(emoji_raw=emoji_raw)
    if role_id is not None:
        sql_select = sql_select.filter_by(role_id=role_id)

    rows = session.execute(sql_select).scalars().all()
    return [(row.emoji_role_id, row.emoji_raw, row.role_id) for row in rows]


def independent_get_guild_rfr_required_role(session: sqlalchemy.orm.Session, guild_id=None, role_id=None
                                            ) -> List[Tuple[int, int]]:
    sql_select = select(GuildRFRRequiredRoles)
    if guild_id is not None:
        sql_select = sql_select.filter_by(guild_id=guild_id)
    if role_id is not None:
        sql_select = sql_select.filter_by(role_id=role_id)
    rows = session.execute(sql_select).scalars().all()

    return [(row.guild_id, row.role_id) for row in rows]


def get_rfr_reaction_role_by_role_id(session: sqlalchemy.orm.Session, emoji_role_id: int, role_id: int
                                     ) -> Optional[int]:
    row = session.execute(select(RFRMessageEmojiRoles.role_id)
                          .filter_by(emoji_role_id=emoji_role_id, role_id=role_id)).one_or_none()
    if row:
        return row.role_id
    else:
        return

</document_content>
</document>
<document index="20">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="21">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

import random
import re
from typing import List

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs import ColourRole
from koala.cogs import colour_role
from koala.cogs.colour_role.utils import COLOUR_ROLE_NAMING
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog
from .utils import make_list_of_roles, make_list_of_custom_colour_roles, make_list_of_protected_colour_roles, \
    random_colour, independent_get_protected_colours, independent_get_colour_change_roles, DBManager


# Built-in/Generic Imports

# Constants

# Variables


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def role_colour_cog(bot: commands.Bot):
    role_colour_cog = ColourRole(bot)
    await bot.add_cog(role_colour_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return role_colour_cog


@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_no_guild_roles(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    assert not colour_role.cog.is_allowed_to_change_colour(ctx)

@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_false(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_roles(ctx.guild, 1)
    role = roles[0]
    DBManager.add_colour_change_role_perms(ctx.guild.id, role.id)
    assert not colour_role.cog.is_allowed_to_change_colour(ctx)


@pytest.mark.asyncio
async def test_is_allowed_to_change_colour_true(utils_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_roles(ctx.guild, 1)
    role = roles[0]
    member: discord.Member = ctx.author
    DBManager.add_colour_change_role_perms(ctx.guild.id, role.id)
    await member.add_roles(role)
    assert colour_role.cog.is_allowed_to_change_colour(ctx)


@pytest.mark.parametrize("hex_str, value",
                         [("000000", 0), ("111111", 1118481), ("228822", 2263074), ("ff82ae", 16745134),("#000000", 0), ("#111111", 1118481), ("#228822", 2263074), ("#ff82ae", 16745134)])
@pytest.mark.asyncio
async def test_get_colour_from_hex_str(hex_str, value, role_colour_cog):
    colour: discord.Colour = role_colour_cog.get_colour_from_hex_str(hex_str)
    assert colour.value == value, str(colour.r) + " " + str(colour.g) + " " + str(colour.b) + " " + str(colour.value)


@pytest.mark.asyncio
@pytest.mark.parametrize("colour_str, expected",
                         [("", False), (".", False), (" ", False), ("223", False), ("a", False), ("ffgeaa", False),
                          ("FFeehu", False), ("FFee66", True), ("ffeea7", True), ("ABCDEF", True), ("#ABCDEF", True), ("#123456", True), ("#", False), ("#123", False)])
async def test_is_valid_colour_str(colour_str, expected, role_colour_cog):
    assert role_colour_cog.is_valid_colour_str(colour_str.upper()) == expected


@pytest.mark.parametrize("colour1_str, colour2_str, expected",
                         [("ffffff", "ffffff", 0), ("FFFFFF", "ffffff", 0), ("ffffff", "000000", 764.8339663572415),
                          ("ff74aa", "6900ff", 362.23060571789074), ("223636", "363636", 29.47456530637899),("#ffffff", "#ffffff", 0), ("#FFFFFF", "#ffffff", 0), ("#ffffff", "000000", 764.8339663572415),
                           ("#ff74aa", "#6900ff", 362.23060571789074), ("#223636", "#363636", 29.47456530637899)])
@pytest.mark.asyncio
async def test_get_rgb_colour_distance(colour1_str, colour2_str, expected, role_colour_cog):
    colour1 = role_colour_cog.get_colour_from_hex_str(colour1_str)
    colour2 = role_colour_cog.get_colour_from_hex_str(colour2_str)
    dist = role_colour_cog.get_rgb_colour_distance(colour1, colour2)
    assert dist == expected


@pytest.mark.asyncio
async def test_role_already_exists(role_colour_cog, utils_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    role_exists = role_colour_cog.role_already_exists(ctx, "ffae14")
    assert not role_exists
    await guild.create_role(name="KoalaBot[0xffae14]")
    role_exists = role_colour_cog.role_already_exists(ctx, "ffae14")
    assert role_exists


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_protected_roles(num_roles, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_roles)
    for role in roles:
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    return_roles = role_colour_cog.get_protected_roles(guild)
    assert set(roles) == set(return_roles)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_custom_colour_allowed_roles(num_roles, role_colour_cog, utils_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    for role in roles:
        DBManager.add_colour_change_role_perms(guild.id, role.id)
    return_roles = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert set(roles) == set(return_roles)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_prune_guild_empty_colour_roles(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    assert set(roles).issubset(guild.roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await role_colour_cog.prune_guild_empty_colour_roles(ctx)
    assert not any(roles) in guild.roles


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_prune_author_old_colour_roles(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    assert set(roles).issubset(guild.roles)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    await role_colour_cog.prune_author_old_colour_roles(ctx)
    author: discord.Member = ctx.author
    assert not any(roles) in author.roles


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_calculate_custom_colour_role_position(num_roles, role_colour_cog: ColourRole):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles: List[discord.Role] = await make_list_of_roles(guild, 5)
    # add num_roles roles to the protected roles
    chosen = random.sample(roles, k=num_roles)
    lowest_protected = 2000000000
    for r in chosen:
        DBManager.add_guild_protected_colour_role(guild.id, r.id)
        if r.position < lowest_protected:
            lowest_protected = r.position
    if lowest_protected == 2000000000 or lowest_protected == 1:
        expected = 1
    else:
        expected = lowest_protected
    assert role_colour_cog.calculate_custom_colour_role_position(guild) == expected, num_roles
    for role in roles:
        await role.delete()


@pytest.mark.asyncio
async def test_create_custom_colour_role(role_colour_cog: ColourRole, utils_cog: LastCtxCog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    colour: discord.Colour = discord.Colour.from_rgb(16, 16, 16)
    colour_str = "101010"
    with mock.patch('koala.cogs.ColourRole.calculate_custom_colour_role_position', return_value=2) as mock_calc:
        await guild.create_role(name="TestRole1")
        role = await role_colour_cog.create_custom_colour_role(colour, colour_str, ctx)
        assert role in guild.roles
        assert re.match(COLOUR_ROLE_NAMING, role.name), role.name
        assert role.colour.value == colour.value
        assert role.position == 2
        mock_calc.assert_called_once_with(guild)


@pytest.mark.parametrize("num_roles", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_get_guild_protected_colours(num_roles, utils_cog, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    roles = await make_list_of_custom_colour_roles(guild, num_roles)
    colours = [role.colour for role in roles]
    with mock.patch('koala.cogs.ColourRole.get_protected_roles', return_value=roles) as mock_roles:
        with mock.patch('koala.cogs.ColourRole.get_role_colours', return_value=colours) as mock_colours:
            result = role_colour_cog.get_guild_protected_colours(ctx)
            mock_roles.assert_called_once_with(guild)
            mock_colours.assert_called_once_with(roles)
            assert result == colours


@pytest.mark.parametrize("num_total, num_protected",
                         [(0, 0), (1, 0), (2, 0), (1, 1), (2, 1), (5, 0), (5, 1), (5, 2), (50, 5), (50, 1), (50, 2),
                          (50, 0)])
@pytest.mark.asyncio
async def test_list_protected_roles(num_total, num_protected):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_total)
    expected = "Roles whose colour is protected are:\r"
    if num_total == 0 or num_protected == 0:
        protected = []
        expected = expected[:-1]
    elif num_protected == num_total:
        protected = roles.copy()
    else:
        protected = random.sample(list(roles), 2)
    for r in protected:
        DBManager.add_guild_protected_colour_role(guild.id, r.id)

    await dpytest.message(koalabot.COMMAND_PREFIX + "list_protected_role_colours")
    msg: discord.Message = await dpytest.sent_queue.get()
    assert expected in msg.content
    for r in protected:
        assert r.mention in msg.content, r.mention + " " + msg.content


@pytest.mark.parametrize("num_total, num_protected",
                         [(0, 0), (1, 0), (2, 0), (1, 1), (2, 1), (5, 0), (5, 1), (5, 2), (50, 5), (50, 1), (50, 2),
                          (50, 0)])
@pytest.mark.asyncio
async def test_list_custom_colour_allowed_roles(num_total, num_protected):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    roles = await make_list_of_roles(guild, num_total)
    expected = "Roles allowed to have a custom colour are:\r"
    if num_total == 0 or num_protected == 0:
        allowed = []
        expected = expected[:-1]
    elif num_protected == num_total:
        allowed = roles.copy()
    else:
        allowed = random.sample(list(roles), 2)
    for r in allowed:
        DBManager.add_colour_change_role_perms(guild.id, r.id)

    await dpytest.message(koalabot.COMMAND_PREFIX + "list_custom_colour_allowed_roles")
    msg: discord.Message = await dpytest.sent_queue.get()
    assert expected in msg.content
    for r in allowed:
        assert r.mention in msg.content, r.mention + " " + msg.content


@pytest.mark.asyncio
async def test_on_guild_role_delete(utils_cog, role_colour_cog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, 2)
    await role_list[0].delete()
    assert role_list[0] not in guild.roles
    role_list = await make_list_of_roles(guild, 2)
    await role_colour_cog.add_protected_role_colour(ctx, role_str=str(role_list[0].id))
    protected = role_colour_cog.get_protected_roles(guild)
    assert role_list[0] in protected
    await role_list[0].delete()
    protected = role_colour_cog.get_protected_roles(guild)
    assert role_list[0] not in protected
    role_list = await make_list_of_roles(guild, 2)
    await role_colour_cog.add_custom_colour_allowed_role(ctx, role_str=str(role_list[0].id))
    custom_colour_allowed = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert role_list[0] in custom_colour_allowed
    await role_list[0].delete()
    custom_colour_allowed = role_colour_cog.get_custom_colour_allowed_roles(ctx)
    assert role_list[0] not in custom_colour_allowed


@pytest.mark.parametrize("num_total, num_protected, test_colour",
                         [(0, 0, random_colour()), (1, 0, random_colour()), (2, 0, random_colour()),
                          (5, 0, random_colour()), (1, 1, random_colour()), (2, 1, random_colour()),
                          (5, 1, random_colour()), (2, 2, random_colour()), (5, 2, random_colour())])
@pytest.mark.asyncio
async def test_is_valid_custom_colour(num_total, num_protected, test_colour, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await make_list_of_roles(guild, num_total - num_protected)
    protected_roles = await make_list_of_protected_colour_roles(guild, num_protected)
    protected_colours = [role.colour for role in protected_roles]
    lowest_colour_dist = 1000
    for colour in protected_colours:
        d = role_colour_cog.get_rgb_colour_distance(colour, test_colour)
        logger.debug(f"\r\ndist={str(d)}. lowest dist={str(lowest_colour_dist)}. {hex(colour.value)} is protected. "
              f"{hex(test_colour.value)} is custom")
        if d < lowest_colour_dist:
            lowest_colour_dist = d
    assert role_colour_cog.is_valid_custom_colour(test_colour, protected_colours)[0] != (lowest_colour_dist < 38.4)


@pytest.mark.parametrize("num_members", [0, 1, 2, 5, 50])
@pytest.mark.asyncio
async def test_prune_member_old_colour_roles(num_members, role_colour_cog):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    colour_role = (await make_list_of_custom_colour_roles(guild, 1))[0]
    test_members = []
    for i in range(num_members):
        member: discord.Member = await dpytest.member_join(name=f"TestMemberWithRole{i}", discrim=i + 1)
        await member.add_roles(colour_role)
        test_members.append(member)
    val = await role_colour_cog.prune_members_old_colour_roles(dpytest.get_config().members)
    assert val
    for member in dpytest.get_config().members:
        assert colour_role not in member.roles


@pytest.mark.asyncio
async def test_add_protected_role_colour():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = await make_list_of_roles(guild, 1)
    assert independent_get_protected_colours(guild.id) == []
    await dpytest.message(koalabot.COMMAND_PREFIX + "add_protected_role_colour " + str(role[0].id))
    assert independent_get_protected_colours(guild.id) == [role[0].id]


@pytest.mark.asyncio
async def test_add_custom_colour_allowed_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = await make_list_of_roles(guild, 1)
    assert independent_get_colour_change_roles(guild.id) == []
    await dpytest.message(koalabot.COMMAND_PREFIX + "add_custom_colour_allowed_role " + str(role[0].id))
    assert independent_get_colour_change_roles(guild.id) == [role[0].id]


@pytest.mark.asyncio
async def test_remove_protected_role_colour():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    assert independent_get_protected_colours(guild.id) == []
    DBManager.add_guild_protected_colour_role(guild.id, role.id)
    assert independent_get_protected_colours(guild.id) == [role.id]
    await dpytest.message(koalabot.COMMAND_PREFIX + "remove_protected_role_colour " + str(role.id))
    assert independent_get_protected_colours(guild.id) == []


@pytest.mark.asyncio
async def test_remove_custom_colour_allowed_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    assert independent_get_colour_change_roles(guild.id) == []
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    assert independent_get_colour_change_roles(guild.id) == [role.id]
    await dpytest.message(koalabot.COMMAND_PREFIX + "remove_custom_colour_allowed_role " + str(role.id))
    assert independent_get_colour_change_roles(guild.id) == []


@pytest.mark.asyncio
async def test_custom_colour_check_failure():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour ab1234")
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no")
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_no_allowed_role():
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour ab1234")
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().guilds[0].roles]
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().members[0].roles]
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()
    with pytest.raises(commands.CheckFailure):
        await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no")
        assert "KoalaBot[0xAB1234]" not in [role.name for role in dpytest.get_config().guilds[0].roles]
        assert dpytest.verify().message().content("You don't have the required role to use this command.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_no_no_colour_role():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour no", member=0)
    assert dpytest.verify().message().content("Okay, removing your old custom colour role then, if you have one.")
    assert dpytest.verify().message().content(f"{member.mention} you don't have any colour roles to remove.")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_custom_colour_colour_is_protected():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    fail_colour = discord.Colour.from_rgb(255, 255, 255)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour FEFEFE", member=0)
    assert dpytest.verify().message().content(
        f"Colour chosen was too close to an already protected colour {hex(fail_colour.value)}. Please choose a different colour.")
    assert "KoalaBot[0xFEFEFE]" not in [role.name for role in guild.roles]


@pytest.mark.asyncio
async def test_custom_colour_invalid_colour_str():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour s34a21", member=0)
    assert dpytest.verify().message().content(
        f"Invalid colour string specified, make sure it's a valid colour hex.")
    assert len(member.roles) == 2


@pytest.mark.asyncio
async def test_custom_colour_valid():
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role = (await make_list_of_roles(guild, 1))[0]
    DBManager.add_colour_change_role_perms(guild.id, role.id)
    member: discord.Member = dpytest.get_config().members[0]
    await member.add_roles(role)
    await dpytest.message(koalabot.COMMAND_PREFIX + "custom_colour e34a21", member=0)
    colour_role = discord.utils.get(guild.roles, name=f"KoalaBot[0xE34A21]")
    assert dpytest.verify().message().content(
        f"Your new custom role colour is #E34A21, with the role {colour_role.mention}")
    assert dpytest.verify().message().nothing()
    assert "KoalaBot[0xE34A21]" in [role.name for role in guild.roles]
    assert "KoalaBot[0xE34A21]" in [role.name for role in member.roles]




</document_content>
</document>
<document index="22">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from sqlalchemy import delete

from koala.cogs.colour_role.models import GuildColourChangePermissions, GuildInvalidCustomColourRoles
# Own modules
from koala.db import session_manager
from .utils import make_list_of_roles, independent_get_colour_change_roles, independent_get_protected_colours, \
    DBManager


# Constants

# Variables


@pytest.mark.parametrize("length", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_cr_db_functions_protected_colour_roles(length):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, length)
    # Test dbmanager add protected role
    for role in role_list:
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    protected_role_list = independent_get_protected_colours(guild.id)
    assert protected_role_list == [protected_role.id for protected_role in role_list], [guild_role.id for guild_role in
                                                                                        guild.roles]
    # Test dbmanager get protected roles
    db_get_list = DBManager.get_protected_colour_roles(guild.id)
    assert set(protected_role_list) == set(db_get_list)
    # Test dbmanager remove protected role and teardown test
    for role in role_list:
        DBManager.remove_guild_protected_colour_role(guild.id, role.id)
    assert independent_get_protected_colours(guild.id) == []


@pytest.mark.parametrize("length", [0, 1, 2, 5])
@pytest.mark.asyncio
async def test_cr_db_functions_colour_change_roles(length):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    role_list = await make_list_of_roles(guild, length)
    # Test dbmanager add colour change role
    for role in role_list:
        DBManager.add_colour_change_role_perms(guild.id, role.id)
    colour_change_role_list = independent_get_colour_change_roles(guild.id)
    assert colour_change_role_list == [colour_change_role.id for colour_change_role in role_list], [guild_role.id for
                                                                                                    guild_role in
                                                                                                    guild.roles]
    # Test dbmanager get colour change roles
    db_get_list = DBManager.get_colour_change_roles(guild.id)
    assert set(colour_change_role_list) == set(db_get_list)
    # Test dbmanager remove colour change role and teardown test
    for role in role_list:
        DBManager.remove_colour_change_role_perms(guild.id, role.id)
    assert independent_get_colour_change_roles(guild.id) == []

@pytest.fixture(scope='session', autouse=True)
def setup_db():
    with session_manager() as session:
        session.execute(delete(GuildColourChangePermissions))
        session.execute(delete(GuildInvalidCustomColourRoles))
        session.commit()
</document_content>
</document>
<document index="23">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/colour_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
from typing import List

import discord
# Libs
from sqlalchemy import select

from koala.cogs.colour_role.db import ColourRoleDBManager
from koala.cogs.colour_role.models import GuildColourChangePermissions, GuildInvalidCustomColourRoles
# Own modules
from koala.db import session_manager

# Constants

# Variables
DBManager = ColourRoleDBManager()


async def make_list_of_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr: List[discord.Role] = []
    for i in range(length):
        role = await guild.create_role(name=f"TestRole{i}")
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
    for i in range(len(arr)):
        arr[i] = guild.get_role(arr[i].id)
    return arr


def random_colour_str():
    import random
    return hex(random.randint(0, 16777216))


def random_colour() -> discord.Colour:
    import random
    r = random.randint(0, 255)
    g = random.randint(0, 255)
    b = random.randint(0, 255)
    return discord.Colour.from_rgb(r, g, b)


def make_list_of_colours(num: int) -> List[discord.Colour]:
    arr: List[discord.Colour] = []
    for i in range(num):
        arr.append(random_colour())
    return arr


async def make_list_of_custom_colour_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr = []
    for i in range(length):
        role = await guild.create_role(name=f"KoalaBot[{random_colour_str().upper()}]", colour=random_colour())
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
    return arr


async def make_list_of_protected_colour_roles(guild: discord.Guild, length: int) -> List[discord.Role]:
    arr = []
    for i in range(length):
        role = await guild.create_role(name=f"TestProtectedRole{i}", colour=random_colour())
        arr.append(role)
        arr[i] = await arr[i].edit(position=i + 1)
        DBManager.add_guild_protected_colour_role(guild.id, role.id)
    return arr


def independent_get_protected_colours(guild_id):
    with session_manager() as session:
        rows = session.execute(select(GuildInvalidCustomColourRoles.role_id).filter_by(guild_id=guild_id)).all()
        return [row.role_id for row in rows]


def independent_get_colour_change_roles(guild_id):
    with session_manager() as session:
        rows = session.execute(select(GuildColourChangePermissions.role_id).filter_by(guild_id=guild_id)).all()
        return [row.role_id for row in rows]

</document_content>
</document>
<document index="24">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="25">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/conftest.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest_asyncio
# Own modules
from discord.ext import commands

from koala.cogs import IntroCog
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(autouse=True)
async def intro_cog(bot: commands.Bot):
    intro_cog = IntroCog(bot)
    await bot.add_cog(intro_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return intro_cog

</document_content>
</document>
<document index="26">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import asyncio

# Libs
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.db import get_guild_welcome_message
from koala.cogs.intro_cog.utils import DEFAULT_WELCOME_MESSAGE, BASE_LEGAL_MESSAGE, wait_for_message

# Constants
fake_guild_id = 1000
non_existent_guild_id = 9999

# Variables


@pytest.mark.asyncio
async def test_wait_for_message(utils_cog):
    bot = dpytest.get_config().client
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()

    import threading
    t2 = threading.Timer(interval=0.2, function=dpytest.message, args=("y"))
    t2.start()
    fut = wait_for_message(bot, ctx)
    t2.join()
    assert fut, dpytest.sent_queue


@pytest.mark.asyncio
async def test_wait_for_message_timeout(utils_cog):
    bot = dpytest.get_config().client
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()
    with pytest.raises(asyncio.TimeoutError):
        await wait_for_message(bot, ctx, 0.2)


@pytest.mark.asyncio
async def test_send_welcome_message():
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
    assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
    assert dpytest.verify().message().content("Okay, sending out the welcome message now.")
    assert dpytest.verify().message().content(f"{DEFAULT_WELCOME_MESSAGE}\r\n{BASE_LEGAL_MESSAGE}")


@pytest.mark.asyncio
async def test_send_welcome_message_cancelled():
    msg_mock = dpytest.back.make_message('n', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
    assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
    assert dpytest.verify().message().content("Okay, I won't send out the welcome message then.")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_send_welcome_message_timeout():
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "send_welcome_message")
        assert dpytest.verify().message().content("This will DM 1 people. Are you sure you wish to do this? Y/N")
        assert dpytest.verify().message().content('Timed out.')
        assert dpytest.verify().message().content("Okay, I won't send out the welcome message then.")
        assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_cancel_update_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    msg_mock = dpytest.back.make_message('n', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Okay, I won't update the welcome message then.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message


@pytest.mark.asyncio
async def test_update_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Okay, updating the welcome message of the guild in the database now.")
    assert dpytest.verify().message().content(
        "Updated in the database, your new welcome message is this is a non default message.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) == new_message


@pytest.mark.asyncio
async def test_update_welcome_message_too_long():
    import random, string
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "".join(random.choice(string.ascii_letters) for _ in range(1800))
    msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)
    assert dpytest.verify().message().content(
        "Your welcome message is too long to send, sorry. The maximum character limit is 1600.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message


@pytest.mark.asyncio
async def test_update_welcome_message_no_args():
    with pytest.raises(commands.MissingRequiredArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message")
    assert dpytest.verify().message().content("Please put in a welcome message to update to.")


@pytest.mark.asyncio
async def test_view_welcome_message():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    await dpytest.message(koalabot.COMMAND_PREFIX + "welcomeViewMsg ")
    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")


@pytest.mark.asyncio
async def test_update_welcome_message_timeout():
    guild = dpytest.get_config().guilds[0]
    old_message = get_guild_welcome_message(guild.id)
    new_message = "this is a non default message"
    # msg_mock = dpytest.back.make_message('y', dpytest.get_config().members[0], dpytest.get_config().channels[0])
    with mock.patch('discord.client.Client.wait_for', mock.AsyncMock(return_value=None)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "update_welcome_message " + new_message)

    assert dpytest.verify().message().content(f"""Your current welcome message is:\n\r{old_message}""")
    assert dpytest.verify().message().content(
        f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}""" +
        """\n\rWould you like to update the message? Y/N?""")
    assert dpytest.verify().message().content("Timed out.")
    assert dpytest.verify().message().content("Okay, I won't update the welcome message then.")
    assert dpytest.verify().message().nothing()
    assert intro_db.fetch_guild_welcome_message(guild.id) != new_message

</document_content>
</document>
<document index="27">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_db.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import asyncio

# Libs
import discord.ext.test as dpytest
import pytest
# Own modules
from sqlalchemy import text

from koala import db as koala_db
from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.utils import DEFAULT_WELCOME_MESSAGE, BASE_LEGAL_MESSAGE, get_non_bot_members
from tests.log import logger
from .utils import fake_guild_id, non_existent_guild_id, add_fake_guild_to_db


# Constants

# Variables

# Welcome Message Database Manager Tests


@pytest.mark.parametrize("guild_id, expected", [(101,
                                                 "fake guild welcome message"),
                                                (non_existent_guild_id, None)])
@pytest.mark.asyncio
async def test_db_manager_fetch_welcome_message(guild_id, expected):
    await add_fake_guild_to_db(101)
    val = intro_db.fetch_guild_welcome_message(guild_id)
    assert val == expected, str(guild_id) + f": {val}"


@pytest.mark.parametrize("guild_id, new_message, expected", [(111, "non-default message", "non-default message"), (
        222, "you're here! you're gonna have fun", "you\'re here! you\'re gonna have fun"), (333, '', ''),
                                                             (444, None, None)])
@pytest.mark.asyncio
async def test_db_manager_update_welcome_message(guild_id, new_message, expected):
    await add_fake_guild_to_db(guild_id)
    intro_db.update_guild_welcome_message(guild_id, new_message)
    await asyncio.sleep(0.2)
    val = intro_db.fetch_guild_welcome_message(guild_id)
    assert val == expected, intro_db.fetch_guild_welcome_message(guild_id)


@pytest.mark.asyncio
async def test_db_manager_new_guild_welcome_message():
    val = intro_db.new_guild_welcome_message(fake_guild_id)
    assert val == DEFAULT_WELCOME_MESSAGE


@pytest.mark.parametrize("guild_id, expected", [(fake_guild_id, 1), (non_existent_guild_id, 0)])
@pytest.mark.asyncio
async def test_db_manager_remove_guild_welcome_message(guild_id, expected):
    count = intro_db.remove_guild_welcome_message(guild_id)
    assert count == expected


@pytest.mark.asyncio
async def test_on_guild_join():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = dpytest.back.make_guild('TestGuildJoin', id_num=1250)
    test_config.guilds.append(guild)
    await dpytest.member_join(1, client.user)
    await asyncio.sleep(0.3)
    val = intro_db.fetch_guild_welcome_message(1250)
    assert val == DEFAULT_WELCOME_MESSAGE


@pytest.mark.asyncio
async def test_on_guild_remove(bot):
    test_config = dpytest.get_config()
    guild = test_config.guilds[0]
    client = test_config.client
    bot_member = test_config.guilds[0].get_member(client.user.id)
    dpytest.backend.delete_member(bot_member)
    val = intro_db.fetch_guild_welcome_message(guild.id)
    assert val is None


@pytest.mark.parametrize("guild_id, expected",
                         [(101, f"fake guild welcome message"), (1250, DEFAULT_WELCOME_MESSAGE),
                          (9999, DEFAULT_WELCOME_MESSAGE)])
@pytest.mark.asyncio
async def test_get_guild_welcome_message(guild_id, expected):
    val = intro_db.get_guild_welcome_message(guild_id)
    assert val == f"{expected}\r\n{BASE_LEGAL_MESSAGE}", val


@pytest.mark.asyncio
async def test_get_non_bot_members():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = test_config.guilds[0]
    assert len(get_non_bot_members(guild)) == 1, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    await dpytest.member_join()
    assert len(get_non_bot_members(guild)) == 2, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    for i in range(3):
        await dpytest.member_join(name=f'TestUser{str(i)}')
    assert len(get_non_bot_members(guild)) == 5, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    logger.debug(
        [str(non_bot_member) + " " + str(non_bot_member.bot) for non_bot_member in get_non_bot_members(guild)])
    dpytest.backend.delete_member(guild.get_member(client.user.id))
    assert len(get_non_bot_members(guild)) == 5, [non_bot_member.name for non_bot_member in
                                                  get_non_bot_members(guild)]
    logger.debug(
        [str(non_bot_member) + " " + str(non_bot_member.bot) for non_bot_member in get_non_bot_members(guild)])


@pytest.mark.asyncio
async def test_on_member_join():
    test_config = dpytest.get_config()
    client = test_config.client
    guild = dpytest.back.make_guild('TestMemberJoin', id_num=1234)
    test_config.guilds.append(guild)
    await dpytest.member_join(1, client.user)
    await asyncio.sleep(0.25)
    welcome_message = intro_db.get_guild_welcome_message(guild.id)
    await dpytest.member_join(1)
    assert dpytest.verify().message().content(welcome_message)
    intro_db.update_guild_welcome_message(guild.id, 'This is an updated welcome message.')
    await asyncio.sleep(0.25)
    welcome_message = intro_db.get_guild_welcome_message(guild.id)
    await dpytest.member_join(1)
    assert dpytest.verify().message().content(welcome_message)


@pytest.fixture(scope='session', autouse=True)
def setup_db():
    with koala_db.session_manager() as session:
        for table in koala_db.fetch_all_tables():
            session.execute(text(f"DELETE FROM {table};"))
        session.commit()

</document_content>
</document>
<document index="28">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/test_utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test as dpytest
import pytest

# Own modules
from koala.cogs.intro_cog.utils import ask_for_confirmation, confirm_message


@pytest.mark.parametrize("msg_content, is_invalid, expected",
                         [('y', False, True), ('n', False, False), ('Y', False, True), ('N', False, False),
                          ('x', True, False), (' ', True, False), ('', True, False), ('yy', True, False)])
@pytest.mark.asyncio
async def test_ask_for_confirmation(msg_content, is_invalid, expected):
    author = dpytest.get_config().members[0]
    channel = dpytest.get_config().channels[0]
    message = dpytest.back.make_message(author=author, content=msg_content, channel=channel)
    x = await ask_for_confirmation(message, channel)
    assert x == expected
    if is_invalid:
        assert dpytest.verify().message()


@pytest.mark.parametrize("msg_content, expected",
                         [('y', True), ('n', False), ('Y', True), ('N', False), ('', None), (' ', None),
                          ('y ', True), (' n', False)])
@pytest.mark.asyncio
async def test_confirm_message(msg_content, expected):
    author = dpytest.get_config().members[0]
    channel = dpytest.get_config().channels[0]
    message = dpytest.back.make_message(author=author, content=msg_content, channel=channel)
    x = await confirm_message(message)
    assert x is expected

</document_content>
</document>
<document index="29">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/intro_cog/utils.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot IntroCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord.ext.test.factories as dpyfactory

from koala.cogs.intro_cog import db as intro_db
from koala.cogs.intro_cog.models import GuildWelcomeMessages
# Own modules
from koala.db import session_manager

# Constants
fake_guild_id = 1000
non_existent_guild_id = 9999

# Variables


async def add_fake_guild_to_db(id=-1):
    with session_manager() as session:
        if id == 9999:
            return -1
        if id == -1:
            id = dpyfactory.make_id()
        intro_db.remove_guild_welcome_message(id)
        session.add(GuildWelcomeMessages(guild_id=id, welcome_message='fake guild welcome message'))
        session.commit()
        return id

</document_content>
</document>
<document index="30">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="31">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_api.py</source>
<document_content>
from http.client import OK, BAD_REQUEST

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web

from koala.cogs.verification.api import VerifyEndpoint, CONFIG_ENDPOINT, REVERIFY_ENDPOINT

TEST_EMAIL = 'verify_test@koalabot.uk'
TEST_EMAIL_DOMAIN = 'koalabot.uk'


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = VerifyEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


async def test_get_verify_config_empty(api_client):
    guild_id = dpytest.get_config().guilds[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [
        ]
    }

    assert expected_result == result


async def test_get_verify_config(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result


async def test_put_verify_config(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []


async def test_put_verify_config_clear(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": []
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": []
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

async def test_put_verify_config_clear(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] != []

    resp = await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": []
    })
    assert resp.status == OK
    result: dict = await resp.json()

    expected_result = {
        "guild_id": guild_id,
        "roles": []
    }
    assert expected_result == result

    resp = await api_client.get('/{}?guild_id={}'.format(CONFIG_ENDPOINT, guild_id))
    assert (await resp.json())["roles"] == []


async def test_post_reverify_nothing(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    resp = await api_client.post('/{}'.format(REVERIFY_ENDPOINT), json={
        "guild_id": guild_id,
        "role_id": role_id})

    assert resp.status == BAD_REQUEST
    result: dict = await resp.json()
    assert result["error"] == "VerifyException"
    assert result["message"] == "Verification is not enabled for that role"


async def test_post_reverify(api_client):
    guild_id = dpytest.get_config().guilds[0].id
    role_id = dpytest.get_config().guilds[0].roles[0].id

    await api_client.put('/{}'.format(CONFIG_ENDPOINT), json={
        "guild_id": guild_id,
        "roles": [{
            "email_suffix": TEST_EMAIL_DOMAIN,
            "role_id": role_id
        }]
    })

    resp = await api_client.post('/{}'.format(REVERIFY_ENDPOINT), json={
        "guild_id": guild_id,
        "role_id": role_id})

    assert resp.status == OK
    result: dict = await resp.json()
    assert result["role_id"] == role_id

</document_content>
</document>
<document index="32">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_cog.py</source>
<document_content>
#!/usr/bin/env python
# TODO Test rig broken, restart from beginning and fix.
"""
Testing KoalaBot Verification
Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import asyncio

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, delete

# Own modules
import koalabot
from koala.cogs import Verification
from koala.cogs.verification.models import VerifiedEmails, ToReVerify, NonVerifiedEmails, Roles, VerifyBlacklist
from koala.db import session_manager
from tests.log import logger

# Constants
TEST_EMAIL = 'verify_test@koalabot.uk'
TEST_EMAIL_DOMAIN = 'koalabot.uk'

# Variables


@pytest_asyncio.fixture(autouse=True)
async def cog(bot: commands.Bot):
    cog = Verification(bot)
    await bot.add_cog(cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return cog


@pytest.fixture(autouse=True)
def delete_tables(session):
    session.execute(delete(VerifiedEmails))
    session.execute(delete(ToReVerify))
    session.execute(delete(NonVerifiedEmails))
    session.execute(delete(Roles))
    session.execute(delete(VerifyBlacklist))
    session.commit()


@pytest.mark.asyncio
async def test_member_join_no_verify():
    await dpytest.member_join()
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio
async def test_member_join_verif_enabled():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = dpytest.back.make_guild("testMemberJoin", id_num=1234)
        test_config.guilds.append(guild)
        dpytest.back.make_role("testRole", guild, id_num=555)
        test_role = Roles(s_id=1234, r_id=555, email_suffix=TEST_EMAIL_DOMAIN)
        session.add(test_role)
        session.commit()
        welcome_message = f"""Welcome to testMemberJoin. This guild has verification enabled.
Please verify one of the following emails to get the appropriate role using `{koalabot.COMMAND_PREFIX}verify your_email@example.com`.
This email is stored so you don't need to verify it multiple times across servers.
`{TEST_EMAIL_DOMAIN}` for `@testRole`"""
        await dpytest.member_join(1)
        await asyncio.sleep(0.25)
        assert dpytest.verify().message().content(welcome_message)
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_member_join_already_verified(bot: commands.Bot):
    with session_manager() as session:
        guild = dpytest.back.make_guild("testMemberJoin", id_num=1234)
        bot._connection._guilds[guild.id] = guild

        test_user = dpytest.back.make_user("TestUser", 1234, id_num=999)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        test_verified_email = VerifiedEmails(u_id=999, email=f'egg@{TEST_EMAIL_DOMAIN}')
        test_role = Roles(s_id=1234, r_id=555, email_suffix=TEST_EMAIL_DOMAIN)
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        await dpytest.member_join(guild, test_user)
        await asyncio.sleep(0.25)
        welcome_message = f"""Welcome to testMemberJoin. This guild has verification enabled.
Please verify one of the following emails to get the appropriate role using `{koalabot.COMMAND_PREFIX}verify your_email@example.com`.
This email is stored so you don't need to verify it multiple times across servers.
`{TEST_EMAIL_DOMAIN}` for `@testRole`"""
        assert dpytest.verify().message().content(welcome_message)
        member = guild.get_member(test_user.id)
        assert role in member.roles

        session.delete(test_verified_email)
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_enable_verification():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")
        entry = session.execute(select(Roles).filter_by(s_id=guild.id, r_id=role.id)).all()
        assert entry
        session.execute(delete(Roles).filter_by(s_id=guild.id))
        session.commit()


@pytest.mark.asyncio
async def test_disable_verification():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        session.add(Roles(s_id=guild.id, r_id=555, email_suffix="egg.com"))
        session.commit()
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeVerification egg.com testRole")
        assert dpytest.verify().message().content("Emails ending with egg.com no longer give testRole")
        entry = session.execute(select(Roles).filter_by(s_id=guild.id, r_id=role.id)).all()
        assert not entry


@pytest.mark.asyncio
async def test_full_flow():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles


@pytest.mark.asyncio
async def test_blacklist():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklist {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will no longer receive testRole upon verifying with this email suffix")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role not in member.roles


@pytest.mark.asyncio
async def test_blacklist_remove():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklist {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will no longer receive testRole upon verifying with this email suffix")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyBlacklistRemove {member.id} testRole {TEST_EMAIL_DOMAIN}")
        assert dpytest.verify().message().content(
            f"{member} will now be able to receive testRole upon verifying with this email suffix")

        assert role in member.roles


@pytest.mark.asyncio
async def test_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        member = guild.members[0]
        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")
        entry = session.execute(select(NonVerifiedEmails).filter_by(u_id=member.id, email=TEST_EMAIL)).all()
        assert entry


@pytest.mark.asyncio
async def test_verify_twice():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

    dm = await member.create_dm()

    msg_mock: discord.Message = dpytest.back.make_message("n", member, dm)
    with mock.patch('discord.client.Client.wait_for',
                    mock.AsyncMock(return_value=msg_mock)):
        await dpytest.message(koalabot.COMMAND_PREFIX + "verify test@egg.com", dm)
    assert dpytest.verify().message().content(
        "This email is already assigned to your account. Would you like to verify anyway? (y/n)")
    assert dpytest.verify().message().content("Okay, you will not be verified with test@egg.com")


@pytest.mark.asyncio
async def test_verify_alternate_account_no():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        member2 = await dpytest.member_join(guild)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles
        assert role not in member2.roles

        dm2 = await member2.create_dm()

        msg_mock: discord.Message = dpytest.back.make_message("n", member2, dm2)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm2, member2)
        assert dpytest.verify().message().content(
            "This email is already assigned to a different account. Would you like to verify anyway? (y/n)")
        assert dpytest.verify().message().content(
            f"Okay, you will not be verified with {TEST_EMAIL}")


@pytest.mark.asyncio
async def test_verify_alternate_account_yes():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        member2 = await dpytest.member_join(guild)
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm)
        assert dpytest.verify().message().content("Please verify yourself using the command you have been emailed")

        token = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member.id, email=TEST_EMAIL)).scalar()

        assert role not in member.roles

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token}", dm)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member.roles
        assert role not in member2.roles

        dm2 = await member2.create_dm()

        msg_mock: discord.Message = dpytest.back.make_message("y", member2, dm2)
        with mock.patch('discord.client.Client.wait_for',
                        mock.AsyncMock(return_value=msg_mock)):
            await dpytest.message(koalabot.COMMAND_PREFIX + f"verify {TEST_EMAIL}", dm2, member2)
        assert dpytest.verify().message().content(
            "This email is already assigned to a different account. Would you like to verify anyway? (y/n)")
        assert dpytest.verify().message().content(
            "Please verify yourself using the command you have been emailed")

        assert role not in member.roles

        token2 = session.execute(select(NonVerifiedEmails.token).filter_by(u_id=member2.id, email=TEST_EMAIL)).scalar()

        await dpytest.message(koalabot.COMMAND_PREFIX + f"confirm {token2}", dm2, member2)
        assert dpytest.verify().message().content("Your email has been verified, thank you")

        assert role in member2.roles


@pytest.mark.asyncio
async def test_verify_list():
    with session_manager() as session:
        config = dpytest.get_config()
        guild = config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        await dpytest.message(koalabot.COMMAND_PREFIX + f"addVerification {TEST_EMAIL_DOMAIN} testRole")
        assert dpytest.verify().message().content(
            f"Verification enabled for testRole for emails ending with `{TEST_EMAIL_DOMAIN}`")

        await dpytest.message(koalabot.COMMAND_PREFIX + f"verifyList")

        expected_embeds = discord.Embed(title=f"Current verification setup for {guild.name}")
        expected_embeds.add_field(name=TEST_EMAIL_DOMAIN, value=f"@{role}")

        assert dpytest.verify().message().embed(expected_embeds)




@pytest.mark.asyncio
async def test_confirm():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        member = guild.members[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        test_role = Roles(s_id=guild.id, r_id=555, email_suffix="egg.com")
        test_verified_email = NonVerifiedEmails(u_id=member.id, email='test@egg.com', token='testtoken')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + "confirm testtoken", dm)
        verified = session.execute(select(VerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        exists = session.execute(select(NonVerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        assert verified
        assert not exists
        await asyncio.sleep(0.5)
        assert role in member.roles
        assert dpytest.verify().message().content("Your email has been verified, thank you")
        session.delete(test_role)
        session.execute(delete(VerifiedEmails).filter_by(u_id=member.id))
        session.commit()


@pytest.mark.asyncio
async def test_un_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        dm = await member.create_dm()
        await dpytest.message(koalabot.COMMAND_PREFIX + "unVerify test@egg.com", dm)
        assert dpytest.verify().message().content(
            "test@egg.com has been un-verified and relevant roles have been removed")
        entry = session.execute(select(VerifiedEmails).filter_by(u_id=member.id, email="test@egg.com")).all()
        assert not entry
        assert role not in member.roles
        session.delete(test_role)
        session.commit()


@pytest.mark.asyncio
async def test_get_emails():
    with session_manager() as session:
        test_verified_email = VerifiedEmails(u_id=123, email=TEST_EMAIL)
        session.add(test_verified_email)
        session.commit()
    await dpytest.message(koalabot.COMMAND_PREFIX + "getEmails 123")
    assert dpytest.verify().message().content(f"""This user has registered with:\n{TEST_EMAIL}""")
    with session_manager() as session:
        session.delete(test_verified_email)
        session.commit()


@pytest.mark.asyncio
async def test_re_verify():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555555555555555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        session.add(test_verified_email)
        session.add(test_role)
        session.commit()

        await dpytest.message(koalabot.COMMAND_PREFIX + "reVerify <@&555555555555555>")
        assert role not in member.roles
        blacklisted = session.execute(select(ToReVerify).filter_by(u_id=member.id)).all()
        assert blacklisted
        assert dpytest.verify().message().content(
            "That role has now been removed from all users and they will need to re-verify the associated email.")
        session.delete(test_verified_email)
        session.delete(test_role)
        session.execute(delete(ToReVerify).filter_by(u_id=member.id))
        session.commit()

@pytest.mark.asyncio
async def test_re_verify_duplicate():
    with session_manager() as session:
        test_config = dpytest.get_config()
        guild = test_config.guilds[0]
        role = dpytest.back.make_role("testRole", guild, id_num=555555555555555)
        member = test_config.members[0]
        await dpytest.add_role(member, role)
        test_verified_email = VerifiedEmails(u_id=member.id, email='test@egg.com')
        test_role = Roles(s_id=guild.id, r_id=role.id, email_suffix='egg.com')
        test_re_verify = ToReVerify(u_id=member.id, r_id=role.id)
        session.add(test_verified_email)
        session.add(test_role)
        session.add(test_re_verify)
        session.commit()

        await dpytest.message(koalabot.COMMAND_PREFIX + "reVerify <@&555555555555555>")
        assert role not in member.roles
        blacklisted = session.execute(select(ToReVerify).filter_by(u_id=member.id)).all()
        assert blacklisted
        assert dpytest.verify().message().content(
            "That role has now been removed from all users and they will need to re-verify the associated email.")
        session.delete(test_verified_email)
        session.delete(test_role)
        session.execute(delete(ToReVerify).filter_by(u_id=member.id))
        session.commit()


</document_content>
</document>
<document index="33">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/verification/test_core.py</source>
<document_content>
import pytest

import discord.ext.test as dpytest
from sqlalchemy import select
from sqlalchemy.orm import Session

from koala.cogs.verification import core
from koala.cogs.verification.models import ToReVerify, VerifiedEmails, NonVerifiedEmails, Roles, VerifyBlacklist


@pytest.mark.asyncio
async def test_confirm_reverify(bot, session: Session):
    await dpytest.get_config().guilds[0].create_role(name="emailRole")

    guild = dpytest.get_config().guilds[0]
    user_id = guild.members[0].id
    role_id = guild.roles[1].id
    email_suffix = "@gmail.com"
    email = "testemail"+email_suffix
    token = "12345"

    session.add(ToReVerify(u_id=user_id, r_id=role_id))
    session.add(VerifiedEmails(u_id=user_id, email=email))
    session.add(NonVerifiedEmails(u_id=user_id, email=email, token=token))
    session.add(Roles(s_id=guild.id, r_id=role_id, email_suffix=email_suffix))

    await core.email_verify_confirm(user_id, token, bot, session=session)

    assert session.execute(select(ToReVerify)).all() == []
    assert session.execute(select(NonVerifiedEmails)).all() == []
    assert len(session.execute(select(VerifiedEmails)).all()) == 1


def test_grouped_list_blacklist(bot, session):
    guild = dpytest.get_config().guilds[0]
    user = guild.members[0]
    role = guild.roles[0]

    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test.com"))

    blacklist_map = core.grouped_list_blacklist(guild.id, bot, session=session)

    assert blacklist_map == {user.name: [role.mention+" / @test.com"]}


def test_grouped_list_blacklist_multiple(bot, session):
    guild = dpytest.get_config().guilds[0]
    user = guild.members[0]
    role = guild.roles[0]

    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test.com"))
    session.add(VerifyBlacklist(user_id=user.id, role_id=role.id, email_suffix="@test2.com"))

    blacklist_map = core.grouped_list_blacklist(guild.id, bot, session=session)

    assert blacklist_map == {user.name: [role.mention+" / @test.com", role.mention+" / @test2.com"]}


</document_content>
</document>
<document index="34">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="35">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_cog.py</source>
<document_content>
# Futures

# Built-in/Generic Imports
import asyncio

import discord
# Libs
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, and_

# Own modules
import koalabot
from koala.cogs import twitch_alert
from koala.cogs.twitch_alert import cog
from koala.cogs.twitch_alert.models import UserInTwitchAlert
from koala.colours import KOALA_GREEN
from koala.db import session_manager
from tests.tests_utils.last_ctx_cog import LastCtxCog

# Constants
DB_PATH = "Koala.db"


# Variables

@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await cog.setup(bot)
    mock1.assert_called()


@pytest_asyncio.fixture
async def twitch_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    twitch_cog = cog.TwitchAlert(bot)
    await bot.add_cog(twitch_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return twitch_cog


@mock.patch("koalabot.check_guild_has_ext", mock.MagicMock(return_value=True))
def test_twitch_is_enabled_true(twitch_cog):
    assert cog.twitch_is_enabled(None)


@mock.patch("koalabot.is_dm_channel", mock.MagicMock(return_value=True))
def test_twitch_is_enabled_dm():
    assert not cog.twitch_is_enabled(None)


@mock.patch("koalabot.is_dm_channel", mock.MagicMock(return_value=False))
@mock.patch("koalabot.is_dpytest", False)
@pytest.mark.asyncio
async def test_twitch_is_enabled_false(twitch_cog: cog.TwitchAlert):
    last_ctx_cog = LastCtxCog(bot=twitch_cog.bot)
    await twitch_cog.bot.add_cog(last_ctx_cog)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx", channel=-1)
    ctx: commands.Context = last_ctx_cog.get_last_ctx()

    assert not cog.twitch_is_enabled(ctx)


# @mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7357))
@pytest.mark.order(1)
@pytest.mark.asyncio
async def test_edit_default_message_default_from_none(twitch_cog):
    this_channel = dpytest.get_config().channels[0]
    assert_embed = discord.Embed(title="Default Message Edited",
                                 description=f"Guild: {dpytest.get_config().guilds[0].id}\n"
                                             f"Channel: {this_channel.id}\n"
                                             f"Default Message: {twitch_alert.utils.DEFAULT_MESSAGE}")

    await dpytest.message(koalabot.COMMAND_PREFIX + f"twitch editMsg {this_channel.id}")
    assert dpytest.verify().message().embed(embed=assert_embed)


# @mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7357))
@pytest.mark.order(2)
@pytest.mark.asyncio
async def test_edit_default_message_existing(twitch_cog):
    this_channel = dpytest.get_config().channels[0]
    assert_embed = discord.Embed(title="Default Message Edited",
                                 description=f"Guild: {dpytest.get_config().guilds[0].id}\n"
                                             f"Channel: {this_channel.id}\n"
                                             "Default Message: {user} is bad")

    await dpytest.message(koalabot.COMMAND_PREFIX + "twitch editMsg " + str(this_channel.id) + " {user} is bad")
    assert dpytest.verify().message().embed(embed=assert_embed)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert(twitch_cog):
    assert_embed = discord.Embed(title="Added User to Twitch Alert",
                                 description=f"Channel: {dpytest.get_config().channels[0].id}\n"
                                             f"User: monstercat\n"
                                             f"Message: {twitch_alert.utils.DEFAULT_MESSAGE}",
                                 colour=KOALA_GREEN)

    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {dpytest.get_config().channels[0].id}")
    assert dpytest.verify().message().embed(embed=assert_embed)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert_wrong_guild(twitch_cog: twitch_alert.cog.TwitchAlert):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().guilds[0].channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {dpytest.get_config().guilds[0].channels[0].id}",
        channel=-1, member=member)

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_add_user_to_twitch_alert_custom_message(twitch_cog: twitch_alert.cog.TwitchAlert):
    test_custom_message = "We be live gamers!"

    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    assert_embed = discord.Embed(title="Added User to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"User: monstercat\n"
                                             f"Message: {test_custom_message}",
                                 colour=KOALA_GREEN)

    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {channel.id} {test_custom_message}", channel=-1,
        member=member)
    assert dpytest.verify().message().embed(embed=assert_embed)

    sql_check_updated_server = select(UserInTwitchAlert.custom_message).where(
        and_(UserInTwitchAlert.twitch_username == 'monstercat', UserInTwitchAlert.channel_id == channel.id))
    with session_manager() as session:
        result = session.execute(sql_check_updated_server).one()
    assert result.custom_message == test_custom_message


@pytest.mark.asyncio()
async def test_remove_user_from_twitch_alert_with_message(twitch_cog: twitch_alert.cog.TwitchAlert):
    test_custom_message = "We be live gamers!"

    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    # Creates Twitch Alert
    await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch add monstercat {channel.id} {test_custom_message}", channel=-1,
        member=member)

    sql_check_updated_server = select(UserInTwitchAlert.custom_message).where(and_(UserInTwitchAlert.twitch_username == 'monstercat', UserInTwitchAlert.channel_id == channel.id))
    with session_manager() as session:
        result_before = session.execute(sql_check_updated_server).one()

        assert result_before.custom_message == test_custom_message
        await dpytest.empty_queue()
        # Removes Twitch Alert
        await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch remove monstercat {channel.id}", channel=-1,
                              member=member)
        new_embed = discord.Embed(title="Removed User from Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel.id}\n"
                                              f"User: monstercat")
        assert dpytest.verify().message().embed(new_embed)
        result_after = session.execute(sql_check_updated_server).one_or_none()
        assert result_after is None

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_remove_user_from_twitch_alert_wrong_guild(twitch_cog):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch remove monstercat {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    assert_embed = discord.Embed(title="Added Team to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"Team: faze\n"
                                             f"Message: {twitch_alert.utils.DEFAULT_MESSAGE}",
                                 colour=KOALA_GREEN)
    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id}", channel=-1,
                          member=member)
    assert dpytest.verify().message().embed(assert_embed)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert_with_message(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    assert_embed = discord.Embed(title="Added Team to Twitch Alert",
                                 description=f"Channel: {channel.id}\n"
                                             f"Team: faze\n"
                                             f"Message: wooo message",
                                 colour=KOALA_GREEN)
    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id} wooo message",
                          channel=-1, member=member)
    assert dpytest.verify().message().embed(assert_embed)


@pytest.mark.asyncio()
async def test_add_team_to_twitch_alert_wrong_guild(twitch_cog):
    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)
    # Creates Twitch Alert
    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
async def test_remove_team_from_twitch_alert_with_message(twitch_cog):
    test_custom_message = "We be live gamers!"

    # Creates guild and channels and adds user and bot
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(-1, name="TestUser", discrim=1)
    await dpytest.member_join(-1, dpytest.get_config().client.user)

    # Creates Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {channel.id} {test_custom_message}",
                          channel=-1, member=member)
    await dpytest.empty_queue()
    # Removes Twitch Alert
    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch removeTeam faze {channel.id}", channel=-1,
                          member=member)
    new_embed = discord.Embed(title="Removed Team from Twitch Alert", colour=KOALA_GREEN,
                              description=f"Channel: {channel.id}\n"
                                          f"Team: faze")
    assert dpytest.verify().message().embed(new_embed)
    pass

@pytest.mark.order(3)
@pytest.mark.asyncio
async def test_remove_team_from_twitch_alert_wrong_guild(twitch_cog):
    guild = dpytest.backend.make_guild(name="TestGuild")
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=guild)
    dpytest.get_config().guilds.append(guild)
    dpytest.get_config().channels.append(channel)
    member = await dpytest.member_join(1, name="TestUser", discrim=1)
    await dpytest.member_join(1, dpytest.get_config().client.user)

    with pytest.raises(discord.ext.commands.errors.ChannelNotFound,
                       match=f"Channel \"{dpytest.get_config().channels[0].id}\" not found."):
        await dpytest.message(
        f"{koalabot.COMMAND_PREFIX}twitch addTeam faze {dpytest.get_config().channels[0].id}",
        channel=-1, member=member)


@pytest.mark.asyncio()
@pytest.mark.first
async def test_on_ready(twitch_cog: twitch_alert.cog.TwitchAlert):
    with mock.patch.object(twitch_alert.cog.TwitchAlert, 'start_loops') as mock1:
        await twitch_cog.on_ready()
    mock1.assert_called_with()


@mock.patch("koala.utils.random_id", mock.MagicMock(return_value=7363))
@mock.patch("cogs.twitch_alert.TwitchAPIHandler.get_streams_data",
            mock.MagicMock(return_value={'id': '3215560150671170227', 'user_id': '27446517',
                                         "user_name": "Monstercat", 'game_id': "26936", 'type': 'live',
                                         'title': 'Music 24/7'}))
@pytest.mark.skip(reason="Issues with testing inside asyncio event loop, not implemented")
@pytest.mark.asyncio
async def test_loop_check_live(twitch_cog: twitch_alert.cog.TwitchAlert):
    this_channel = dpytest.get_config().channels[0]
    expected_embed = discord.Embed(colour=koalabot.KOALA_GREEN,
                                   title="<:twitch:734024383957434489>  Monstercat is now streaming!",
                                   description="https://twitch.tv/monstercat")
    expected_embed.add_field(name="Stream Title", value="Non Stop Music - Monstercat Radio :notes:")
    expected_embed.add_field(name="Playing", value="Music & Performing Arts")
    expected_embed.set_thumbnail(url="https://static-cdn.jtvnw.net/jtv_user_pictures/"
                                     "monstercat-profile_image-3e109d75f8413319-300x300.jpeg")

    await dpytest.message(f"{koalabot.COMMAND_PREFIX}twitch add monstercat 7363")
    await dpytest.empty_queue()
    twitch_cog.start_loop()
    await asyncio.sleep(10)
    assert dpytest.verify().message().embed(expected_embed)


@pytest.mark.skip(reason="Issues with testing inside asyncio event loop, not implemented")
@pytest.mark.asyncio
async def test_loop_check_team_live(twitch_cog):
    assert False, "Not Implemented"



</document_content>
</document>
<document index="36">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_db.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot twitch_alert

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

import discord
# Libs
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands
from sqlalchemy import select, update, insert, delete, and_, or_
from twitchAPI.object import Stream

from koala.cogs.twitch_alert import utils
# Own modules
from koala.cogs.twitch_alert.cog import TwitchAlert
from koala.cogs.twitch_alert.db import TwitchAlertDBManager
from koala.cogs.twitch_alert.models import TwitchAlerts, TeamInTwitchAlert, UserInTwitchTeam, UserInTwitchAlert
from koala.db import session_manager

# Constants
DB_PATH = "Koala.db"


# Variables

@pytest_asyncio.fixture
async def twitch_cog(bot: discord.ext.commands.Bot):
    """ setup any state specific to the execution of the given module."""
    twitch_cog = TwitchAlert(bot)
    await bot.add_cog(twitch_cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return twitch_cog


@pytest_asyncio.fixture
async def twitch_alert_db_manager(twitch_cog: TwitchAlert):
    twitch_alert_db_manager = TwitchAlertDBManager(twitch_cog.bot)
    await twitch_alert_db_manager.setup_twitch_handler()
    return twitch_alert_db_manager


@pytest.fixture(autouse=True)
def twitch_alert_db_manager_tables(twitch_alert_db_manager):
    with session_manager() as session:
        session.execute(delete(TwitchAlerts))
        session.execute(delete(TeamInTwitchAlert))
        session.execute(delete(UserInTwitchAlert))
        session.execute(delete(UserInTwitchTeam))
        session.commit()
        return twitch_alert_db_manager


def test_create_tables():
    tables = ['TwitchAlerts', 'UserInTwitchAlert', 'TeamInTwitchAlert', 'UserInTwitchTeam']
    sql_check_table_exists = "SELECT name FROM sqlite_master " \
                             "WHERE type='table' AND " \
                             "name IN ('TwitchAlerts', 'UserInTwitchAlert', 'TeamInTwitchAlert', 'UserInTwitchTeam');"
    with session_manager() as session:
        tables_found = session.execute(sql_check_table_exists).all()
    for table in tables_found:
        assert table.name in tables


def test_new_ta(twitch_alert_db_manager_tables):
    assert utils.DEFAULT_MESSAGE == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=2345)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 2345)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == utils.DEFAULT_MESSAGE


def test_new_ta_message(twitch_alert_db_manager_tables):
    test_message = "Test message"
    assert test_message == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=23456,
                                                                 default_message=test_message)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 23456)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == test_message


def test_new_ta_replace(twitch_alert_db_manager_tables):
    test_message = "Test message2"
    test_new_ta_message(twitch_alert_db_manager_tables=twitch_alert_db_manager_tables)
    assert test_message == twitch_alert_db_manager_tables.new_ta(guild_id=1234, channel_id=23456,
                                                                 default_message=test_message, replace=True)

    sql_check_db_updated = select(TwitchAlerts.guild_id, TwitchAlerts.default_message)\
        .where(TwitchAlerts.channel_id == 23456)
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_check_db_updated).fetchone()
    assert result.guild_id == 1234
    assert result.default_message == test_message


def test_add_user_to_ta_default_message(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.new_ta(1234, 1234567891, None)
    twitch_alert_db_manager_tables.add_user_to_ta(1234567891, "monstercat", None, 1234)

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567891, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_find_twitch_alert).fetchone()
    assert result.twitch_username == 'monstercat'
    assert result.custom_message is None


def test_add_user_to_ta_custom_message(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.new_ta(1234, 1234567892, None)
    twitch_alert_db_manager_tables.add_user_to_ta(1234567892, "monstercat", "FiddleSticks {user} is live!", 1234)

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567892, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        result: TwitchAlerts = session.execute(sql_find_twitch_alert).fetchone()
    assert result.twitch_username == 'monstercat'
    assert result.custom_message == "FiddleSticks {user} is live!"


@pytest.mark.asyncio()
async def test_remove_user_from_ta(twitch_alert_db_manager_tables):
    test_add_user_to_ta_default_message(twitch_alert_db_manager_tables)
    await twitch_alert_db_manager_tables.remove_user_from_ta(1234567891, "monstercat")

    sql_find_twitch_alert = select(UserInTwitchAlert.twitch_username, UserInTwitchAlert.custom_message)\
        .where(and_(UserInTwitchAlert.channel_id == 1234567891, UserInTwitchAlert.twitch_username == 'monstercat'))
    with session_manager() as session:
        assert session.execute(sql_find_twitch_alert).one_or_none() is None


@pytest.mark.asyncio()
async def test_delete_message(twitch_alert_db_manager_tables, session):
    with mock.patch.object(discord.TextChannel, 'fetch_message') as mock1:
        await twitch_alert_db_manager_tables.delete_message(1234, dpytest.get_config().channels[0].id, session=session)
    mock1.assert_called_with(1234)


def test_add_team_to_ta(twitch_alert_db_manager_tables):
    twitch_alert_db_manager_tables.add_team_to_ta(channel_id=566, twitch_team="faze", custom_message=None, guild_id=568)

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 566, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        result: TeamInTwitchAlert = session.execute(sql_select_team).fetchone()

    assert result.custom_message is None


def test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=573, guild_id=574):
    twitch_alert_db_manager_tables.add_team_to_ta(channel_id=channel_id, twitch_team="faze",
                                                  custom_message="Message here", guild_id=guild_id)

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == channel_id, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        result: TeamInTwitchAlert = session.execute(sql_select_team).fetchone()

    assert result.custom_message == "Message here"


@pytest.mark.asyncio()
async def test_remove_team_from_ta(twitch_alert_db_manager_tables):
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    await twitch_alert_db_manager_tables.remove_team_from_ta(590, "faze")

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 590, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        assert session.execute(sql_select_team).one_or_none() is None


@pytest.mark.asyncio()
async def test_remove_team_from_ta_duplicate(twitch_alert_db_manager_tables):
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    test_add_team_to_ta_custom_message(twitch_alert_db_manager_tables, channel_id=590, guild_id=591)
    await twitch_alert_db_manager_tables.remove_team_from_ta(590, "faze")

    sql_select_team = select(TeamInTwitchAlert.custom_message)\
        .where(and_(TeamInTwitchAlert.channel_id == 590, TeamInTwitchAlert.twitch_team_name == 'faze'))
    with session_manager() as session:
        assert session.execute(sql_select_team).one_or_none() is not None


@pytest.mark.asyncio()
async def test_remove_team_from_ta_invalid(twitch_alert_db_manager_tables):
    with pytest.raises(AttributeError,
                       match="Team name not found"):
        await twitch_alert_db_manager_tables.remove_team_from_ta(590, 590)


@pytest.mark.asyncio()
async def test_remove_team_from_ta_deletes_messages(twitch_alert_db_manager_tables):
    await test_update_team_members(twitch_alert_db_manager_tables)

    test = update(UserInTwitchTeam)\
        .where(and_(UserInTwitchTeam.team_twitch_alert_id == 604,
                    UserInTwitchTeam.twitch_username == 'monstercat')).values(message_id=1)
    with session_manager() as session:
        session.execute(test)
        session.commit()

    with mock.patch.object(TwitchAlertDBManager, 'delete_message') as mock1:
        await twitch_alert_db_manager_tables.remove_team_from_ta(605, "monstercat")
    mock1.assert_called_with(1, 605, session=mock.ANY)


@pytest.mark.asyncio()
async def test_update_team_members(twitch_alert_db_manager_tables):
    sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
        team_twitch_alert_id=604, channel_id=605, twitch_team_name='monstercat')
    with session_manager() as session:
        session.execute(sql_insert_monstercat_team)
        session.commit()

        await twitch_alert_db_manager_tables.update_team_members(604, "monstercat")

        sql_select_monstercat_team = select(UserInTwitchTeam).where(and_(UserInTwitchTeam.team_twitch_alert_id == 604,
                                                                         UserInTwitchTeam.twitch_username == 'monstercat'))

        result = session.execute(sql_select_monstercat_team)
        assert result.one_or_none() is not None


@pytest.mark.asyncio()
async def test_update_all_teams_members(twitch_alert_db_manager_tables):
    sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
        team_twitch_alert_id=614, channel_id=615, twitch_team_name='monstercat')
    with session_manager() as session:
        session.execute(sql_insert_monstercat_team)

        sql_insert_monstercat_team = insert(TeamInTwitchAlert).values(
            team_twitch_alert_id=616, channel_id=617, twitch_team_name='monstercat')
        session.execute(sql_insert_monstercat_team)
        session.commit()

        await twitch_alert_db_manager_tables.update_all_teams_members()

        sql_select_monstercats_team = select(UserInTwitchTeam.twitch_username).where(and_(
                or_(UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
                UserInTwitchTeam.twitch_username == 'monstercat'))

        result = session.execute(sql_select_monstercats_team).all()
        assert len(result) == 2


@pytest.mark.asyncio()
async def test_delete_all_offline_streams(twitch_alert_db_manager_tables, bot: discord.ext.commands.Bot):
    message_id = (await dpytest.message("test_msg", bot.guilds[0].channels[0])).id
    sql_add_message = insert(UserInTwitchAlert).values(
        channel_id=bot.guilds[0].channels[0].id,
        twitch_username='monstercat',
        custom_message=None,
        message_id=message_id)
    with session_manager() as session:
        session.execute(sql_add_message)
        session.commit()

        await twitch_alert_db_manager_tables.delete_all_offline_streams(['monstercat'], session=session)

        sql_select_messages = select(UserInTwitchAlert).where(and_(
            UserInTwitchAlert.twitch_username == 'monstercat',
            UserInTwitchAlert.channel_id == bot.guilds[0].channels[0].id))
        result = session.execute(sql_select_messages).scalars().one_or_none()

        assert result is not None
        assert result.message_id is None
        with pytest.raises(discord.errors.NotFound,
                           match="Unknown Message"):
            await bot.guilds[0].channels[0].fetch_message(message_id)


@pytest.mark.asyncio()
async def test_delete_all_offline_streams_team(twitch_alert_db_manager_tables, bot: discord.ext.commands.Bot):
    await test_update_all_teams_members(twitch_alert_db_manager_tables)

    sql_add_message = update(UserInTwitchTeam).where(and_(or_(
        UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
        UserInTwitchTeam.twitch_username == 'monstercat')).values(message_id=1)
    with session_manager() as session:
        session.execute(sql_add_message)
        session.commit()

        await twitch_alert_db_manager_tables.delete_all_offline_team_streams(['monstercat'], session=session)

        sql_select_messages = select(UserInTwitchTeam.message_id, UserInTwitchTeam.twitch_username).where(
            and_(or_(UserInTwitchTeam.team_twitch_alert_id == 614, UserInTwitchTeam.team_twitch_alert_id == 616),
                 UserInTwitchTeam.twitch_username == 'monstercat'))
        result = session.execute(sql_select_messages).fetchall()

        assert len(result) == 2
        assert result[0].message_id is None
        assert result[1].message_id is None


@pytest.mark.asyncio
async def test_create_alert_embed(twitch_alert_db_manager_tables):
    stream_data = Stream(id='3215560150671170227', user_id='27446517', user_name="Monstercat", user_login="monstercat",
                         game_id="26936", type='live', title='Music 24/7')

    assert type(await twitch_alert_db_manager_tables.create_alert_embed(stream_data, None)) is discord.Embed

</document_content>
</document>
<document index="37">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_twitch_handler.py</source>
<document_content>
import pytest
import pytest_asyncio

from koala.cogs.twitch_alert.env import TWITCH_KEY, TWITCH_SECRET
from koala.cogs.twitch_alert.twitch_handler import TwitchAPIHandler


@pytest_asyncio.fixture
async def twitch_api_handler():
    twitch_api_handler = TwitchAPIHandler()
    await twitch_api_handler.setup(TWITCH_KEY, TWITCH_SECRET)
    return twitch_api_handler


@pytest.mark.asyncio
async def test_get_streams_data(twitch_api_handler):
    usernames = ['monstercat', 'jaydwee']
    streams_data = await twitch_api_handler.get_streams_data(usernames)
    assert streams_data is not None


@pytest.mark.asyncio
async def test_get_user_data(twitch_api_handler):
    assert await twitch_api_handler.get_user_data('monstercat') is not None


@pytest.mark.asyncio
async def test_get_game_data(twitch_api_handler):
    assert 'music' in (await twitch_api_handler.get_game_data('26936')).name.lower()


@pytest.mark.asyncio
async def test_get_team_users(twitch_api_handler):
    # assumes uosvge is in the team called uosvge
    members = await twitch_api_handler.get_team_users('uosvge')
    for member in members:
        if member.user_login == 'uosvge':
            assert True
            return
    assert False

</document_content>
</document>
<document index="38">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/twitch_alert/test_utils.py</source>
<document_content>
# Futures

# Built-in/Generic Imports

import discord
# Libs
import discord.ext.test as dpytest
from twitchAPI.object import Stream, TwitchUser, Game

# Own modules
from koala.cogs.twitch_alert import utils
from koala.colours import KOALA_GREEN

# Constants
DB_PATH = "Koala.db"


# Variables


def test_create_live_embed():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="TestGame")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")
    game_info = Game(name="TestGame")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, game_info, "")
    assert dpytest.embed_eq(result, expected)


def test_create_live_embed_with_message():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test", description="Hello Message")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="TestGame")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")
    game_info = Game(name="TestGame")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, game_info, "Hello Message")
    assert dpytest.embed_eq(result, expected)


def test_create_live_embed_without_game():
    # Create the expected embed with information required
    expected = discord.Embed(colour=KOALA_GREEN, title="https://twitch.tv/test", description="Hello Message")
    expected.set_author(name="Test is now streaming!", icon_url=utils.TWITCH_ICON)
    expected.add_field(name="Stream Title", value="Test Title")
    expected.add_field(name="Playing", value="No Category")
    expected.set_thumbnail(url="http://koalabot.uk")

    # Create JSON required to pass to method
    stream_info = Stream(user_name="Test", user_login="test", title="Test Title")
    user_info = TwitchUser(profile_image_url="http://koalabot.uk")

    # Get response and assert equal
    result = utils.create_live_embed(stream_info, user_info, None, "Hello Message")
    assert dpytest.embed_eq(result, expected)


def test_split_to_100s_small():
    assert len(utils.split_to_100s(list(range(1,99)))) == 1


def test_split_to_100s_medium():
    assert len(utils.split_to_100s(list(range(1,150)))) == 2


def test_split_to_100s_large():
    result = utils.split_to_100s(list(range(1, 1501)))
    assert len(result) == 16
    for res in result:
        assert len(res) <= 100


def test_split_to_100s_empty():
    result = utils.split_to_100s([])
    assert result == []

</document_content>
</document>
<document index="39">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="40">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/text_filter/test_cog.py</source>
<document_content>
#!/usr/bin/env python
"""
Testing KoalaBot TextFilter
"""

# Libs
import discord
import discord.ext.test as dpytest
import pytest
import pytest_asyncio
from sqlalchemy import select, delete

# Own modules
import koalabot
from koala.cogs import BaseCog
from koala.cogs import TextFilter as TextFilterCog
from koala.cogs.text_filter.db import TextFilterDBManager
from koala.cogs.text_filter.models import TextFilter, TextFilterModeration
from koala.colours import KOALA_GREEN
from koala.db import session_manager
from koala.utils import is_int
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Variables


@pytest_asyncio.fixture(scope="function", autouse=True)
async def utils_cog(bot: discord.ext.commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def base_cog(bot: discord.ext.commands.Bot):
    base_cog = BaseCog(bot)
    await bot.add_cog(base_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return base_cog


@pytest_asyncio.fixture(scope="function", autouse=True)
async def tf_cog(bot: discord.ext.commands.Bot):
    tf_cog = TextFilterCog(bot)
    await bot.add_cog(tf_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return tf_cog


def assert_banned_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " has been deleted by KoalaBot.")


def assert_risky_warning(word):
    assert dpytest.verify().message().content(
        "Watch your language! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " contains a 'risky' word. This is a warning.")


def assert_email_warning(word):
    assert dpytest.verify().message().content(
        "Be careful! Your message: '*" + word + "*' in " + dpytest.get_config().guilds[0].channels[
            0].mention + " includes personal information and has been deleted by KoalaBot.")


def assert_filtered_confirmation(word, type):
    assert dpytest.verify().message().content("*" + word + "* has been filtered as **" + type + "**.")


def assert_new_ignore(id):
    assert dpytest.verify().message().content("New ignore added: " + id)


def assert_remove_ignore(id):
    assert dpytest.verify().message().content("Ignore removed: " + id)


def create_new_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Added"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def list_mod_channel_embed(channels):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for channel in channels:
        embed.add_field(name="Name & Channel ID", value=channel.mention + " " + str(channel.id), inline=False)
    return embed


def list_ignored_embed(ignored):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Ignored Users/Channels"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    for ig in ignored:
        embed.add_field(name="Name & ID", value=ig.mention + " " + str(ig.id))
    return embed


def remove_mod_channel_embed(channel):
    embed = discord.Embed()
    embed.title = "Koala Moderation - Mod Channel Removed"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=str(channel.id))
    return embed


def create_filtered_string(text):
    create_text_string = ""
    for current in text:
        create_text_string += current + "\n"
    return create_text_string


def filtered_words_embed(words, filter, regex):
    word_string = create_filtered_string(words)
    filter_string = create_filtered_string(filter)
    regex_string = create_filtered_string(regex)
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="Banned Words", value=word_string)
    embed.add_field(name="Filter Types", value=filter_string)
    embed.add_field(name="Is Regex?", value=regex_string)
    return embed

def no_filtered_words_embed():
    embed = discord.Embed()
    embed.title = "Koala Moderation - Filtered Words"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    embed.add_field(name="No words found", value="For more help with using the Text Filter try k!help TextFilter")
    return embed


def cleanup(guild_id, tf_cog, session):
    session.execute(delete(TextFilter).filter_by(guild_id=guild_id))


@pytest.mark.asyncio()
async def test_filter_new_word_correct_database(tf_cog):
    with session_manager() as session:
        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word no",
                              channel=dpytest.get_config().guilds[0].channels[0])
        assert_filtered_confirmation("no", "banned")
        assert len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text="no")).all()) == old + 1
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_filter_empty_word():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word")


@pytest.mark.asyncio()
async def test_filter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word a b c d e f g")


@pytest.mark.asyncio()
async def test_filter_risky_word(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word yup risky")
        assert_filtered_confirmation("yup", "risky")

        await dpytest.message("yup test")
        assert_risky_warning("yup test")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unrecognised_filter_type():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word testy unknown")


@pytest.mark.asyncio()
async def test_filter_email_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_invalid_regex(tf_cog):
    with session_manager() as session:
        with pytest.raises(Exception):
            await dpytest.message(koalabot.COMMAND_PREFIX + "filter_regex [")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_normal_filter_does_not_recognise_regex():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter \"^verify [a-zA-Z0-9]+@soton.ac.uk$\"")
    assert_filtered_confirmation("^verify [a-zA-Z0-9]+@soton.ac.uk$", "banned")

    await dpytest.message("verify abc@soton.ac.uk")
    assert dpytest.verify().message().nothing()


@pytest.mark.asyncio()
async def test_filter_various_emails_with_regex(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + r"filter_regex [a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]")
        assert_filtered_confirmation(r"[a-z0-9]+[\._]?[a-z0-9]+[@]+[herts]+[.ac.uk]", "banned")

        # Should delete and warn
        await dpytest.message("hey stefan@herts.ac.uk")
        assert_banned_warning("hey stefan@herts.ac.uk")

        # Should delete and warn
        await dpytest.message("hey stefan.c.27.abc@herts.ac.uk")
        assert_banned_warning("hey stefan.c.27.abc@herts.ac.uk")

        # Should not warn
        await dpytest.message("hey herts.ac.uk")
        assert dpytest.verify().message().nothing()

        # Should not warn
        await dpytest.message("hey stefan@herts")
        assert dpytest.verify().message().nothing()

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_word_correct_database(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word unfilterboi")
        assert_filtered_confirmation("unfilterboi", "banned")

        old = len(session.execute(select(TextFilter.filtered_text).filter_by(filtered_text='unfilterboi')).all())
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word unfilterboi")

        assert len(session.execute(select(TextFilter.filtered_text)
                                   .filter_by(filtered_text='unfilterboi')).all()) == old - 1
        assert dpytest.verify().message().content("*unfilterboi* has been unfiltered.")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_unfilter_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word")


@pytest.mark.asyncio()
async def test_unfilter_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unfilter_word a b c d e")


@pytest.mark.asyncio()
async def test_list_filtered_words(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing1")
        assert_filtered_confirmation("listing1", "banned")
        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word listing2 risky")
        assert_filtered_confirmation("listing2", "risky")

        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = filtered_words_embed(['listing1', 'listing2'], ['banned', 'risky'], ['0', '0'])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_filtered_words_empty(tf_cog):
    with session_manager() as session:
        await dpytest.message(koalabot.COMMAND_PREFIX + "check_filtered_words")
        assert_embed = no_filtered_words_embed()
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.fixture
def text_filter_db_manager():
    return TextFilterDBManager(dpytest.get_config())


@pytest.mark.asyncio()
async def test_add_mod_channel_tag(text_filter_db_manager, tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel <#" + str(channel.id) + ">")
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        result = session.execute(select(TextFilterModeration.channel_id).filter_by(guild_id=channel.guild.id)).all()
        assert is_int(result[0][0])
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_add_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel")


@pytest.mark.asyncio()
async def test_add_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel 123")


@pytest.mark.asyncio()
async def test_add_mod_channel_too_many_arguments():
    channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
    dpytest.get_config().channels.append(channel)
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id) + " a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        channel_id = str(channel.id)
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + channel_id)
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel " + channel_id)
        assert_embed = remove_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_remove_mod_channel_empty():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel")


@pytest.mark.asyncio()
async def test_remove_mod_channel_too_many_arguments():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_remove_mod_channel_unrecognised_channel():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "removeModChannel 123 a b c d e")


@pytest.mark.asyncio()
async def test_list_channels(tf_cog):
    with session_manager() as session:
        channel = dpytest.backend.make_text_channel(name="TestChannel", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel.id))
        assert_embed = create_new_mod_channel_embed(channel)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_list_multiple_channels(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])
        channel2 = dpytest.backend.make_text_channel(name="TestChannel2", guild=dpytest.get_config().guilds[0])
        dpytest.get_config().channels.append(channel1)
        dpytest.get_config().channels.append(channel2)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel1.id))
        assert_embed = create_new_mod_channel_embed(channel1)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "setupModChannel " + str(channel2.id))
        assert_embed = create_new_mod_channel_embed(channel2)
        assert dpytest.verify().message().embed(embed=assert_embed)

        await dpytest.message(koalabot.COMMAND_PREFIX + "listModChannels")
        assert_embed = list_mod_channel_embed([channel1, channel2])
        assert dpytest.verify().message().embed(embed=assert_embed)
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_channel(tf_cog):
    with session_manager() as session:
        channel1 = dpytest.backend.make_text_channel(name="TestChannel1", guild=dpytest.get_config().guilds[0])

        await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreme")
        assert_filtered_confirmation("ignoreme", "banned")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreChannel " + channel1.mention)
        assert_new_ignore(channel1.mention)

        # Should be ignored
        await dpytest.message("ignoreme", channel=channel1)

        # Should be deleted and warned
        await dpytest.message("ignoreme")
        assert_banned_warning("ignoreme")

        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_user(tf_cog):
    with session_manager() as session:
        message = await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
        assert_filtered_confirmation("ignoreuser", "banned")

        # Should be deleted and warned
        await dpytest.message("ignoreuser")
        assert_banned_warning("ignoreuser")

        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + message.author.mention)
        assert_new_ignore(message.author.mention)

        # Should be ignored
        await dpytest.message("ignoreuser")
        cleanup(dpytest.get_config().guilds[0].id, tf_cog, session)


@pytest.mark.asyncio()
async def test_ignore_empty_user():
    with pytest.raises(Exception):
        await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser")


@pytest.mark.asyncio()
async def test_unignore_channel():
    await dpytest.message(koalabot.COMMAND_PREFIX + "filter_word ignoreuser")
    assert_filtered_confirmation("ignoreuser", "banned")

    await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be ignored
    await dpytest.message("ignoreuser")

    await dpytest.message(koalabot.COMMAND_PREFIX + "unignore " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_remove_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    # Should be deleted and warned
    await dpytest.message("ignoreuser")
    assert_banned_warning("ignoreuser")


@pytest.mark.asyncio()
async def test_list_ignored():
    mes = await dpytest.message(
        koalabot.COMMAND_PREFIX + "ignoreChannel " + dpytest.get_config().guilds[0].channels[0].mention)
    assert_new_ignore(dpytest.get_config().guilds[0].channels[0].mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "ignoreUser " + mes.author.mention)
    assert_new_ignore(mes.author.mention)

    await dpytest.message(koalabot.COMMAND_PREFIX + "listIgnored")
    assert list_ignored_embed([dpytest.get_config().guilds[0].channels[0], mes.author])

</document_content>
</document>
<document index="41">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="42">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/conftest.py</source>
<document_content>
import pytest
from aiohttp import web
from discord.ext.commands import Bot
from sqlalchemy import delete

from koala.cogs.base.api import BaseEndpoint
from koala.cogs.base.models import ScheduledActivities
from koala.models import KoalaExtensions, GuildExtensions


@pytest.fixture(autouse=True)
def delete_tables(session):
    session.execute(delete(KoalaExtensions))
    session.execute(delete(GuildExtensions))
    session.execute(delete(ScheduledActivities))
    session.commit()

@pytest.fixture(autouse=True)
def setup_attributes(bot: Bot):
    app = web.Application()
    endpoint = BaseEndpoint(bot)
    endpoint.register(app)
    setattr(bot, "koala_web_app", app)
</document_content>
</document>
<document index="43">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_api.py</source>
<document_content>
from http.client import BAD_REQUEST, CREATED, OK

# Libs
import discord
import discord.ext.test as dpytest
import pytest
from aiohttp import web
from mock import mock

import koalabot
from koala.cogs.base.api import BaseEndpoint


@pytest.fixture
def api_client(bot: discord.ext.commands.Bot, aiohttp_client, loop):
    app = web.Application()
    endpoint = BaseEndpoint(bot)
    app = endpoint.register(app)
    return loop.run_until_complete(aiohttp_client(app))


'''

GET /activity

'''


async def test_get_activities(api_client):
    resp = await api_client.get('/scheduled-activity?show_all=False')
    assert resp.status == OK
    text = await resp.text()
    assert text == '[]'


async def test_get_activities_bad_param(api_client):
    resp = await api_client.get('/scheduled-activity?invalid_arg=abc')
    assert resp.status == BAD_REQUEST


async def test_get_activities_missing_param(api_client):
    resp = await api_client.get('/scheduled-activity')
    assert resp.status == BAD_REQUEST


'''

PUT /scheduled-activity

'''


async def test_put_schedule_activity(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == CREATED
    text = await resp.text()
    assert text == '{"message": "Activity scheduled"}'


async def test_put_schedule_activity_missing_param(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'end_time'}"


async def test_put_schedule_activity_bad_activity(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'invalidActivity',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2025-01-01 00:00:00',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Invalid activity type'


async def test_put_schedule_activity_bad_start_time(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'playing',
        'message': 'test',
        'url': 'test.com',
        'start_time': 'invalid_time',
        'end_time': '2026-01-01 00:00:00'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Bad start / end time'


async def test_put_schedule_activity_bad_end_time(api_client):
    resp = await api_client.put('/scheduled-activity', json=
    {
        'activity_type': 'invalidActivity',
        'message': 'test',
        'url': 'test.com',
        'start_time': '2026-01-01 00:00:00',
        'end_time': 'invalidTime'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error scheduling activity: Bad start / end time'


'''

PUT /activity

'''


async def test_put_set_activity(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'playing',
        'name': 'test',
        'url': 'test.com'
    })
    assert resp.status == CREATED
    text = await resp.text()
    assert text == '{"message": "Activity set"}'
    assert dpytest.verify().activity().matches(
        discord.Activity(type=discord.ActivityType.playing, name="test", url="test.com"))


async def test_put_set_activity_bad_req(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'invalidActivity',
        'name': 'test',
        'url': 'test.com'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error setting activity: Invalid activity type'


async def test_put_set_activity_missing_param(api_client):
    resp = await api_client.put('/activity', json=
    {
        'activity_type': 'invalidActivity',
        'url': 'test.com'
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'name'}"


'''

GET /ping

'''


async def test_get_ping(api_client):
    with mock.patch('discord.client.Client.latency', new_callable=mock.PropertyMock) as mock_last_transaction:
        mock_last_transaction.return_value = 0.42
        resp = await api_client.get('/ping')
        assert resp.status == OK
        text = (await resp.json())['message']
        assert "Pong! 420ms" in text


'''

GET /version

'''


async def test_get_version(api_client):
    resp = await api_client.get('/version')
    text = (await resp.json())['message']
    assert f"version: {koalabot.__version__}" in text


'''

GET /support

'''


async def test_get_support_link(api_client):
    resp = await api_client.get('/support')
    text = (await resp.json())['message']
    assert "Join our support server for more help! https://discord.gg/5etEjVd" in text


'''

POST /load-cog

'''


async def test_post_load_cog(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog loaded"


async def test_post_load_base_cog(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'base',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog loaded"


async def test_post_load_cog_bad_req(api_client):
    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'invalidCog',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error loading cog: Invalid extension'


async def test_post_load_cog_missing_param(api_client):
    resp = await api_client.post('/load-cog', json={})
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'extension'}"


async def test_post_load_cog_already_loaded(api_client):
    await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })

    resp = await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error loading cog: Already loaded'


'''

POST /unload-cog

'''


async def test_post_unload_cog(api_client):
    await api_client.post('/load-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })

    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Cog unloaded"


async def test_post_unload_cog_not_loaded(api_client):
    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'announce',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == 'Error unloading cog: Extension not loaded'


async def test_post_unload_cog_missing_param(api_client):
    resp = await api_client.post('/unload-cog', json={})
    assert resp.status == BAD_REQUEST
    assert (await resp.json())['message'] == "Unsatisfied Arguments: {'extension'}"


async def test_post_unload_base_cog(api_client):
    resp = await api_client.post('/unload-cog', json=
    {
        'extension': 'BaseCog',
        'package': koalabot.COGS_PACKAGE
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error unloading cog: Sorry, you can't unload the base cog"


'''

POST /enable-extension

'''


@mock.patch("koalabot.ENABLED_COGS", ["announce"])
async def test_post_enable_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/enable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })

    assert resp.status == OK
    text = (await resp.json())['message']
    assert text == "Extension enabled"


async def test_post_enable_extension_bad_req(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]

    resp = await api_client.post('/enable-extension', json=
    {
        'guild_id': guild.id,
        'koala_ext': 'Invalid Extension'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error enabling extension: Invalid extension"


async def test_post_enable_extension_missing_param(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/enable-extension', json=
    {
        'guild_id': guild.id
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'koala_ext'}"


'''

POST /disable-extension

'''


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
async def test_post_disable_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    setup = await api_client.post('/enable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert setup.status == OK

    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert resp.status == OK
    text = await resp.text()
    assert text == '{"message": "Extension disabled"}'


async def test_post_disable_extension_not_enabled(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id,
        'koala_ext': 'Announce'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error disabling extension: Extension not enabled"


async def test_post_disable_extension_missing_param(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.post('/disable-extension', json={
        'guild_id': guild.id
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'koala_ext'}"


async def test_post_disable_extension_bad_req(api_client):
    guild: discord.Guild = dpytest.get_config().guilds[0]

    resp = await api_client.post('/disable-extension', json=
    {
        'guild_id': guild.id,
        'koala_ext': 'Invalid Extension'
    })
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Error disabling extension: Extension not enabled"


'''

GET /extensions

'''


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
async def test_get_extension(api_client, bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = await api_client.get('/extensions?guild_id={}'.format(guild.id))
    assert resp.status == OK
    text = await resp.text()
    assert text == '["Announce"]'


async def test_get_extension_bad_param(api_client):
    resp = await api_client.get('/extensions?invalid-arg=abc')
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'guild_id'}"


async def test_get_extension_missing_param(api_client):
    resp = await api_client.get('/extensions')
    assert resp.status == BAD_REQUEST
    text = (await resp.json())['message']
    assert text == "Unsatisfied Arguments: {'guild_id'}"

</document_content>
</document>
<document index="44">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot BaseCog

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.cogs.base.cog import setup as setup_cog, BaseCog
from koala.colours import KOALA_GREEN


# Constants

# Variables


@pytest.fixture(scope='session', autouse=True)
def setup_is_dpytest():
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False


@pytest_asyncio.fixture(scope='function', autouse=True)
async def base_cog(bot: commands.Bot):
    """ setup any state specific to the execution of the given module."""
    cog = BaseCog(bot)
    await bot.add_cog(cog)
    await dpytest.empty_queue()
    dpytest.configure(bot)
    return cog


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ["greetings_cog"])
@pytest.mark.asyncio
async def test_list_koala_ext_disabled(bot, base_cog):
    await koalabot.load_all_cogs(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "listExt")
    expected_embed = discord.Embed()
    expected_embed.title = "Enabled extensions"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":negative_squared_cross_mark: Disabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_enable_koala_ext(bot, base_cog):
    await koalabot.load_all_cogs(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "enableExt Greetings")
    expected_embed = discord.Embed()
    expected_embed.title = "Greetings enabled"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":white_check_mark: Enabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_disable_koala_ext(bot, base_cog):
    await test_enable_koala_ext(bot, base_cog)
    await dpytest.message(koalabot.COMMAND_PREFIX + "disableExt Greetings")
    expected_embed = discord.Embed()
    expected_embed.title = "Greetings disabled"
    expected_embed.colour = KOALA_GREEN
    expected_embed.add_field(name=":negative_squared_cross_mark: Disabled", value="Greetings\n")
    expected_embed.set_footer(text=f"Guild ID: {dpytest.get_config().guilds[0].id}")
    assert dpytest.verify().message().embed(embed=expected_embed)


@pytest.mark.asyncio
async def test_on_ready(base_cog: BaseCog):
    await base_cog.on_ready()
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.playing,
                                                                name=koalabot.COMMAND_PREFIX + "help koalabot.uk"))


@pytest.mark.asyncio
async def test_activity():
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity set watching you")
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you"))
    assert dpytest.verify().message().content("I am now watching you")


@pytest.mark.asyncio
async def test_invalid_activity():
    with pytest.raises(commands.BadArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "activity set oof you")


@pytest.mark.asyncio
async def test_schedule_activity():
    await dpytest.message(koalabot.COMMAND_PREFIX +
                          "activity schedule playing test \"2020-01-01 00:00:00\" \"2020-01-01 01:00:00\"")
    assert dpytest.verify().message().content("Activity saved")


@pytest.mark.asyncio
async def test_schedule_activity_invalid_date():
    with pytest.raises(commands.BadArgument):
        await dpytest.message(koalabot.COMMAND_PREFIX + "activity schedule playing test abc abc")


@pytest.mark.asyncio
async def test_list_activity():
    await test_schedule_activity()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list")
    assert dpytest.verify().message().content("Activities:")


@pytest.mark.asyncio
async def test_list_activity_show_all():
    await test_schedule_activity()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list true")
    assert dpytest.verify().message().content("Activities:"
                                              "\n1, playing, None, test, 2020-01-01 00:00:00, 2020-01-01 01:00:00")


@pytest.mark.asyncio
async def test_remove_activity():
    await test_list_activity_show_all()
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity remove 1")
    assert dpytest.verify().message().content("Removed:"
                                              "\n1, playing, None, test, 2020-01-01 00:00:00, 2020-01-01 01:00:00")
    await dpytest.message(koalabot.COMMAND_PREFIX + "activity list true")
    assert dpytest.verify().message().content("Activities:")


@mock.patch("builtins.round", mock.MagicMock(return_value=4))
@pytest.mark.asyncio
async def test_ping(base_cog: BaseCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "ping")
    assert dpytest.verify().message().content("Pong! 4ms")


@pytest.mark.asyncio
async def test_support():
    await dpytest.message(koalabot.COMMAND_PREFIX + "support")
    assert dpytest.verify().message().content("Join our support server for more help! https://discord.gg/5etEjVd")


@pytest.mark.asyncio
async def test_default_clear():
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear")
    mock1.assert_called_with(limit=2)


@pytest.mark.asyncio
async def test_clear():
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear 4")
    mock1.assert_called_with(limit=5)


@pytest.mark.asyncio
async def test_invalid_clear(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.BadArgument,
                       match="Converting to \"int\" failed for parameter \"amount\"."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "clear a")


@pytest.mark.asyncio
async def test_load_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog base")
    mock1.assert_called_with(".base", package="koala.cogs")


@pytest.mark.asyncio
async def test_invalid_load_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.CommandInvokeError,
                       match=r".* Extension 'koala.cogs.FakeCog' could not be loaded."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog FakeCog")


@pytest.mark.asyncio
async def test_unload_base_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.CommandInvokeError, match="Sorry, you can't unload the base cog"):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog BaseCog")


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@pytest.mark.asyncio
async def test_load_valid_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@pytest.mark.asyncio
async def test_load_and_unload_valid_cog(base_cog: BaseCog):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "load_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")

    with mock.patch.object(discord.ext.commands.bot.Bot, 'unload_extension') as mock1:
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog Greetings")
    mock1.assert_called_with(".Greetings", package="tests.tests_utils.fake_load_all_cogs")


@pytest.mark.asyncio
async def test_invalid_unload_cog(base_cog: BaseCog):
    with pytest.raises(discord.ext.commands.errors.CommandInvokeError,
                       match="Command raised an exception: ExtensionNotLoaded:"
                             " Extension 'koala.cogs.FakeCog' has not been loaded."):
        await dpytest.message(koalabot.COMMAND_PREFIX + "unload_cog FakeCog")


@pytest.mark.asyncio
async def test_version(base_cog: BaseCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "version")
    assert dpytest.verify().message().content("version: " + koalabot.__version__)


@pytest.mark.asyncio
async def test_setup(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'add_cog') as mock1:
        await setup_cog(bot)
    mock1.assert_called()

</document_content>
</document>
<document index="45">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_core.py</source>
<document_content>
import datetime

import discord
import discord.ext.test as dpytest
import mock
import pytest
from discord.ext import commands

import koalabot
from koala.cogs.base import core


@pytest.fixture
def reset_extensions(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    core.disable_extension(bot, guild.id, "All")


def test_activity_clear_current():
    core.current_activity = "test"
    assert core.current_activity
    core.activity_clear_current()
    assert not core.current_activity


@pytest.mark.asyncio
async def test_activity_set(bot: commands.Bot):
    await core.activity_set(discord.ActivityType.watching, "you", None, bot)
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you"))


@pytest.mark.asyncio
async def test_activity_set_current_scheduled(bot: commands.Bot, session):
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    await core.activity_set_current_scheduled(bot, session=session)
    assert dpytest.verify().activity().matches(discord.Activity(type=discord.ActivityType.watching, name="you2"))


def test_activity_list():
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    schedule = core.activity_list(True)
    assert schedule[0].activity_id == 1
    assert schedule[0].activity_type == discord.ActivityType.watching
    assert schedule[0].message == "you2"


async def test_remove_scheduled_activity():
    core.activity_schedule(discord.ActivityType.watching, "you2", None,
                           datetime.datetime.now(), datetime.datetime.now() + datetime.timedelta(days=1))
    assert core.activity_list(True)[0].activity_id == 1

    core.activity_remove(1)
    assert not core.activity_list(True)


@pytest.mark.asyncio
async def test_ping(bot: commands.Bot):
    with mock.patch('discord.client.Client.latency', new_callable=mock.PropertyMock) as mock_last_transaction:
        mock_last_transaction.return_value = 0.42
        resp = await core.ping(bot)
        assert "Pong! 420ms" in resp


def test_support_link():
    resp = core.support_link()
    assert "Join our support server for more help! https://discord.gg/5etEjVd" in resp


def test_version():
    resp = core.get_version()
    assert f"version: {koalabot.__version__}" in resp


@pytest.mark.asyncio
async def test_purge(bot: commands.Bot):
    channel: discord.TextChannel = dpytest.get_config().channels[0]
    with mock.patch.object(discord.TextChannel, 'purge') as mock1:
        await core.purge(bot, channel.id, 2)
    mock1.assert_called_with(limit=3)

# Load cogs

@mock.patch("koalabot.ENABLED_COGS", ['announce'])
@pytest.mark.asyncio
async def test_load_cog(bot: commands.Bot):
    resp = await core.load_cog(bot, "announce")
    assert resp == "announce Cog Loaded"


@pytest.mark.asyncio
async def test_load_base_cog(bot: commands.Bot):
    resp = await core.load_cog(bot, "base")
    assert resp == "base Cog Loaded"


@pytest.mark.asyncio
async def test_load_invalid_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotFound, match="Extension 'koala.cogs.FakeCog' could not be loaded."):
        await core.load_cog(bot, "FakeCog")


@mock.patch("koalabot.ENABLED_COGS", ['announce'])
@pytest.mark.asyncio
async def test_load_already_loaded_cog(bot: commands.Bot):
    await core.load_cog(bot, "announce")
    with pytest.raises(discord.ext.commands.errors.ExtensionAlreadyLoaded, match="Extension 'koala.cogs.announce' is already loaded"):
        await core.load_cog(bot, "announce")

# Unload cogs

@pytest.mark.asyncio
async def test_unload_cog(bot: commands.Bot):
    await core.load_cog(bot, "announce")
    resp = await core.unload_cog(bot, "announce")
    assert resp == "announce Cog Unloaded"


@pytest.mark.asyncio
async def test_unload_base_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionError, match="Sorry, you can't unload the base cog"):
        await core.unload_cog(bot, "base")


@pytest.mark.asyncio
async def test_unload_not_loaded_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotLoaded, match="Extension 'koala.cogs.announce' has not been loaded."):
        await core.unload_cog(bot, "announce")


@pytest.mark.asyncio
async def test_unload_invalid_cog(bot: commands.Bot):
    with pytest.raises(discord.ext.commands.errors.ExtensionNotLoaded, match="Extension 'koala.cogs.FakeCog' has not been loaded."):
        await core.unload_cog(bot, "FakeCog")

# Enable extensions

@mock.patch("koalabot.ENABLED_COGS", ["Announce"])
@pytest.mark.asyncio
async def test_enable_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_load_cog(bot)
    embed = await core.enable_extension(bot, guild.id, "Announce")
    assert embed.title == "Announce enabled"


@pytest.mark.asyncio
async def test_enable_extension_all(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    embed = await core.enable_extension(bot, guild.id, "All")
    assert embed.title == "All extensions enabled"


@pytest.mark.asyncio
async def test_enable_invalid_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    with pytest.raises(NotImplementedError, match="InvalidExtension is not a valid extension"):
        await core.enable_extension(bot, guild.id, "InvalidExtension")

# Disable extensions

@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_disable_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension(bot)
    embed = await core.disable_extension(bot, guild.id, "Announce")
    assert embed.title == "Announce disabled"


@pytest.mark.asyncio
async def test_disable_extension_all(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension_all(bot)
    embed = await core.disable_extension(bot, guild.id, "All")
    assert embed.title == "All disabled"


@pytest.mark.asyncio
async def test_disable_extension_not_enabled(bot: commands.Bot):
    with pytest.raises(NotImplementedError, match="Announce is not an enabled extension"):
        guild: discord.Guild = dpytest.get_config().guilds[0]
        await core.disable_extension(bot, guild.id, "Announce")


@pytest.mark.asyncio
async def test_disable_invalid_extension(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    with pytest.raises(NotImplementedError, match="InvalidExtension is not an enabled extension"):
        await core.disable_extension(bot, guild.id, "InvalidExtension")

# List enabled extensions

@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_list_enabled_extensions(bot: commands.Bot):
    guild: discord.Guild = dpytest.get_config().guilds[0]
    await test_enable_extension(bot)
    embed = await core.list_enabled_extensions(guild.id)
    assert embed.fields[0].name == ":white_check_mark: Enabled"
    assert "Announce" in embed.fields[0].value

# Get available extensions

@mock.patch("koalabot.COGS_PACKAGE", koalabot.COGS_PACKAGE)
@mock.patch("koalabot.ENABLED_COGS", ["announce"])
@pytest.mark.asyncio
async def test_get_extensions(bot: commands.Bot):
    await koalabot.load_all_cogs(bot)
    guild: discord.Guild = dpytest.get_config().guilds[0]
    resp = core.get_all_available_guild_extensions(guild.id)
    print(resp)
    assert resp[0] == "Announce"
</document_content>
</document>
<document index="46">
<source>/Users/malcolm/dev/KoalaBot/tests/cogs/base/test_db.py</source>
<document_content>
import datetime

import discord
from sqlalchemy import select

from koala.cogs.base import db
from koala.cogs.base.models import ScheduledActivities


def test_add_scheduled_activity(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = "https://twitch.tv/thenuel"
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    results = session.execute(select(ScheduledActivities)).scalars().all()
    assert len(results) == 1
    result = results[0]
    assert result.message == "NUEL finals"
    assert result.time_end == time_end


def test_add_scheduled_activity_no_url(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    results = session.execute(select(ScheduledActivities)).scalars().all()
    assert len(results) == 1
    result = results[0]
    assert result.message == "NUEL finals"
    assert result.stream_url is None


def test_get_scheduled_activities(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    assert len(db.get_scheduled_activities(False, False)) == 1


def test_remove_scheduled_activities(session):
    activity_type = discord.ActivityType.streaming
    message = "NUEL finals"
    url = None
    time_start = datetime.datetime.fromisoformat("2020-01-01 00:00:00")
    time_end = datetime.datetime.fromisoformat("2021-01-01 00:00:00")

    db.add_scheduled_activity(activity_type, message, url, time_start, time_end, session=session)

    db.remove_scheduled_activities(1)

    assert len(db.get_scheduled_activities(False, False)) == 0


</document_content>
</document>
<document index="47">
<source>/Users/malcolm/dev/KoalaBot/tests/conftest.py</source>
<document_content>
"""
A configuration file for methods useful in all testing with pytest
"""
# Futures

# Built-in/Generic Imports
import shutil

import discord
import discord.ext.test as dpytest
# Libs
import pytest
import pytest_asyncio

import koala.db as db
# Own modules
import koalabot
from koala.db import session_manager
from tests.log import logger

# Constants

pytest_plugins = 'aiohttp.pytest_plugin'


@pytest.fixture(scope='session', autouse=True)
def teardown_config():

    # yield, to let all tests within the scope run
    yield

    # tear_down: then clear table at the end of the scope
    logger.info("Tearing down session")

    from koala.env import CONFIG_PATH

    shutil.rmtree(CONFIG_PATH, ignore_errors=True)


@pytest_asyncio.fixture
async def bot():
    import koalabot
    intents = discord.Intents.default()
    intents.members = True
    intents.guilds = True
    intents.messages = True
    intents.message_content = True
    b = koalabot.KoalaBot(koalabot.COMMAND_PREFIX, intents=intents)
    await b._async_setup_hook()
    await dpytest.empty_queue()
    dpytest.configure(b)
    return b


@pytest.fixture(autouse=True)
def setup_is_dpytest():
    db.__create_sqlite_tables()
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False


@pytest_asyncio.fixture
async def session():
    with session_manager() as session:
        yield session

</document_content>
</document>
<document index="48">
<source>/Users/malcolm/dev/KoalaBot/tests/test_koalabot.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot Base Code

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.db import clear_all_tables, fetch_all_tables
from tests.tests_utils.last_ctx_cog import LastCtxCog
from tests.tests_utils.utils import FakeAuthor

# Constants

# Variables
utils_cog = None


@pytest_asyncio.fixture(autouse=True)
async def test_ctx(bot: commands.Bot):
    global utils_cog
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    return utils_cog.get_last_ctx()


@pytest.fixture(scope='session', autouse=True)
def setup_db():
    clear_all_tables(fetch_all_tables())


@pytest_asyncio.fixture(scope='function', autouse=True)
async def setup_clean_messages():
    await dpytest.empty_queue()
    yield dpytest


def test_test_user_is_owner(test_ctx):
    assert koalabot.is_owner(test_ctx)


def test_invalid_test_user_is_owner(test_ctx):
    for i in range(len(koalabot.BOT_OWNER)):
        test_ctx.author = FakeAuthor(id=koalabot.BOT_OWNER[i] + 1)
        koalabot.is_dpytest = False
        assert not koalabot.is_owner(test_ctx)
        koalabot.is_dpytest = True


def test_owner_is_owner(test_ctx):
    for i in range(len(koalabot.BOT_OWNER)):
        test_ctx.author = FakeAuthor(id=(koalabot.BOT_OWNER[i]))
        assert koalabot.is_owner(test_ctx)


def test_test_user_is_admin(test_ctx):
    assert koalabot.is_admin(test_ctx)


def test_invalid_test_user_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(id=int(koalabot.BOT_OWNER[0]) + 2)
    koalabot.is_dpytest = False
    assert not koalabot.is_admin(test_ctx)
    koalabot.is_dpytest = True


def test_admin_test_user_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(name="TestUser#0001", all_permissions=True)
    assert koalabot.is_admin(test_ctx)


def test_admin_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(name="TestUser#0002", all_permissions=True)
    assert koalabot.is_admin(test_ctx)


def test_not_admin_is_admin(test_ctx):
    test_ctx.author = FakeAuthor(all_permissions=False)
    koalabot.is_dpytest = False
    assert not koalabot.is_admin(test_ctx)
    koalabot.is_dpytest = True


@mock.patch("koalabot.COGS_PACKAGE", "tests.tests_utils.fake_load_all_cogs")
@mock.patch("koalabot.ENABLED_COGS", ['greetings_cog'])
@pytest.mark.asyncio
async def test_load_all_cogs(bot):
    with mock.patch.object(discord.ext.commands.bot.Bot, 'load_extension') as mock1:
        await koalabot.load_all_cogs(bot)
    mock1.assert_called_with(".greetings_cog", package="tests.tests_utils.fake_load_all_cogs")


@pytest.mark.asyncio
async def test_dm_single_group_message():
    test_message = 'default message'
    test_member = dpytest.get_config().members[0]
    x = await koalabot.dm_group_message([test_member], test_message)
    assert dpytest.verify().message().content(test_message)
    assert x == 1


@pytest.mark.asyncio
async def test_dm_plural_group_message():
    test_message = 'default message'
    test_member = dpytest.get_config().members[0]
    test_member_2 = await dpytest.member_join()
    await dpytest.empty_queue()
    x = await koalabot.dm_group_message([test_member, test_member_2], test_message)
    assert dpytest.verify().message().content(test_message)
    assert dpytest.verify().message().content(test_message)
    assert x == 2


@pytest.mark.asyncio
async def test_dm_empty_group_message():
    test_message = 'this should not be sent'
    x = await koalabot.dm_group_message([], test_message)
    assert dpytest.verify().message().nothing()
    assert x == 0


@pytest.fixture(scope='session', autouse=True)
def setup_is_dpytest():
    koalabot.is_dpytest = True
    yield
    koalabot.is_dpytest = False

</document_content>
</document>
<document index="49">
<source>/Users/malcolm/dev/KoalaBot/tests/test_utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Testing KoalaBot Utils

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
import discord.ext.test as dpytest
import mock
import pytest
import pytest_asyncio
from discord.ext import commands

# Own modules
import koalabot
from koala.utils import __parse_args, format_config_path, wait_for_message
from tests.log import logger
from tests.tests_utils.last_ctx_cog import LastCtxCog


# Constants

# Variables


def test_parse_args_config():
    assert "/config/" == vars(__parse_args(["--config", "/config/"])).get("config")


def test_parse_args_invalid():
    assert vars(__parse_args(["--test", "/test/"])).get("config") is None


@mock.patch("os.name", "posix")
def test_format_db_path_linux_absolute():
    db_path = format_config_path("/test_dir/", "test.db")
    assert db_path == "/test_dir/test.db"


@mock.patch("os.name", "nt")
def test_format_db_path_windows():
    db_path = format_config_path("/test_dir/", "windows_test.db")
    assert db_path == "\\test_dir\\windows_test.db"


@pytest.mark.parametrize("msg_content", [" ", "something"])
@pytest.mark.asyncio
async def test_wait_for_message_not_none(msg_content, utils_cog: LastCtxCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    bot: discord.Client = config.client
    import threading
    t2 = threading.Timer(interval=0.1, function=dpytest.message, args=(msg_content))
    t2.start()
    fut = await wait_for_message(bot, ctx, 0.2)
    t2.join()
    assert fut, dpytest.sent_queue


@pytest.mark.asyncio
async def test_wait_for_message_none(utils_cog: LastCtxCog):
    await dpytest.message(koalabot.COMMAND_PREFIX + "store_ctx")
    ctx: commands.Context = utils_cog.get_last_ctx()
    config: dpytest.RunnerConfig = dpytest.get_config()
    bot: discord.Client = config.client
    msg, channel = await wait_for_message(bot, ctx, 0.2)
    assert not msg
    assert channel == ctx.channel


@pytest_asyncio.fixture(autouse=True)
async def utils_cog(bot: commands.Bot):
    utils_cog = LastCtxCog(bot)
    await bot.add_cog(utils_cog)
    dpytest.configure(bot)
    logger.info("Tests starting")
    return utils_cog
</document_content>
</document>
<document index="50">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/__init__.py</source>
<document_content>
from .announce import Announce
from .base import BaseCog
from .colour_role import ColourRole
from .insights import Insights
from .intro_cog import IntroCog
from .react_for_role import ReactForRole
from .text_filter import TextFilter
from .twitch_alert import TwitchAlert
from .verification import Verification
from .voting import Voting
</document_content>
</document>
<document index="51">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/insights/__init__.py</source>
<document_content>
#from . import utils, db, models - use this if necessary in future
from .cog import Insights, setup

</document_content>
</document>
<document index="52">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/insights/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Insights Cog Code
"""
# Futures

# Built-in/Generic Imports

# Libs
from discord.ext import commands

# Own modules
import koalabot
from .log import logger
from .core import get_insights, get_servers

# Constants

# Variables


class Insights(commands.Cog, name="Insights"):
    """
    A discord.py cog with commands to give insight into information about the servers the bot is in
    """

    def __init__(self, bot):
        self.bot = bot

    @commands.command(name="insights")
    @commands.check(koalabot.is_owner)
    async def insights(self, ctx):
        """
        Lists the number of servers the bot is in, and the total number of members across all of those servers
        (includes double counting)
        :param ctx: Context of the command
        """

        await ctx.send(get_insights(self.bot))

    @commands.command(name="servers")
    @commands.check(koalabot.is_owner)
    async def list_servers(self, ctx, filter_string=""):
        """
        Lists all servers that the bot is in, packaged into 2000 character messages, optional parameter for specifying
        that the servers must contain a specific string
        :param ctx: Context of the command
        :param filter_string: The string used to filter servers listed
        """

        server_list = get_servers(self.bot, filter_string)

        if len(server_list) > 0:
            partial_message = server_list[0]
            for guild in server_list[1:]:
                guild_length = len(guild)
                if len(partial_message) + guild_length + 2 > 2000:
                    await ctx.send(partial_message)
                    partial_message = guild
                else:
                    partial_message += f", {guild}"
            await ctx.send(partial_message)
        else:
            await ctx.send(f"No servers found containing the string \"{filter_string}\".")


async def setup(bot: koalabot) -> None:
    """
    Loads this cog into the selected bot
    :param bot: The client of the KoalaBot
    """
    await bot.add_cog(Insights(bot))
    logger.info("Insights Cog is ready.")

</document_content>
</document>
<document index="53">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/insights/core.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Insights Core Code
"""
# Futures

# Built-in/Generic Imports

# Libs

# Own modules

# Constants

# Variables


def get_insights(bot):
    """
    Processes the information concerning the number of servers and members, and the formatting for insights
    :param bot: The bot for which information is being gathered
    """

    message = f"Insights:\nThis bot is in a total of {len(bot.guilds)} servers.\nThere are a total " +\
              f"of {sum([len(guild.members) for guild in bot.guilds])} members across these servers."

    return message


def get_servers(bot, filter_string):
    """
    Retrieves a list of servers that the bot is in, can also use a filter to select only servers containing that string
    :param bot: The bot for which information is being gathered
    :param filter_string: A filter string which allows only servers containing that string to be selected
    """

    if filter_string != "":
        server_list = [guild.name for guild in bot.guilds if filter_string.lower() in guild.name.lower()]
    else:
        server_list = [guild.name for guild in bot.guilds]

    return server_list

</document_content>
</document>
<document index="54">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/insights/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="55">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/__init__.py</source>
<document_content>
from . import utils, db, log, models
from .announce_message import AnnounceMessage
from .cog import Announce, setup

</document_content>
</document>
<document index="56">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/announce_message.py</source>
<document_content>
class AnnounceMessage:
    """
    A class consisting the information about a announcement message
    """

    def __init__(self, title, message, thumbnail):
        """
        Initiate the message with default thumbnail, title and description
        :param title: The title of the announcement
        :param message: The message included in the announcement
        :param thumbnail: The logo of the server
        """
        self.title = title
        self.description = message
        self.thumbnail = thumbnail

    def set_title(self, title):
        """
        Changing the title of the announcement
        :param title: A string consisting the title
        :return:
        """
        self.title = title

    def set_description(self, message):
        """
        Changing the message in the announcement
        :param message: A string consisting the message
        :return:
        """
        self.description = message

</document_content>
</document>
<document index="57">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/cog.py</source>
<document_content>
# Built-in/Generic Imports
import math
import time

# Libs
import discord
from discord.ext import commands

# Own modules
import koalabot
from koala.colours import KOALA_GREEN
from koala.db import insert_extension
from koala.utils import extract_id, wait_for_message
from .announce_message import AnnounceMessage
from .db import AnnounceDBManager
from .log import logger
from .utils import ANNOUNCE_SEPARATION_DAYS, SECONDS_IN_A_DAY, MAX_MESSAGE_LENGTH


def announce_is_enabled(ctx):
    """
    A command used to check if the guild has enabled announce
    e.g. @commands.check(announce_is_enabled)

    :param ctx: The context of the message
    :return: True if enabled or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "Announce")
    except PermissionError:
        result = False

    return result or (str(ctx.guild) == koalabot.TEST_USER and koalabot.is_dpytest)


class Announce(commands.Cog):
    """
        Send DM announcements to certain roles and people.
    """

    def __init__(self, bot):
        self.bot = bot
        self.messages = {}
        self.roles = {}
        insert_extension("Announce", 0, True, True)
        self.announce_database_manager = AnnounceDBManager()

    def not_exceeded_limit(self, guild_id):
        """
        Check if enough days have passed for the user to use the announce function
        :return:
        """
        if self.announce_database_manager.get_last_use_date(guild_id):
            return int(time.time()) - self.announce_database_manager.get_last_use_date(
                guild_id) > ANNOUNCE_SEPARATION_DAYS * SECONDS_IN_A_DAY
        return True

    def has_active_msg(self, guild_id):
        """
        Check if a particular id has an active announcement pending announcement
        :param guild_id: The id of the guild of the command
        :return: Boolean of whether there is an active announcement or not
        """
        return guild_id in self.messages.keys()

    def get_role_names(self, guild_id, roles):
        """
        A function to get the names of all the roles the announcement will be sent to
        :param roles: The list of roles in the guild
        :param guild_id: The id of the guild
        :return: All the names of the roles that are tagged
        """
        temp = []
        for role in self.roles[guild_id]:
            temp.append(discord.utils.get(roles, id=role).name)
        return temp

    def get_receivers(self, guild_id, roles):
        """
        A function to get the receivers of a particular announcement
        :param roles: The list of roles in the guild
        :param guild_id: The id of the guild
        :return: All the receivers of the announcement
        """
        temp = []
        for role in self.roles[guild_id]:
            temp += discord.utils.get(roles, id=role).members
        return list(set(temp))

    def receiver_msg(self, guild):
        """
        A function to create a string message about receivers
        :param guild: The guild of the bot
        :return: A string message about receivers
        """
        if not self.roles[guild.id]:
            return f"You are currently sending to Everyone and there are {str(len(guild.members))} receivers"
        return f"You are currently sending to {self.get_role_names(guild.id, guild.roles)} and there are {str(len(self.get_receivers(guild.id, guild.roles)))} receivers "

    def construct_embed(self, guild: discord.Guild):
        """
        Constructing an embedded message from the information stored in the manager
        :param guild: The the guild
        :return: An embedded message for the announcement
        """
        message = self.messages[guild.id]
        embed: discord.Embed = discord.Embed(title=message.title,
                                             description=message.description, colour=KOALA_GREEN)
        embed.set_author(name="Announcement from " + guild.name)
        if message.thumbnail != 'https://cdn.discordapp.com/':
            embed.set_thumbnail(url=message.thumbnail)
        return embed

    @commands.check(announce_is_enabled)
    @commands.group(name="announce")
    async def announce(self, ctx):
        """
        Use k!announce create to create an announcement
        """
        if ctx.invoked_subcommand is None:
            await ctx.send(f"Please use `{koalabot.COMMAND_PREFIX}help announce` for more information")

    @commands.check(announce_is_enabled)
    @announce.command(name="create")
    async def create(self, ctx):
        """
        Create a new message that will be available for sending
        :param ctx: The context of the bot
        :return:
        """
        if not self.not_exceeded_limit(ctx.guild.id):
            remaining_days = math.ceil(
                ANNOUNCE_SEPARATION_DAYS - ((int(time.time()) - self.announce_database_manager.get_last_use_date(
                    ctx.guild.id)) / SECONDS_IN_A_DAY))
            await ctx.send("You have recently sent an announcement and cannot use this function for " + str(
                remaining_days) + " days")
            return
        if self.has_active_msg(ctx.guild.id):
            await ctx.send("There is currently an active announcement being created, you can use 'k!announce cancel' "
                           "or 'k!announce send' to complete it")
        else:
            await ctx.send("Please enter a message, I'll wait for 60 seconds, no rush.")
            message, channel = await wait_for_message(self.bot, ctx)
            if not message:
                await channel.send("Okay, I'll cancel the command.")
                return
            if len(message.content) > MAX_MESSAGE_LENGTH:
                await ctx.send("The content is more than 2000 characters long, and exceeds the limit")
                return
            self.messages[ctx.guild.id] = AnnounceMessage(f"",
                                                          message.content,
                                                          ctx.guild.icon)
            self.roles[ctx.guild.id] = []
            await ctx.send(f"An announcement has been created for guild {ctx.guild.name}")
            await ctx.send(embed=self.construct_embed(ctx.guild))
            await ctx.send(self.receiver_msg(ctx.guild))

    @commands.check(announce_is_enabled)
    @announce.command(name="changeTitle")
    async def change_title(self, ctx):
        """
        Change the title of the embedded message
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            await ctx.send("Please enter the new title, I'll wait for 60 seconds, no rush.")
            title, channel = await wait_for_message(self.bot, ctx)
            if not title:
                await channel.send("Okay, I'll cancel the command.")
                return
            self.messages[ctx.guild.id].set_title(title.content)
            await ctx.send(embed=self.construct_embed(ctx.guild))
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="changeContent")
    async def change_content(self, ctx):
        """
        Change the content of the embedded message
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            await ctx.send("Please enter the new message, I'll wait for 60 seconds, no rush.")
            message, channel = await wait_for_message(self.bot, ctx)
            if not message:
                await channel.send("Okay, I'll cancel the command.")
                return
            if len(message.content) > MAX_MESSAGE_LENGTH:
                await ctx.send("The content is more than 2000 characters long, and exceeds the limit")
                return
            self.messages[ctx.guild.id].set_description(message.content)
            await ctx.send(embed=self.construct_embed(ctx.guild))
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="addRole", aliases=["add"])
    async def add_role(self, ctx):
        """
        Add a role to list of people to send the announcement to
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            await ctx.send("Please enter the roles you want to tag separated by space, I'll wait for 60 seconds, no rush.")
            message, channel = await wait_for_message(self.bot, ctx)
            if not message:
                await channel.send("Okay, I'll cancel the command.")
                return
            for new_role in message.content.split():
                role_id = extract_id(new_role)
                if role_id not in self.roles[ctx.guild.id] and discord.utils.get(ctx.guild.roles,
                                                                                 id=role_id) is not None:
                    self.roles[ctx.guild.id].append(role_id)
            await ctx.send(self.receiver_msg(ctx.guild))
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="removeRole", aliases=["remove"])
    async def remove_role(self, ctx):
        """
        Remove a role from a list of people to send the announcement to
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            await ctx.send("Please enter the roles you want to remove separated by space, I'll wait for 60 seconds, no rush.")
            message, channel = await wait_for_message(self.bot, ctx)
            if not message:
                await channel.send("Okay, I'll cancel the command.")
                return
            for new_role in message.content.split():
                role_id = extract_id(new_role)
                if role_id in self.roles[ctx.guild.id]:
                    self.roles[ctx.guild.id].remove(role_id)
            await ctx.send(self.receiver_msg(ctx.guild))
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="preview")
    async def preview(self, ctx):
        """
        Post a constructed embedded message to the channel where the command is invoked
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            await ctx.send(embed=self.construct_embed(ctx.guild))
            await ctx.send(self.receiver_msg(ctx.guild))
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="send")
    async def send(self, ctx):
        """
        Send a pending announcement
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            embed = self.construct_embed(ctx.guild)
            if self.roles[ctx.guild.id]:
                for receiver in self.get_receivers(ctx.guild.id, ctx.guild.roles):
                    try:
                        await receiver.send(embed=embed)
                    except (discord.Forbidden, AttributeError, discord.HTTPException) as e:
                        logger.error(f'User {receiver.id} cannot recieve dms')
            else:
                for receiver in ctx.guild.members:
                    try:
                        await receiver.send(embed=embed)
                    except (discord.Forbidden, AttributeError, discord.HTTPException) as e:
                        logger.error(f'User {receiver.id} cannot recieve dms')

            self.messages.pop(ctx.guild.id)
            self.roles.pop(ctx.guild.id)
            self.announce_database_manager.set_last_use_date(ctx.guild.id, int(time.time()))
            await ctx.send("The announcement was made successfully")
        else:
            await ctx.send("There is currently no active announcement")

    @commands.check(announce_is_enabled)
    @announce.command(name="cancel")
    async def cancel(self, ctx):
        """
        Cancel a pending announcement
        :param ctx: The context of the bot
        :return:
        """
        if self.has_active_msg(ctx.guild.id):
            self.messages.pop(ctx.guild.id)
            self.roles.pop(ctx.guild.id)
            await ctx.send("The announcement was cancelled successfully")
        else:
            await ctx.send("There is currently no active announcement")


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(Announce(bot))
    logger.info("announce is ready.")

</document_content>
</document>
<document index="58">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/db.py</source>
<document_content>
# Built-in/Generic Imports
from sqlalchemy import select

# Own modules
from koala.db import session_manager
from .models import GuildUsage


# Libs


class AnnounceDBManager:
    """
    A class for interacting with the KoalaBot announcement database
    """
    def get_last_use_date(self, guild_id: int):
        """
        Gets the last time when this function was used
        :param guild_id: id of the target guild
        :return:
        """
        with session_manager() as session:
            usage = session.execute(
                select(GuildUsage.last_message_epoch_time).filter_by(guild_id=guild_id)).one_or_none()
            if usage:
                return usage.last_message_epoch_time
            else:
                return None

    def set_last_use_date(self, guild_id: int, last_time: int):
        """
        Set the last time when this function was used
        :param guild_id: id of the guild
        :param last_time: time when the function was used
        :return:
        """
        with session_manager() as session:
            guild_usage = session.execute(select(GuildUsage).filter_by(guild_id=guild_id)).scalars().one_or_none()
            if not guild_usage:
                guild_usage = GuildUsage(guild_id=guild_id, last_message_epoch_time=last_time)
                session.add(guild_usage)
            else:
                guild_usage.last_message_epoch_time = last_time
            session.commit()

</document_content>
</document>
<document index="59">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="60">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/models.py</source>
<document_content>
from sqlalchemy import Column, INT, ForeignKey

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class GuildUsage:
    __tablename__ = 'GuildUsage'
    __table_args__= {'extend_existing': True}
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'), primary_key=True)
    last_message_epoch_time = Column(INT)

    def __repr__(self):
        return "<GuildUsage(%s, %s)>" % \
               (self.guild_id, self.last_message_epoch_time)

</document_content>
</document>
<document index="61">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/announce/utils.py</source>
<document_content>
# Constants
ANNOUNCE_SEPARATION_DAYS = 30
SECONDS_IN_A_DAY = 86400
TIMEOUT_TIME = 60.0
MAX_MESSAGE_LENGTH = 2000

</document_content>
</document>
<document index="62">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/__init__.py</source>
<document_content>
from . import utils, db, log, models
from .cog import Voting, setup

</document_content>
</document>
<document index="63">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Vote Cog code and additional base cog functions
Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports
import time

# Libs
import discord
import parsedatetime.parsedatetime
from discord.ext import commands, tasks
from sqlalchemy import select, delete, update

# Own modules
import koalabot
from koala.db import session_manager, insert_extension
from .db import VoteManager, get_results, create_embed, add_reactions
from .log import logger
from .models import Votes
from .option import Option
from .utils import make_result_embed


# Constants

# Variables


def currently_configuring():
    """
    Decorator that returns true if the command invoker has an active vote in the server they're calling it in
    :return: True if the user has an active vote, false if not
    """
    async def predicate(ctx):
        cog = ctx.command.cog
        if koalabot.is_dm_channel(ctx):
            return False
        return ctx.author.id in cog.vote_manager.configuring_votes.keys() and cog.vote_manager.configuring_votes[ctx.author.id].guild == ctx.guild.id

    return commands.check(predicate)


def has_current_votes():
    async def predicate(ctx):
        cog = ctx.command.cog
        if koalabot.is_dm_channel(ctx):
            return False
        return ctx.author.id in map(lambda x: x[0], cog.vote_manager.vote_lookup.keys())

    return commands.check(predicate)


def vote_is_enabled(ctx):
    """
    A command used to check if the guild has enabled verify
    e.g. @commands.check(vote_is_enabled)
    :param ctx: The context of the message
    :return: True if enabled or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "Vote")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class Voting(commands.Cog, name="Vote"):
    def __init__(self, bot):
        """
        discord cog to manage the voting interface
        :param bot: the bot that the cog is being run on
        :param db_manager: a database manager (allows testing on a clean database)
        """
        self.bot = bot
        insert_extension("Vote", 0, True, True)
        self.vote_manager = VoteManager()
        self.vote_manager.load_from_db()
        self.running = False

    @commands.Cog.listener()
    async def on_ready(self):
        if not self.running:
            self.vote_end_loop.start()
            self.running = True

    async def cog_unload(self):
        self.vote_end_loop.cancel()
        self.running = False

    @tasks.loop(seconds=60.0)
    async def vote_end_loop(self):
        try:
            with session_manager() as session:
                now = time.time()
                votes = session.execute(select(Votes.vote_id, Votes.author_id, Votes.guild_id, Votes.title, Votes.end_time)
                                        .where(Votes.end_time < now)).all()
                for v_id, a_id, g_id, title, end_time in votes:
                    if v_id in self.vote_manager.sent_votes.keys():
                        vote = self.vote_manager.get_vote_from_id(v_id)
                        results = await get_results(self.bot, vote)
                        embed = await make_result_embed(vote, results)
                        try:
                            if vote.chair:
                                try:
                                    chair = await self.bot.fetch_user(vote.chair)
                                    await chair.send(f"Your vote {title} has closed")
                                    await chair.send(embed=embed)
                                except discord.Forbidden:
                                    user = await self.bot.fetch_user(vote.author)
                                    await user.send(f"Your vote {title} has closed")
                                    await user.send(embed=embed)
                            else:
                                try:
                                    user = await self.bot.fetch_user(vote.author)
                                    await user.send(f"Your vote {title} has closed")
                                    await user.send(embed=embed)
                                except discord.Forbidden:
                                    guild = await self.bot.fetch_guild(vote.guild)
                                    user = await self.bot.fetch_user(guild.owner_id)
                                    await user.send(f"A vote in your guild titled {title} has closed and the chair is unavailable.")
                                    await user.send(embed=embed)
                            session.execute(delete(Votes).filter_by(vote_id=vote.id))
                            session.commit()
                            self.vote_manager.cancel_sent_vote(vote.id, session=session)
                        except Exception as e:
                            session.execute(update(Votes).filter_by(vote_id=vote.id).values(end_time=time.time() + 86400))
                            session.commit()
                            logger.error(f"error in vote loop: {e}")
        except Exception as e:
            logger.error("Exception in outer vote loop: %s" % e, exc_info=e)

    @vote_end_loop.before_loop
    async def before_vote_loop(self):
        await self.bot.wait_until_ready()

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload):
        """
        Listens for when a reaction is added to a message
        :param payload: payload of data about the reaction
        """
        await self.update_vote_message(payload.message_id, payload.user_id)

    @commands.Cog.listener()
    async def on_raw_reaction_remove(self, payload):
        """
        Listens for when a reaction is removed from a message
        :param payload: payload of data about the reaction
        """
        await self.update_vote_message(payload.message_id, payload.user_id)

    @commands.check(koalabot.is_admin)
    @commands.check(vote_is_enabled)
    @commands.group(name="vote")
    async def vote(self, ctx):
        """
        Use k!vote create <title> to create a vote!
        """
        if ctx.invoked_subcommand is None:
            await ctx.send(f"Please use `{koalabot.COMMAND_PREFIX}help vote` for more information")

    @commands.check(koalabot.is_admin)
    @commands.check(vote_is_enabled)
    @vote.command(name="create")
    async def start_vote(self, ctx, *, title):
        """
        Creates a new vote
        :param title: The title of the vote
        """
        with session_manager() as session:
            if self.vote_manager.has_active_vote(ctx.author.id):
                guild_name = self.bot.get_guild(self.vote_manager.get_configuring_vote(ctx.author.id).guild)
                await ctx.send(f"You already have an active vote in {guild_name}. Please send that with `{koalabot.COMMAND_PREFIX}vote send` before creating a new one.")
                return

            in_db = session.execute(select(Votes).filter_by(title=title, author_id=ctx.author.id)).all()
            if in_db:
                await ctx.send(f"You already have a vote with title {title} sent!")
                return

            if len(title) > 200:
                await ctx.send("Title too long")
                return

            self.vote_manager.create_vote(ctx.author.id, ctx.guild.id, title, session=session)
            await ctx.send(f"Vote titled `{title}` created for guild {ctx.guild.name}. Use `{koalabot.COMMAND_PREFIX}help vote` to see how to configure it.")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="addRole")
    async def add_role(self, ctx, *, role: discord.Role):
        """
        Adds a role to the list of roles the vote will be sent to
        If no roles are added, the vote will go to all users in a guild (unless a target voice channel has been set)
        :param role: role id (e.g. 135496683009081345) or a role ping (e.g. @Student)
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        vote.add_role(role.id)
        await ctx.send(f"Vote will be sent to those with the {role.name} role")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="removeRole")
    async def remove_role(self, ctx, *, role: discord.Role):
        """
       Removes a role to the list of roles the vote will be sent to
       :param role: role id (e.g. 135496683009081345) or a role ping (e.g. @Student)
       """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        vote.remove_role(role.id)
        await ctx.send(f"Vote will no longer be sent to those with the {role.name} role")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="setChair")
    async def set_chair(self, ctx, *, chair: discord.Member = None):
        """
        Sets the chair of a vote
        If no chair defaults to sending the message to the channel the vote is closed in
        :param chair: user id (e.g. 135496683009081345) or ping (e.g. @ito#8813)
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        if chair:
            try:
                await chair.send(f"You have been selected as the chair for vote titled {vote.title}")
                vote.set_chair(chair.id)
                await ctx.send(f"Set chair to {chair.name}")
            except discord.Forbidden:
                await ctx.send("Chair not set as requested user is not accepting direct messages.")
        else:
            vote.set_chair(None)
            await ctx.send(f"Results will be sent to the channel vote is closed in")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="setChannel")
    async def set_channel(self, ctx, *, channel: discord.VoiceChannel = None):
        """
        Sets the target voice channel of a vote (Users connected to this channel will receive the vote message)
        If there isn't one set votes will go to all users in a guild (unless target roles have been added)
        :param channel: channel id (e.g. 135496683009081345) or mention (e.g. #cool-channel)
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        if channel:
            vote.set_vc(channel.id)
            await ctx.send(f"Set target channel to {channel.name}")
        else:
            vote.set_vc()
            await ctx.send("Removed channel restriction on vote")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="addOption")
    async def add_option(self, ctx, *, option_string):
        """
        Adds an option to the current vote
        separate the title and description with a "+" e.g. option title+option description
        :param option_string: a title and description for the option separated by a '+'
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        if len(vote.options) > 9:
            await ctx.send("Vote has maximum number of options already (10)")
            return
        current_option_length = sum([len(x.head) + len(x.body) for x in vote.options])
        if current_option_length + len(option_string) > 1500:
            await ctx.send(f"Option string is too long. The total length of all the vote options cannot be over 1500 characters.")
            return
        if "+" not in option_string:
            await ctx.send("Example usage: k!vote addOption option title+option description")
            return
        header, body = option_string.split("+")
        vote.add_option(Option(header, body, self.vote_manager.generate_unique_opt_id()))
        await ctx.send(f"Option {header} with description {body} added to vote")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="removeOption")
    async def remove_option(self, ctx, index: int):
        """
        Removes an option from a vote based on it's index
        :param index: the number of the option
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        vote.remove_option(index)
        await ctx.send(f"Option number {index} removed")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="setEndTime")
    async def set_end_time(self, ctx, *, time_string):
        """
        Sets a specific time for the vote to end. Results will be sent to the chair or owner if you use this, not a channel.
        If the vote has not been sent by the end time it will close automatically once it is sent.
        :param time_string: string representing a time e.g. "2021-03-22 12:56" or "tomorrow at 10am" or "in 5 days and 15 minutes"
        :return:
        """
        now = time.time()
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        cal = parsedatetime.Calendar()
        end_time_readable = cal.parse(time_string)[0]
        end_time = time.mktime(end_time_readable)
        if (end_time - now) < 0:
            await ctx.send("You can't set a vote to end in the past")
            return
        # if (end_time - now) < 599:
        #     await ctx.send("Please set the end time to be at least 10 minutes in the future.")
        #     return
        vote.set_end_time(end_time)
        await ctx.send(f"Vote set to end at {time.strftime('%Y-%m-%d %H:%M:%S', end_time_readable)} UTC")

    @currently_configuring()
    @commands.check(vote_is_enabled)
    @vote.command(name="preview")
    async def preview_vote(self, ctx):
        """
        Generates a preview of what users will see with the current configuration of the vote
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)
        msg = await ctx.send(embed=create_embed(vote))
        await add_reactions(vote, msg)

    @commands.check(vote_is_enabled)
    @has_current_votes()
    @vote.command(name="cancel")
    async def cancel_vote(self, ctx, *, title):
        """
        Cancels a vote you are setting up or have sent
        :param title: title of the vote to cancel
        """
        with session_manager() as session:
            v_id = self.vote_manager.vote_lookup[(ctx.author.id, title)]
            if v_id in self.vote_manager.sent_votes.keys():
                self.vote_manager.cancel_sent_vote(v_id, session=session)
            else:
                self.vote_manager.cancel_configuring_vote(ctx.author.id, session=session)
            await ctx.send(f"Vote {title} has been cancelled.")

    @commands.check(vote_is_enabled)
    @has_current_votes()
    @vote.command("list", aliases=["currentVotes"])
    async def check_current_votes(self, ctx):
        """
        Return a list of all votes you have in this guild.
        :return:
        """
        with session_manager() as session:
            embed = discord.Embed(title="Your current votes")
            votes = session.execute(select(Votes.title).filter_by(author_id=ctx.author.id, guild_id=ctx.guild.id)).all()
            body_string = ""
            for title in votes:
                body_string += f"{title[0]}\n"
            embed.add_field(name="Vote Title", value=body_string, inline=False)
            await ctx.send(embed=embed)

    @currently_configuring()
    @vote.command(name="send")
    async def send_vote(self, ctx):
        """
        Sends a vote to all users within the restrictions set with the current options added
        """
        vote = self.vote_manager.get_configuring_vote(ctx.author.id)

        if not vote.is_ready():
            await ctx.send("Please add more than 1 option to vote for")
            return

        self.vote_manager.configuring_votes.pop(ctx.author.id)
        self.vote_manager.sent_votes[vote.id] = vote

        users = [x for x in ctx.guild.members if not x.bot]
        if vote.target_voice_channel:
            vc_users = discord.utils.get(ctx.guild.voice_channels, id=vote.target_voice_channel).members
            users = list(set(vc_users) & set(users))
        if vote.target_roles:
            role_users = []
            for role_id in vote.target_roles:
                role = discord.utils.get(ctx.guild.roles, id=role_id)
                role_users += role.members
            role_users = list(dict.fromkeys(role_users))
            users = list(set(role_users) & set(users))
        for user in users:
            try:
                msg = await user.send(f"You have been asked to participate in this vote from {ctx.guild.name}.\nPlease react to make your choice (You can change your mind until the vote is closed)", embed=create_embed(vote))
                vote.register_sent(user.id, msg.id)
                await add_reactions(vote, msg)
            except discord.Forbidden:
                logger.error(f"tried to send vote to user {user.id} but direct messages are turned off.")
        await ctx.send(f"Sent vote to {len(users)} users")

    @commands.check(vote_is_enabled)
    @has_current_votes()
    @vote.command(name="close")
    async def close(self, ctx, *, title):
        """
        Ends a vote, and collects the results
        """
        vote_id = self.vote_manager.vote_lookup.get((ctx.author.id, title))
        if vote_id not in self.vote_manager.sent_votes.keys():
            if ctx.author.id in self.vote_manager.configuring_votes.keys():
                await ctx.send(f"That vote has not been sent yet. Please send it to your audience with {koalabot.COMMAND_PREFIX}vote send {title}")
            else:
                await ctx.send("You have no votes of that title to close")
            return

        vote = self.vote_manager.get_vote_from_id(vote_id)
        results = await get_results(self.bot, vote)
        with session_manager() as session:
            self.vote_manager.cancel_sent_vote(vote.id, session=session)
        embed = await make_result_embed(vote, results)
        if vote.chair:
            try:
                chair = await self.bot.fetch_user(vote.chair)
                await chair.send(embed=embed)
                await ctx.send(f"Sent results to {chair}")
            except discord.Forbidden:
                await ctx.send("Chair does not accept direct messages, sending results here.")
                await ctx.send(embed=embed)
        else:
            await ctx.send(embed=embed)

    @commands.check(vote_is_enabled)
    @has_current_votes()
    @vote.command(name="checkResults")
    async def check_results(self, ctx,  *, title):
        """
        Checks the results of a vote without closing it
        """
        vote_id = self.vote_manager.vote_lookup.get((ctx.author.id, title))
        if vote_id is None:
            raise ValueError(f"{title} is not a valid vote title for user {ctx.author.name}")

        if vote_id not in self.vote_manager.sent_votes.keys():
            if ctx.author.id in self.vote_manager.configuring_votes.keys():
                await ctx.send(
                    f"That vote has not been sent yet. Please send it to your audience with {koalabot.COMMAND_PREFIX}vote send {title}")
            else:
                await ctx.send("You have no votes of that title to check")
            return

        vote = self.vote_manager.get_vote_from_id(vote_id)
        results = await get_results(self.bot, vote)
        embed = await make_result_embed(vote, results)
        await ctx.send(embed=embed)

    async def update_vote_message(self, message_id, user_id):
        """
        Updates the vote message with the currently selected option
        :param message_id: id of the message that was reacted on
        :param user_id: id of the user who reacted
        """
        vote = self.vote_manager.was_sent_to(message_id)
        user = self.bot.get_user(user_id)
        if vote and not user.bot:
            msg = await user.fetch_message(message_id)
            embed = msg.embeds[0]
            choice = None
            for reaction in msg.reactions:
                if reaction.count > 1:
                    choice = reaction
                    break
            if choice:
                embed.set_footer(text=f"You will be voting for {choice.emoji} - {vote.options[VoteManager.emote_reference[choice.emoji]].head}")
            else:
                embed.set_footer(text="There are no valid choices selected")
            await msg.edit(embed=embed)


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(Voting(bot))
    logger.info("Voting is ready.")

</document_content>
</document>
<document index="64">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/db.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Vote Cog code and additional base cog functions
Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports
from random import randint

# Libs
import discord
from sqlalchemy import select, delete

# Own modules
from koala.db import session_manager
from .log import logger
from .models import Votes, VoteTargetRoles, VoteOptions, VoteSent
from .option import Option
from .two_way import TwoWay
from .utils import MAX_ID_VALUE, MIN_ID_VALUE
from .vote import Vote


# Constants

# Variables


async def add_reactions(vote, msg):
    """
    Adds the relevant reactions from a vote to a given message
    :param vote: the vote the message is for
    :param msg: the discord.Message object to react on
    :return:
    """
    for x in range(len(vote.options)):
        await msg.add_reaction(VoteManager.emote_reference[x])


def create_embed(vote):
    """
    Creates an embed of the current vote configuration
    :return: discord.Embed
    """
    embed = discord.Embed(title=vote.title)
    for x, option in enumerate(vote.options):
        embed.add_field(name=f"{VoteManager.emote_reference[x]} - {option.head}", value=option.body, inline=False)
    return embed


async def get_results(bot, vote):
    """
    Gathers the results from all users who were sent the vote
    :param vote: the vote object
    :param bot: the discord.commands.Bot that sent out the vote messages
    :return: dict of results
    """
    results = {}
    for u_id, msg_id in vote.sent_to.items():
        user = bot.get_user(u_id)
        if user:
            msg = await user.fetch_message(msg_id)
            for reaction in msg.reactions:
                if reaction.count > 1:
                    opt = vote.options[VoteManager.emote_reference[reaction.emoji]]
                    if opt in results.keys():
                        results[opt] += 1
                    else:
                        results[opt] = 1
                    break
        else:
            logger.error("User %s not found for msg_id: %s" % (u_id, msg_id))
    return results


class VoteManager:
    def __init__(self):
        """
        Manages votes for the bot
        """
        self.configuring_votes = {}
        self.sent_votes = {}
        self.vote_lookup = {}

    emote_reference = TwoWay({0: "1", 1: "2", 2: "3",
                              3: "4", 4: "5", 5: "6",
                              6: "7", 7: "8", 8: "9", 9: ""})

    def generate_unique_opt_id(self):
        with session_manager() as session:
            used_ids = session.execute(select(VoteOptions.opt_id)).all()
            return self.gen_id(len(used_ids) > (MAX_ID_VALUE - MIN_ID_VALUE))

    def gen_vote_id(self):
        return self.gen_id(len(self.configuring_votes.keys()) == (MAX_ID_VALUE - MIN_ID_VALUE))

    def gen_id(self, cond):
        if cond:
            return None
        while True:
            temp_id = randint(MIN_ID_VALUE, MAX_ID_VALUE)
            if temp_id not in self.configuring_votes.keys():
                return temp_id

    def load_from_db(self):
        with session_manager() as session:
            existing_votes = session.execute(select(Votes.vote_id, Votes.author_id, Votes.guild_id,
                                                    Votes.title, Votes.chair_id, Votes.voice_id, Votes.end_time)).all()
            for v_id, a_id, g_id, title, chair_id, voice_id, end_time in existing_votes:
                vote = Vote(v_id, title, a_id, g_id)
                vote.set_chair(chair_id, session=session)
                vote.set_vc(voice_id, session=session)
                self.vote_lookup[(a_id, title)] = v_id

                target_roles = session.execute(select(VoteTargetRoles.role_id).filter_by(vote_id=v_id)).all()
                if target_roles:
                    for r_id in target_roles:
                        vote.add_role(r_id[0], session=session)

                options = session.execute(select(VoteOptions.opt_id, VoteOptions.option_title,
                                                 VoteOptions.option_desc).filter_by(vote_id=v_id)).all()
                if options:
                    for o_id, o_title, o_desc in options:
                        vote.add_option(Option(o_title, o_desc, opt_id=o_id), session=session)

                delivered = session.execute(select(VoteSent.vote_receiver_id, VoteSent.vote_receiver_message)
                                            .filter_by(vote_id=v_id)).all()
                if delivered:
                    self.sent_votes[v_id] = vote
                    for rec_id, msg_id in delivered:
                        vote.register_sent(rec_id, msg_id, session=session)
                else:
                    self.configuring_votes[a_id] = vote

    def get_vote_from_id(self, v_id):
        """
        Returns a vote from a given discord context
        :param v_id: id of the vote
        :return: Relevant vote object
        """
        return self.sent_votes[v_id]

    def get_configuring_vote(self, author_id):
        return self.configuring_votes[author_id]

    def has_active_vote(self, author_id):
        """
        Checks if a user already has an active vote somewhere
        :param author_id: id of the author
        :return: True if they have an existing vote, otherwise False
        """
        return author_id in self.configuring_votes.keys()

    def create_vote(self, author_id, guild_id, title, *, session):
        """
        Creates a vote object and assigns it to a users ID
        :param author_id: id of the author of the vote
        :param guild_id: id of the guild of the vote
        :param title: title of the vote
        :return: the newly created Vote object
        """
        v_id = self.gen_vote_id()
        vote = Vote(v_id, title, author_id, guild_id)
        self.vote_lookup[(author_id, title)] = v_id
        self.configuring_votes[author_id] = vote
        session.add(Votes(vote_id=vote.id, author_id=author_id, guild_id=vote.guild, title=vote.title,
                          chair_id=vote.chair, voice_id=vote.target_voice_channel, end_time=vote.end_time))
        session.commit()
        return vote

    def cancel_sent_vote(self, v_id, *, session):
        """
        Removed a vote from the list of active votes
        :param v_id: the vote id
        :param session: db session
        :return: None
        """
        vote = self.sent_votes.pop(v_id)
        self.cancel_vote(vote, session=session)

    def cancel_configuring_vote(self, author_id, *, session):
        vote = self.configuring_votes.pop(author_id)
        self.cancel_vote(vote, session=session)

    def cancel_vote(self, vote, *, session):
        self.vote_lookup.pop((vote.author, vote.title))
        session.execute(delete(Votes).filter_by(vote_id=vote.id))
        session.execute(delete(VoteTargetRoles).filter_by(vote_id=vote.id))
        session.execute(delete(VoteOptions).filter_by(vote_id=vote.id))
        session.execute(delete(VoteSent).filter_by(vote_id=vote.id))
        session.commit()

    def was_sent_to(self, msg_id):
        """
        Checks if a given message was sent by the bot for a vote, so it knows if it should listen for reactions on it.
        :param msg_id: the message that has been reacted on
        :return: the relevant vote for the message, if there is one
        """
        for vote in self.sent_votes.values():
            if msg_id in vote.sent_to.values():
                return vote
        return None



</document_content>
</document>
<document index="65">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="66">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/models.py</source>
<document_content>
from sqlalchemy import Column, VARCHAR, FLOAT

from koala.models import mapper_registry, DiscordSnowflake


# FIXME: Previous approach had no primary keys, this sets all as primary key but shouldn't affect existing databases
# FIXME: When refactoring database, set a primary key


@mapper_registry.mapped
class Votes:
    __tablename__ = 'Votes'
    vote_id = Column(DiscordSnowflake, primary_key=True)
    author_id = Column(DiscordSnowflake)
    guild_id = Column(DiscordSnowflake)
    title = Column(VARCHAR(200, collation="utf8mb4_unicode_520_ci"))
    chair_id = Column(DiscordSnowflake, nullable=True)
    voice_id = Column(DiscordSnowflake, nullable=True)
    end_time = Column(FLOAT, nullable=True)

    def __repr__(self):
        return "<Votes(%s, %s, %s, %s, %s, %s, %s)>" % \
               (self.vote_id, self.author_id, self.guild_id, self.title, self.chair_id, self.voice_id, self.end_time)


@mapper_registry.mapped
class VoteTargetRoles:
    __tablename__ = 'VoteTargetRoles'
    vote_id = Column(DiscordSnowflake, primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)

    def __repr__(self):
        return "<VoteTargetRoles(%s, %s)>" % \
               (self.vote_id, self.role_id)


@mapper_registry.mapped
class VoteOptions:
    __tablename__ = 'VoteOptions'
    vote_id = Column(DiscordSnowflake, primary_key=True)
    opt_id = Column(DiscordSnowflake, primary_key=True)
    option_title = Column(VARCHAR(150, collation="utf8mb4_unicode_520_ci"))
    option_desc = Column(VARCHAR(150, collation="utf8mb4_unicode_520_ci"))

    def __repr__(self):
        return "<VoteOptions(%s, %s, %s, %s)>" % \
               (self.vote_id, self.opt_id, self.option_title, self.option_desc)


@mapper_registry.mapped
class VoteSent:
    __tablename__ = 'VoteSent'
    vote_id = Column(DiscordSnowflake, primary_key=True)
    vote_receiver_id = Column(DiscordSnowflake, primary_key=True)
    vote_receiver_message = Column(DiscordSnowflake)

    def __repr__(self):
        return "<VoteSent(%s, %s, %s)>" % \
               (self.vote_id, self.vote_receiver_id, self.vote_receiver_message)

</document_content>
</document>
<document index="67">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/option.py</source>
<document_content>
class Option:
    def __init__(self, head, body, opt_id):
        """
        Object holding information about an option
        :param head: the title of the option
        :param body: the description of the option
        """
        self.id = opt_id
        self.head = head
        self.body = body

</document_content>
</document>
<document index="68">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/two_way.py</source>
<document_content>
class TwoWay(dict):
    """Makes a dict a bijection"""
    def __init__(self, dict_in=None):
        """
        Constructor method
        :param dict_in: an existing dict to make two-way
        """
        super(TwoWay, self).__init__()
        if dict_in is not None:
            self.update(dict_in)

    def __delitem__(self, key):
        """
        Remove an item from the dict
        :param key: the key of the item
        """
        self.pop(self.pop(key))

    def __setitem__(self, key, value):
        """
        Add an item to the dict. Errors if it already exists
        :param key: the key of the item to add
        :param value: the value of the item to add
        """
        assert key not in self or self[key] == value
        super(TwoWay, self).__setitem__(key, value)
        super(TwoWay, self).__setitem__(value, key)

    def update(self, e, **f):
        """
        Update the dict
        :param e: new dict to integrate into the existing one
        :param f: keyword arguments
        """
        for key, value in e.items():
            assert key not in self or self[key] == value
            self[key] = value

</document_content>
</document>
<document index="69">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Vote Cog code and additional base cog functions
Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports

# Libs
import discord

# Own modules

# Constants
MIN_ID_VALUE = 100000000000000000
MAX_ID_VALUE = 999999999999999999

# Variables


async def make_result_embed(vote, results):
    """
    Create a discord.Embed object from a set of results for a vote
    :param vote: the vote the results are for
    :param results: the results from the vote
    :return: discord.Embed object to send
    """
    embed = discord.Embed(title=f"{vote.title} Results:")
    for option in vote.options:
        if option not in results.keys():
            results[option] = 0
    for opt, count in results.items():
        embed.add_field(name=opt.head, value=f"{count} votes", inline=False)
    if not results:
        embed.add_field(name="No votes yet!", value="Try giving more time to vote")
    return embed

</document_content>
</document>
<document index="70">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/voting/vote.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Vote Cog code and additional base cog functions
Commented using reStructuredText (reST)
"""
# Built-in/Generic Imports

# Libs
from sqlalchemy import select, delete, update

# Own modules
from koala.db import session_manager, assign_session
from .models import Votes, VoteTargetRoles, VoteSent, VoteOptions


# Constants

# Variables


class Vote:
    def __init__(self, v_id, title, author_id, guild_id):
        """
        An object containing methods and attributes of an active vote
        :param title: title of the vote
        :param author_id: creator of the vote
        :param guild_id: location of the vote
        """
        self.guild = guild_id
        self.id = v_id
        self.author = author_id
        self.title = title

        self.target_roles = []
        self.chair = None
        self.target_voice_channel = None
        self.end_time = None

        self.options = []

        self.sent_to = {}

    def is_ready(self):
        """
        Check if the vote is ready to be sent out
        :return: True if ready, False otherwise
        """
        return 1 < len(self.options) < 11 and not self.sent_to

    @assign_session
    def add_role(self, role_id, *, session):
        """
        Adds a target role to send the vote to
        :param role_id: target role
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        self.target_roles.append(role_id)
        in_db = session.execute(select(VoteTargetRoles).filter_by(vote_id=self.id, role_id=role_id)).all()
        if not in_db:
            session.add(VoteTargetRoles(vote_id=self.id, role_id=role_id))
            session.commit()

    @assign_session
    def remove_role(self, role_id, *, session):
        """
        Removes target role from vote targets
        :param role_id: target role
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        self.target_roles.remove(role_id)
        session.execute(delete(VoteTargetRoles).filter_by(vote_id=self.id, role_id=role_id))
        session.commit()

    @assign_session
    def set_end_time(self, time=None, *, session):
        """
        Sets the end time of the vote.
        :param time: time in unix time
        :param session: db session
        :return:
        """
        self.end_time = time
        session.execute(update(Votes).filter_by(vote_id=self.id).values(end_time=time))
        session.commit()

    @assign_session
    def set_chair(self, chair_id=None, *, session):
        """
        Sets the chair of the vote to the given id
        :param chair_id: target chair
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        self.chair = chair_id
        vote: Votes = session.execute(select(Votes).filter_by(vote_id=self.id)).scalar()
        vote.chair_id = chair_id
        session.commit()

    @assign_session
    def set_vc(self, channel_id=None, *, session):
        """
        Sets the target voice channel to a given channel id
        :param channel_id: target discord voice channel id
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        self.target_voice_channel = channel_id
        session.execute(update(Votes).filter_by(vote_id=self.id).values(voice_id=channel_id))
        session.commit()

    @assign_session
    def add_option(self, option, *, session):
        """
        Adds an option to the vote
        :param option: Option object
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        self.options.append(option)
        in_db = session.execute(select(VoteOptions).filter_by(opt_id=option.id)).all()
        if not in_db:
            session.add(VoteOptions(vote_id=self.id, opt_id=option.id, option_title=option.head, option_desc=option.body))
            session.commit()

    @assign_session
    def remove_option(self, index, *, session):
        """
        Removes an option from the vote
        :param index: the location in the list of options to remove
        :param session: db session
        :return: None
        """
        if self.sent_to:
            return
        opt = self.options.pop(index-1)
        session.execute(delete(VoteOptions).filter_by(vote_id=self.id, opt_id=opt.id))
        session.commit()

    @assign_session
    def register_sent(self, user_id, msg_id, *, session):
        """
        Marks a user as having been sent a message to vote on
        :param user_id: user who was sent the message
        :param msg_id: the id of the message that was sent
        :param session: db session
        :return:
        """
        self.sent_to[user_id] = msg_id
        in_db = session.execute(select(VoteSent).filter_by(vote_receiver_message=msg_id)).all()
        if not in_db:
            session.add(VoteSent(vote_id=self.id, vote_receiver_id=user_id, vote_receiver_message=msg_id))
            session.commit()

</document_content>
</document>
<document index="71">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/__init__.py</source>
<document_content>
from . import utils, db, models, cog, core, api
from .cog import ReactForRole


async def setup(bot):
    await cog.setup(bot)
    api.setup(bot)

</document_content>
</document>
<document index="72">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/api.py</source>
<document_content>
# Futures
# Built-in/Generic Imports
# Libs
from typing import List

import discord
from aiohttp import web
from discord.ext.commands import Bot

import koalabot
from koala.rest.api import parse_request
# Own modules
from . import core
from .dto import ReactRole
from .log import logger
from ... import colours

# Constants
RFR_ENDPOINT = 'react-for-role'

MESSAGE = 'message'
REQUIRED_ROLES = 'required-roles'


class RfrEndpoint:
    _bot: koalabot.KoalaBot
    """
    The API endpoints for BaseCog
    """

    def __init__(self, bot):
        self._bot = bot

    def register(self, app):
        """
        Register the routes for the given application
        :param app: The aiohttp.web.Application (likely of the sub app)
        :return: app
        """
        app.add_routes([web.post('/{}'.format(MESSAGE), self.post_message),
                        web.get('/{}'.format(MESSAGE), self.get_message),
                        web.put('/{}'.format(MESSAGE), self.put_message),
                        web.patch('/{}'.format(MESSAGE), self.patch_message),
                        web.delete('/{}'.format(MESSAGE), self.delete_message),
                        web.put('/{}'.format(REQUIRED_ROLES), self.put_required_roles),
                        web.get('/{}'.format(REQUIRED_ROLES), self.get_required_roles)])
        return app

    @parse_request
    async def post_message(self,
                           guild_id: int,
                           channel_id: int,
                           title: str,
                           description: str = "",
                           colour: str = colours.KOALA_GREEN.__str__(),
                           thumbnail: str = None,
                           inline: bool = None,
                           roles: List[ReactRole] = None
                           ):
        """
        Create a React For Role message

        :param guild_id: Guild ID of RFR message
        :param channel_id: Channel ID of RFR message
        :param title: Title of RFR message
        :param description: Description of RFR message
        :param colour: Hex colour code of RFR message
        :param thumbnail: thumbnail URL
        :param inline: fields should be inline
        :param roles: roles for RFR message
        :return:
        """
        guild = self._bot.get_guild(guild_id)
        if roles is not None:
            roles = [r.to_tuple(guild) for r in roles]

        return await core.create_rfr_message(bot=self._bot,
                                             guild_id=guild_id,
                                             channel_id=channel_id,
                                             title=title,
                                             description=description,
                                             colour=discord.Colour.from_str(colour),
                                             thumbnail=thumbnail,
                                             inline=inline,
                                             roles=roles)

    @parse_request
    async def get_message(self,
                          message_id: int,
                          guild_id: int,
                          channel_id: int
                          ):
        """
        Get a React For Role message

        :param message_id: Message ID of RFR message
        :param guild_id: Guild ID of RFR message
        :param channel_id: Channel ID of RFR message
        :return:
        """
        return await core.get_rfr_message_dto(self._bot, message_id, guild_id, channel_id)

    @parse_request
    async def put_message(self,
                          message_id: int,
                          guild_id: int,
                          channel_id: int,
                          title: str,
                          description: str,
                          colour: str,
                          thumbnail: str,
                          inline: bool,
                          roles: List[dict]
                          ):
        """
        Edit a React For Role message

        :param message_id: Message ID of RFR message
        :param guild_id: Guild ID of RFR message
        :param channel_id: Channel ID of RFR message
        :param title: Title of RFR message
        :param description: Description of RFR message
        :param colour: Hex colour code of RFR message
        :param thumbnail: thumbnail URL
        :param inline: fields should be inline
        :param roles: roles for RFR message
        :return:
        """
        guild = self._bot.get_guild(guild_id)
        if roles is not None:
            roles = [ReactRole(r["emoji"], r["role_id"]).to_tuple(guild) for r in roles]
        return await core.update_rfr_message(bot=self._bot,
                                             message_id=message_id,
                                             guild_id=guild_id,
                                             channel_id=channel_id,
                                             title=title,
                                             description=description,
                                             colour=discord.Colour.from_str(colour),
                                             thumbnail=thumbnail,
                                             inline=inline,
                                             roles=roles)

    @parse_request
    async def patch_message(self,
                            message_id: int,
                            guild_id: int,
                            channel_id: int,
                            title: str = None,
                            description: str = None,
                            colour: str = None,
                            thumbnail: str = None,
                            inline: bool = None,
                            roles: List[ReactRole] = None
                            ):
        """
        Edit a React For Role message

        :param message_id: Message ID of RFR message
        :param guild_id: Guild ID of RFR message
        :param channel_id: Channel ID of RFR message
        :param title: Title of RFR message
        :param description: Description of RFR message
        :param colour: Hex colour code of RFR message
        :param thumbnail: thumbnail URL
        :param inline: fields should be inline
        :param roles: roles for RFR message
        :return:
        """
        guild = self._bot.get_guild(guild_id)
        if roles is not None:
            roles = [r.to_tuple(guild) for r in roles]

        if colour is not None:
            colour = discord.Colour.from_str(colour)

        return await core.update_rfr_message(bot=self._bot,
                                             message_id=message_id,
                                             guild_id=guild_id,
                                             channel_id=channel_id,
                                             title=title,
                                             description=description,
                                             colour=colour,
                                             thumbnail=thumbnail,
                                             inline=inline,
                                             roles=roles)

    @parse_request
    async def delete_message(self,
                             message_id: int,
                             guild_id: int,
                             channel_id: int
                             ):
        """
        Delete a React For Role message

        :param message_id: Message ID of RFR message
        :param guild_id: Guild ID of RFR message
        :param channel_id: Channel ID of RFR message
        :return:
        """
        await core.delete_rfr_message(self._bot, message_id, guild_id, channel_id)
        return {"status": "DELETED",  "message_id": message_id}

    @parse_request
    async def put_required_roles(self,
                                 guild_id: int,
                                 role_ids: List[int] = None
                                 ):
        """
        Set or edit RFR required roles for a guild

        :param guild_id: Guild ID of RFR message
        :param role_ids: List of required role IDs
        :return:
        """
        core.edit_guild_rfr_required_roles(self._bot, guild_id, role_ids)
        return core.rfr_list_guild_required_roles(self._bot.get_guild(guild_id))

    @parse_request
    async def get_required_roles(self, guild_id: int):
        """
        Get RFR required roles for a guild

        :param guild_id: Guild ID of RFR message
        :return:
        """
        return core.rfr_list_guild_required_roles(self._bot.get_guild(guild_id))


def setup(bot: Bot):
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    sub_app = web.Application()
    endpoint = RfrEndpoint(bot)
    endpoint.register(sub_app)
    getattr(bot, "koala_web_app").add_subapp('/{}'.format(RFR_ENDPOINT), sub_app)
    logger.info("RFR API is ready.")

</document_content>
</document>
<document index="73">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
KoalaBot Reaction Roles Code

Author: Anan Venkatesh
Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
from io import BytesIO
from typing import *

import aiohttp
import discord
import emoji
from discord.ext import commands

import koalabot
from koala.colours import KOALA_GREEN
from koala.db import insert_extension
from koala.utils import wait_for_message
# Own modules
from . import core
from .db import get_rfr_message, get_rfr_message_emoji_roles, get_guild_rfr_required_roles, get_guild_rfr_roles, \
    get_guild_rfr_messages
from .exception import ReactionException, ReactionErrorCode
from .log import logger


def rfr_is_enabled(ctx):
    """
    A command used to check if the guild has enabled rfr
    e.g. @commands.check(rfr_is_enabled)
    :param ctx: The context of the message
    :return: True if enabled or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "ReactForRole")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class ReactForRole(commands.Cog):
    """
    A discord.py cog pertaining to a React for Role system to allow for automation in getting roles.
    """

    def __init__(self, bot):
        self.bot = bot
        insert_extension("ReactForRole", 0, True, True)

    @commands.check(koalabot.is_guild_channel)
    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @commands.group(name="rfr", aliases=["reactForRole", "react_for_role"])
    async def react_for_role_group(self, ctx: commands.Context):
        """
        Group of commands for React for Role (rfr) functionality.
        :param ctx: Context of the command
        :return:
        """
        return

    @staticmethod
    async def get_image_from_url(ctx: discord.ext.commands.Context, url: str) -> str:
        """
        Gets a workable image URL that was sent/handled without a file attachment in disc, but as a raw URL in msg content. Works by sending the image in the same context, then getting that attachment
        :param ctx: Context of the original message
        :param url: Original raw URL
        :return: URL of attachment to use in a method call
        """

        async def file_type_from_hdr(resp: aiohttp.ClientResponse):
            """
            Gets a file extension based only on the Content-Type MIME type header of the HTTP GET request sent.
            :param resp: Original HTTP response
            :return: file ext or empty string if not compatible as discord image
            """
            content_type: str = resp.content_type
            if content_type == 'image/png':
                return "png"
            elif content_type == 'image/jpeg':
                return "jpg"
            elif content_type == 'image/gif':
                return "gif"
            else:
                return None

        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status != 200:
                    logger.error(
                        "RFR: HTTP error Access code " + str(response.status) + " when attempting GET on " + url)
                    raise aiohttp.ClientError(
                        "HTTP error Access code " + str(response.status) + " when attempting GET on " + url)
                image_bytes = await response.read()
                data = BytesIO(image_bytes)
                ftype: str = await file_type_from_hdr(response)
                if not ftype:
                    logger.error(
                        "RFR: Couldn't verify image file type from " + url + " due to missing/different Content-Type header")
                    raise commands.BadArgument("Couldn't get an image from the message you sent.")
                msg: discord.Message = await ctx.send(file=discord.File(data, f"thumbnail.{ftype}"))
                try:
                    img = msg.attachments[0].url
                    await msg.delete()
                    return img
                except Exception as e:
                    logger.error("RFR " + str(e))
                    raise e

    @staticmethod
    def attachment_img_content_type(mime: Optional[str]):
        if not mime:
            return False
        else:
            return mime.startswith("image/")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @react_for_role_group.command(name="create", aliases=["createMsg", "createMessage"])
    async def rfr_create_message(self, ctx: commands.Context):
        """
        Creates a new rfr message in a channel of user's choice. User is prompted for (in this order)
        channel ID/name/mention, message title, message description. Default title and description exist, which are
        "React for Role" and "Roles below!" respectively. User requires admin perms to use.
        :param ctx: Context of the command
        :return:
        """
        await ctx.send(
            "Okay, this will create a new react for role message in a channel of your choice."
            "\nNote: The channel you specify will have its permissions edited to make it such that the @ everyone role "
            "is unable to add new reactions to messages, they can only reaction with existing ones. Please keep this in"
            " mind, or setup another channel entirely for this.")
        channel_raw = await self.prompt_for_input(ctx, "channel ID, name or mention")
        channel = None if (channel_raw == "") else await commands.TextChannelConverter().convert(ctx, channel_raw)
        if not channel:
            await ctx.send("Sorry, you didn't specify a valid channel ID, mention or name. Please restart the command.")
        else:
            del_msg = await channel.send(f"This should be a thing sent in the right channel.")
            await ctx.send(
                "Okay, what would you like the title of the react for role message to be? Please enter within 60"
                " seconds.")
            x = await wait_for_message(self.bot, ctx)
            msg: discord.Message = x[0]
            if not x[0]:
                await ctx.send(
                    "Okay, didn't receive a title. Do you actually want to continue? Send anything to confirm this.")
                if not await self.is_user_alive(ctx):
                    await ctx.send("Okay, didn't receive any confirmation. Cancelling command. Please restart.")
                    await del_msg.delete()
                    return
                else:
                    title: str = "React for Role"
                    await ctx.send(
                        "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr edit"
                        " commands.")
            else:
                title: str = msg.content
            await ctx.send(
                f"Okay, the title of the message will be \"{title}\". What do you want the description to be? "
                f"I'll wait 60 seconds, don't worry")
            y = await wait_for_message(self.bot, ctx)
            msg: discord.Message = y[0]
            if not y[0]:
                await ctx.send(
                    "Okay, didn't receive a description. Do you actually want to continue? Send anything to confirm this.")
                if not await self.is_user_alive(ctx):
                    await ctx.send("Okay, didn't receive any confirmation. Cancelling command. Please restart.")
                    await del_msg.delete()
                    return
                else:
                    desc: str = "Roles below!"
                    await ctx.send(
                        "Okay, I'll just put in a default value for you, you can edit it later by using the k!rfr "
                        "edit command.")
            else:
                desc: str = msg.content
            await ctx.send(f"Okay, the description of the message will be \"{desc}\".\n Okay, "
                           f"I'll create the react for role message now.")

            rfr_msg_id = (await core.create_rfr_message(self.bot, ctx.guild.id, channel.id, title, desc, KOALA_GREEN)).message_id
            # TODO - Get this working, for some reason we get 403 currently
            # await core.setup_rfr_reaction_permissions(ctx.guild, channel, self.bot)
            await self.overwrite_channel_add_reaction_perms(ctx.guild, channel)
            await ctx.send(
                f"Your react for role message ID is {rfr_msg_id}, it's in {channel.mention}. You can use the other "
                "k!rfr subcommands to change the message and add functionality as required.")
            await del_msg.delete()

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @react_for_role_group.command(name="delete", aliases=["deleteMsg", "deleteMessage"])
    async def rfr_delete_message(self, ctx: commands.Context):
        """
        Deletes an existing rfr message. User is prompted for (in this order) channel ID/name/mention, message ID/URL,
        Y/N confirmation. User needs admin perms to use.
        :param ctx: Context of the command
        :return:
        """
        await ctx.send(
            "Okay, this will delete an existing react for role message. I'll need some details first though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        await ctx.send("Please confirm that you would indeed like to delete the react for role message.")
        if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
            await ctx.send("Ok")
            await core.delete_rfr_message(self.bot, msg.id, ctx.guild.id, channel.id)
            await ctx.send("ReactForRole Message deleted")
        else:
            await ctx.send("Cancelled command.")

    @react_for_role_group.group(name="edit", pass_context=True)
    async def edit_group(self, ctx: commands.Context):
        return

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="description", aliases=["desc"])
    async def rfr_edit_description(self, ctx: commands.Context):
        """
        Edit the description of an existing rfr message. User is prompted for rfr message channel ID/name/mention,
        rfr message ID/URL, new description, Y/N confirmation. User needs admin perms to use.
        :param ctx: Context of the command
        :return:
        """
        await ctx.send("Okay, this will edit the description of an existing react for role message. I'll need some "
                       "details first though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        embed = core.get_embed_from_message(msg)
        await ctx.send(f"Your current description is {embed.description}. Please enter your new description.")
        desc = await self.prompt_for_input(ctx, "description")
        if desc != "":
            await ctx.send(f"Your new description would be {desc}. Please confirm that you'd like this change.")
            if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
                await core.rfr_edit(msg, description=desc)
            else:
                await ctx.send("Okay, cancelling command.")
        else:
            await ctx.send("Okay, cancelling command.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="title")
    async def rfr_edit_title(self, ctx: commands.Context):
        """
        Edit the title of an existing rfr message. User is prompted for rfr message channel ID/name/mention,
        rfr message ID/URL, new title, Y/N confirmation. User needs admin perms to use.
        :param ctx: Context of the command
        :return:
        """
        await ctx.send("Okay, this will edit the title of an existing react for role message. I'll need some details "
                       "first though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        embed = core.get_embed_from_message(msg)
        await ctx.send(f"Your current title is {embed.title}. Please enter your new title.")
        title = await self.prompt_for_input(ctx, "title")
        if title != "":
            await ctx.send(f"Your new title would be {title}. Please confirm that you'd like this change.")
            if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
                await core.rfr_edit(msg, title=title)
            else:
                await ctx.send("Okay, cancelling command.")
        else:
            await ctx.send("Okay, cancelling command.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="thumbnail", aliases=["image", "picture"])
    async def rfr_edit_thumbnail(self, ctx: commands.Context):
        """
        Edit the thumbnail of an existing rfr message. User is prompted for rfr message channel ID/name/mention, rfr
        message ID/URL, new thumbnail, Y/N confirmation. User needs admin perms
        :param ctx: Context of the command
        :return:
        """
        await ctx.send("Okay, this will edit the thumbnail of a react for role message. I'll need some details first "
                       "though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        embed = core.get_embed_from_message(msg)
        if not embed:
            logger.error(
                f"RFR: Can't find embed for message id {msg.id}, channel {channel.id}, guild id {ctx.guild.id}.")
        await ctx.send(f"Your current image here is {embed.thumbnail.url}")
        image = await self.prompt_for_input(ctx, "image you'd like to use as a thumbnail")
        if not image or image == "":
            await ctx.send("Okay, cancelling command.")
        if isinstance(image, discord.Attachment) and self.attachment_img_content_type(image.content_type):
            # correct type
            if not image.url:
                logger.error(f"Attachment url not found, details : {image}")
                raise commands.BadArgument("Couldn't get an image from the message you sent.")
            else:
                await core.rfr_edit(msg, thumbnail_url=str(image.url))
                await ctx.send("Okay, set the thumbnail of the thumbnail to your desired image. This will error if you "
                               "delete the message you sent with the image, so make sure you don't.")
        elif isinstance(image, str):
            # no attachment in message, just a raw URL in content
            img_url = await self.get_image_from_url(ctx, image)
            await core.rfr_edit(msg, thumbnail_url=img_url)
            await ctx.send("Okay, set the thumbnail of the thumbnail to your desired image.")
        else:
            raise commands.BadArgument("Couldn't get an image from the message you sent.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="inline")
    async def rfr_edit_inline(self, ctx: commands.Context):
        """
        Edit the inline property of embed fields in rfr embeds. Can edit all rfr messages in a server or a specific one.
        User is prompted for whether they'd like inline fields or not, as well as details of the specific message if
        that option is selected. User requires admin perms
        :param ctx: Context of the command
        :return:
        """
        await ctx.send("Okay, this will change how your embeds look. By default fields are not inline. However, you can"
                       " choose to change this for a specific message or all rfr messages on the server. To do this, I'"
                       "ll need some information though. Can you say if you want a specific message edited, or all mess"
                       "ages on the server?")
        input = await self.prompt_for_input(ctx, "all or specific")
        if not isinstance(input, str) or not input:
            await ctx.send("Okay, cancelling command")
        else:
            input_comm = input.lstrip().rstrip().lower()
            if input_comm not in ["all", "specific"]:
                await ctx.send("Okay, cancelling command.")
            elif input_comm == "all":
                await ctx.send(
                    "Okay, do you want all rfr messages in this server to have inline fields or not? Y for yes, "
                    "N for no.")
                change_all = await self.prompt_for_input(ctx, "Y/N")
                if not change_all or change_all.rstrip().lstrip().upper() not in ["Y", "N"]:
                    await ctx.send("Okay, cancelling command")
                    return
                change_all = change_all.rstrip().lstrip().upper()
                if change_all not in ["Y", "N"]:
                    await ctx.send("Invalid input for Y/N. Okay, cancelling command")
                    return
                else:
                    await ctx.send(
                        "Keep in mind that this process may take a while if you have a lot of RFR messages on your "
                        "server.")
                    await core.use_inline_rfr_all(ctx.guild, change_all == "Y")
                    await ctx.send("Okay, the process should be finished now. Please check.")
            elif input_comm.lstrip().rstrip().lower() == "specific":
                # try and get specific message
                await ctx.send("Okay, I'll need the information about the specific rfr message.")
                msg, channel = await self.get_rfr_message_from_prompts(ctx)
                embed: discord.Embed = core.get_embed_from_message(msg)
                if not embed:
                    await ctx.send("Couldn't get embed, is this an RFR message?")
                else:
                    await ctx.send("Okay, please say Y if you want inline fields, or N if you don't.")
                    yes_no = await self.prompt_for_input(ctx, "Y/N")
                    if not yes_no or yes_no.lstrip().rstrip().upper() not in ["Y", "N"]:
                        await ctx.send("Invalid input, cancelling command.")
                        return
                    yes_no = yes_no.lstrip().rstrip().upper()
                    if yes_no not in ["Y", "N"]:
                        await ctx.send("Invalid input, cancelling command")
                    else:
                        await ctx.send("Okay, I'll change it as requested.")
                        await core.use_inline_rfr_specific(msg, yes_no == "Y")
                        await ctx.send("Okay, should be done. Please check.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="fixEmbed")
    async def rfr_fix_embed(self, ctx: commands.Context):
        """
        Cosmetic fix method if the bot ever has a moment and doesn't react with the correct emojis/has duplicates.
        """
        msg, chnl = await self.get_rfr_message_from_prompts(ctx)
        await core.setup_rfr_reaction_permissions(chnl.guild, chnl, self.bot)
        emb = core.get_embed_from_message(msg)
        reacts: List[Union[discord.PartialEmoji, discord.Emoji, str]] = [x.emoji for x in msg.reactions]
        if not emb:
            logger.error(
                f"RFR: Can't find embed for message id {msg.id}, channel {chnl.id}, guild id {ctx.guild.id}.")
        else:
            _, _, _, er_id = get_rfr_message(ctx.guild.id, chnl.id, msg.id)
            if not er_id:
                logger.error(
                    f"RFR: Can't find rfr message with {msg.id}, channel {chnl.id}, guild id {ctx.guild.id}. DB ER_ID : {er_id}")
            else:
                rfr_er = get_rfr_message_emoji_roles(er_id)
                if not rfr_er:
                    logger.error(
                        f"RFR: Can't retrieve RFR message (ER_ID: {er_id})'s emoji role combinations.")
                else:
                    combos = ""
                    for er in rfr_er:
                        combos += emoji.emojize(er[1]) + ", " + str(er[2]) + "\n"
                    er_list = await self.parse_emoji_and_role_input_str(ctx, combos, 20)
                    embed: discord.Embed = discord.Embed(title=emb.title, description=emb.description,
                                                         colour=KOALA_GREEN)
                    embed.set_footer(text=emb.footer.text)
                    embed.set_thumbnail(url=emb.thumbnail.url)
                    emb.set_image(url=emb.image.url)
                    for e in reacts:
                        if e not in [x for x, _ in er_list]:
                            await msg.clear_reaction(e)
                    for e, r in er_list:
                        embed.add_field(name=str(e), value=r.mention, inline=False)
                        if e not in reacts:
                            await msg.add_reaction(e)
                    await msg.edit(embed=embed)
                    await ctx.send("Tried fixing the message, please check that it's fixed.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="addRoles")
    async def rfr_add_roles_to_msg(self, ctx: commands.Context):
        """
        Adds roles to an existing rfr message. User is prompted for rfr message channel ID/name/mention, rfr message ID/
        URL, emoji-role combos. Emoji-role combinations are to be given in
        \\\n\"<emoji>, <role>\"
        \\\n\"<emoji>, <role>\"
        format. <role> can be the role ID, name or mention. `emoji` can be a custom emoji from the server, or a standard
        unicode emoji. \\\nUser needs admin perms to use.
        :param ctx: Context of the command.
        :return:
        """

        await ctx.send(
            "Okay. This will add roles to an already created react for role message. I'll need some details first "
            "though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        rfr_msg_row = get_rfr_message(ctx.guild.id, channel.id, msg.id)

        if not rfr_msg_row:
            raise commands.CommandError("Message ID given is not that of a react for role message.")
        await ctx.send("Okay, found the message you want to add to.")
        remaining_slots = 20 - core.get_number_of_embed_fields(core.get_embed_from_message(msg))

        if remaining_slots == 0:
            await ctx.send(
                "Unfortunately due to discord limitations that message cannot have any more reactions. If you want I "
                "can create another message in the same channel though. Shall I do that?")

            if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
                await ctx.send(
                    "Okay, I'll continue then. The new message will have the same title and description as the "
                    "old one.")
                old_embed = core.get_embed_from_message(msg)
                rfr_msg_id = (await core.create_rfr_message(self.bot, ctx.guild.id, channel.id,
                                                     title=old_embed.title, description=old_embed.description,
                                                     colour=KOALA_GREEN)).message_id
                await ctx.send(f"Okay, the new message has ID {rfr_msg_id} and is in {msg.channel.mention}.")
            else:
                await ctx.send("Okay, I'll stop the command then.")
                return

        await ctx.send(
            "Okay. Can I get the roles and emojis you want added to the message in a list with format: \n<emoji>,"
            " <role>\n<emoji>, <role>\n<emoji>, <role>\netc. You can get a new line by using SHIFT + ENTER.")
        await ctx.send(
            f"Please note however that you've only got {remaining_slots} emoji-role combinations you can enter. I'll "
            f"therefore only take the first {remaining_slots} you do. I'll wait for 3 minutes.")

        input_role_emojis = (await wait_for_message(self.bot, ctx, 180))[0].content
        emoji_role_list = await self.parse_emoji_and_role_input_str(ctx, input_role_emojis, remaining_slots)
        duplicateRolesFound, duplicateEmojisFound, edited_msg = await core.rfr_add_emoji_role(ctx.guild, channel,
                                                                                        msg, emoji_role_list)
        if (duplicateEmojisFound): await ctx.send("Found duplicate emoji in the message, I'm not accepting it.")
        if (duplicateRolesFound): await ctx.send("Found duplicate roles in the message, I'm not accepting it.")
        await ctx.send("Okay, you should see the message with its new emojis now.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @edit_group.command(name="removeRoles")
    async def rfr_remove_roles_from_msg(self, ctx: commands.Context):
        """
        Removes roles from an existing rfr message. User is prompted for rfr message channel ID/name/mention, rfr message
        ID/URL, emojis/roles to remove. User can specify either the emoji or the role for any emoji-role combination to
        remove it, but it needs to be specified in the format below.
        \\\n\"<emoji>/<role>\"
        \\\n\"<emoji>/<role>\"
        <role> can be the role ID, name or mention. emoji can be a custom emoji from the server, or a standard
        unicode emoji. \\\nUser needs admin perms to use.
        :param ctx: Context of the command.
        :return:
        """
        await ctx.send(
            "Okay, this will remove roles from an already existing react for role message. I'll need some details first"
            " though.")
        msg, channel = await self.get_rfr_message_from_prompts(ctx)
        rfr_msg_row = get_rfr_message(ctx.guild.id, channel.id, msg.id)

        if not rfr_msg_row:
            raise commands.CommandError("Message ID given is not that of a react for role message.")
        await ctx.send("Okay, found the message you want to remove roles from.")
        remaining_slots = core.get_number_of_embed_fields(core.get_embed_from_message(msg))

        if remaining_slots == 0:
            await ctx.send(
                "Okay, it looks like you've already gotten rid of all roles from this message. Would you like me to del"
                "ete the message too?")

            if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
                await ctx.send("Okay, deleting that message and removing it from the database.")
                await core.delete_rfr_message(self.bot, msg.id, ctx.guild.id, channel.id)
                await ctx.send("Okay, deleted that react for role message. Have a nice day.")
                return
            else:
                await ctx.send("Okay, I'll stop the command then.")
                return
        else:
            await ctx.send(
                "Okay, I'll take the info of the roles/emojis you want to remove now. Just enter it in a message "
                "separated by new lines (SHIFT+ENTER). You can enter either the emojis used or the roles' ID/mention/"
                "name, for each one.")

            input_emoji_roles = (await wait_for_message(self.bot, ctx, 120))[0].content
            wanted_removals = await self.parse_emoji_or_roles_input_str(ctx, input_emoji_roles)

            new_embed, errors = await core.rfr_remove_emojis_roles(self.bot, ctx.guild, msg,
                                                                   rfr_msg_row, wanted_removals)
            for e in errors:
                await ctx.send(e)

            if core.get_number_of_embed_fields(new_embed) == 0:
                await ctx.send("I see you've removed all emoji-role combinations from this react for role message. "
                               "Would you like to delete this message?")

                if (await self.prompt_for_input(ctx, "Y/N")).lstrip().strip().upper() == "Y":
                    await ctx.send("Okay, I'll delete the message then.")
                    await core.delete_rfr_message(self.bot, msg.id, ctx.guild.id, channel.id)
                    return

            await ctx.send("Okay, I've removed those options from the react for role message.")

    @commands.Cog.listener()
    @commands.check(koalabot.is_guild_channel)
    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        """
        Event listener for adding a reaction. Doesn't need message to be in loaded cache.
        Gives the user a role if they can get it, if not strips all their roles and removes their reacts.
        :param payload: RawReactionActionEvent that happened
        :return:
        """
        if payload.guild_id is not None and not payload.member.bot:
            rfr_message = get_rfr_message(payload.guild_id, payload.channel_id, payload.message_id)
            if not rfr_message:
                return

            try:
                member_role = await self.get_role_member_info(payload.emoji, payload.guild_id,
                                                              payload.channel_id,
                                                              payload.message_id, payload.user_id)
            except ReactionException as e:
                logger.error("RFR Member role not found", exc_info=e)
                # Remove the reaction
                guild: discord.Guild = self.bot.get_guild(payload.guild_id)
                channel: discord.TextChannel = guild.get_channel(payload.channel_id)
                msg: discord.Message = await channel.fetch_message(payload.message_id)
                await msg.remove_reaction(payload.emoji, payload.member)
            else:
                if self.can_have_rfr_role(member_role[0]):
                    await member_role[0].add_roles(member_role[1])
                else:
                    # Remove all rfr roles from member
                    role_ids = get_guild_rfr_roles(payload.guild_id)
                    roles: List[discord.Role] = []
                    for role_id in role_ids:
                        role = discord.utils.get(member_role[0].guild.roles, id=role_id)
                        if not role:
                            continue
                        roles.append(role)
                    for role_to_remove in roles:
                        await member_role[0].remove_roles(role_to_remove)
                    # Remove members' reaction from all rfr messages in guild
                    guild_rfr_messages = get_guild_rfr_messages(payload.guild_id)
                    if not guild_rfr_messages:
                        logger.error(
                            f"ReactForRole: Guild RFR messages is empty on raw reaction add. Please check"
                            f" guild ID {payload.guild_id}")

                    else:
                        for guild_rfr_message in guild_rfr_messages:
                            guild: discord.Guild = member_role[0].guild
                            channel: discord.TextChannel = guild.get_channel(guild_rfr_message[1])
                            msg: discord.Message = await channel.fetch_message(guild_rfr_message[2])
                            for x in msg.reactions:
                                await x.remove(payload.member)

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @react_for_role_group.command("addRequiredRole")
    async def rfr_add_guild_required_role(self, ctx: commands.Context, role: discord.Role):
        """
        Adds a role to perms to use rfr functionality in a server, so you can specify that you need, e.g. "@Student" to
        be able to use rfr functionality in the server. It's server-wide permissions handling however. By default anyone
        can use rfr functionality in the server. User needs to have admin perms to use.
        :param ctx: Context of the command
        :param role: Role ID/name/mention
        :return:
        """
        try:
            core.add_guild_rfr_required_role(ctx.guild, role.id)
            await ctx.send(f"Okay, I'll add {role.name} to the list of roles required for RFR usage on the server.")
        except (commands.CommandError, commands.BadArgument):
            await ctx.send("Found an issue with your provided argument, couldn't get an actual role. Please try again.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @react_for_role_group.command("removeRequiredRole")
    async def rfr_remove_guild_required_role(self, ctx: commands.Context, role: discord.Role):
        """
        Removes a role from perms for use of rfr functionality in a server, so you can specify that you need, e.g.
        "@Student" to be able to use rfr functionality in the server. It's server-wide permissions handling however. By
        default anyone can use rfr functionality in the server. User needs to have admin perms to use.
        :param ctx: Context of the command
        :param role: Role ID/name/mention
        :return:
        """
        try:
            core.remove_guild_rfr_required_role(ctx.guild, role.id)
            await ctx.send(
                f"Okay, I'll remove {role.name} from the list of roles required for RFR usage on the server.")
        except (commands.CommandError, commands.BadArgument):
            await ctx.send("Found an issue with your provided argument, couldn't get an actual role. Please try again.")

    @commands.check(koalabot.is_admin)
    @commands.check(rfr_is_enabled)
    @react_for_role_group.command("listRequiredRoles")
    async def rfr_list_guild_required_roles(self, ctx: commands.Context):
        """
        Lists the server-specific role permissions for using rfr functionality. If list is empty, any role can use rfr
        functionality.
        :param ctx: Context of the command.
        :return:
        """
        role_ids = core.rfr_list_guild_required_roles(ctx.guild).role_ids
        msg_str = "You will need one of these roles to react to rfr messages on this server:\n"
        for role_id in role_ids:

            role: discord.Role = discord.utils.get(ctx.guild.roles, id=role_id)
            if not role:
                logger.error(f"ReactForRole: Couldn't find role {role_id} in guild {ctx.guild.id}. Please "
                             f"check.")
            else:
                msg_str += f"{role.mention}\n"
        if msg_str == "You will need one of these roles to react to rfr messages on this server:\n":
            msg_str = "Anyone can react to rfr messages on this server."
        await ctx.send(msg_str)

    @commands.Cog.listener()
    @commands.check(koalabot.is_guild_channel)
    async def on_raw_reaction_remove(self, payload: discord.RawReactionActionEvent):
        """
        Event listener for removing a reaction. Doesn't need message to be in loaded cache. Removes the role from the
        user if they have it, else does nothing.
        :param payload: RawReactionActionEvent that happened.
        :return:
        """

        if payload.guild_id is not None:
            rfr_message = get_rfr_message(payload.guild_id, payload.channel_id,
                                                                    payload.message_id)
            if not rfr_message:
                return
            member_role = await self.get_role_member_info(payload.emoji, payload.guild_id,
                                                          payload.channel_id,
                                                          payload.message_id, payload.user_id)
            if not member_role or member_role[0].bot:
                return
            await member_role[0].remove_roles(member_role[1])

    def can_have_rfr_role(self, member: discord.Member) -> bool:
        """
        check for rfr required roles, taking a member as argument
        :param member: Member to check rfr perms for
        :return: True if member has one of the required roles, or if there are no required roles. False otherwise
        """
        required_roles: List[int] = get_guild_rfr_required_roles(member.guild.id)
        if not required_roles or len(required_roles) == 0:
            return True
        return any(x in required_roles for x in [y.id for y in member.roles])

    async def get_rfr_message_from_prompts(self, ctx: commands.Context) -> Tuple[discord.Message, discord.TextChannel]:
        """
        Gets an rfr message from prompting user, basically just calls prompt_for_input multiple times and gets value from
        database based on input.
        :param ctx: Context of the command this function is called in
        :return: 2-Tuple of the message (if there is one, else None), and channel (if there is no message, else None).
        """
        channel_raw = await self.prompt_for_input(ctx, "Channel name, mention or ID")
        channel = None if (channel_raw == "") else await commands.TextChannelConverter().convert(ctx, channel_raw)
        if not channel:
            raise commands.CommandError("Invalid channel given.")
        msg_id_raw = await self.prompt_for_input(ctx, "react for role message ID")
        msg_id = None if (msg_id_raw == "") else int(msg_id_raw)
        if not msg_id:
            raise commands.CommandError("Invalid Message ID given.")
        msg = await channel.fetch_message(msg_id)
        if not msg:
            raise commands.CommandError("Invalid Message ID given.")
        rfr_msg_row = get_rfr_message(ctx.guild.id, channel.id, msg_id)
        if not rfr_msg_row:
            raise commands.CommandError("Message ID given is not that of a react for role message.")
        return msg, channel

    async def get_role_member_info(self, emoji_reacted: discord.PartialEmoji, guild_id: int,
                                   channel_id: int, message_id: int, user_id: int) -> Optional[
        Tuple[discord.Member, discord.Role]]:
        """
        Gets the role that should be added/removed to/from a Member on reacting to a known RFR message, and works out
        which Member reacted.
        :param emoji_reacted: Emoji of the raw reaction payload
        :param emoji_role_id: DB key identifying specific RFR message in a Guild
        :param guild_id: ID of the guild this event occurred in
        :param channel_id: ID of the channel that the message was in
        :param message_id: ID of the message that was reacted to
        :param user_id: ID of the user who reacted
        :return: Optional 2-Tuple (member, role) where member is the Member that reacted, and Role is the role that
        should be given/taken away. If a role or member couldn't be found, returns None instead.
        """

        guild: discord.Guild = self.bot.get_guild(guild_id)
        member: discord.Member = discord.utils.get(guild.members, id=user_id)
        if not member:
            raise ReactionException(ReactionErrorCode.UNKNOWN_MEMBER_REACTION, user_id, guild_id)
        channel: discord.TextChannel = discord.utils.get(guild.text_channels, id=channel_id)
        if not channel:
            raise ReactionException(ReactionErrorCode.UNKNOWN_CHANNEL_REACTION, channel_id, guild_id)
        message: discord.Message = await channel.fetch_message(message_id)
        if not message:
            raise ReactionException(ReactionErrorCode.UNKNOWN_MESSAGE_REACTION, message_id, guild_id)
        embed: discord.Embed = self.get_embed_from_message(message)

        if emoji_reacted.is_unicode_emoji():  # Unicode Emoji
            rep = emoji.emojize(emoji_reacted.name)
            if not rep:
                rep = emoji.emojize(emoji_reacted.name, use_aliases=True)

            field = await self.get_field_by_emoji(embed, rep)
            if not field:
                raise ReactionException(ReactionErrorCode.UNKNOWN_REACTION_FIELD, message_id, guild_id)
            role_str: str = field
            if not role_str:
                raise ReactionException(ReactionErrorCode.UNKNOWN_REACTION_ROLE, field, guild_id)
            role: discord.Role = discord.utils.get(guild.roles, mention=role_str.lstrip().rstrip())
            if not role:
                raise ReactionException(ReactionErrorCode.UNKNOWN_REACTION_ROLE, role, guild_id)
        else:  # Custom Emoji
            rep = str(emoji_reacted)
            field = await self.get_field_by_emoji(embed, rep)
            if not field:
                raise ReactionException(ReactionErrorCode.UNKNOWN_REACTION_FIELD, message_id, guild_id)
            role_str = field
            role: discord.Role = discord.utils.get(guild.roles, mention=role_str.lstrip().rstrip())
        return member, role

    async def parse_emoji_and_role_input_str(self, ctx: commands.Context, input_str: str, remaining_slots: int) -> List[
        Tuple[Union[discord.Emoji, str], discord.Role]]:
        """
        Parses input for the "k!rfr edit addRoles" commmand, in the
        \n"<emoji>, <role>\n
        <emoji>, <role>"
        format.
        :param ctx: context of the command that called this
        :param input_str: input message content
        :param remaining_slots: remaining slots left on the rfr embed referred to
        :return: List of Emoji-Role pairs parsed from the input message.
        """
        rows = input_str.splitlines()

        arr = []
        for row in rows:
            emoji_role = row.split(',')
            # print(emoji_role)
            if (len(emoji_role) < 2):
                continue
            if len(emoji_role) > 2:
                raise commands.BadArgument("Too many/little categories/etc on one line.")
            emoji, err = await core.get_first_emoji_from_str(ctx.bot, ctx.guild, emoji_role[0].strip())

            if not emoji:
                await ctx.send(f"Yeah, didn't find emoji for `{emoji_role[0]}` - {err}")
                continue

            role = await commands.RoleConverter().convert(ctx, emoji_role[1].lstrip().rstrip())
            arr.append((emoji, role))
            if len(arr) == remaining_slots:
                return arr
        return arr

    async def parse_emoji_or_roles_input_str(self, ctx: commands.Context, input_str: str) -> List[
        Union[discord.Emoji, str, discord.Role]]:
        """
        Parses input prompt for the "k!rfr edit removeRoles" command, to get a list of roles and emoji as the output.
        Input format is
        \n"<emoji>/<role>\n
        <emoji>/<role>"
        <role> can be the role ID, name or mention. emoji can be a custom emoji from the server, or a standard
        unicode emoji.
        :param ctx: Context of the command that called this
        :param input_str: Input message content
        :return: List of roles & emojis given in the input string.
        """
        rows = input_str.splitlines()
        arr = []
        for row in rows:
            # Try and match it to an raw_emoji first
            raw_emoji, err = await core.get_first_emoji_from_str(self.bot, ctx.guild, row.strip())
            if not raw_emoji:
                role = await commands.RoleConverter().convert(ctx, row.strip())
                if not role:
                    raise commands.BadArgument("Couldn't convert to a role or emoji.")
                else:
                    arr.append(role)
            else:
                arr.append(raw_emoji)
        return arr


    async def prompt_for_input(self, ctx: commands.Context, input_type: str) -> Union[discord.Attachment, str]:
        """
        Prompts a user for input in the form of a message. Has a forced timer of 60 seconds, because it basically just
        deals with the rfr specific stuff. Returns whatever was input, or cancels the calling command
        :param ctx: Context of the command that calls this
        :param input_type: Name of whatever info is needed from a user, just so that the message looks nice/clear
        :return: User's response's content
        """
        await ctx.send(f"Please enter {input_type} so I can progress further. I'll wait 60 seconds, don't worry.")
        msg, channel = await wait_for_message(self.bot, ctx)
        if not msg:
            await channel.send("Okay, I'll cancel the command.")
            return ""
        elif len(msg.attachments) > 0:
            return msg.attachments[0]
        else:
            return msg.content

    async def overwrite_channel_add_reaction_perms(self, guild: discord.Guild, channel: discord.TextChannel):
        """
        Overwrites a text channel's reaction perms so that nobody can add new reactions to any message sent in the
        channel, only the bot, to make sure people don't mess with the system. Relies on roles tending not to be added/
        removed constantly to keep performance satisfactory.
        :param guild: Guild that the rfr message is in
        :param channel: Channel that the rfr message is in
        :return:
        """
        #  Get the @everyone role.
        role: discord.Role = discord.utils.get(guild.roles, id=guild.id)
        overwrite: discord.PermissionOverwrite = discord.PermissionOverwrite()
        overwrite.update(add_reactions=False)
        await channel.set_permissions(role, overwrite=overwrite)
        bot_members = [member for member in guild.members if member.bot and member.id == self.bot.user.id]
        overwrite.update(add_reactions=True)
        for bot_member in bot_members:
            await channel.set_permissions(bot_member, overwrite=overwrite)


    async def is_user_alive(self, ctx: commands.Context):
        """
        Prompts user for message to check if they're alive. Any message will do. We hope they're alive anyways.
        :param ctx: Context of the command that calls this
        :return: True if message received, False otherwise.
        """
        msg = await wait_for_message(self.bot, ctx, 10)
        if not msg[0]:
            return False
        return True

    async def get_field_by_emoji(self, embed: discord.Embed, emoji: Optional[str]):
        """
        Get the specific field value of an rfr embed by the string representation of the emoji in the field name

        :param embed: RFR Embed to check
        :param emoji: Emoji required
        :return: If a field exists such that its name is :emoji:, then that field's value. Else None
        """
        if not emoji:
            return
        else:
            fields = embed.fields
            field = discord.utils.get(fields, name=emoji)
            if not field:
                return
            return field.value


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(ReactForRole(bot))

</document_content>
</document>
<document index="74">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/core.py</source>
<document_content>
from typing import *

import discord
import emoji
from discord.ext import commands
from discord.ext.commands import Bot

import koalabot
from koala.db import assign_session
from . import db
from .db import get_rfr_message
from .dto import ReactMessage, ReactRole, RequiredRoles
from .log import logger
from .utils import CUSTOM_EMOJI_REGEXP, UNICODE_EMOJI_REGEXP, FLAG_EMOJI_REGEXP

# Constants

koala_logo = "https://cdn.discordapp.com/attachments/737280260541907015/752024535985029240/discord1.png"

# Variables


@assign_session
async def get_rfr_message_dto(bot: koalabot.KoalaBot, message_id: int, guild_id: int, channel_id: int,
                              **kwargs):
    guild = bot.get_guild(guild_id)
    channel = guild.get_channel(channel_id)
    message: discord.Message = await channel.fetch_message(message_id)

    rfr_embed = get_embed_from_message(message)

    _, _, _, emoji_role_id = db.get_rfr_message(guild_id, channel_id, message_id, **kwargs)
    roles_list = db.get_rfr_message_emoji_roles(emoji_role_id, **kwargs)

    return ReactMessage(
        message_id=message_id,
        guild_id=guild_id,
        channel_id=channel_id,
        title=rfr_embed.title,
        description=rfr_embed.description,
        thumbnail=rfr_embed.thumbnail.url,
        colour=rfr_embed.colour.__str__(),
        inline=len(rfr_embed.fields) > 0 and rfr_embed.fields[0].inline,
        roles=[ReactRole(role[1], role[2]) for role in roles_list]
    )


@assign_session
async def create_rfr_message(bot: koalabot.KoalaBot, guild_id: int, channel_id: int, title: str, description: str,
                             colour: discord.Colour, thumbnail: str = None, inline: bool = None,
                             roles: List[Tuple[Union[discord.Emoji, str], discord.Role]] = None,
                             **kwargs) -> ReactMessage:
    guild = bot.get_guild(guild_id)
    channel = guild.get_channel(channel_id)

    embed: discord.Embed = discord.Embed(title=title, description=description, colour=colour)
    embed.set_footer(text="ReactForRole")
    if thumbnail is None:
        embed.set_thumbnail(url=koala_logo)
    else:
        embed.set_thumbnail(url=thumbnail)

    rfr_msg: discord.Message = await channel.send(embed=embed)
    db.add_rfr_message(guild_id, channel_id, rfr_msg.id, **kwargs)

    if roles is not None:
        await rfr_add_emoji_role(guild, channel, rfr_msg, roles, **kwargs)

    if inline is not None:
        await use_inline_rfr_specific(rfr_msg, inline)

    return await get_rfr_message_dto(bot, rfr_msg.id, guild_id, channel_id, **kwargs)


@assign_session
async def update_rfr_message(bot: koalabot.KoalaBot, message_id: int, guild_id: int, channel_id: int,
                             title: str, description: str, colour: discord.Colour,
                             thumbnail: str, inline: bool,
                             roles: List[Tuple[Union[discord.Emoji, str], discord.Role]],
                             **kwargs):
    guild = bot.get_guild(guild_id)
    channel = guild.get_channel(channel_id)

    if roles is not None:
        await rfr_edit_emoji_role(bot, message_id, guild_id, channel_id, roles, **kwargs)

    await rfr_edit(await channel.fetch_message(message_id), title=title, description=description, thumbnail_url=thumbnail, colour=colour)

    if inline is not None:
        await use_inline_rfr_specific(await channel.fetch_message(message_id), inline)

    return await get_rfr_message_dto(bot, message_id, guild_id, channel_id, **kwargs)


@assign_session
async def delete_rfr_message(bot: koalabot.KoalaBot, message_id: int, guild_id: int, channel_id: int, **kwargs):
    rfr_msg_row = db.get_rfr_message(guild_id, channel_id, message_id, **kwargs)
    db.remove_rfr_message_emoji_roles(rfr_msg_row[3], **kwargs)
    db.remove_rfr_message(guild_id, channel_id, message_id, **kwargs)

    guild = bot.get_guild(guild_id)
    channel = guild.get_channel(channel_id)
    message = await channel.fetch_message(message_id)

    await message.delete()


@assign_session
async def use_inline_rfr_all(guild: discord.Guild, inline: bool, **kwargs):
    text_channels: List[discord.TextChannel] = guild.text_channels
    guild_rfr_messages = db.get_guild_rfr_messages(guild.id, **kwargs)
    for rfr_message in guild_rfr_messages:
        channel: discord.TextChannel = discord.utils.get(text_channels, id=rfr_message[1])
        msg: discord.Message = await channel.fetch_message(rfr_message[2])
        embed: discord.Embed = get_embed_from_message(msg)
        length = get_number_of_embed_fields(embed)
        for i in range(length):
            field = embed.fields[i]
            embed.set_field_at(i, name=field.name, value=field.value, inline=inline)
        await msg.edit(embed=embed)


async def use_inline_rfr_specific(msg: discord.Message, inline: bool):
    rfr_embed = get_embed_from_message(msg)
    length = get_number_of_embed_fields(rfr_embed)
    for i in range(length):
        field = rfr_embed.fields[i]
        rfr_embed.set_field_at(i, name=field.name, value=field.value, inline=inline)
    await msg.edit(embed=rfr_embed)


async def rfr_edit(message: discord.Message, *,
                   title: str = None, description: str = None, thumbnail_url: str = None, colour: discord.Colour = None):
    embed = get_embed_from_message(message)
    if title is not None:
        embed.title = title
    if description is not None:
        embed.description = description
    if thumbnail_url is not None:
        embed.set_thumbnail(url=thumbnail_url)
    if colour is not None:
        embed.colour = colour
    return await message.edit(embed=embed)


@assign_session
async def rfr_remove_emojis_roles(bot: Bot, guild: discord.Guild, msg: discord.Message,
                                  rfr_msg_row: Tuple[int, int, int, int],
                                  wanted_removals: List[Union[discord.Emoji, str, discord.Role]], **kwargs):
    rfr_embed: discord.Embed = get_embed_from_message(msg)
    rfr_embed_fields = rfr_embed.fields
    new_embed = rfr_embed.copy()
    new_embed.clear_fields()
    removed_field_indexes = []
    reactions_to_remove: List[discord.Reaction] = []
    errors = []

    for row in wanted_removals:
        if isinstance(row, discord.Emoji) or isinstance(row, str):
            field_index = [x.name for x in rfr_embed_fields].index(str(row))
            if isinstance(row, str):
                db.remove_rfr_message_emoji_role(rfr_msg_row[3], emoji_raw=emoji.demojize(row), **kwargs)
            else:
                db.remove_rfr_message_emoji_role(rfr_msg_row[3], emoji_raw=row, **kwargs)
        else:
            # row is instance of role
            field_index = [x.value for x in rfr_embed_fields].index(row.mention)
            db.remove_rfr_message_emoji_role(rfr_msg_row[3], role_id=row.id, **kwargs)

        field = rfr_embed_fields[field_index]
        removed_field_indexes.append(field_index)
        reaction_emoji, err = await get_first_emoji_from_str(bot, guild, field.name)
        if (err != None):
            errors.append(err)
        reaction: discord.Reaction = [x for x in msg.reactions if str(x.emoji) == str(reaction_emoji)][0]
        reactions_to_remove.append(reaction)

    new_embed_fields = [field for field in rfr_embed_fields if
                        rfr_embed_fields.index(field) not in removed_field_indexes]

    for field in new_embed_fields:
        new_embed.add_field(name=field.name, value=field.value, inline=False)

    for reaction in reactions_to_remove:
        await reaction.clear()
    await msg.edit(embed=new_embed)

    return new_embed, errors


@assign_session
async def rfr_edit_emoji_role(bot: koalabot.KoalaBot, message_id: int, guild_id: int, channel_id: int,
                              emoji_role_map: List[Tuple[Union[discord.Emoji, str], discord.Role]],
                              **kwargs):
    guild = bot.get_guild(guild_id)
    channel = guild.get_channel(channel_id)

    _, _, _, emoji_role_id = db.get_rfr_message(guild_id, channel_id, message_id, **kwargs)
    emoji_roles = db.get_rfr_message_emoji_roles(emoji_role_id, **kwargs)
    remove_role_map = {emoji.emojize(r[1]): guild.get_role(r[2]) for r in emoji_roles}
    add_role_map = {}

    for emoji_str, role in emoji_role_map:
        if emoji.emojize(emoji_str) in remove_role_map.keys():
            remove_role_map.pop(emoji.emojize(emoji_str))
        else:
            add_role_map[emoji.emojize(emoji_str)] = role

    remove_role_map = [(r, remove_role_map.get(r)) for r in remove_role_map.keys()]
    add_role_map = [(r, add_role_map.get(r)) for r in add_role_map.keys()]

    if remove_role_map:
        await rfr_remove_emojis_roles(bot, guild, await channel.fetch_message(message_id), get_rfr_message(guild_id, channel_id, message_id, **kwargs),
                                      [r[1] for r in remove_role_map], **kwargs)

    if add_role_map:
        await rfr_add_emoji_role(guild, channel, await channel.fetch_message(message_id), add_role_map, **kwargs)


@assign_session
async def rfr_add_emoji_role(guild: discord.Guild, channel: discord.TextChannel,
                             msg: discord.Message, emoji_role_map: List[Tuple[Union[discord.Emoji, str], discord.Role]],
                             **kwargs):
    rfr_embed = get_embed_from_message(msg)
    duplicate_roles_found = False
    duplicate_emojis_found = False
    rfr_msg_row = db.get_rfr_message(guild.id, channel.id, msg.id)

    for emoji_role in emoji_role_map:
        discord_emoji = emoji_role[0]
        role = emoji_role[1]

        if discord_emoji in [x.name for x in rfr_embed.fields]:
            duplicate_emojis_found = True
        elif role in [x.value for x in rfr_embed.fields]:
            duplicate_roles_found = True
        else:
            if isinstance(discord_emoji, str):
                db.add_rfr_message_emoji_role(rfr_msg_row[3], emoji.demojize(discord_emoji),
                                              role.id, **kwargs)
            else:
                db.add_rfr_message_emoji_role(rfr_msg_row[3], str(discord_emoji), role.id, **kwargs)
            rfr_embed.add_field(name=str(discord_emoji), value=role.mention, inline=False)
            await msg.add_reaction(discord_emoji)

            if isinstance(discord_emoji, str):
                logger.info(
                    f"ReactForRole: Added role ID {str(role.id)} to rfr message (channel, guild) {msg.id} "
                    f"({str(channel.id)}, {str(guild.id)}) with emoji {emoji.demojize(discord_emoji)}.")
            else:
                logger.info(
                    f"ReactForRole: Added role ID {str(role.id)} to rfr message (channel, guild) {msg.id} "
                    f"({str(channel.id)}, {str(guild.id)}) with emoji {discord_emoji.id}.")

    edited_msg = await msg.edit(embed=rfr_embed)
    return duplicate_roles_found, duplicate_emojis_found, edited_msg


@assign_session
def edit_guild_rfr_required_roles(bot: koalabot.KoalaBot, guild_id: int, role_ids: List[int], **kwargs):
    guild = bot.get_guild(guild_id)

    add_role_ids = []
    remove_role_ids: List = rfr_list_guild_required_roles(guild, **kwargs).role_ids

    for role_id in role_ids:
        if role_id in remove_role_ids:
            remove_role_ids.remove(role_id)
        else:
            add_role_ids.append(role_id)

    for role_id in remove_role_ids:
        remove_guild_rfr_required_role(guild, role_id, **kwargs)

    for role_id in add_role_ids:
        add_guild_rfr_required_role(guild, role_id, **kwargs)


def add_guild_rfr_required_role(guild: discord.Guild, role_id: int, **kwargs):
    db.add_guild_rfr_required_role(guild.id, role_id, **kwargs)


def remove_guild_rfr_required_role(guild: discord.Guild, role_id: int, **kwargs):
    db.remove_guild_rfr_required_role(guild.id, role_id, **kwargs)


def rfr_list_guild_required_roles(guild: discord.Guild, **kwargs):
    return RequiredRoles(guild.id, db.get_guild_rfr_required_roles(guild.id, **kwargs))


async def setup_rfr_reaction_permissions(guild: discord.Guild, channel: discord.TextChannel, bot: Bot):
    """
    Overwrites a text channel's reaction perms so that nobody can add new reactions to any message sent in the
    channel, only the bot, to make sure people don't mess with the system. Relies on roles tending not to be added/
    removed constantly to keep performance satisfactory.
    :param guild: Guild that the rfr message is in
    :param channel: Channel that the rfr message is in
    :return:
    """
    #  Get the @everyone role.
    role: discord.Role = discord.utils.get(guild.roles, id=guild.id)
    overwrite: discord.PermissionOverwrite = discord.PermissionOverwrite()
    overwrite.update(add_reactions=False)
    # TODO - tests fail here with 403, missing 'manage_roles' permission
    await channel.set_permissions(role, overwrite=overwrite)
    bot_members = [member for member in guild.members if member.bot and member.id == bot.user.id]
    overwrite.update(add_reactions=True)
    for bot_member in bot_members:
        await channel.set_permissions(bot_member, overwrite=overwrite)


def get_embed_from_message(msg: discord.Message) -> Optional[discord.Embed]:
    """
    Gets the embed from a given message
    :param msg: Message to check
    :return: Returns the embed if there is one. If there isn't returns None
    """
    if not msg:
        return None
    try:
        embed = msg.embeds[0]
        if not embed:
            return None
        return embed
    except IndexError:
        return None


def get_number_of_embed_fields(embed: discord.Embed) -> int:
    """
    Gets the number of fields in an embed.
    :param embed: Embed to check
    :return: Number of embed fields.
    """
    return len(embed.fields)


async def get_first_emoji_from_str(bot: Bot, guild: discord.Guild,
                                   content: str) -> Tuple[Optional[Union[discord.Emoji, str]], Optional[str]]:
    """
    Gets the first emoji in a string input, custom or not. Doesn't work with custom emojis the bot doesn't have
    access to.
    :param bot:
    :param guild:
    :param content: Message content
    :return: Emoji if there is a valid one. Otherwise None.
    """

    # First check for a custom discord emoji in the string
    search_result = CUSTOM_EMOJI_REGEXP.search(str(content))
    if search_result:
        emoji_id = int(search_result[:-1].split(":")[-1])
        try:
            discord_emoji: discord.Emoji = await guild.fetch_emoji(emoji_id)
            if discord_emoji is None:
                discord_emoji: discord.Emoji = bot.get_emoji(emoji_id)
            return discord_emoji, None
        except commands.CommandError:
            return None, "An error occurred when trying to get the emoji. Please contact the bot developers for support."
        except commands.BadArgument:
            return None, "Couldn't get the emoji you used - is it from this server or a server I'm in?"

    # Check for a unicode emoji in the string
    search_result = UNICODE_EMOJI_REGEXP.search(content)
    search_result_flag = FLAG_EMOJI_REGEXP.search(content)
    if search_result or search_result_flag:
       return content, None

    return None, "No emoji found."

</document_content>
</document>
<document index="75">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/db.py</source>
<document_content>
#!/usr/bin/env python

# Built-in/Generic Imports
from typing import *

import sqlalchemy.exc
import sqlalchemy.orm
from sqlalchemy import select, delete, and_

from koala.db import assign_session
# Own modules
from koala.db import session_manager
from .log import logger
from .models import GuildRFRMessages, RFRMessageEmojiRoles, GuildRFRRequiredRoles


@assign_session
def add_rfr_message(guild_id: int, channel_id: int, message_id: int, session: sqlalchemy.orm.Session):
    """
    Add an rfr message to a guild. Table stores a unique emoji_role_id to prevent the same combination
    appearing twice on a given message
    :param guild_id: ID of the guild
    :param channel_id: ID of the channel the rfr message is in
    :param message_id: ID of the rfr message
    :return:
    """
    session.add(
        GuildRFRMessages(guild_id=guild_id, channel_id=channel_id, message_id=message_id))
    session.commit()


@assign_session
def add_rfr_message_emoji_role(emoji_role_id: int, emoji_raw: str, role_id: int, session: sqlalchemy.orm.Session):
    """
    Add an emoji-role combination to an rfr message.
    :param emoji_role_id: unique ID/key
    :param emoji_raw: raw emoji representation in string format
    :param role_id: ID of the role to give on react
    :return:
    """
    try:
        session.add(RFRMessageEmojiRoles(emoji_role_id=emoji_role_id, emoji_raw=emoji_raw, role_id=role_id))
        session.commit()
    except sqlalchemy.exc.IntegrityError:
        logger.warning("RFRMessageEmojiRoles already exists for <%s, %s, %s>, continuing",
                       emoji_role_id, emoji_raw, role_id)


@assign_session
def remove_rfr_message_emoji_role(emoji_role_id: int, emoji_raw: str = None, role_id: int = None,
                                  session: sqlalchemy.orm.Session = None):
    """
    Remove an emoji-role combination from the rfr message database. Uses the unique emoji_role_id to identify the
    specific combo. Only removes one emoji-role combo
    :param emoji_role_id: unique ID/key
    :param emoji_raw: raw string representation of the emoji
    :param role_id: ID of the role to give on react
    :return:
    """
    if not emoji_raw:
        delete_sql = delete(RFRMessageEmojiRoles) \
            .where(
            and_(
                RFRMessageEmojiRoles.emoji_role_id == emoji_role_id,
                RFRMessageEmojiRoles.role_id == role_id
            ))
    else:
        delete_sql = delete(RFRMessageEmojiRoles) \
            .where(
            and_(
                RFRMessageEmojiRoles.emoji_role_id == emoji_role_id,
                RFRMessageEmojiRoles.emoji_raw == emoji_raw
            ))
    session.execute(delete_sql)
    session.commit()


@assign_session
def remove_rfr_message_emoji_roles(emoji_role_id: int, session: sqlalchemy.orm.Session):
    """
    Removes all emoji-role combos with the same emoji_role_id i.e. on the same message.
    :param emoji_role_id: unique ID/key
    :return:
    """
    delete_sql = delete(RFRMessageEmojiRoles) \
        .where(RFRMessageEmojiRoles.emoji_role_id == emoji_role_id)

    session.execute(delete_sql)
    session.commit()


@assign_session
def remove_rfr_message(guild_id: int, channel_id: int, message_id: int, session: sqlalchemy.orm.Session):
    """
    Removes an rfr message from the rfr message database, and also removes all emoji-role combos as part of it.
    :param guild_id: Guild ID of the rfr message
    :param channel_id: Channel ID of the rfr message
    :param message_id: Message ID of the rfr message
    :return:
    """
    emoji_role_id = get_rfr_message(guild_id, channel_id, message_id)
    if not emoji_role_id:
        return
    else:
        remove_rfr_message_emoji_roles(emoji_role_id[3])

    delete_sql = delete(GuildRFRMessages) \
        .where(and_(and_(
        GuildRFRMessages.guild_id == guild_id,
        GuildRFRMessages.channel_id == channel_id),
        GuildRFRMessages.message_id == message_id))
    session.execute(delete_sql)
    session.commit()


@assign_session
def get_rfr_message(guild_id: int, channel_id: int, message_id: int, session: sqlalchemy.orm.Session) -> Optional[
    Tuple[int, int, int, int]]:
    """
    Gets the unique rfr message that is specified by the guild ID, channel ID and message ID.
    :param guild_id: Guild ID of the rfr message
    :param channel_id: Channel ID of the rfr message
    :param message_id: Message ID of the rfr message
    :return: RFR message info of the specific message if found, otherwise None.
    """
    message = session.execute(select(GuildRFRMessages)
                              .filter_by(guild_id=guild_id,
                                         channel_id=channel_id,
                                         message_id=message_id)).scalars().one_or_none()
    if message:
        return message.old_format()
    else:
        return None


@assign_session
def get_guild_rfr_messages(guild_id: int, session: sqlalchemy.orm.Session) -> List[Tuple[int, int, int]]:
    """
    Gets all rfr messages in a given guild, from the guild ID
    :param guild_id: ID of the guild
    :return: List of rfr messages in the guild.
    """
    messages = session.execute(select(GuildRFRMessages)
                               .filter_by(guild_id=guild_id)).scalars().all()
    return [message.old_format()
            for message in messages]


@assign_session
def get_guild_rfr_roles(guild_id: int, *, session) -> List[int]:
    """
    Returns all role IDs of roles given by RFR messages in a guild

    :param guild_id: Guild ID to check in.
    :param session: database session
    :return: Role IDs of RFR roles in a specific guild
    """
    rfr_messages = session.execute(select(GuildRFRMessages).filter_by(guild_id=guild_id)).scalars().all()
    if not rfr_messages:
        return []
    role_ids: List[int] = []
    for rfr_message in rfr_messages:
        roles: List[Tuple[int, str, int]] = get_rfr_message_emoji_roles(rfr_message.emoji_role_id)
        if not roles:
            continue
        ids: List[int] = [x[2] for x in roles]
        role_ids.extend(ids)
    return role_ids


@assign_session
def get_rfr_message_emoji_roles(emoji_role_id: int, *, session: sqlalchemy.orm.Session):
    """
    Returns all the emoji-role combinations on an rfr message

    :param emoji_role_id: emoji-role combo identifier
    :param session:
    :return: List of rows in the database if found, otherwise None
    """
    rows = session.execute(select(RFRMessageEmojiRoles).filter_by(emoji_role_id=emoji_role_id)).scalars().all()

    return [(row.emoji_role_id, row.emoji_raw, row.role_id) for row in rows]


@assign_session
def get_rfr_reaction_role(emoji_role_id: int, emoji_raw: str, role_id: int, *, session: sqlalchemy.orm.Session):
    """
    Returns a specific emoji-role combo on an rfr message

    :param emoji_role_id: emoji-role combo identifier
    :param emoji_raw: raw string representation of the emoji
    :param role_id: role ID of the emoji-role combo
    :param session:
    :return: Unique row corresponding to a specific emoji-role combo
    """
    row = session.execute(select(RFRMessageEmojiRoles).filter_by(
        emoji_role_id=emoji_role_id, emoji_raw=emoji_raw, role_id=role_id)).scalar()
    if row:
        return row.emoji_role_id, row.emoji_raw, row.role_id
    else:
        return None


@assign_session
def get_rfr_reaction_role_by_emoji_str(emoji_role_id: int, emoji_raw: str, session: sqlalchemy.orm.Session):
    """
    Gets a role ID from the emoji_role_id and the emoji associated with that role in the emoji-role combo
    :param emoji_role_id: emoji-role combo identifier
    :param emoji_raw: raw string representation of the emoji
    :return: role ID of the emoji-role combo
    """
    with session_manager() as session:
        row = session.execute(select(RFRMessageEmojiRoles.role_id)
                              .filter_by(emoji_role_id=emoji_role_id, emoji_raw=emoji_raw)).one_or_none()
        if not row:
            return
        return row[0]


@assign_session
def add_guild_rfr_required_role(guild_id: int, role_id: int, session: sqlalchemy.orm.Session):
    """
    Adds a role to the list of roles required to use rfr functionality in a guild.
    :param guild_id: guild ID
    :param role_id: role ID
    :return:
    """
    session.add(GuildRFRRequiredRoles(guild_id=guild_id, role_id=role_id))
    session.commit()


@assign_session
def remove_guild_rfr_required_role(guild_id: int, role_id: int, session: sqlalchemy.orm.Session):
    """
    Removes a role from the list of roles required to use rfr functionality in a guild
    :param guild_id: guild ID
    :param role_id: role ID
    :return:
    """
    session.execute(delete(GuildRFRRequiredRoles).filter_by(guild_id=guild_id, role_id=role_id))
    session.commit()


@assign_session
def get_guild_rfr_required_roles(guild_id, session: sqlalchemy.orm.Session) -> List[int]:
    """
    Gets the list of role IDs of roles required to use rfr functionality in a guild
    :param guild_id: guild ID
    :return: List of role IDs
    """
    rows = session.execute(select(GuildRFRRequiredRoles).filter_by(guild_id=guild_id)).scalars().all()

    role_ids = [x.role_id for x in rows]
    if not role_ids:
        return []
    return role_ids

</document_content>
</document>
<document index="76">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/dto.py</source>
<document_content>
from dataclasses import dataclass
from typing import List

import discord


@dataclass
class ReactRole:
    emoji: str
    role_id: int

    def to_tuple(self, guild: discord.Guild):
        return self.emoji, guild.get_role(self.role_id)


@dataclass
class ReactMessage:
    message_id: int
    guild_id: int
    channel_id: int
    title: str
    description: str
    colour: str
    thumbnail: str
    inline: bool
    roles: List[ReactRole]


@dataclass
class RequiredRoles:
    guild_id: int
    role_ids: List[int]

</document_content>
</document>
<document index="77">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/exception.py</source>
<document_content>
import enum

from koala.exception import KoalaException, KoalaErrorCode


class ReactionErrorCode(KoalaErrorCode):
    UNKNOWN_MEMBER_REACTION = "Unknown Member Reaction - userId: %s, guildId: %s"
    UNKNOWN_CHANNEL_REACTION = "Unknown Channel Reaction - channelId: %s, guildId: %s"
    UNKNOWN_MESSAGE_REACTION = "Unknown Message Reaction - messageId: %s, guildId: %s"
    UNKNOWN_REACTION_FIELD = "Unknown Reaction Field - messageId: %s, guildId: %s"
    UNKNOWN_REACTION_ROLE = "Unknown Reaction Role - roleId: %s, guildId: %s"


class ReactionException(KoalaException):
    pass

</document_content>
</document>
<document index="78">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="79">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/models.py</source>
<document_content>
from sqlalchemy import Column, INT, VARCHAR, ForeignKey, UniqueConstraint

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class GuildRFRMessages:
    __tablename__ = 'GuildRFRMessages'
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'))
    channel_id = Column(DiscordSnowflake)
    message_id = Column(DiscordSnowflake)
    emoji_role_id = Column(INT, primary_key=True)
    __table_args__ = (UniqueConstraint('guild_id', 'channel_id', 'message_id', name="uniq_message"),)

    def __repr__(self):
        return "<GuildRFRMessages(%s, %s, %s, %s)>" % \
               (self.emoji_role_id, self.guild_id, self.channel_id, self.message_id)

    def old_format(self):
        return int(self.guild_id), int(self.channel_id), int(self.message_id), int(self.emoji_role_id)


@mapper_registry.mapped
class RFRMessageEmojiRoles:
    __tablename__ = 'RFRMessageEmojiRoles'
    emoji_role_id = Column(INT, ForeignKey("GuildRFRMessages.emoji_role_id", ondelete='CASCADE'), primary_key=True)
    emoji_raw = Column(VARCHAR(50, collation="utf8mb4_unicode_520_ci"), primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)
    __table_args__ = (UniqueConstraint('emoji_role_id', 'emoji_raw', name="uniq_emoji"),
                      UniqueConstraint('emoji_role_id', 'role_id', name="uniq_role_emoji"))

    def __repr__(self):
        return "<RFRMessageEmojiRoles(%s, %s, %s)>" % \
               (self.emoji_role_id, self.emoji_raw, self.role_id)


@mapper_registry.mapped
class GuildRFRRequiredRoles:
    __tablename__ = 'GuildRFRRequiredRoles'
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'), primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)
    __table_args__ = (UniqueConstraint('guild_id', 'role_id', name="uniq_guild_role"),)

    def __repr__(self):
        return "<GuildRFRRequiredRoles(%s, %s)>" % \
               (self.guild_id, self.role_id)

</document_content>
</document>
<document index="80">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/react_for_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
KoalaBot Reaction Roles Code

Author: Anan Venkatesh
Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import re

import emoji
import flag

# Own modules

# Libs

# Constants

UNICODE_DISCORD_EMOJI_REGEXP: re.Pattern = re.compile(r"^:(\w+):$")
CUSTOM_EMOJI_REGEXP: re.Pattern = re.compile(r"^<a?:(\w+):(\d+)>$")
UNICODE_EMOJI_REGEXP: re.Pattern = re.compile(emoji.get_emoji_regexp())
FLAG_EMOJI_REGEXP: re.Pattern = re.compile("([\U0001F1E6-\U0001F1FF]+)", flags=re.UNICODE)
IMAGE_FORMATS = ("image/png", "image/jpeg", "image/gif")

</document_content>
</document>
<document index="81">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/__init__.py</source>
<document_content>
from . import utils, db, log, models
from .cog import ColourRole, setup

</document_content>
</document>
<document index="82">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
KoalaBot Cog for guild members wishing to change their role colour
"""

# Futures

# Built-in/Generic Imports

import math
import re
from typing import List, Tuple, Any

# Libs
import discord
from discord.ext import commands

# Own modules
import koalabot
from koala.db import insert_extension
from .db import ColourRoleDBManager
from .log import logger
from .utils import COLOUR_ROLE_NAMING


# Variables


def is_allowed_to_change_colour(ctx: commands.Context):
    """
    Command check to see if someone can use the custom_colour command

    :param ctx: Context of the command
    :return: True if the command invoker has a role in the list of roles that are allowed to use the command, False
    otherwise. Always False if there's no roles that have been granted permission to use the command
    """
    if isinstance(ctx.channel, discord.DMChannel):
        return False
    cr_database_manager = ColourRoleDBManager()
    allowed_role_ids = cr_database_manager.get_colour_change_roles(ctx.guild.id)
    allowed_set = set(allowed_role_ids)
    author: discord.Member = ctx.author
    author_role_ids = [role.id for role in author.roles]
    author_set = set(author_role_ids)
    return allowed_set & author_set


def colour_is_enabled(ctx):
    """
    A command used to check if the guild has enabled twitch alert
    e.g. @commands.check(koalabot.is_admin)
    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "ColourRole")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class ColourRole(commands.Cog):
    """
        A discord.py cog with commands to allow server members to change their display name colours to something of their choosing.
    """

    def __init__(self, bot):
        """
        Initialises local variables
        :param bot: The bot client for this cog
        """
        self.bot = bot
        insert_extension("ColourRole", 0, True, True)
        self.cr_database_manager = ColourRoleDBManager()

    @commands.Cog.listener()
    async def on_guild_role_delete(self, role: discord.Role):
        """
        Listens for roles being deleted in a guild. On a role being deleted, it automatically removes the role from the
        relevant database tables if it was protected or a permission role for using custom_colour, and reshuffles a
        guild's custom colour roles to ensure people who are still allowed to may keep their custom colour.

        :param role: Role that was deleted from the guild
        """
        protected = self.cr_database_manager.get_protected_colour_roles(role.guild.id)
        if role.id in protected:
            self.cr_database_manager.remove_guild_protected_colour_role(role.guild.id, role.id)
        custom_colour_allowed = self.cr_database_manager.get_colour_change_roles(role.guild.id)
        if role.id in custom_colour_allowed:
            self.cr_database_manager.remove_colour_change_role_perms(role.guild.id, role.id)
        await self.rearrange_custom_colour_role_positions(role.guild)

    def get_colour_from_hex_str(self, colour_str: str) -> discord.Colour:
        """
        Parses a length 6 hex string and returns a Discord.Colour made from that string.

        :param colour_str: Hex string of colour
        :return: Colour from colour_str
        """
        if colour_str[0] == '#':
            r = int(colour_str[1:3], 16)
            g = int(colour_str[3:5], 16)
            b = int(colour_str[-2:], 16)
        else:
            r = int(colour_str[:2], 16)
            g = int(colour_str[2:4], 16)
            b = int(colour_str[-2:], 16)
        return discord.Colour.from_rgb(r, g, b)

    @commands.cooldown(1, 15, commands.BucketType.member)
    @commands.check(is_allowed_to_change_colour)
    @commands.check(colour_is_enabled)
    @commands.command(name="customColour", aliases=["custom_colour", "customColor", "custom_color"])
    async def custom_colour(self, ctx: commands.Context, colour_str: str):
        """
        For a user with the correct role to be able to change their display colour in a guild.
        Syntax is k!custom_colour ("no" / colour hex). Usage with no removes any custom colour held before.
        Won't accept it if the colour chosen too closely resembles a role that was protected's colour or a discord
        blocked colour. A role must be made and that role be added to the permissions by usage of
        k!add_custom_colour_allowed_role <role>, and the command invoker must have that role before they can use this
        command. Has a 15 second cooldown.

        :param ctx: Context of the command
        :param colour_str: The colour hex string specified, or "no" in case of cancelling colour
        """
        colour_str = colour_str.upper()
        if colour_str[0] == "#":
            colour_str = colour_str[1:]
        if colour_str == "NO":
            removed = await self.prune_author_old_colour_roles(ctx)
            await ctx.send("Okay, removing your old custom colour role then, if you have one.")
            if not removed:
                await ctx.send(f"{ctx.author.mention} you don't have any colour roles to remove.")
            await self.prune_guild_empty_colour_roles(ctx)
        elif not ColourRole.is_valid_colour_str(colour_str):
            await ctx.send("Invalid colour string specified, make sure it's a valid colour hex.")
        else:
            colour = self.get_colour_from_hex_str(colour_str)
            # Check if the custom colour is valid
            invalid_colours = self.get_guild_protected_colours(ctx)
            valid_colour_check = ColourRole.is_valid_custom_colour(colour, invalid_colours)
            if not valid_colour_check[0]:
                fail: discord.Colour = valid_colour_check[1]
                await ctx.send(
                    f"Colour chosen was too close to an already protected colour {hex(fail.value)}. Please choose a different colour.")
            else:
                # remove the author's old colour roles
                await self.prune_author_old_colour_roles(ctx)
                # Check if the role exists already
                if ColourRole.role_already_exists(ctx, colour_str):
                    # add that role to the author
                    role = discord.utils.get(ctx.guild.roles, name=f"KoalaBot[0x{colour_str}]")
                    await ctx.author.add_roles(role)
                else:
                    # create the role
                    role: discord.Role = await self.create_custom_colour_role(colour, colour_str, ctx)
                    # add that role to the person
                    await ctx.author.add_roles(role)
                await ctx.send(f"Your new custom role colour is #{colour_str}, with the role {role.mention}")
                # prune any empty guild colour roles then
                await self.prune_guild_empty_colour_roles(ctx)

    @custom_colour.error
    async def custom_colour_error(self, ctx: commands.Context, error):
        """
        Catches any error from using the command custom_colour. Only has special case for CheckFailure. Others are
        logged, and a contact support message sent.

        :param ctx: Context of the command
        :param error: Error that occurred
        """
        if isinstance(error, commands.CheckFailure):
            await ctx.send("You don't have the required role to use this command.")
        else:
            import time
            logger.error(f"Unexpected error occurred in Guild {ctx.guild.id}, channel {ctx.channel.id}. "
                                  f"Error was of type {str(type(error))}. Cause was {error.__cause__}.")
            await ctx.send(
                f"Unexpected error occurred. Please contact bot developers with the timestamp {time.time()}, "
                f"guild ID {ctx.guild.id} and Error type {str(type(error))}")

    async def prune_author_old_colour_roles(self, ctx: commands.Context) -> bool:
        """
        Removes any old custom colour roles from the author/invoker of the command if they have any.

        :param ctx: Context of the command
        :return: True if a role was removed. False otherwise.
        """
        author: discord.Member = ctx.author
        roles: List[discord.Role] = [role for role in author.roles if
                                     re.match(COLOUR_ROLE_NAMING, role.name)]
        if not roles:
            logger.debug(
                f"User {author.id} in guild {ctx.guild.id} changed their colour. Found no old colour roles to prune.")
            return False
        await author.remove_roles(*roles)
        msg = "Removed their roles with role id(s) "
        for i in roles:
            msg += str(i.id)
            msg += ", "
        msg = msg[:-2] + "."
        logger.debug(
            f"User {author.id} in guild {ctx.guild.id} changed their colour. {msg}")
        return True

    async def prune_guild_empty_colour_roles(self, ctx: commands.Context):
        """
        Removes custom colour roles from the command context's guild if they've got no members with that role.

        :param ctx: Context of the command
        """
        guild: discord.Guild = ctx.guild
        roles: List[discord.Role] = [role for role in guild.roles if
                                     re.match(COLOUR_ROLE_NAMING, role.name) and len(role.members) == 0]
        if not roles:
            logger.debug(f"Found no empty colour roles to prune in guild {guild.id}.")
        else:
            msg = "Role IDs were "
            for role in roles:
                msg += str(role.id) + ", "
                await role.delete(reason="Pruned since empty colour role")
            msg = msg[:-2]
            logger.debug(f"Guild id {guild.id}. Pruned {len(roles)} colour roles with no members. {msg}")

    async def prune_members_old_colour_roles(self, members: List[discord.Member]) -> bool:
        """
        Removes custom colour roles from a list of members, for example if they all lost permission to have a custom
        colour if the list of roles allowed to have a custom colour changed.

        :param members: List of members whose custom colour roles should be removed
        :return: True if removed at least 1 member's role, or no members had that role in the first place. False
        otherwise.
        """
        if len(members) == 0:
            return True
        count = 0
        m: discord.Member = members[0]
        guild: discord.Guild = m.guild
        msg = "Removed colour roles from members who had held this role previously. These were members "
        for member in members:
            roles: List[discord.Role] = [role for role in member.roles if
                                         re.match(COLOUR_ROLE_NAMING, role.name)]
            if not roles:
                logger.debug(
                    f"Guild {member.guild.id} removed a role from their roles allowed to have custom colours. Found no newly illegal custom colour roles to prune from member {member.id}.")
            await member.remove_roles(*roles)
            count += 1
            msg += str(member.id) + ", "
        msg = msg[:-2] + "."
        logger.debug(
            f"Guild {guild.id} removed a role from their roles allowed to have custom colours. {msg}")
        if count == 0:
            return False
        return True

    async def create_custom_colour_role(self, colour: discord.Colour, colour_str: str,
                                        ctx: commands.Context) -> discord.Role:
        """
        Creates a custom colour role in the context's guild, with an auto-generated name.

        :param colour: Colour of the role
        :param colour_str: Hex string value of the role colour
        :param ctx: Context of the command
        :return: The role that was created
        """
        colour_role: discord.Role = await ctx.guild.create_role(name=f"KoalaBot[0x{colour_str}]",
                                                                colour=colour,
                                                                mentionable=False, hoist=False)
        colour_role = ctx.guild.get_role(colour_role.id)
        role_pos = self.calculate_custom_colour_role_position(ctx.guild)
        return await colour_role.edit(position=role_pos)

    def calculate_custom_colour_role_position(self, guild: discord.Guild) -> int:
        """
        Calculates the position a custom role colour should be to ensure it's shown on people's display names correctly.
        In most cases, it'll be 1 position lower than the lowest positioned protected role.

        :param guild: Guild to calculate for
        :return: Role position custom colour roles should be in.
        """
        protected_role_list: List[discord.Role] = self.get_protected_roles(guild)
        if len(guild.roles) == 0:
            return 1
        if protected_role_list is None or len(protected_role_list) == 0:
            bot_member: discord.Member = guild.get_member(self.bot.user.id)
            role_pos = sorted(bot_member.roles, key=lambda x: x.position)[-1].position - 1
        else:
            sorted_protected_role_list: List[discord.Role] = sorted(protected_role_list, key=lambda x: x.position)
            role_pos = sorted_protected_role_list[0].position
        if role_pos < 1:
            role_pos = 1
        return role_pos

    async def rearrange_custom_colour_role_positions(self, guild: discord.Guild):
        """
        Rearranges custom colour roles in a guild to ensure that they're still correctly positioned after updates to
        the guild's roles or the extension's protected roles and such.

        :param guild: Guild to rearrange roles in
        """
        role_pos = self.calculate_custom_colour_role_position(guild)
        roles: List[discord.Role] = [role for role in guild.roles if
                                     re.match(COLOUR_ROLE_NAMING, role.name)]
        for role in roles:
            await role.edit(position=role_pos)

    def get_guild_protected_colours(self, ctx: commands.Context) -> List[discord.Colour]:
        """
        Gets the list of protected roles' colours in the context's guild.

        :param discord.ext.commands.Context ctx: Context of the command
        :return: The list of the protected roles' colours
        :rtype: List[discord.Colour]
        """
        return ColourRole.get_role_colours(self.get_protected_roles(ctx.guild))

    @staticmethod
    def is_valid_colour_str(colour_str: str):
        """
        Checks if a string is a valid colour hex string value.

        :param colour_str: String to check
        :return: True if a valid colour hex string, false otherwise
        """
        if re.match("^(#?[A-Fa-f0-9]{6})$", colour_str):
            return True
        return False

    @staticmethod
    def get_role_colours(roles: List[discord.Role]) -> List[discord.Colour]:
        """
        Gets the list of role colours from a list of roles.

        :param roles: Roles whose colours to get
        :return: The list of colours to return
        :rtype: List[discord.Colour]
        """
        role_colours = [role.colour for role in roles]
        role_colours.extend([discord.Colour.from_rgb(0, 0, 0), discord.Colour.from_rgb(54, 54, 54),
                             discord.Colour.from_rgb(255, 255, 255)])
        return role_colours

    @staticmethod
    def get_rgb_colour_distance(colour1: discord.Colour, colour2: discord.Colour) -> float:
        """
        Gets colour distance between two colours. Uses a low-cost algorithm sourced from
        https://www.compuphase.com/cmetric.htm to determine the distance between colours in a way that mimics human
        perception.

        :param colour1: Colour 1 for distance calculation
        :param colour2: Colour 2 for distance calculation
        :return: Distance between colours. Ranges from 0 to ~768.
        """
        r_diff = colour2.r - colour1.r
        r_sqr_diff = r_diff ** 2
        g_diff = colour2.g - colour1.g
        g_sqr_diff = g_diff ** 2
        b_diff = colour2.b - colour1.b
        b_sqr_diff = b_diff ** 2
        # Below from https://www.compuphase.com/cmetric.htm
        r_avg: float = (colour1.r + colour2.r) / 2
        b_fra = (255 - r_avg) / 256
        r_fra = r_avg / 256
        dist_sqr = ((2 + r_fra) * r_sqr_diff) + (4 * g_sqr_diff) + ((2 + b_fra) * b_sqr_diff)
        dist = math.sqrt(dist_sqr)
        return dist

    @staticmethod
    def is_valid_custom_colour(custom_colour: discord.Colour, protected_colours: List[discord.Colour]) -> Tuple[
        bool, Any]:
        """
        Checks if a given custom colour is a valid custom colour and not too close to any protected colours.

        :param custom_colour: Custom colour given
        :param protected_colours: List of protected colours in a guild
        :return: Tuple whose first element is True if valid, and False if invalid. If valid, the second element is None.
        Otherwise, the second element is the colour it ended up being too close to.
        """
        if not protected_colours:
            return True, None
        for protected_colour in protected_colours:
            colour_distance = ColourRole.get_rgb_colour_distance(custom_colour, protected_colour)
            logger.info(
                f"Colour distance between {hex(custom_colour.value)} and {hex(protected_colour.value)} is {colour_distance}.")
            if colour_distance < 38.4:
                return False, protected_colour
        return True, None

    @staticmethod
    def role_already_exists(ctx: commands.Context, colour_str: str):
        """
        Checks if a custom colour role with a specific name already exists in the context's guild.

        :param ctx: Context of the command
        :param colour_str: Colour hex string to check
        :return: True if the role already exists, False otherwise.
        """
        role_name = f"KoalaBot[0x{colour_str}]"
        guild: discord.Guild = ctx.guild
        return role_name in [role.name for role in guild.roles]

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="listProtectedRoleColours",
                      aliases=["list_protected_role_colours", "listInvalidCustomColours", "listProtectedRoleColors",
                               "listInvalidCustomColors"])
    async def list_protected_role_colours(self, ctx: commands.Context):
        """
        Lists the protected roles, whose colours are protected from being imitated by a custom colour, in a
        guild. Requires admin permissions to use.

        :param ctx: Context of the command
        :return: Sends a message with the mentions of the roles that are protected in a guild
        """
        roles = self.get_protected_roles(ctx.guild)
        # logger.debug(roles)
        msg = "Roles whose colour is protected are:\r\n"
        for role in roles:
            msg += f"{role.mention}\n"
        await ctx.send(msg[:-1])

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="listCustomColourAllowedRoles",
                      aliases=["list_custom_colour_allowed_roles"])
    async def list_custom_colour_allowed_roles(self, ctx: commands.Context):
        """
        Lists the roles in a guild which are permitted to have their own custom colours. Requires admin
        permissions to use.

        :param ctx: Context of the command
        :return: Sends a message with the mentions of the roles that are protected in a guild.
        """
        roles = self.get_custom_colour_allowed_roles(ctx)
        # logger.debug(roles)
        msg = "Roles allowed to have a custom colour are:\r\n"
        for role in roles:
            msg += f"{role.mention}\n"
        await ctx.send(msg[:-1])

    def get_custom_colour_allowed_roles(self, ctx: commands.Context) -> List[discord.Role]:
        """
        Gets the list of roles in the context's guild that are allowed to have a custom colour.

        :param ctx: Context of the command
        :return: List of roles allowed to use the custom_colour command/have a custom colour
        """
        role_ids = self.cr_database_manager.get_colour_change_roles(ctx.guild.id)
        # logger.debug(role_ids)
        if not role_ids:
            return []
        guild: discord.Guild = ctx.guild
        roles = [guild.get_role(role_id) for role_id in role_ids]
        return roles

    def get_protected_roles(self, guild: discord.Guild) -> List[discord.Role]:
        """
        Gets the list of roles in the guild that are protected from custom colours.

        :param guild: Guild to check/access
        :return: List of roles which are protected
        """
        role_ids = self.cr_database_manager.get_protected_colour_roles(guild.id)
        # logger.debug(role_ids)
        if not role_ids:
            return []
        roles = [guild.get_role(role_id) for role_id in role_ids]
        return roles

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="addProtectedRoleColour",
                      aliases=["add_protected_role_colour", "addInvalidCustomColourRole", "addInvalidCustomColorRole",
                               "addProtectedRoleColor"])
    async def add_protected_role_colour(self, ctx: commands.Context, *, role_str: str):
        """
        Adds a role, via ID, mention or name, to the list of protected roles. Needs admin permissions to
        use.

        :param ctx: Context of the command
        :param role_str: The role to add (ID, name or mention)
        """
        role: discord.Role = await commands.RoleConverter().convert(ctx, role_str)
        if not role:
            await ctx.send("Please specify a single valid role's mention, ID or name.")
        else:
            self.cr_database_manager.add_guild_protected_colour_role(ctx.guild.id, role.id)
            await ctx.send(f"Added {role.mention} to the list of roles whose colours are protected.")
            await self.rearrange_custom_colour_role_positions(ctx.guild)

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="removeProtectedRoleColour",
                      aliases=["remove_protected_role_colour", "removeProtectedRoleColor",
                               "removeInvalidCustomColourRole", "removeInvalidCustomColorRole"])
    async def remove_protected_role_colour(self, ctx: commands.Context, *, role_str: str):
        """
        Removes a role, via ID, mention or name, from the list of protected roles. Needs admin permissions
        to use.

        :param ctx: Context of the command
        :param role_str: The role to remove (ID, name or mention)
        """
        role: discord.Role = await commands.RoleConverter().convert(ctx, role_str)
        if not role:
            await ctx.send("Please specify a single valid role's mention, ID or name.")
        else:
            self.cr_database_manager.remove_guild_protected_colour_role(ctx.guild.id, role.id)
            await ctx.send(f"Removed {role.mention} from the list of roles whose colours are protected.")
            await self.rearrange_custom_colour_role_positions(ctx.guild)

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="addCustomColourAllowedRole",
                      aliases=["add_custom_colour_allowed_role", "addCustomColorAllowedRole"])
    async def add_custom_colour_allowed_role(self, ctx: commands.Context, *, role_str: str):
        """
        Adds a role, via ID, mention or name, to the list of roles allowed to have a custom colour. Needs
        admin permissions to use.

        :param ctx: Context of the command
        :param role_str: The role to add (ID, name or mention)
        """
        role: discord.Role = await commands.RoleConverter().convert(ctx, role_str)
        if not role:
            await ctx.send("Please specify a single valid role's mention, ID or name.")
        else:
            self.cr_database_manager.add_colour_change_role_perms(ctx.guild.id, role.id)
            await ctx.send(f"Added {role.mention} to the list of roles allowed to have a custom colour.")

    @commands.check(koalabot.is_admin)
    @commands.check(colour_is_enabled)
    @commands.command(name="removeCustomColourAllowedRole",
                      aliases=["remove_custom_colour_allowed_role", "removeCustomColorAllowedRole"])
    async def remove_custom_colour_allowed_role(self, ctx: commands.Context, *, role_str: str):
        """
        Removes a role, via ID, mention or name, from the list of roles allowed to have a custom colour.
        Needs admin permissions to use.

        :param ctx: Context of the command
        :param role_str: The role to remove (ID, name or mention)
        """
        role: discord.Role = await commands.RoleConverter().convert(ctx, role_str)
        if not role:
            await ctx.send("Please specify a single valid role's mention, ID or name.")
        else:
            members: List[discord.Member] = role.members
            await self.prune_members_old_colour_roles(members)
            self.cr_database_manager.remove_colour_change_role_perms(ctx.guild.id, role.id)
            await ctx.send(
                f"Removed {role.mention} from the list of roles allowed to have a custom colour. Removed the role members' custom colours too, and pruned empty custom colour roles.")
            await self.prune_guild_empty_colour_roles(ctx)


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(ColourRole(bot))
    logger.info("ColourRole is ready.")
</document_content>
</document>
<document index="83">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/db.py</source>
<document_content>
#!/usr/bin/env python

"""
KoalaBot Cog for guild members wishing to change their role colour
"""

# Futures

# Built-in/Generic Imports
from typing import List, Optional

# Libs
from sqlalchemy import select, delete, and_

# Own modules
from koala.db import session_manager
# Own modules
from .models import GuildColourChangePermissions, GuildInvalidCustomColourRoles


# Variables


class ColourRoleDBManager:
    """
    A class for interacting with the Koala Colour Role database
    """

    def add_colour_change_role_perms(self, guild_id, role_id):
        with session_manager() as session:
            new = GuildColourChangePermissions(guild_id=guild_id, role_id=role_id)
            session.add(new)
            session.commit()

    def remove_colour_change_role_perms(self, guild_id, role_id):
        with session_manager() as session:
            session.execute(
                delete(GuildColourChangePermissions)
                .where(
                    and_(GuildColourChangePermissions.guild_id == guild_id,
                         GuildColourChangePermissions.role_id == role_id)))
            session.commit()

    def add_guild_protected_colour_role(self, guild_id, role_id):
        with session_manager() as session:
            new = GuildInvalidCustomColourRoles(guild_id=guild_id, role_id=role_id)
            session.add(new)
            session.commit()

    def remove_guild_protected_colour_role(self, guild_id, role_id):
        with session_manager() as session:
            session.execute(
                delete(GuildInvalidCustomColourRoles)
                .where(
                    and_(GuildInvalidCustomColourRoles.guild_id == guild_id,
                         GuildInvalidCustomColourRoles.role_id == role_id)))
            session.commit()

    def get_protected_colour_roles(self, guild_id) -> Optional[List[int]]:
        with session_manager() as session:
            colour_roles = session.execute(select(GuildInvalidCustomColourRoles)
                                           .filter_by(guild_id=guild_id)).scalars().all()
            if colour_roles:
                return [colour_role.role_id for colour_role in colour_roles]
            else:
                return []

    def get_colour_change_roles(self, guild_id) -> Optional[List[int]]:
        with session_manager() as session:
            colour_roles = session.execute(select(GuildColourChangePermissions)
                                           .filter_by(guild_id=guild_id)).scalars().all()
            if colour_roles:
                return [colour_role.role_id for colour_role in colour_roles]
            else:
                return []

</document_content>
</document>
<document index="84">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="85">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/models.py</source>
<document_content>
from sqlalchemy import Column, ForeignKey

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class GuildColourChangePermissions:
    __tablename__ = 'GuildColourChangePermissions'
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'), primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)

    def __repr__(self):
        return "<GuildColourChangePermissions(%s, %s)>" % \
               (self.guild_id, self.role_id)


@mapper_registry.mapped
class GuildInvalidCustomColourRoles:
    __tablename__ = 'GuildInvalidCustomColourRoles'
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'), primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)

    def __repr__(self):
        return "<GuildColourChangePermissions(%s, %s)>" % \
               (self._guild_id, self._role_id)

</document_content>
</document>
<document index="86">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/colour_role/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
KoalaBot Cog for guild members wishing to change their role colour
"""

# Futures

# Built-in/Generic Imports

# Libs

# Own modules

# Variables

# Constants
COLOUR_ROLE_NAMING = r"^KoalaBot\x5B0x#?[A-F0-9]{6}\x5D$"

</document_content>
</document>
<document index="87">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/__init__.py</source>
<document_content>
from . import utils, db, models
from .cog import IntroCog, setup

</document_content>
</document>
<document index="88">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Intro Message Cog Code

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import asyncio

import discord
from discord.ext import commands

# Own modules
import koalabot
from .db import get_guild_welcome_message, update_guild_welcome_message, new_guild_welcome_message, \
    remove_guild_welcome_message
from .log import logger
from .utils import get_non_bot_members, ask_for_confirmation, wait_for_message, \
    BASE_LEGAL_MESSAGE


# Constants

# Variables


class IntroCog(commands.Cog, name="Intro"):
    """
    A discord.py cog with commands pertaining to the welcome messages that a member will receive
    """

    def __init__(self, bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild):
        """
        On bot joining guild, add this guild to the database of guild welcome messages.
        :param guild: Guild KoalaBot just joined
        """
        new_guild_welcome_message(guild.id)
        logger.info(f"KoalaBot joined new guild, id = {guild.id}, name = {guild.name}.")

    @commands.Cog.listener()
    async def on_member_join(self, member: discord.Member):
        """
        On member joining guild, send DM to member with welcome message.
        :param member: Member which just joined guild
        """
        await koalabot.dm_group_message([member], get_guild_welcome_message(member.guild.id))
        logger.info(f"New member {member.name} joined guild id {member.guild.id}. Sent them welcome message.")

    @commands.Cog.listener()
    async def on_guild_remove(self, guild: discord.Guild):
        """
        On bot leaving guild, remove the guild from the database of guild welcome messages
        :param guild: Guild KoalaBot just left
        """
        count = remove_guild_welcome_message(guild.id)
        logger.info(
            f"KoalaBot left guild, id = {guild.id}, name = {guild.name}. Removed {count} rows from GuildWelcomeMessages")

    @commands.cooldown(1, 60, commands.BucketType.guild)
    @commands.check(koalabot.is_admin)
    @commands.command(name="welcomeSendMsg", aliases=["send_welcome_message"])
    async def send_welcome_message(self, ctx):
        """
        Allows admins to send out their welcome message manually to all members of a guild. Has a 60 second cooldown per
        guild.

        :param ctx: Context of the command
        """
        non_bot_members = get_non_bot_members(ctx.guild)

        await ctx.send(f"This will DM {len(non_bot_members)} people. Are you sure you wish to do this? Y/N")
        try:
            confirmation_received = await ask_for_confirmation(await wait_for_message(self.bot, ctx), ctx.channel)
        except asyncio.TimeoutError:
            await ctx.send('Timed out.')
            confirmation_received = False
        if confirmation_received:
            await ctx.send("Okay, sending out the welcome message now.")
            await koalabot.dm_group_message(non_bot_members, get_guild_welcome_message(ctx.guild.id))
            return True
        else:
            await ctx.send("Okay, I won't send out the welcome message then.")
            return False

    @commands.cooldown(1, 60, commands.BucketType.guild)
    @commands.check(koalabot.is_admin)
    @commands.command(name="welcomeUpdateMsg", aliases=["update_welcome_message"])
    async def update_welcome_message(self, ctx, *, new_message: str):
        """
        Allows admins to change their customisable part of the welcome message of a guild. Has a 60 second cooldown per
        guild.

        :param ctx: Context of the command
        :param new_message: New customised part of the welcome message
        """
        if len(new_message) > 1600:
            await ctx.send("Your welcome message is too long to send, sorry. The maximum character limit is 1600.")
        else:
            await ctx.send(f"""Your current welcome message is:\n\r{get_guild_welcome_message(ctx.guild.id)}""")
            await ctx.send(f"""Your new welcome message will be:\n\r{new_message}\n\r{BASE_LEGAL_MESSAGE}\n\rWould """ +
                           """you like to update the message? Y/N?""")
            try:
                confirmation_received = await ask_for_confirmation(await wait_for_message(self.bot, ctx), ctx.channel)
            except asyncio.TimeoutError:
                await ctx.send('Timed out.')
                confirmation_received = False
            if confirmation_received:
                try:
                    await ctx.send("Okay, updating the welcome message of the guild in the database now.")
                    new_message = new_message.lstrip()
                    updated_entry = update_guild_welcome_message(ctx.guild.id, new_message)
                    await ctx.send(f"Updated in the database, your new welcome message is {updated_entry}.")
                except None:
                    await ctx.send("Something went wrong, please contact the bot developers for support.")
            else:
                await ctx.send("Okay, I won't update the welcome message then.")

    @commands.check(koalabot.is_admin)
    @commands.command(name="welcomeViewMsg")
    async def view_welcome_message(self, ctx):
        """
        Shows this server's current welcome message
        """
        await ctx.send(f"""Your current welcome message is:\n\r{get_guild_welcome_message(ctx.guild.id)}""")

    @update_welcome_message.error
    async def on_update_error(self, ctx, error):
        if isinstance(error, discord.ext.commands.MissingRequiredArgument):
            await ctx.send('Please put in a welcome message to update to.')


async def setup(bot: koalabot) -> None:
    """
    Loads this cog into the selected bot
    :param bot: The client of the KoalaBot
    """
    await bot.add_cog(IntroCog(bot))
    logger.info("IntroCog is ready.")

</document_content>
</document>
<document index="89">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/db.py</source>
<document_content>
# Futures

# Built-in/Generic Imports

# Libs
from sqlalchemy import select, update

# Own modules
from koala.db import session_manager
from .models import GuildWelcomeMessages
from .utils import DEFAULT_WELCOME_MESSAGE, BASE_LEGAL_MESSAGE


# Constants

# Variables


def fetch_guild_welcome_message(guild_id):
    """
    Fetches the guild welcome message for a given guild

    :param guild_id: Discord guild ID for a given server
    """
    with session_manager() as session:
        msg = session.execute(select(GuildWelcomeMessages.welcome_message)
                              .where(GuildWelcomeMessages.guild_id == guild_id)).one_or_none()
    if not msg:
        return None
    else:
        return msg.welcome_message


def update_guild_welcome_message(guild_id, new_message: str):
    """
    Update guild welcome message for a given guild

    :param guild_id: Discord guild ID for a given server
    :param new_message: The new guild welcome message to be set
    """
    with session_manager() as session:
        session.execute(update(GuildWelcomeMessages)
                        .where(GuildWelcomeMessages.guild_id == guild_id)
                        .values(welcome_message=new_message))
        session.commit()
    return new_message


def remove_guild_welcome_message(guild_id):
    """
    Removes the guild welcome message from a given guild

    :param guild_id: Discord guild ID for a given server
    """
    with session_manager() as session:
        welcome_message = session.execute(select(GuildWelcomeMessages).filter_by(guild_id=guild_id))\
            .scalars().one_or_none()
        if welcome_message:
            session.delete(welcome_message)
            session.commit()
            return 1
        return 0


def new_guild_welcome_message(guild_id):
    """
    Sets the default guild welcome message to a given guild

    :param guild_id: Discord guild ID for a given server
    """

    with session_manager() as session:
        session.add(GuildWelcomeMessages(guild_id=guild_id, welcome_message=DEFAULT_WELCOME_MESSAGE))
        session.commit()
    return fetch_guild_welcome_message(guild_id)


def get_guild_welcome_message(guild_id: int):
    """
    Retrieves a guild's customised welcome message from the database. Includes the basic legal message constant
    :param guild_id: ID of the guild
    :return: The particular guild's welcome message : str
    """
    msg = fetch_guild_welcome_message(guild_id)
    if msg is None:
        msg = new_guild_welcome_message(guild_id)
    return f"{msg}\r\n{BASE_LEGAL_MESSAGE}"

</document_content>
</document>
<document index="90">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="91">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/models.py</source>
<document_content>
from sqlalchemy import Column, VARCHAR

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class GuildWelcomeMessages:
    __tablename__ = 'GuildWelcomeMessages'
    guild_id = Column(DiscordSnowflake, primary_key=True)
    welcome_message = Column(VARCHAR(2000, collation="utf8mb4_unicode_520_ci"), nullable=True)

    def __repr__(self):
        return "<GuildWelcomeMessages(%s, %s)>" % \
               (self.guild_id, self.welcome_message)

</document_content>
</document>
<document index="92">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/intro_cog/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Intro Message Cog Code

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
from discord.ext import commands

# Own modules
import koalabot

# Constants

BASE_LEGAL_MESSAGE = """This server utilizes KoalaBot. In joining this server, you agree to the Terms & Conditions of
KoalaBot and confirm you have read and understand our Privacy Policy. For legal documents relating to this, please view
the following link: http://legal.koalabot.uk/"""
DEFAULT_WELCOME_MESSAGE = "Hello. This is a default welcome message because the guild that this came from did not configure a welcome message! Please see below."

# Variables


def wait_for_message(bot: discord.Client, ctx: commands.Context, timeout=60.0) -> (discord.Message, discord.TextChannel):
    try:
        confirmation = bot.wait_for('message', timeout=timeout, check=lambda message: message.author == ctx.author)
        return confirmation
    except Exception:
        confirmation = None
    return confirmation, ctx.channel


async def ask_for_confirmation(confirmation: discord.Message, channel: discord.TextChannel):
    if confirmation is None:
        await channel.send('Timed out.')
        return False
    else:
        channel = confirmation.channel
        x = await confirm_message(confirmation)
        if x is None:
            await channel.send('Invalid input, please redo the command.')
            return False
        return x


async def confirm_message(message: discord.Message):
    conf_message = message.content.rstrip().strip().lower()
    if conf_message not in ['y', 'n']:
        return
    else:
        if conf_message == 'y':
            return True
        else:
            return False


def get_non_bot_members(guild: discord.Guild):
    if koalabot.is_dpytest:
        return [member for member in guild.members if not member.bot and str(member) != koalabot.TEST_BOT_USER]
    else:
        return [member for member in guild.members if not member.bot]

</document_content>
</document>
<document index="93">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/__init__.py</source>
<document_content>
from . import log, models, api, cog
from .cog import Verification


async def setup(bot):
    await cog.setup(bot)
    api.setup(bot)

</document_content>
</document>
<document index="94">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/api.py</source>
<document_content>
# Futures
# Built-in/Generic Imports
# Libs
from typing import List

from aiohttp import web
from discord.ext.commands import Bot

from koala.rest.api import parse_request
# Own modules
from . import core
from .dto import VerifyRole
from .log import logger

# Constants
VERIFY_ENDPOINT = 'verify'
CONFIG_ENDPOINT = 'config'
REVERIFY_ENDPOINT = 'reverify'

# Variables


class VerifyEndpoint:
    """
    The API endpoints for Verify
    """
    def __init__(self, bot):
        self._bot = bot

    def register(self, app):
        """
        Register the routes for the given application
        :param app: The aiohttp.web.Application (likely of the sub app)
        :return: app
        """
        app.add_routes([web.get('/{}'.format(CONFIG_ENDPOINT), self.get_verify_config),
                        web.put('/{}'.format(CONFIG_ENDPOINT), self.put_verify_config),
                        web.post('/{}'.format(REVERIFY_ENDPOINT), self.post_reverify)])
        return app

    @parse_request
    async def get_verify_config(self, guild_id: int):
        """
        Get verify config for a given server
        :param guild_id: Guild ID of server
        :return: VerifyConfig
        """
        guild_id = int(guild_id)
        return core.get_verify_config_dto(guild_id)

    @parse_request
    async def put_verify_config(self, guild_id: int, roles: List[dict]):
        """
        Set verify config for a given server
        :param guild_id: Guild ID of server
        :param roles: List of VerifyRole
        :return: VerifyConfig
        """
        guild_id = int(guild_id)
        if roles is not None:
            roles = [VerifyRole(r["email_suffix"], r["role_id"]) for r in roles]

        return await core.set_verify_role(guild_id, roles, self._bot)

    @parse_request
    async def post_reverify(self, guild_id: int, role_id: int):
        """
        Mark a role for re-verification in a server
        :param guild_id: Guild ID of server
        :param role_id: Role ID to be re-verified
        :return: Role ID
        """
        guild_id = int(guild_id)
        role_id = int(role_id)
        await core.re_verify_role(guild_id, role_id, self._bot)
        return {"role_id": role_id}


def setup(bot: Bot):
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    sub_app = web.Application()
    endpoint = VerifyEndpoint(bot)
    endpoint.register(sub_app)
    getattr(bot, "koala_web_app").add_subapp('/{}'.format(VERIFY_ENDPOINT), sub_app)
    logger.info("Base API is ready.")

</document_content>
</document>
<document index="95">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Cog code and additional base cog functions
Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord
from discord.ext import commands

# Own modules
import koalabot
from koala.db import insert_extension
from . import core, errors
from .env import GMAIL_EMAIL, GMAIL_PASSWORD
from .log import logger


# Constants

# Variables


def verify_is_enabled(ctx):
    """
    A command used to check if the guild has enabled verify
    e.g. @commands.check(verify_is_enabled)
    :param ctx: The context of the message
    :return: True if enabled or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "Verify")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class Verification(commands.Cog, name="Verify"):

    def __init__(self, bot):
        self.bot = bot
        self.on_ready_ran=False
        insert_extension("Verify", 0, True, True)

    @commands.Cog.listener()
    async def on_ready(self):
        if not self.on_ready_ran:
            self.on_ready_ran = True
            await core.assign_roles_on_startup(self.bot)

    @commands.Cog.listener()
    async def on_member_join(self, member):
        """
        Assigns necessary roles to users upon joining a server
        :param member: the member object who just joined a server
        :return:
        """
        await core.send_verify_intro_message(member)

    @commands.check(koalabot.is_admin)
    @commands.command(name="verifyAdd", aliases=["addVerification"])
    @commands.check(verify_is_enabled)
    async def enable_verification(self, ctx: commands.Context, suffix: str, role: discord.Role):
        """
        Set up a role and email pair for KoalaBot to verify users with
        :param ctx: context of the discord message
        :param suffix: end of the email (e.g. "example.com")
        :param role: the role to give users with that email verified (e.g. @students)
        :return:
        """
        await core.add_verify_role(ctx.guild.id, suffix, role.id, self.bot)
        await ctx.send(f"Verification enabled for {role} for emails ending with `{suffix}`")

    @commands.check(koalabot.is_admin)
    @commands.command(name="verifyRemove", aliases=["removeVerification"])
    @commands.check(verify_is_enabled)
    async def disable_verification(self, ctx, suffix: str, role: discord.Role):
        """
        Disable an existing verification listener
        :param ctx: context of the discord message
        :param suffix: end of the email (e.g. "example.com")
        :param role: the role paired with the email (e.g. @students)
        :return:
        """
        core.remove_verify_role(ctx.guild.id, suffix, role.id)

        await ctx.send(f"Emails ending with {suffix} no longer give {role}")

    @commands.check(koalabot.is_admin)
    @commands.command(name="verifyBlacklist")
    @commands.check(verify_is_enabled)
    async def blacklist(self, ctx, user: discord.Member, role: discord.Role, suffix: str):
        """
        Blacklist a user from gaining a specified role using a given email
        :param ctx: context of the discord message
        :param user: user to be blacklisted
        :param role: role to be blacklisted for user
        :param suffix: suffix of email to be blacklisted for user
        :return:
        """
        await core.blacklist_member(user.id, ctx.guild.id, role.id, suffix, self.bot)
        await ctx.send(f"{user} will no longer receive {role} upon verifying with this email suffix")

    @commands.check(koalabot.is_admin)
    @commands.command(name="verifyBlacklistRemove")
    @commands.check(verify_is_enabled)
    async def blacklist_remove(self, ctx, user: discord.Member, role: discord.Role, suffix: str):
        """
        Remove a blacklisted user
        :param ctx: context of the discord message
        :param user: user to be un-blacklisted
        :param role: role to be un-blacklisted for user
        :param suffix: suffix of email to be un-blacklisted for user
        :return:
        """
        await core.remove_blacklist_member(user.id, ctx.guild.id, role.id, suffix, self.bot)
        await ctx.send(f"{user} will now be able to receive {role} upon verifying with this email suffix")

    @commands.check(koalabot.is_admin)
    @commands.command(name="verifyBlacklistList")
    @commands.check(verify_is_enabled)
    async def blacklist_list(self, ctx):
        """
        List the blacklisted user and role mappings
        :param ctx: context of the discord message
        :return:
        """
        embed = discord.Embed(title=f"Current verification blacklist for {ctx.guild.name}")
        blacklist_map = core.grouped_list_blacklist(ctx.guild.id, self.bot)

        for rd_suffix, rd_roles in blacklist_map.items():
            embed.add_field(name=rd_suffix, value='\n'.join(rd_roles))

        await ctx.send(embed=embed)

    @commands.check(koalabot.is_dm_channel)
    @commands.command(name="verify")
    async def verify(self, ctx, email: str):
        """
        Send to KoalaBot in dms to verify an email with our system
        :param ctx: the context of the discord message
        :param email: the email you want to verify
        :return:
        """
        try:
            await core.email_verify_send(ctx.author.id, email, self.bot)
        except errors.VerifyExistsException as e:
            await ctx.send(e.__str__()+" Would you like to verify anyway? (y/n)")

            def check(m):
                return m.channel == ctx.channel and m.author == ctx.author

            msg = await self.bot.wait_for('message', check=check)
            if msg.content.lower() == "y" or msg.content.lower() == "yes":
                await core.email_verify_send(ctx.author.id, email, self.bot, force=True)
            else:
                await ctx.send(f"Okay, you will not be verified with {email}")
                return
        await ctx.send("Please verify yourself using the command you have been emailed")

    @commands.check(koalabot.is_dm_channel)
    @commands.command(name="unVerify")
    async def un_verify(self, ctx, email):
        """
        Send to KoalaBot in dms to un-verify an email with our system
        :param ctx: the context of the discord message
        :param email: the email you want to un-verify
        :return:
        """
        await core.email_verify_remove(ctx.author.id, email, self.bot)
        await ctx.send(f"{email} has been un-verified and relevant roles have been removed")

    @commands.check(koalabot.is_dm_channel)
    @commands.command(name="confirm")
    async def confirm(self, ctx, token):
        """
        Send to KoalaBot in dms to confirm the verification of an email
        :param ctx: the context of the discord message
        :param token: the token emailed to you to verify with
        :return:
        """
        await core.email_verify_confirm(ctx.author.id, token, self.bot)
        await ctx.send("Your email has been verified, thank you")

    @commands.check(koalabot.is_owner)
    @commands.command(name="getEmails")
    async def get_emails(self, ctx, user_id: int):
        """
        See the emails a user is verified with
        :param ctx: the context of the discord message
        :param user_id: the id of the user whose emails you want to find
        :return:
        """
        emails = '\n'.join(core.email_verify_list(user_id))
        await ctx.send(f"This user has registered with:\n{emails}")

    @commands.command(name="verifyList", aliases=["checkVerifications"])
    @commands.check(verify_is_enabled)
    async def check_verifications(self, ctx):
        """
        List the current verification setup for the server
        :param ctx: the context of the discord message
        :return:
        """
        embed = discord.Embed(title=f"Current verification setup for {ctx.guild.name}")
        role_dict = core.grouped_list_verify_role(ctx.guild.id, self.bot)

        for rd_suffix, rd_roles in role_dict.items():
            embed.add_field(name=rd_suffix, value='\n'.join(rd_roles))

        await ctx.send(embed=embed)

    @commands.check(koalabot.is_admin)
    @commands.command(name="reVerify")
    @commands.check(verify_is_enabled)
    async def re_verify(self, ctx, role: discord.Role):
        """
        Removes a role from all users who have it and marks them as needing to re-verify before giving it back
        :param ctx: the context of the discord message
        :param role: the role to be removed and re-verified (e.g. @students)
        :return:
        """
        await core.re_verify_role(ctx.guild.id, role.id, self.bot)
        await ctx.send("That role has now been removed from all users and they will need to "
                       "re-verify the associated email.")


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    if GMAIL_EMAIL is None or GMAIL_PASSWORD is None:
        logger.warning("Verification not started. API keys not found in environment.")
        insert_extension("Verify", 0, False, False)
    else:
        await bot.add_cog(Verification(bot))
        logger.info("Verification is ready.")

</document_content>
</document>
<document index="96">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/core.py</source>
<document_content>
#!/usr/bin/env python
import random
import string
from typing import List, Dict, Tuple
import re

# Futures
# Built-in/Generic Imports
# Libs
import discord
from discord.ext.commands import Bot
from sqlalchemy import select, text, delete, and_
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session

import koalabot
# Own modules
from koala.cogs.verification import errors
from koala.cogs.verification.dto import VerifyConfig, VerifyRole
from koala.cogs.verification.errors import VerifyException
from koala.cogs.verification.log import logger
from koala.cogs.verification.models import VerifiedEmails, ToReVerify, VerifyBlacklist, Roles, NonVerifiedEmails
from koala.cogs.verification.utils import send_email
from koala.db import assign_session
from koala.enums import DatabaseType
from koala.env import DB_TYPE
# Constants
# Variables
from koala.errors import InvalidArgumentError

'''
COMMANDS
'''


@assign_session
async def set_verify_role(guild_id, roles: List[VerifyRole], bot, **kwargs):
    add_roles: List[VerifyRole] = []
    remove_roles: List[VerifyRole] = [VerifyRole.from_db_roles(r) for r in list_verify_role(guild_id, **kwargs)]
    for role in roles:
        if role in remove_roles:
            remove_roles.remove(role)
        else:
            add_roles.append(role)

    for role in add_roles:
        await add_verify_role(guild_id, role.email_suffix, role.role_id, bot, **kwargs)

    for role in remove_roles:
        remove_verify_role(guild_id, role.email_suffix, role.role_id, **kwargs)

    return get_verify_config_dto(guild_id)


@assign_session
async def add_verify_role(guild_id, email_suffix, role_id, bot: koalabot.KoalaBot, *, session: Session):
    email_suffix = email_suffix.lower()
    guild = bot.get_guild(guild_id)

    role = guild.get_role(role_id)
    if not role:
        raise InvalidArgumentError("Please mention a role in this guild")

    exists = session.execute(select(Roles)
                             .filter_by(s_id=guild_id, r_id=role_id, email_suffix=email_suffix)).all()
    if exists:
        raise VerifyException("Verification is already enabled for that role")

    session.add(Roles(s_id=guild_id, r_id=role_id, email_suffix=email_suffix))
    session.commit()

    await assign_role_to_guild(guild, role, email_suffix)


@assign_session
def remove_verify_role(guild_id, email_suffix, role_id, *, session: Session):
    email_suffix = email_suffix.lower()
    session.execute(delete(Roles).filter_by(s_id=guild_id, r_id=role_id, email_suffix=email_suffix))
    session.commit()


@assign_session
def get_verify_config_dto(guild_id, **kwargs) -> VerifyConfig:
    return VerifyConfig(guild_id, [VerifyRole(r.email_suffix, r.r_id) for r in list_verify_role(guild_id, **kwargs)])


@assign_session
def list_verify_role(guild_id, *, session: Session) -> List[Roles]:
    return session.execute(select(Roles).filter_by(s_id=guild_id)).scalars().all()


@assign_session
def grouped_list_verify_role(guild_id, bot: koalabot.KoalaBot, *, session: Session) -> Dict[str, List[str]]:
    guild = bot.get_guild(guild_id)
    roles = list_verify_role(guild_id, session=session)
    role_dict = {}
    for role in roles:
        d_role = guild.get_role(role.r_id)
        if d_role is None:
            session.execute(delete(Roles).filter_by(r_id=role.r_id))
        elif role.email_suffix in role_dict:
            role_dict[role.email_suffix].append("@" + d_role.name)
        else:
            role_dict[role.email_suffix] = ["@" + d_role.name]
    session.commit()
    return role_dict


@assign_session
async def re_verify_role(guild_id, role_id, bot: koalabot.KoalaBot, *, session: Session):
    exists = session.execute(select(Roles).filter_by(s_id=guild_id, r_id=role_id)).all()

    if not exists:
        raise VerifyException("Verification is not enabled for that role")
    existing_reverify = session.execute(select(ToReVerify.u_id).filter_by(r_id=role_id)).scalars().all()
    guild = bot.get_guild(guild_id)
    role = guild.get_role(role_id)
    for member in role.members:
        await member.remove_roles(role)
        if member.id not in existing_reverify:
            session.add(ToReVerify(u_id=member.id, r_id=role_id))

    session.commit()


@assign_session
async def blacklist_member(user_id, guild_id, role_id, suffix, bot: Bot, *, session: Session):
    guild: discord.Guild = bot.get_guild(guild_id)
    role = guild.get_role(role_id)

    if not role:
        raise InvalidArgumentError("Please mention a role in this guild")

    blacklisted = VerifyBlacklist(user_id=user_id, role_id=role_id, email_suffix=suffix)
    try:
        session.add(blacklisted)
        session.commit()
    except IntegrityError:
        raise errors.VerifyException("This user verification is already blacklisted.")
    await remove_roles_for_user(user_id, suffix, bot, session=session)


@assign_session
async def remove_blacklist_member(user_id, guild_id, role_id, suffix, bot: Bot, *, session: Session):
    guild: discord.Guild = bot.get_guild(guild_id)
    role = guild.get_role(role_id)

    if not role:
        raise InvalidArgumentError("Please mention a role in this guild")

    blacklisted = session.execute(select(VerifyBlacklist)
                                  .filter_by(user_id=user_id, role_id=role_id, email_suffix=suffix)).scalar()
    if not blacklisted:
        raise errors.VerifyException("This user verification blacklist doesn't exist.")
    session.delete(blacklisted)
    session.commit()

    await assign_roles_for_user(user_id, suffix, bot, session=session)
    await assign_role_to_guild(guild, role, suffix, session=session)


@assign_session
def grouped_list_blacklist(guild_id, bot: koalabot.KoalaBot, *, session: Session) -> Dict[str, List[str]]:
    guild = bot.get_guild(guild_id)
    blacklist_array = session.execute(
        select(VerifyBlacklist)
        .where(VerifyBlacklist.role_id.in_([r.id for r in guild.roles]))
    ).scalars().all()
    blacklist_map = {}
    for blacklist in blacklist_array:
        d_role = guild.get_role(blacklist.role_id)
        if d_role is None:
            session.execute(delete(VerifyBlacklist).filter_by(role_id=blacklist.role_id))
        elif blacklist.user_id in blacklist_map:
            blacklist_map[blacklist.user_id].append(f"{d_role.mention} / {blacklist.email_suffix}")
        else:
            blacklist_map[blacklist.user_id] = [f"{d_role.mention} / {blacklist.email_suffix}"]
    session.commit()
    blacklist_map = {guild.get_member(k).name: v for (k, v) in blacklist_map.items()}

    return blacklist_map


@assign_session
async def email_verify_send(user_id, email, bot, force=False, *, session: Session):
    email = email.lower()

    # Take only the first email, preventing injection / verification bypass with ',' , ';' , ':', etc.
    email_regex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    valid_emails = re.findall(email_regex, email)
    if valid_emails:
        email = valid_emails[0]
    else:
        raise errors.VerifyException("No Valid Emails found")


    already_verified = session.execute(select(VerifiedEmails).filter_by(email=email)).scalar()

    to_reverify = session.execute(select(ToReVerify).filter_by(u_id=user_id)).all()

    if already_verified and not to_reverify:
        if force:
            session.delete(already_verified)
            session.commit()
            await remove_roles_for_user(already_verified.u_id, email, bot, session=session)
        elif already_verified.u_id == user_id:
            raise errors.VerifyExistsException("This email is already assigned to your account.")
        else:
            raise errors.VerifyExistsException("This email is already assigned to a different account.")

    verification_code = ''.join(random.choice(string.ascii_letters) for _ in range(8))
    session.add(NonVerifiedEmails(u_id=user_id, email=email, token=verification_code))
    session.commit()

    send_email(email, verification_code)


@assign_session
async def email_verify_remove(user_id, email, bot, *, session: Session):
    entry = session.execute(select(VerifiedEmails).filter_by(u_id=user_id, email=email)).all()

    if not entry:
        raise VerifyException("You have not verified that email")

    session.execute(delete(VerifiedEmails).filter_by(u_id=user_id, email=email))
    session.commit()

    await remove_roles_for_user(user_id, email, bot, session=session)


@assign_session
async def email_verify_confirm(user_id, token, bot, *, session: Session):
    entry = session.execute(select(NonVerifiedEmails).filter_by(token=token, u_id=user_id)).scalar()

    if not entry:
        raise InvalidArgumentError("That is not a valid token")

    verified_email = session.execute(select(VerifiedEmails).filter_by(u_id=user_id, email=entry.email)).one_or_none()
    if verified_email is None:
        session.add(VerifiedEmails(u_id=user_id, email=entry.email))

    session.execute(delete(NonVerifiedEmails).filter_by(token=token, u_id=user_id))

    potential_roles = session.execute(select(Roles.r_id)
                                      .where(value_suffix_like_column(":email", "email_suffix")),
                                      {"email": entry.email}).all()
    if potential_roles:
        for role_id in potential_roles:
            session.execute(delete(ToReVerify).filter_by(r_id=role_id[0], u_id=user_id))

    session.commit()
    await assign_roles_for_user(user_id, entry.email, bot, session=session)


@assign_session
def email_verify_list(user_id, *, session: Session):
    return session.execute(select(VerifiedEmails.email).filter_by(u_id=user_id)).scalars().all()


'''
EVENTS
'''


@assign_session
async def assign_roles_on_startup(bot: koalabot.KoalaBot, *, session: Session):
    results = session.execute(select(Roles.s_id, Roles.r_id, Roles.email_suffix)).all()
    for g_id, r_id, suffix in results:
        guild = bot.get_guild(g_id)
        if not guild:
            logger.error("Verify bot not in guild %s", guild.id)
            continue

        role = guild.get_role(r_id)
        try:
            await assign_role_to_guild(guild, role, suffix, session=session)
        except VerifyException as e:
            logger.error(f"Guild {g_id} has not given Koala sufficient permissions to give roles",
                         exc_info=e)


@assign_session
async def send_verify_intro_message(member: discord.Member, *, session: Session):
    guild = member.guild

    potential_emails = session.execute(select(Roles.r_id, Roles.email_suffix)
                                       .filter_by(s_id=guild.id)).all()

    if potential_emails:
        roles = {}
        for role_id, suffix in potential_emails:
            role = guild.get_role(role_id)
            roles[suffix] = role
            results = session.execute(select(VerifiedEmails).where(
                and_(
                    VerifiedEmails.email.endswith(suffix),
                    VerifiedEmails.u_id == member.id
                ))).all()

            blacklisted = session.execute(select(ToReVerify)
                                          .filter_by(r_id=role_id, u_id=member.id)).all()

            if results and not blacklisted:
                await member.add_roles(role)
        message_string = f"""Welcome to {guild.name}. This guild has verification enabled.
Please verify one of the following emails to get the appropriate role using \
`{koalabot.COMMAND_PREFIX}verify your_email@example.com`.
This email is stored so you don't need to verify it multiple times across servers."""
        await member.send(
            content=message_string + "\n" + "\n".join([f"`{x}` for `@{y}`" for x, y in roles.items()]))


'''
UTILS
'''


@assign_session
async def assign_role_to_guild(guild, role, suffix, *, session):
    results = session.execute(select(VerifiedEmails.u_id).where(VerifiedEmails.email.endswith(suffix),
                                                                VerifiedEmails.u_id.in_(
                                                                    [member.id for member in guild.members]
                                                                ))).scalars().all()
    for user_id in results:
        try:
            should_re_verify = session.execute(select(ToReVerify)
                                               .filter_by(r_id=role.id, u_id=user_id)).all()

            blacklisted = session.execute(select(VerifyBlacklist)
                                          .filter_by(user_id=user_id, role_id=role.id, email_suffix=suffix)).all()
            if blacklisted or should_re_verify:
                continue

            member = guild.get_member(user_id)
            await member.add_roles(role)
        except AttributeError as e:
            # bot not in guild
            logger.error(exc_info=e)
        except discord.errors.NotFound as e:
            logger.error(f"user with id {user_id} not found in {guild}", exc_info=e)
        except discord.errors.Forbidden:
            raise errors.VerifyException(f"I do not have permission to assign {role}. "
                                         f"Make sure I have permission to give roles and {role} is lower than the "
                                         "KoalaBot role in the hierarchy, then try again.")


@assign_session
async def assign_roles_for_user(user_id, email, bot, *, session):
    results = session.execute(select(Roles.s_id, Roles.r_id, Roles.email_suffix)
                              .where(value_suffix_like_column(":email", "email_suffix")), {"email": email}).all()

    for g_id, r_id, suffix in results:
        should_re_verify = session.execute(select(ToReVerify).filter_by(r_id=r_id, u_id=user_id)).all()

        blacklisted = session.execute(select(VerifyBlacklist).filter_by(user_id=user_id, role_id=r_id)
                                      .where(value_suffix_like_column(":email", "email_suffix")), {"email": email}).all()

        if blacklisted or should_re_verify:
            continue
        try:
            guild = bot.get_guild(g_id)
            role = discord.utils.get(guild.roles, id=r_id)
            member = guild.get_member(user_id)
            if not member:
                member = await guild.fetch_member(user_id)
            if not member:
                raise discord.errors.NotFound
            await member.add_roles(role)
        except AttributeError as e:
            # bot not in guild
            logger.error(e)
        except discord.errors.NotFound:
            logger.error(f"user with id {user_id} not found")
        except discord.errors.Forbidden:
            raise errors.VerifyException(
                "I do not have permission to assign a role. Make sure I have permission to give roles and "
                "that is lower than the KoalaBot role in the hierarchy, then try again.")


@assign_session
async def remove_roles_for_user(user_id, email, bot, *, session):
    results = session.execute(select(Roles.s_id, Roles.r_id, Roles.email_suffix)
                              .where(value_suffix_like_column(":email", "email_suffix")), {"email": email}).all()

    for g_id, r_id, suffix in results:
        try:
            guild = bot.get_guild(g_id)
            role = discord.utils.get(guild.roles, id=r_id)
            member = guild.get_member(user_id)
            if not member:
                member = await guild.fetch_member(user_id)
            await member.remove_roles(role)
        except AttributeError as e:
            # bot not in guild
            logger.error(e)
        except discord.errors.NotFound:
            logger.error(f"user with id {user_id} not found in {g_id}")


def value_suffix_like_column(value, column):
    """
    Creates a sqlalchemy where query value for a given value that contains
    a suffix which is found in the db

    example:

        value_suffix_like_column(":email", "email_suffix")

        text(":email like ('%' || email_suffix)")       SQLITE
        text(":email like CONCAT('%', email_suffix)")   MYSQL

    :param value: full value, or alias
    :param column: column name
    :return:
    """
    if DB_TYPE == DatabaseType.SQLITE:
        return text(f"{value} like ('%' || {column})")
    else:
        return text(f"{value} like CONCAT('%', {column})")

</document_content>
</document>
<document index="97">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/db.py</source>
<document_content>

</document_content>
</document>
<document index="98">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/dto.py</source>
<document_content>
from dataclasses import dataclass
from typing import List

from koala.cogs.verification.models import Roles


@dataclass
class VerifyRole:
    email_suffix: str
    role_id: int

    @staticmethod
    def from_db_roles(roles: Roles):
        return VerifyRole(roles.email_suffix, roles.r_id)


@dataclass
class VerifyConfig:
    guild_id: str
    roles: List[VerifyRole]



</document_content>
</document>
<document index="99">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/env.py</source>
<document_content>
import os

from dotenv import load_dotenv

load_dotenv()

GMAIL_EMAIL = os.environ.get('GMAIL_EMAIL')
GMAIL_PASSWORD = os.environ.get('GMAIL_PASSWORD')

</document_content>
</document>
<document index="100">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/errors.py</source>
<document_content>
from koala.errors import KoalaException


class VerifyException(KoalaException):
    """
    Unspecified error within the 'verify' extension
    """
    pass


class VerifyExistsException(VerifyException):
    """
    Verify already exists
    """
    pass

</document_content>
</document>
<document index="101">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="102">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/models.py</source>
<document_content>
from sqlalchemy import Column, VARCHAR, ForeignKey

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class VerifiedEmails:
    __tablename__ = 'verified_emails'
    u_id = Column(DiscordSnowflake, primary_key=True)
    email = Column(VARCHAR(100, collation="utf8_bin"), primary_key=True)

    def __repr__(self):
        return "<verified_emails(%s, %s)>" % \
               (self.u_id, self.email)


@mapper_registry.mapped
class NonVerifiedEmails:
    __tablename__ = 'non_verified_emails'
    u_id = Column(DiscordSnowflake)
    email = Column(VARCHAR(100))
    token = Column(VARCHAR(8), primary_key=True)

    def __repr__(self):
        return "<non_verified_emails(%s, %s, %s)>" % \
               (self.u_id, self.email, self.token)


@mapper_registry.mapped
class Roles:
    __tablename__ = 'roles'
    s_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'), primary_key=True)
    r_id = Column(DiscordSnowflake, primary_key=True)
    email_suffix = Column(VARCHAR(100), primary_key=True)

    def __repr__(self):
        return "<roles(%s, %s, %s)>" % \
               (self.s_id, self.r_id, self.email_suffix)


@mapper_registry.mapped
class ToReVerify:
    __tablename__ = 'to_re_verify'
    u_id = Column(DiscordSnowflake, primary_key=True)
    r_id = Column(DiscordSnowflake, primary_key=True)

    def __repr__(self):
        return "<to_re_verify(%s, %s)>" % \
               (self.u_id, self.r_id)


@mapper_registry.mapped
class VerifyBlacklist:
    __tablename__ = 'VerifyBlacklist'
    user_id = Column(DiscordSnowflake, primary_key=True)
    role_id = Column(DiscordSnowflake, primary_key=True)
    email_suffix = Column(VARCHAR(100), primary_key=True)

    def __repr__(self):
        return "<VerifyBlacklist(%s, %s, %s)>" % \
               (self.user_id, self.role_id, self.email_suffix)

</document_content>
</document>
<document index="103">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/utils.py</source>
<document_content>
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from bs4 import BeautifulSoup

import koalabot
from koala.cogs.verification.env import GMAIL_EMAIL, GMAIL_PASSWORD


def send_email(email, token):
    """
    Sends an email through gmails smtp server from the email stored in the environment variables
    :param email: target to send an email to
    :param token: the token the recipient will need to verify with
    :return:
    """
    email_server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
    email_server.ehlo()
    username = GMAIL_EMAIL
    password = GMAIL_PASSWORD

    html = open("koala/cogs/verification/templates/emailtemplate.html").read()
    soup = BeautifulSoup(html, features="html.parser")
    soup.find(id="confirmbuttonbody").string = f"{koalabot.COMMAND_PREFIX}confirm {token}"
    soup.find(id="backup").string = "Main body not loading? Send this command to the bot: " \
                                    f"{koalabot.COMMAND_PREFIX}confirm {token}"

    msg = MIMEMultipart('alternative')
    msg.attach(MIMEText(str(soup), 'html'))
    msg['Subject'] = "Koalabot Verification"
    msg['From'] = username
    msg['To'] = email

    email_server.login(username, password)
    email_server.sendmail(username, [email], msg.as_string())
    email_server.quit()
</document_content>
</document>
<document index="104">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/verification/templates/emailtemplate.html</source>
<document_content>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="UTF-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="x-apple-disable-message-reformatting">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta content="telephone=no" name="format-detection">
<title>New Template</title>
<!--[if (mso 16)]>
<style type="text/css">
a {text-decoration: none;}
</style>
<![endif]-->
<!--[if gte mso 9]><style>sup { font-size: 100% !important; }</style><![endif]-->
<!--[if gte mso 9]>
<xml>
<o:OfficeDocumentSettings>
<o:AllowPNG></o:AllowPNG>
<o:PixelsPerInch>96</o:PixelsPerInch>
</o:OfficeDocumentSettings>
</xml>
<![endif]-->
<style type="text/css">
#outlook a {
padding:0;
}
.es-button {
mso-style-priority:100!important;
text-decoration:none!important;
}
a[x-apple-data-detectors] {
color:inherit!important;
text-decoration:none!important;
font-size:inherit!important;
font-family:inherit!important;
font-weight:inherit!important;
line-height:inherit!important;
}
.es-desk-hidden {
display:none;
float:left;
overflow:hidden;
width:0;
max-height:0;
line-height:0;
mso-hide:all;
}
@media only screen and (max-width:600px) {p, ul li, ol li, a { line-height:150%!important } h1 { font-size:30px!important; text-align:center; line-height:120%!important } h2 { font-size:26px!important; text-align:center; line-height:120%!important } h3 { font-size:20px!important; text-align:center; line-height:120%!important } .es-header-body h1 a, .es-content-body h1 a, .es-footer-body h1 a { font-size:30px!important } .es-header-body h2 a, .es-content-body h2 a, .es-footer-body h2 a { font-size:26px!important } .es-header-body h3 a, .es-content-body h3 a, .es-footer-body h3 a { font-size:20px!important } .es-menu td a { font-size:16px!important } .es-header-body p, .es-header-body ul li, .es-header-body ol li, .es-header-body a { font-size:16px!important } .es-content-body p, .es-content-body ul li, .es-content-body ol li, .es-content-body a { font-size:16px!important } .es-footer-body p, .es-footer-body ul li, .es-footer-body ol li, .es-footer-body a { font-size:16px!important } .es-infoblock p, .es-infoblock ul li, .es-infoblock ol li, .es-infoblock a { font-size:12px!important } *[class="gmail-fix"] { display:none!important } .es-m-txt-c, .es-m-txt-c h1, .es-m-txt-c h2, .es-m-txt-c h3 { text-align:center!important } .es-m-txt-r, .es-m-txt-r h1, .es-m-txt-r h2, .es-m-txt-r h3 { text-align:right!important } .es-m-txt-l, .es-m-txt-l h1, .es-m-txt-l h2, .es-m-txt-l h3 { text-align:left!important } .es-m-txt-r img, .es-m-txt-c img, .es-m-txt-l img { display:inline!important } .es-button-border { display:block!important } a.es-button, button.es-button { font-size:20px!important; display:block!important; border-width:10px 0px 10px 0px!important } .es-adaptive table, .es-left, .es-right { width:100%!important } .es-content table, .es-header table, .es-footer table, .es-content, .es-footer, .es-header { width:100%!important; max-width:600px!important } .es-adapt-td { display:block!important; width:100%!important } .adapt-img { width:100%!important; height:auto!important } .es-m-p0 { padding:0px!important } .es-m-p0r { padding-right:0px!important } .es-m-p0l { padding-left:0px!important } .es-m-p0t { padding-top:0px!important } .es-m-p0b { padding-bottom:0!important } .es-m-p20b { padding-bottom:20px!important } .es-mobile-hidden, .es-hidden { display:none!important } tr.es-desk-hidden, td.es-desk-hidden, table.es-desk-hidden { width:auto!important; overflow:visible!important; float:none!important; max-height:inherit!important; line-height:inherit!important } tr.es-desk-hidden { display:table-row!important } table.es-desk-hidden { display:table!important } td.es-desk-menu-hidden { display:table-cell!important } .es-menu td { width:1%!important } table.es-table-not-adapt, .esd-block-html table { width:auto!important } table.es-social { display:inline-block!important } table.es-social td { display:inline-block!important } }
</style>
</head>
<body style="width:100%;font-family:arial, 'helvetica neue', helvetica, sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;padding:0;Margin:0">
<div class="es-wrapper-color" style="background-color:#F6F6F6">
<!--[if gte mso 9]>
<v:background xmlns:v="urn:schemas-microsoft-com:vml" fill="t">
<v:fill type="tile" color="#f6f6f6"></v:fill>
</v:background>
<![endif]-->
<table class="es-wrapper" width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;padding:0;Margin:0;width:100%;height:100%;background-repeat:repeat;background-position:center top">
<tr>
<td valign="top" style="padding:0;Margin:0">
<table class="es-content" cellspacing="0" cellpadding="0" align="center" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%">
<tr>
<td align="center" style="padding:0;Margin:0">
<table class="es-content-body" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:transparent;width:600px" cellspacing="0" cellpadding="0" align="center">
<tr>
<td align="left" style="Margin:0;padding-top:20px;padding-bottom:20px;padding-left:20px;padding-right:20px">
<!--[if mso]><table style="width:560px" cellpadding="0" cellspacing="0"><tr><td style="width:356px" valign="top"><![endif]-->
<table class="es-left" cellspacing="0" cellpadding="0" align="left" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;float:left">
<tr>
<td class="es-m-p0r es-m-p20b" valign="top" align="center" style="padding:0;Margin:0;width:356px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td class="es-infoblock es-m-txt-c" align="left" style="padding:0;Margin:0;line-height:14px;font-size:12px;color:#CCCCCC"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:14px;color:#CCCCCC;font-size:12px">KoalaBot Verification Confirmation</p></td>
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td><td style="width:20px"></td><td style="width:184px" valign="top"><![endif]-->
<table cellspacing="0" cellpadding="0" align="right" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="left" style="padding:0;Margin:0;width:184px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<!--<td class="es-infoblock es-m-txt-c" align="right" style="padding:0;Margin:0;line-height:14px;font-size:12px;color:#CCCCCC"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:14px;color:#CCCCCC;font-size:12px"><a target="_blank" href="http://viewstripo.email" style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;text-decoration:underline;color:#2CB543;font-size:12px">View email in your browser</a></p></td>-->
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td></tr></table><![endif]--></td>
</tr>
</table></td>
</tr>
</table>
<table class="es-content" cellspacing="0" cellpadding="0" align="center" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%">
<tr>
<td align="center" style="padding:0;Margin:0">
<table class="es-content-body" cellspacing="0" cellpadding="0" bgcolor="#ffffff" align="center" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:#FFFFFF;width:600px">
<tr>
<td style="Margin:0;padding-top:20px;padding-bottom:20px;padding-left:20px;padding-right:20px;background-color:#00AA6E" bgcolor="#00aa6e" align="left">
<table width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td valign="top" align="center" style="padding:0;Margin:0;width:560px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="center" style="padding:0;Margin:0"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:42px;color:#FFFFFF;font-size:28px"><strong>Confirm KoalaBot Verification</strong><br></p></td>
</tr>
<tr>
<td align="left" style="padding:20px;Margin:0"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:21px;color:#FFFFFF;font-size:14px">Thanks for using KoalaBot to verify your email address.To complete the confirmation please direct message the following command to KoalaBot:</p></td>
</tr>
<tr>
<td bgcolor="#ffffff" align="center" style="padding:0;Margin:0"><p id="confirmbuttonbody" style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:42px;color:#333333;font-size:28px"><strong>k!confirm abcdefgh</strong></p></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
<tr>
<td style="padding:0;Margin:0;padding-left:20px;padding-right:20px;background-color:#09AA6D" bgcolor="#09aa6d" align="left">
<table width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td valign="top" align="center" style="padding:0;Margin:0;width:560px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td style="padding:10px;Margin:0;font-size:0" align="center">
<table width="100%" height="100%" cellspacing="0" cellpadding="0" border="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td style="padding:0;Margin:0;border-bottom:1px solid #CCCCCC;background:#FFFFFF none repeat scroll 0% 0%;height:1px;width:100%;margin:0px"></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
<tr>
<td style="padding:0;Margin:0;padding-top:15px;padding-left:20px;padding-right:20px;background-color:#09AA6D" bgcolor="#09aa6d" align="left">
<!--[if mso]><table style="width:560px" cellpadding="0" cellspacing="0"><tr><td style="width:200px" valign="top"><![endif]-->
<table class="es-left" cellspacing="0" cellpadding="0" align="left" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;float:left">
<tr>
<td class="es-m-p20b" align="left" style="padding:0;Margin:0;width:200px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td style="padding:0;Margin:0;font-size:0px" align="center"><img class="adapt-img" src="https://regaki.stripocdn.email/content/guids/CABINET_63e25ed574f64f478e1500b188c3240e/images/43521618841954245.png" alt style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic" width="200"></td>
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td><td style="width:20px"></td><td style="width:340px" valign="top"><![endif]-->
<table class="es-right" cellspacing="0" cellpadding="0" align="right" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;float:right">
<tr>
<td align="left" style="padding:0;Margin:0;width:340px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="left" style="padding:0;Margin:0"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:18px;color:#FFFFFF;font-size:12px">KoalaBot is a free open source discord bot being developed by students and alumni from around the UK and Europe. Our aim is to ensure university society committee leaders can access all they need and from one easy to use discord bot to improve their server and society.<br><br></p><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:18px;color:#FFFFFF;font-size:12px">Includes features such as:<br></p>
<ul>
<li style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:18px;Margin-bottom:15px;color:#FFFFFF;font-size:12px">Email verification for roles<br></li>
<li style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:18px;Margin-bottom:15px;color:#FFFFFF;font-size:12px">Text filtering</li>
<li style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:18px;Margin-bottom:15px;color:#FFFFFF;font-size:12px">React-for-role management</li>
</ul></td>
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td></tr></table><![endif]--></td>
</tr>
<tr>
<td style="padding:20px;Margin:0;background-color:#09AA6D" bgcolor="#09aa6d" align="left">
<!--[if mso]><table style="width:560px" cellpadding="0" cellspacing="0"><tr><td style="width:270px" valign="top"><![endif]-->
<table class="es-left" cellspacing="0" cellpadding="0" align="left" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;float:left">
<tr>
<td class="es-m-p20b" align="left" style="padding:0;Margin:0;width:270px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="center" style="padding:0;Margin:0"><span class="es-button-border" style="border-style:solid;border-color:#2CB543;background:#038C7F none repeat scroll 0% 0%;border-width:0px 0px 2px 0px;display:inline-block;border-radius:30px;width:auto"><a href="https://discord.com/api/oauth2/authorize?client_id=754669777347149844&permissions=8&scope=bot" class="es-button" target="_blank" style="mso-style-priority:100 !important;text-decoration:none;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;color:#FFFFFF;font-size:18px;border-style:solid;border-color:#038C7F;border-width:10px 20px 10px 20px;display:inline-block;background:#038C7F none repeat scroll 0% 0%;border-radius:30px;font-family:arial, 'helvetica neue', helvetica, sans-serif;font-weight:normal;font-style:normal;line-height:22px;width:auto;text-align:center">Add to your Discord</a></span></td>
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td><td style="width:20px"></td><td style="width:270px" valign="top"><![endif]-->
<table class="es-right" cellspacing="0" cellpadding="0" align="right" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;float:right">
<tr>
<td align="left" style="padding:0;Margin:0;width:270px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="center" style="padding:0;Margin:0"><span class="es-button-border" style="border-style:solid;border-color:#2CB543;background:#038C7F none repeat scroll 0% 0%;border-width:0px 0px 2px 0px;display:inline-block;border-radius:30px;width:auto"><a href="https://discord.gg/5etEjVd" class="es-button" target="_blank" style="mso-style-priority:100 !important;text-decoration:none;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;color:#FFFFFF;font-size:18px;border-style:solid;border-color:#038C7F;border-width:10px 20px 10px 20px;display:inline-block;background:#038C7F none repeat scroll 0% 0%;border-radius:30px;font-family:arial, 'helvetica neue', helvetica, sans-serif;font-weight:normal;font-style:normal;line-height:22px;width:auto;text-align:center">Join Support Discord</a></span></td>
</tr>
</table></td>
</tr>
</table>
<!--[if mso]></td></tr></table><![endif]--></td>
</tr>
</table></td>
</tr>
</table>
<table class="es-footer" cellspacing="0" cellpadding="0" align="center" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%;background-color:transparent;background-repeat:repeat;background-position:center top">
<tr>
<td align="center" style="padding:0;Margin:0">
<table class="es-footer-body" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:transparent;border-top:1px solid #CCCCCC;border-right:1px solid #CCCCCC;border-left:1px solid #CCCCCC;width:600px;border-bottom:1px solid #CCCCCC" cellspacing="0" cellpadding="0" align="center">
<tr>
<td style="padding:15px;Margin:0;background-color:#038C7F" bgcolor="#038c7f" align="left">
<table width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td valign="top" align="center" style="padding:0;Margin:0;width:568px">
<table width="100%" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td style="padding:0;Margin:0;font-size:0" align="center">
<table class="es-table-not-adapt es-social" cellspacing="0" cellpadding="0" role="presentation" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
    <td valign="top" align="center" style="padding:0;Margin:0;padding-right:10px"><a target="_blank" href="https://koalabot.uk" style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;text-decoration:underline;color:#1376C8;font-size:11px"><img src="https://regaki.stripocdn.email/content/assets/img/other-icons/circle-colored/link-circle-colored.png" alt="KoalaBot Website" title="KoalaBot Website" width="32" style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic"></a></td>
    <td valign="top" align="center" style="padding:0;Margin:0;padding-right:10px"><a target="_blank" href="https://twitter.com/KoalaBotUK" style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;text-decoration:underline;color:#1376C8;font-size:11px"><img src="https://regaki.stripocdn.email/content/assets/img/social-icons/circle-colored/twitter-circle-colored.png" alt="Tw" title="Twitter" width="32" style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic"></a></td>
    <td valign="top" align="center" style="padding:0;Margin:0;padding-right:10px"><a target="_blank" href="https://github.com/KoalaBotUK" style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;text-decoration:underline;color:#1376C8;font-size:11px"><img src="https://regaki.stripocdn.email/content/assets/img/other-icons/circle-colored/github-circle-colored.png" alt="GitHub" title="GitHub" width="32" style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic"></a></td>
    <td valign="top" align="center" style="padding:0;Margin:0"><a target="_blank" href="https://linkedin.com/company/koalabotuk" style="-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;text-decoration:underline;color:#1376C8;font-size:11px"><img src="https://regaki.stripocdn.email/content/assets/img/social-icons/circle-colored/linkedin-circle-colored.png" alt="In" title="Linkedin" width="32" style="display:block;border:0;outline:none;text-decoration:none;-ms-interpolation-mode:bicubic"></a></td>
</tr>
</table></td>
</tr>
<tr>
<td align="center" style="padding:0;Margin:0;padding-top:10px;padding-bottom:10px"><p style="Margin:0;-webkit-text-size-adjust:none;-ms-text-size-adjust:none;mso-line-height-rule:exactly;font-family:arial, 'helvetica neue', helvetica, sans-serif;line-height:17px;color:#FFFFFF;font-size:11px"> 2020 KoalaBot</p></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table>
<table class="es-content" cellspacing="0" cellpadding="0" align="center" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;table-layout:fixed !important;width:100%">
<tr>
<td align="center" style="padding:0;Margin:0">
<table class="es-content-body" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px;background-color:transparent;width:600px" cellspacing="0" cellpadding="0" align="center">
<tr>
<td align="left" style="padding:0;Margin:0;padding-left:20px;padding-right:20px;padding-bottom:30px">
<table width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td valign="top" align="center" style="padding:0;Margin:0;width:560px">
<table width="100%" cellspacing="0" cellpadding="0" style="mso-table-lspace:0pt;mso-table-rspace:0pt;border-collapse:collapse;border-spacing:0px">
<tr>
<td align="center" style="padding:0;Margin:0;display:none"></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table></td>
</tr>
</table>
</div>
<div id="backup">
</div>
</body>
</html>
</document_content>
</document>
<document index="105">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/__init__.py</source>
<document_content>
from . import utils, db, twitch_handler, log, models
from .cog import TwitchAlert, setup

</document_content>
</document>
<document index="106">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/cog.py</source>
<document_content>
# Futures

import re
# Built-in/Generic Imports
import time

# Libs
import discord
from discord.ext import commands, tasks

# Own modules
import koalabot
from koala.colours import KOALA_GREEN
from koala.db import insert_extension
from koala.utils import error_embed, is_channel_in_guild
from koalabot import COMMAND_PREFIX as CP
from . import core
from .db import TwitchAlertDBManager
from .env import TWITCH_KEY, TWITCH_SECRET
from .log import logger
from .utils import DEFAULT_MESSAGE, TWITCH_USERNAME_REGEX, \
    LOOP_CHECK_LIVE_DELAY, REFRESH_TEAMS_DELAY, TEAMS_LOOP_CHECK_LIVE_DELAY


# Constants


# Variables


def twitch_is_enabled(ctx):
    """
    A command used to check if the guild has enabled twitch alert
    e.g. @commands.check(koalabot.is_admin)
    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "TwitchAlert")
    except PermissionError:
        result = False

    return result


class TwitchAlert(commands.Cog):
    """
        A discord.py cog for alerting when someone goes live on twitch
    """

    def __init__(self, bot: discord.ext.commands.Bot):

        """
        Initialises local variables
        :param bot: The bot client for this cog
        """
        self.bot = bot
        insert_extension("TwitchAlert", 0, True, True)
        self.ta_database_manager = TwitchAlertDBManager(bot)
        # self.ta_database_manager.translate_names_to_ids()
        self.loop_thread = None
        self.loop_team_thread = None
        self.running = False
        self.stop_loop = False

    @commands.check(koalabot.is_guild_channel)
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    @commands.group(name="twitch", short_doc="Group of commands for Twitch Alert functionality.")
    async def twitch_group(self, ctx: commands.Context):
        """
        Group of commands for Twitch Alert functionality.
        """
        pass

    @twitch_group.command(name="editMsg",
                          brief="Edit the default message used in a Twitch Alert notification",
                          usage=f"{CP}twitch editMsg <channel> [message]",
                          help=("""Edit the default message used in a Twitch Alert notification

                                <channel>: The channel to be modified (e.g. #text-channel)
                                [message]: *optional* The default notification message for this text channel """
                                f"""(e.g. Your favourite stream is now live!)

                                Example: {CP}twitch editMsg #text-channel \"Your favourite stream is now live!\""""))
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def edit_default_message(self, ctx, channel: discord.TextChannel, *default_live_message):
        """
        Edit the default message put in a Twitch Alert Notification
        :param ctx: The discord context of the command
        :param channel: The channel where the twitch alert is being used
        :param default_live_message: The default live message of users within this Twitch Alert,
        leave empty for program default
        :return:
        """
        channel_id = channel.id

        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        # Assigning default message if provided
        if default_live_message is not None and default_live_message != (None,):
            default_message = " ".join(default_live_message)
            if len(default_message) > 1000:
                await ctx.send(embed=error_embed(
                    "custom_message is too long, try something with less than 1000 characters"))
                return

        else:
            default_message = None

        # Creates a new Twitch Alert with the used guild ID and default message if provided
        default_message = self.ta_database_manager.new_ta(ctx.message.guild.id, channel_id, default_message,
                                                          replace=True)

        # Returns an embed with information altered
        new_embed = discord.Embed(title="Default Message Edited", colour=KOALA_GREEN,
                                  description=f"Guild: {ctx.message.guild.id}\n"
                                              f"Channel: {channel_id}\n"
                                              f"Default Message: {default_message}")
        await ctx.send(embed=new_embed)

    @twitch_group.command(name="viewMsg",
                          brief="Shows the current default message for Twitch Alerts",
                          usage=f"{CP}twitch viewMsg <channel>",
                          help=f"""Shows the current default message for Twitch Alerts

                          <channel>: The channel to be modified (e.g. #text-channel)

                          Example: {CP}twitch viewMsg #text-channel""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def view_default_message(self, ctx, channel: discord.TextChannel):
        """
        Shows the current default message for Twitch Alerts
        :param ctx: The discord context of the command
        :param channel: The channel where the twitch alert is being used
        leave empty for program default
        :return:
        """
        channel_id = channel.id

        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        # Creates a new Twitch Alert with the used guild ID and default message if provided
        default_message = self.ta_database_manager.get_default_message(channel_id)

        # Returns an embed with information altered
        new_embed = discord.Embed(title="Default Message", colour=KOALA_GREEN,
                                  description=f"Guild: {ctx.message.guild.id}\n"
                                              f"Channel: {channel_id}\n"
                                              f"Default Message: {default_message}")
        # new_embed.set_footer(text=f"Twitch Alert ID: {new_id}")
        await ctx.send(embed=new_embed)

    @twitch_group.command(name="add",
                          brief="Add a Twitch user to a Twitch Alert",
                          usage=f"{CP}twitch add <username> <channel> [message]",
                          help=f"""Add a Twitch user to a Twitch Alert

                          <username>: The twitch username to be added (e.g. thenuel)
                          <channel> : The channel to be modified (e.g. #text-channel)
                          [message] : *optional* The notification message for this user """
                          f"""(e.g. Your favourite streamer is now live!)

                          Example: {CP}twitch add thenuel #text-channel \"Come watch us play games!\"""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def add_user_to_twitch_alert(self, ctx, twitch_username,
                                       channel: discord.TextChannel, *custom_live_message):
        """
        Add a Twitch user to a Twitch Alert
        :param ctx: The discord context of the command
        :param twitch_username: The Twitch Username of the user being added (lowercase)
        :param channel: The channel ID where the twitch alert is being used
        :param custom_live_message: the custom live message for this user's alert
        :return:
        """
        channel_id = channel.id
        twitch_username = str.lower(twitch_username)
        if not re.search(TWITCH_USERNAME_REGEX, twitch_username):
            raise ValueError(
                "The given twitch_username is not a valid username (please use lowercase)")

        # Check the channel specified is in this guild
        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        default_message = self.ta_database_manager.new_ta(ctx.message.guild.id, channel_id)

        # Setting the custom message as required
        if custom_live_message is not None and custom_live_message != (None,):
            custom_message = " ".join(custom_live_message)
            default_message = custom_message
            if len(default_message) > 1000:
                await ctx.send(embed=error_embed(
                    "custom_message is too long, try something with less than 1000 characters"))
                return
        else:
            custom_message = None

        self.ta_database_manager.add_user_to_ta(channel_id, twitch_username, custom_message, ctx.message.guild.id)

        # Response Message
        new_embed = discord.Embed(title="Added User to Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel_id}\n"
                                              f"User: {twitch_username}\n"
                                              f"Message: {default_message}")

        await ctx.send(embed=new_embed)

    @twitch_group.command(name="remove",
                          brief="Removes a user from a Twitch Alert",
                          usage=f"{CP}twitch remove <username> <channel>",
                          help=f"""Removes a user from a Twitch Alert

                          <username>: The twitch username to be removed (e.g. thenuel)
                          <channel> : The channel to be modified (e.g. #text-channel)

                          Example: {CP}twitch remove thenuel #text-channel""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def remove_user_from_twitch_alert(self, ctx, twitch_username, channel: discord.TextChannel):
        """
        Removes a user from a Twitch Alert
        :param ctx: the discord context
        :param twitch_username: The username of the user to be removed
        :param channel: The discord channel ID of the Twitch Alert
        :return:
        """

        channel_id = channel.id

        # Check the channel specified is in this guild
        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        await self.ta_database_manager.remove_user_from_ta(channel_id, twitch_username)
        # Response Message
        new_embed = discord.Embed(title="Removed User from Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel_id}\n"
                                              f"User: {twitch_username}")

        await ctx.send(embed=new_embed)

    @twitch_group.command(name="addTeam",
                          brief="Add a Twitch team to a Twitch Alert",
                          usage=f"{CP}twitch addTeam <team> <channel> [message]",
                          help=f"""Add a Twitch team to a Twitch Alert

                          <team>    : The Twitch team to be added (e.g. thenuel)
                          <channel> : The channel to be modified (e.g. #text-channel)
                          [message] : *optional* The notification message for this user """
                          f"""(e.g. Your favourite streamer is now live!)

                          Example: {CP}twitch addTeam thenuel #text-channel \"Come watch us play games!\"""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def add_team_to_twitch_alert(self, ctx, team_name, channel: discord.TextChannel, *custom_live_message):
        """
        Add a Twitch team to a Twitch Alert
        :param ctx: The discord context of the command
        :param team_name: The Twitch team being added (lowercase)
        :param channel: The channel ID where the twitch alert is being used
        :param custom_live_message: the custom live message for this team's alert
        :return:
        """
        channel_id = channel.id
        team_name = str.lower(team_name)

        if not re.search(TWITCH_USERNAME_REGEX, team_name):
            raise ValueError(
                "The given team_name is not a valid twitch team name (please use lowercase)")

        # Check the channel specified is in this guild
        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        self.ta_database_manager.new_ta(ctx.message.guild.id, channel_id)

        # Setting the custom message as required
        if custom_live_message is not None and custom_live_message != (None,):
            default_message = " ".join(custom_live_message)
            if len(default_message) > 1000:
                await ctx.send(embed=error_embed(
                    "custom_message is too long, try something with less than 1000 characters"))
                return
        else:
            default_message = DEFAULT_MESSAGE

        self.ta_database_manager.add_team_to_ta(channel_id, team_name, default_message, ctx.message.guild.id)

        # Response Message
        new_embed = discord.Embed(title="Added Team to Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel_id}\n"
                                              f"Team: {team_name}\n"
                                              f"Message: {default_message}")
        # new_embed.set_footer(text=f"Twitch Alert ID: {channel_id}")
        await ctx.send(embed=new_embed)

    @twitch_group.command(name="removeTeam",
                          brief="Removes a team from a Twitch Alert",
                          usage=f"{CP}twitch removeTeam <team> <channel>",
                          help=f"""Removes a team from a Twitch Alert

                          <team>    : The Twitch team to be added (e.g. thenuel)
                          <channel> : The channel to be modified (e.g. #text-channel)

                          Example: {CP}twitch removeTeam thenuel #text-channel""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def remove_team_from_twitch_alert(self, ctx, team_name, channel: discord.TextChannel):
        """
        Removes a team from a Twitch Alert
        :param ctx: the discord context
        :param team_name: The Twitch team being added (lowercase)
        :param channel: The discord channel ID of the Twitch Alert
        :return:
        """

        channel_id = channel.id

        # Check the channel specified is in this guild
        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return

        await self.ta_database_manager.remove_team_from_ta(channel_id, team_name)
        # Response Message
        new_embed = discord.Embed(title="Removed Team from Twitch Alert", colour=KOALA_GREEN,
                                  description=f"Channel: {channel_id}\n"
                                              f"Team: {team_name}")

        await ctx.send(embed=new_embed)

    @twitch_group.command(name="list",
                          brief="Show twitch alerts in a channel",
                          usage=f"{CP}twitch list <channel>",
                          help=f"""Shows all current TwitchAlert users and teams in a channel

                          <channel> : The discord channel (e.g. #text-channel)

                          Example: {CP}twitch list #text-channel""")
    @commands.check(koalabot.is_admin)
    @commands.check(twitch_is_enabled)
    async def list_twitch_alert(self, ctx: discord.ext.commands.Context, channel: discord.TextChannel):
        """
        Shows all current TwitchAlert users and teams in a channel
        :param ctx:
        :param channel: The discord channel ID of the Twitch Alert
        """
        if not channel:
            channel = ctx.channel

        channel_id = channel.id

        if not is_channel_in_guild(self.bot, ctx.message.guild.id, channel_id):
            await ctx.send(embed=error_embed("The channel ID provided is either invalid, or not in this server."))
            return
        embed = discord.Embed()
        embed.title = "Twitch Alerts"
        embed.colour = KOALA_GREEN
        embed.set_footer(text=f"Channel ID: {channel_id}")

        results = self.ta_database_manager.get_users_in_ta(channel_id)
        if results:
            users = ""
            for result in results:
                users += f"{result.twitch_username}\n"
            embed.add_field(name=":bust_in_silhouette: Users", value=users)
        else:
            embed.add_field(name=":bust_in_silhouette: Users", value="None")

        results = self.ta_database_manager.get_teams_in_ta(channel_id)
        if results:
            teams = ""
            for result in results:
                teams += f"{result.twitch_team_name}\n"
            embed.add_field(name=":busts_in_silhouette: Teams", value=teams)
        else:
            embed.add_field(name=":busts_in_silhouette: Teams", value="None")

        await ctx.send(embed=embed)

    @commands.Cog.listener()
    async def on_ready(self):
        """
        When the bot is started up, the loop begins
        :return:
        """
        await self.ta_database_manager.setup_twitch_handler()
        if not self.running:
            self.start_loops()

    def start_loops(self):
        self.loop_update_teams.start()
        self.loop_check_team_live.start()
        self.loop_check_live.start()
        self.running = True

    def end_loops(self):
        self.loop_update_teams.cancel()
        self.loop_check_team_live.cancel()
        self.loop_check_live.cancel()
        self.running = False

    @tasks.loop(minutes=LOOP_CHECK_LIVE_DELAY)
    async def loop_check_live(self):
        """
        A loop that continually checks the live status of users and
        sends alerts when online, removing them when offline
        :return:
        """
        try:
            await core.create_user_alerts(self.bot, self.ta_database_manager)
        except Exception as err:
            logger.error("Twitch user live loop error: ", exc_info=err)

    @tasks.loop(minutes=REFRESH_TEAMS_DELAY)
    async def loop_update_teams(self):
        start = time.time()
        # logger.info("TwitchAlert: Started Update Teams")
        await self.ta_database_manager.update_all_teams_members()
        time_diff = time.time() - start
        if time_diff > 5:
            logger.warning(f"TwitchAlert: Teams updated in > 5s | {time_diff}s")

    @tasks.loop(minutes=TEAMS_LOOP_CHECK_LIVE_DELAY)
    async def loop_check_team_live(self):
        """
        A loop to repeatedly send messages if a member of a team is live, and remove it when they are not

        :return:
        """
        try:
            await core.create_team_alerts(self.bot, self.ta_database_manager)
        except Exception as err:
            logger.error("Twitch team live loop error: ", exc_info=err)


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    if TWITCH_SECRET is None or TWITCH_KEY is None:
        logger.error("TwitchAlert not started. API keys not found in environment.")
        insert_extension("TwitchAlert", 0, False, False)
    else:
        await bot.add_cog(TwitchAlert(bot))
        logger.info("TwitchAlert is ready.")

</document_content>
</document>
<document index="107">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/core.py</source>
<document_content>
import time
from typing import List

import discord
from discord.ext.commands import Bot
from sqlalchemy import select, func, or_, and_, null, update, delete
from twitchAPI.object import Stream

from koala.db import assign_session
from koala.models import GuildExtensions
from .log import logger
from .models import UserInTwitchTeam, TeamInTwitchAlert, TwitchAlerts, UserInTwitchAlert


@assign_session
async def create_team_alerts(bot: Bot, ta_database_manager, *, session):
    start = time.time()

    sql_select_team_users = select(func.distinct(UserInTwitchTeam.twitch_username)) \
        .join(TeamInTwitchAlert, UserInTwitchTeam.team_twitch_alert_id == TeamInTwitchAlert.team_twitch_alert_id) \
        .join(TwitchAlerts, TeamInTwitchAlert.channel_id == TwitchAlerts.channel_id) \
        .join(GuildExtensions, TwitchAlerts.guild_id == GuildExtensions.guild_id) \
        .where(or_(GuildExtensions.extension_id == 'TwitchAlert', GuildExtensions.extension_id == 'All'))
    users = session.execute(sql_select_team_users).all()
    # sql_select_team_users = "SELECT twitch_username, twitch_team_name " \
    #                         "FROM UserInTwitchTeam " \
    #                         "JOIN TeamInTwitchAlert TITA " \
    #                         "  ON UserInTwitchTeam.team_twitch_alert_id = TITA.team_twitch_alert_id " \
    #                         "JOIN TwitchAlerts TA on TITA.channel_id = TA.channel_id " \
    #                         "JOIN (SELECT extension_id, guild_id FROM GuildExtensions " \
    #                         "WHERE extension_id = 'TwitchAlert' " \
    #                         "  OR extension_id = 'All') GE on TA.guild_id = GE.guild_id "

    usernames = [str.lower(user[0]) for user in users]

    if not usernames:
        return

    streams: List[Stream] = await ta_database_manager.twitch_handler.get_streams_data(usernames)

    if streams is None:
        return

    for stream in streams:
        try:
            if stream.type == "live":
                current_username = str.lower(stream.user_login)
                logger.debug("Creating team stream alert for %s" % current_username)
                old_len = len(usernames)
                usernames.remove(current_username)
                if len(usernames) == old_len:
                    logger.error(f"TwitchAlert: {stream.user_login} not found in the user teams list")
                sql_find_message_id = select(TeamInTwitchAlert.channel_id,
                                             UserInTwitchTeam.message_id,
                                             TeamInTwitchAlert.team_twitch_alert_id,
                                             TeamInTwitchAlert.custom_message,
                                             TwitchAlerts.default_message) \
                    .join(TeamInTwitchAlert,
                          UserInTwitchTeam.team_twitch_alert_id == TeamInTwitchAlert.team_twitch_alert_id) \
                    .join(TwitchAlerts, TeamInTwitchAlert.channel_id == TwitchAlerts.channel_id) \
                    .join(GuildExtensions, TwitchAlerts.guild_id == GuildExtensions.guild_id) \
                    .where(and_(and_(or_(GuildExtensions.extension_id == 'TwitchAlert',
                                         GuildExtensions.extension_id == 'All'),
                                     UserInTwitchTeam.twitch_username == current_username),
                                UserInTwitchTeam.message_id == null()))

                # sql_find_message_id = """
                # SELECT TITA.channel_id, UserInTwitchTeam.message_id, TITA.team_twitch_alert_id, custom_message,
                #   default_message
                # FROM UserInTwitchTeam
                # JOIN TeamInTwitchAlert TITA on UserInTwitchTeam.team_twitch_alert_id = TITA.team_twitch_alert_id
                # JOIN TwitchAlerts TA on TITA.channel_id = TA.channel_id
                # JOIN (SELECT extension_id, guild_id
                #       FROM GuildExtensions
                #       WHERE extension_id = 'TwitchAlert' OR extension_id = 'All') GE ON TA.guild_id = GE.guild_id
                # WHERE twitch_username = ?"""

                results = session.execute(sql_find_message_id).all()

                new_message_embed = None

                for result in results:
                    channel_id = result.channel_id
                    message_id = result.message_id
                    team_twitch_alert_id = result.team_twitch_alert_id
                    custom_message = result.custom_message
                    channel_default_message = result.default_message
                    channel: discord.TextChannel = bot.get_channel(channel_id)
                    try:
                        # If no Alert is posted
                        if message_id is None:
                            if new_message_embed is None:
                                if custom_message is not None:
                                    message = custom_message
                                else:
                                    message = channel_default_message

                                new_message_embed = await ta_database_manager.create_alert_embed(stream, message)

                            if new_message_embed is not None and channel is not None:
                                new_message = await channel.send(embed=new_message_embed)

                                sql_update_message_id = update(UserInTwitchTeam) \
                                    .where(and_(UserInTwitchTeam.team_twitch_alert_id == team_twitch_alert_id,
                                                UserInTwitchTeam.twitch_username == current_username)) \
                                    .values(message_id=new_message.id)
                                session.execute(sql_update_message_id)
                                session.commit()
                    except discord.errors.Forbidden as err:
                        logger.warning(f"TwitchAlert: {err}  Name: {channel} ID: {channel.id}")
                        sql_remove_invalid_channel = delete(TwitchAlerts).where(
                            TwitchAlerts.channel_id == channel.id)
                        session.execute(sql_remove_invalid_channel)
                        session.commit()
        except Exception as err:
            logger.error(f"TwitchAlert: Team Loop error {err}")

    # Deals with remaining offline streams
    await ta_database_manager.delete_all_offline_team_streams(usernames, session=session)
    time_diff = time.time() - start
    if time_diff > 5:
        logger.warning(f"TwitchAlert: Teams Loop Finished in > 5s | {time_diff}s")


@assign_session
async def create_user_alerts(bot: Bot, ta_database_manager, session):
    start = time.time()
    # logger.info("TwitchAlert: User Loop Started")
    sql_find_users = select(func.distinct(UserInTwitchAlert.twitch_username)) \
        .join(TwitchAlerts, UserInTwitchAlert.channel_id == TwitchAlerts.channel_id) \
        .join(GuildExtensions, TwitchAlerts.guild_id == GuildExtensions.guild_id) \
        .where(or_(GuildExtensions.extension_id == 'TwitchAlert', GuildExtensions.extension_id == 'All'))
    # "SELECT twitch_username " \
    #              "FROM UserInTwitchAlert " \
    #              "JOIN TwitchAlerts TA on UserInTwitchAlert.channel_id = TA.channel_id " \
    #              "JOIN (SELECT extension_id, guild_id FROM GuildExtensions " \
    #              "WHERE extension_id = 'twitch_alert' OR extension_id = 'All') GE on TA.guild_id = GE.guild_id;"
    users = session.execute(sql_find_users).all()

    usernames = [str.lower(user[0]) for user in users]

    if not usernames:
        return

    user_streams: List[Stream] = await ta_database_manager.twitch_handler.get_streams_data(usernames)
    if user_streams is None:
        return

    # Deals with online streams
    for streams_details in user_streams:
        try:
            if streams_details.type == "live":
                current_username = str.lower(streams_details.user_login)
                old_len = len(usernames)
                usernames.remove(current_username)
                if len(usernames) == old_len:
                    logger.error(f"TwitchAlert: {streams_details.user_login} not found in the user list")

                sql_find_message_id = select(UserInTwitchAlert.channel_id,
                                             UserInTwitchAlert.message_id,
                                             UserInTwitchAlert.custom_message,
                                             TwitchAlerts.default_message) \
                    .join(TwitchAlerts, UserInTwitchAlert.channel_id == TwitchAlerts.channel_id) \
                    .join(GuildExtensions, TwitchAlerts.guild_id == GuildExtensions.guild_id) \
                    .where(and_(and_(or_(GuildExtensions.extension_id == 'TwitchAlert',
                                         GuildExtensions.extension_id == 'All'),
                                     UserInTwitchAlert.twitch_username == current_username),
                                UserInTwitchAlert.message_id == null()))
                # "SELECT UserInTwitchAlert.channel_id, message_id, custom_message, default_message " \
                # "FROM UserInTwitchAlert " \
                # "JOIN TwitchAlerts TA on UserInTwitchAlert.channel_id = TA.channel_id " \
                # "JOIN (SELECT extension_id, guild_id FROM GuildExtensions " \
                # "WHERE extension_id = 'TwitchAlert' " \
                # "  OR extension_id = 'All') GE on TA.guild_id = GE.guild_id " \
                # "WHERE twitch_username = ?;"

                results = session.execute(sql_find_message_id).all()

                new_message_embed = None

                for result in results:
                    channel_id = result.channel_id
                    message_id = result.message_id
                    custom_message = result.custom_message
                    channel_default_message = result.default_message

                    channel = bot.get_channel(channel_id)
                    try:
                        # If no Alert is posted
                        if message_id is None:
                            if new_message_embed is None:
                                if custom_message is not None:
                                    message = custom_message
                                else:
                                    message = channel_default_message

                                new_message_embed = await ta_database_manager.create_alert_embed(streams_details,
                                                                                                 message)

                            if new_message_embed is not None and channel is not None:
                                new_message = await channel.send(embed=new_message_embed)
                                sql_update_message_id = update(UserInTwitchAlert).where(and_(
                                    UserInTwitchAlert.channel_id == channel_id,
                                    UserInTwitchAlert.twitch_username == current_username)) \
                                    .values(message_id=new_message.id)
                                session.execute(sql_update_message_id)
                                session.commit()
                    except discord.errors.Forbidden as err:
                        logger.warning(f"TwitchAlert: {err}  Name: {channel} ID: {channel.id}")
                        sql_remove_invalid_channel = delete(TwitchAlerts).where(
                            TwitchAlerts.channel_id == channel.id)
                        session.execute(sql_remove_invalid_channel)
                        session.commit()

        except Exception as err:
            logger.error(f"TwitchAlert: User Loop error {err}")

    # Deals with remaining offline streams
    await ta_database_manager.delete_all_offline_streams(usernames, session=session)
    time_diff = time.time() - start
    if time_diff > 5:
        logger.warning(f"TwitchAlert: User Loop Finished in > 5s | {time_diff}s")


</document_content>
</document>
<document index="108">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/db.py</source>
<document_content>
# Futures

# Built-in/Generic Imports
import re

# Libs
import discord
from sqlalchemy import select, delete, and_, null
from sqlalchemy.orm import joinedload
from twitchAPI.object import Stream

# Own modules
from koala.db import session_manager
from .env import TWITCH_KEY, TWITCH_SECRET
from .log import logger
from .models import TwitchAlerts, TeamInTwitchAlert, UserInTwitchTeam, UserInTwitchAlert
from .twitch_handler import TwitchAPIHandler
from .utils import DEFAULT_MESSAGE, TWITCH_USERNAME_REGEX, create_live_embed


# Constants

# Variables


def delete_invalid_accounts():
    """
    Removes invalid teams & users (where the names are not valid according to the twitch Regex)
    :return:
    """
    with session_manager() as session:
        usernames = session.execute(select(UserInTwitchAlert.twitch_username))
        teams = session.execute(select(TeamInTwitchAlert.twitch_team_name))
        users_in_teams = session.execute(select(UserInTwitchTeam.twitch_username))

        invalid_usernames = [user for user in usernames
                             if not re.search(TWITCH_USERNAME_REGEX, user.twitch_username)]
        invalid_teams = [team.twitch_team_name for team in teams
                         if not re.search(TWITCH_USERNAME_REGEX, team.twitch_team_name)]
        invalid_users_in_teams = [user.twitch_username for user in users_in_teams
                                  if not re.search(TWITCH_USERNAME_REGEX, user.twitch_username)]

        if invalid_usernames:
            logger.warning(f'Deleting Invalid Users')
        if invalid_teams:
            logger.warning(f'Deleting Invalid Teams')
        if invalid_users_in_teams:
            logger.warning(f'Deleting Invalid Users in Teams')

        delete_invalid_usernames = delete(UserInTwitchAlert)\
            .where(UserInTwitchAlert.twitch_username.in_(invalid_usernames))
        delete_invalid_teams = delete(TeamInTwitchAlert)\
            .where(TeamInTwitchAlert.twitch_team_name.in_(invalid_teams))
        # This should be nothing
        delete_invalid_users_in_teams = delete(TeamInTwitchAlert)\
            .where(TeamInTwitchAlert.twitch_team_name.in_(invalid_teams))

        session.execute(delete_invalid_usernames)
        session.execute(delete_invalid_teams)
        session.execute(delete_invalid_users_in_teams)
        session.commit()


class TwitchAlertDBManager:
    """
    A class for interacting with the Koala twitch database
    """
    twitch_handler: TwitchAPIHandler

    def __init__(self, bot_client: discord.client):
        """
        Initialises local variables
        :param bot_client:
        """
        delete_invalid_accounts()
        self.bot = bot_client

    def new_ta(self, guild_id, channel_id, default_message=None, replace=False):
        """
        Creates a new Twitch Alert and gives the default message associated with it
        :param guild_id: The discord guild ID where the Twitch Alert is located
        :param channel_id: The discord channel ID of the twitch Alert
        :param default_message: The default message of users in the Twitch Alert
        :param replace: True if the new ta should replace the current if exists
        :return: The new default_message
        """
        # Sets the default message if not provided
        if default_message is None:
            default_message = DEFAULT_MESSAGE
        with session_manager() as session:
            sql_find_ta = select(TwitchAlerts).where(
                and_(TwitchAlerts.channel_id == channel_id, TwitchAlerts.guild_id == guild_id))
            message: TwitchAlerts = session.execute(sql_find_ta).scalar()
            if message and ((not replace) or (default_message == message.default_message)):
                return message.default_message

            # Insert new Twitch Alert to database
            if message:
                message.default_message = default_message
            else:
                session.add(TwitchAlerts(guild_id=guild_id, channel_id=channel_id, default_message=default_message))
            session.commit()
            return default_message

    def get_default_message(self, channel_id):
        """
        Get the set default message for the twitch alert
        :param channel_id: The discord channel ID of the twitch Alert
        :return: The current default_message
        """
        with session_manager() as session:
            result = session.execute(
                select(TwitchAlerts.default_message)
                .filter_by(channel_id=channel_id)
            ).one_or_none()
        if result:
            return result.default_message
        else:
            return DEFAULT_MESSAGE

    def add_user_to_ta(self, channel_id, twitch_username, custom_message, guild_id):
        """
        Add a twitch user to a given Twitch Alert
        :param channel_id: The discord channel ID of the twitch Alert
        :param twitch_username: The Twitch username of the user to be added
        :param custom_message: The custom Message of the user's live notification.
            None = use default Twitch Alert message
        :param guild_id: The guild ID of the channel
        :return:
        :raises: KeyError if channel ID is not defined in TwitchAlerts and guild_id is not provided
        """
        self.new_ta(guild_id, channel_id)
        with session_manager() as session:
            new_user = UserInTwitchAlert(channel_id=channel_id, twitch_username=str.lower(twitch_username))

            if custom_message:
                new_user.custom_message = custom_message

            session.add(new_user)
            session.commit()

    async def remove_user_from_ta(self, channel_id, twitch_username):
        """
        Removes a user from a given Twitch Alert
        :param channel_id: The discord channel ID of the twitch Alert
        :param twitch_username: The Twitch username of the user to be added
        :return:
        """
        with session_manager() as session:
            message = session.execute(select(UserInTwitchAlert)
                                      .filter_by(twitch_username=twitch_username, channel_id=channel_id)
                                      ).scalars().first()
            if message is not None:
                await self.delete_message(message.message_id, channel_id, session=session)
                session.delete(message)
                session.commit()

    async def delete_message(self, message_id, channel_id, *, session):
        """
        Deletes a given discord message
        :param message_id: discord message ID of the message to delete
        :param channel_id: discord channel ID which has the message
        :param session: db session
        :return:
        """
        try:
            channel = self.bot.get_channel(int(channel_id))
            if channel is None:
                logger.warning(f"TwitchAlert: Channel ID {channel_id} does not exist, removing from database")
                sql_remove_invalid_channel = delete(TwitchAlerts).where(TwitchAlerts.channel_id == channel_id)
                session.execute(sql_remove_invalid_channel)
                session.commit()
                return
            message = await channel.fetch_message(message_id)
            await message.delete()
        except discord.errors.NotFound as err:
            logger.warning(f"TwitchAlert: Message ID {message_id} does not exist, skipping \nError: {err}")
        except discord.errors.Forbidden as err:
            logger.warning(f"TwitchAlert: {err}  Channel ID: {channel_id}")
            sql_remove_invalid_channel = delete(TwitchAlerts).where(TwitchAlerts.channel_id == channel_id)
            session.execute(sql_remove_invalid_channel)
            session.commit()

    def get_users_in_ta(self, channel_id):
        """
        Returns all users in a given Twitch Alert
        :param channel_id: The channel ID of the Twitch Alert
        :return: The sql results of the users
        """
        sql_get_users = select(UserInTwitchAlert.twitch_username).filter_by(channel_id=channel_id)
        with session_manager() as session:
            return session.execute(sql_get_users).all()

    def get_teams_in_ta(self, channel_id):
        """
        Returns all teams in a given Twitch Alert
        :param channel_id: The channel ID of the Twitch Alert
        :return: The sql results of the teams
        """
        sql_get_teams = select(TeamInTwitchAlert.twitch_team_name).filter_by(channel_id=channel_id)
        with session_manager() as session:
            return session.execute(sql_get_teams).all()

    def add_team_to_ta(self, channel_id, twitch_team, custom_message, guild_id=None):
        """
        Add a twitch team to a given Twitch Alert
        :param channel_id: The discord channel ID of the twitch Alert
        :param twitch_team: The Twitch team to be added
        :param custom_message: The custom Message of the team's live notification.
            None = use default Twitch Alert message
        :param guild_id: The guild ID of the channel
        :return:
        :raises: KeyError if channel ID is not defined in TwitchAlerts and guild_id is not provided
        """
        self.new_ta(guild_id, channel_id)
        with session_manager() as session:
            new_team = TeamInTwitchAlert(channel_id=channel_id, twitch_team_name=str.lower(twitch_team))

            if custom_message:
                new_team.custom_message = custom_message

            session.add(new_team)
            session.commit()

    async def remove_team_from_ta(self, channel_id, team_name):
        """
        Removes a team from a given twitch alert
        :param channel_id: The channel ID of the Twitch Alert
        :param team_name: The team name of the team to be removed
        :return:
        """
        with session_manager() as session:
            team = session.execute(select(TeamInTwitchAlert)
                                   .filter_by(twitch_team_name=team_name, channel_id=channel_id)
                                   ).scalars().first()
            if not team:
                raise AttributeError("Team name not found")

            users = session.execute(select(UserInTwitchTeam)
                                    .filter_by(team_twitch_alert_id=team.team_twitch_alert_id)).scalars().all()
            if users is not None:
                for user in users:
                    if user.message_id is not None:
                        await self.delete_message(user.message_id, channel_id, session=session)
                    session.delete(user)

            session.delete(team)
            session.commit()

    async def update_team_members(self, twitch_team_id, team_name):
        """
        Users in a team are updated to ensure they are assigned to the correct team
        :param twitch_team_id: the team twitch alert id
        :param team_name: the name of the team
        :return:
        """
        if re.search(TWITCH_USERNAME_REGEX, team_name):
            users = await self.twitch_handler.get_team_users(team_name)
            for user_info in users:
                with session_manager() as session:
                    user = session.execute(
                        select(UserInTwitchTeam)
                        .filter_by(team_twitch_alert_id=twitch_team_id, twitch_username=user_info.user_login))\
                        .scalars()\
                        .one_or_none()

                    if user is None:
                        session.add(UserInTwitchTeam(
                            team_twitch_alert_id=twitch_team_id, twitch_username=user_info.user_login))
                        session.commit()

    async def update_all_teams_members(self):
        """
        Updates all teams with the current team members
        :return:
        """
        with session_manager() as session:
            teams_info = session.execute(select(TeamInTwitchAlert)).scalars().all()

        for team_info in teams_info:
            await self.update_team_members(team_info.team_twitch_alert_id, team_info.twitch_team_name)

    async def delete_all_offline_team_streams(self, usernames, *, session):
        """
        A method that deletes all currently offline streams
        :param usernames: The usernames of the team members
        :param session: db session
        :return:
        """
        results = session.execute(
            select(UserInTwitchTeam).where(
                and_(
                    UserInTwitchTeam.message_id != null(),
                    UserInTwitchTeam.twitch_username.in_(usernames))
                ).options(
                    joinedload(UserInTwitchTeam.team)
                )
        ).scalars().all()

        if not results:
            return
        logger.debug("Deleting offline streams: %s" % results)
        for result in results:
            if result.team:
                await self.delete_message(result.message_id, result.team.channel_id, session=session)
                result.message_id = None
            else:
                logger.debug("Result team not found: %s", result)
                logger.debug("Existing teams: %s", session.execute(select(TeamInTwitchAlert)).scalars().all())
                # session.delete(result)
        session.commit()

    async def delete_all_offline_streams(self, usernames, *, session):
        """
        A method that deletes all currently offline streams
        :param usernames: The usernames of the twitch members
        :param session: db session
        :return:
        """
        results = session.execute(
            select(
                UserInTwitchAlert
            ).where(
                and_(
                    UserInTwitchAlert.message_id != null(),
                    UserInTwitchAlert.twitch_username.in_(usernames)))
        ).scalars().all()

        if results is None:
            return
        for result in results:
            await self.delete_message(result.message_id, result.channel_id, session=session)
            result.message_id = None
        session.commit()

    # def translate_names_to_ids(self):
    #     """
    #     Translates usernames and team_names to twitch unique IDs
    #     """
    #     # todo: Create a backup before
    #     with session_manager() as session:
    #         if len(session.execute("SELECT name "
    #                            "FROM sqlite_master "
    #                            "WHERE type='table' AND (name='UserInTwitchAlert' OR name='TeamInTwitchAlert');"
    #                            ).all()) == 0:
    #             return
    #
    #     table_name = "UserInTwitchAlert"
    #     fields = self.db_execute_select(f"PRAGMA table_info({table_name});")
    #     if fields[1][1] == 'twitch_username':
    #         self.user_names_to_ids()
    #     elif fields[1][1] != 'twitch_user_id':
    #         raise NameError(f"Unexpected field {fields[1][1]} in ")
    #
    #     table_name = "TeamInTwitchAlert"
    #     fields = self.db_execute_select(f"PRAGMA table_info({table_name});")
    #     if fields[2][1] == 'twitch_team_name':
    #         self.team_names_to_ids()
    #     elif fields[2][1] != 'twitch_team_id':
    #         raise NameError(f"Unexpected field {fields[1][1]} in ")
    #
    #     # todo: remove all current messages from UserInTwitchTeam & update from empty
    #
    # def user_names_to_ids(self):
    #     with session_manager() as session:
    #         users_in_twitch_alert = session.execute(select(UserInTwitchAlert)).all()
    #         for user in users_in_twitch_alert:
    #             try:
    #                 session.execute(update(UserInTwitchAlert).where(
    #                     UserInTwitchAlert.twitch_username == user.twitch_username).values(
    #                     twitch_username=(self.twitch_handler.get_user_data(usernames=[user.twitch_username]))[0].get("id")))
    #                 session.commit()
    #             except Exception as err:
    #                 logger.error(f"User not found on Twitch {user}, deleted")
    #         session.execute("ALTER TABLE UserInTwitchAlert RENAME COLUMN twitch_username TO twitch_user_id")
    #         session.commit()
    #
    # def team_names_to_ids(self):
    #     with session_manager() as session:
    #         team_in_twitch_alert = session.execute(select(TeamInTwitchAlert)).all()
    #         for team in team_in_twitch_alert:
    #             try:
    #                 session.execute(update(TeamInTwitchAlert).where(
    #                     TeamInTwitchAlert == team.twitch_team_name).values(
    #                     twitch_team_name=self.twitch_handler.get_team_data(team.twitch_team_name).get("id")))
    #                 session.commit()
    #             except Exception as err:
    #                 logger.error(f"Team not found on Twitch {team}, deleted")
    #         session.execute("ALTER TABLE TeamInTwitchAlert RENAME COLUMN twitch_team_name TO twitch_team_id")
    #         session.commit()

    async def create_alert_embed(self, stream: Stream, message):
        """
        Creates and sends an alert message
        :param stream: The twitch stream data to have in the message
        :param message: The custom message to be added as a description
        :return: The discord message id of the sent message
        """
        user_details = (await self.twitch_handler.get_user_data(
            stream.user_name))[0]
        game_details = await self.twitch_handler.get_game_data(
            stream.game_id)
        return create_live_embed(stream, user_details, game_details, message)

    async def setup_twitch_handler(self):
        self.twitch_handler = TwitchAPIHandler()
        await self.twitch_handler.setup(TWITCH_KEY, TWITCH_SECRET)

</document_content>
</document>
<document index="109">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/env.py</source>
<document_content>
import os

from dotenv import load_dotenv

load_dotenv()

TWITCH_KEY = os.environ.get('TWITCH_TOKEN')
TWITCH_SECRET = os.environ.get('TWITCH_SECRET')

</document_content>
</document>
<document index="110">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="111">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/models.py</source>
<document_content>
from sqlalchemy import Column, INT, VARCHAR, ForeignKey, orm

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class TwitchAlerts:
    __tablename__ = 'TwitchAlerts'
    guild_id = Column(DiscordSnowflake, ForeignKey("Guilds.guild_id", ondelete='CASCADE'))
    channel_id = Column(DiscordSnowflake, primary_key=True)
    default_message = Column(VARCHAR(1000, collation="utf8mb4_unicode_520_ci"))

    def __repr__(self):
        return "<TwitchAlerts(%s, %s, %s)>" % \
               (self.guild_id, self.channel_id, self.default_message)


@mapper_registry.mapped
class UserInTwitchAlert:
    __tablename__ = 'UserInTwitchAlert'
    channel_id = Column(DiscordSnowflake, ForeignKey("TwitchAlerts.channel_id", ondelete='CASCADE'), primary_key=True)
    twitch_username = Column(VARCHAR(25), primary_key=True)
    custom_message = Column(VARCHAR(1000, collation="utf8mb4_unicode_520_ci"), nullable=True)
    message_id = Column(DiscordSnowflake, nullable=True)
    twitch_alert = orm.relationship("TwitchAlerts")

    def __repr__(self):
        return "<UserInTwitchAlert(%s, %s, %s, %s)>" % \
               (self.channel_id, self.twitch_username, self.custom_message, self.message_id)


@mapper_registry.mapped
class TeamInTwitchAlert:
    __tablename__ = 'TeamInTwitchAlert'
    team_twitch_alert_id = Column(INT, autoincrement=True, primary_key=True)
    channel_id = Column(DiscordSnowflake, ForeignKey("TwitchAlerts.channel_id", ondelete='CASCADE'))
    twitch_team_name = Column(VARCHAR(25))
    custom_message = Column(VARCHAR(1000, collation="utf8mb4_unicode_520_ci"), nullable=True)
    twitch_alert = orm.relationship("TwitchAlerts")

    def __repr__(self):
        return "<TeamInTwitchAlert(%s, %s, %s, %s)>" % \
               (self.team_twitch_alert_id, self.channel_id, self.twitch_team_name, self.custom_message)


@mapper_registry.mapped
class UserInTwitchTeam:
    __tablename__ = 'UserInTwitchTeam'
    team_twitch_alert_id = Column(INT, ForeignKey("TeamInTwitchAlert.team_twitch_alert_id", ondelete='CASCADE'), primary_key=True)
    twitch_username = Column(VARCHAR(25), primary_key=True)
    message_id = Column(DiscordSnowflake, nullable=True)
    team = orm.relationship("TeamInTwitchAlert")

    def __repr__(self):
        return "<UserInTwitchTeam(%s, %s, %s)>" % \
               (self.team_twitch_alert_id, self.twitch_username, self.message_id)

</document_content>
</document>
<document index="112">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/twitch_handler.py</source>
<document_content>
# Futures
from typing import List

from twitchAPI.object import Stream, TwitchUser, Game, ChannelTeam
# Libs
from twitchAPI.twitch import Twitch
from twitchAPI.types import TwitchAPIException

from .log import logger
# Own modules
from .utils import split_to_100s


# Built-in/Generic Imports

# Constants


# Variables

class TwitchAPIHandler:
    """
    A wrapper to interact with the twitch API
    """
    twitch: Twitch

    async def setup(self, client_id: str, client_secret: str):
        self.twitch = await Twitch(client_id, client_secret)

    async def get_streams_data(self, usernames) -> List[Stream]:
        """
        Gets all stream information from a list of given usernames
        :param usernames: The list of usernames
        :return: The JSON data of the request
        """
        result: List[Stream] = []
        batches = split_to_100s(usernames)
        for batch in batches:
            batch_result: List[Stream] = []
            try:
                async for stream in self.twitch.get_streams(user_login=batch):
                    batch_result.append(stream)
            except TwitchAPIException:
                logger.error(f"Streams data not received for batch, invalid request")
                for user in batch:
                    try:
                        async for stream in self.twitch.get_streams(user_login=user):
                            batch_result.append(stream)
                    except TwitchAPIException:
                        logger.error("User data cannot be found, invalid request")

            result.extend(batch_result)

        return result

    async def get_user_data(self, usernames=None, ids=None) -> List[TwitchUser]:
        """
        Gets the user information of a given user

        :param usernames: The display twitch usernames of the users
        :param ids: The unique twitch ids of the users
        :return: The JSON information of the user's data
        """
        result = []

        if usernames:
            user_list = split_to_100s(usernames)
            for u_batch in user_list:
                async for user in self.twitch.get_users(logins=u_batch):
                    result.append(user)

        if ids:
            id_list = split_to_100s(ids)
            for id_batch in id_list:
                async for user in self.twitch.get_users(logins=id_batch):
                    result.append(user)

        return result

    async def get_game_data(self, game_id) -> Game:
        """
        Gets the game information of a given game
        :param game_id: The twitch game ID of a game
        :return: The JSON information of the game's data
        """
        if game_id != "":
            async for game in self.twitch.get_games(game_ids=game_id):
                return game

    async def get_team_users(self, team_id):
        """
        Gets the users data about a given team
        :param team_id: The team name of the twitch team
        :return: the JSON information of the users
        """
        return (await self.get_team_data(team_id)).users

    async def get_team_data(self, team_id) -> ChannelTeam:
        """
        Gets the users data about a given team
        :param team_id: The team name of the twitch team
        :return: the JSON information of the users
        """
        return await self.twitch.get_teams(name=team_id)

</document_content>
</document>
<document index="113">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/twitch_alert/utils.py</source>
<document_content>
# Futures

# Built-in/Generic Imports

# Libs
import discord
from twitchAPI.object import Game, Stream, TwitchUser

# Own modules
from koala.colours import KOALA_GREEN

# Constants
DEFAULT_MESSAGE = ""
TWITCH_ICON = "https://cdn3.iconfinder.com/data/icons/social-messaging-ui-color-shapes-2-free" \
              "/128/social-twitch-circle-512.png"
TWITCH_USERNAME_REGEX = "^[a-z0-9][a-z0-9_-]{3,24}$"

LOOP_CHECK_LIVE_DELAY = 1
TEAMS_LOOP_CHECK_LIVE_DELAY = 1
REFRESH_TEAMS_DELAY = 5

# Variables


def create_live_embed(stream_info: Stream, user_info: TwitchUser, game_info: Game, message):
    """
    Creates an embed for the go live announcement
    :param stream_info: The stream data from the Twitch API
    :param user_info: The user data for this streamer from the Twitch API
    :param game_info: The game data for this game from the Twitch API
    :param message: The custom message to be added as a description
    :return: The embed created
    """
    embed = discord.Embed(colour=KOALA_GREEN)
    if message is not None and message != "":
        embed.description = message

    embed.set_author(name=stream_info.user_name + " is now streaming!",
                     icon_url=TWITCH_ICON)
    embed.title = "https://twitch.tv/" + str.lower(stream_info.user_login)

    embed.add_field(name="Stream Title", value=stream_info.title)
    if game_info is None:
        embed.add_field(name="Playing", value="No Category")
    else:
        embed.add_field(name="Playing", value=game_info.name)
    embed.set_thumbnail(url=user_info.profile_image_url)

    return embed


def split_to_100s(array: list):
    if not array:
        return array
    result = []
    while len(array) >= 100:
        result.append(array[:100])
        array = array[100:]
    result.append(array)
    return result

</document_content>
</document>
<document index="114">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/__init__.py</source>
<document_content>
from . import utils, db, models
from .cog import TextFilter, setup

</document_content>
</document>
<document index="115">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports
import re

import discord
# Libs
from discord.ext import commands

# Own modules
import koalabot
from koala.colours import KOALA_GREEN
from koala.db import insert_extension
from koala.utils import extract_id
from .db import TextFilterDBManager
from .utils import type_exists, build_word_list_embed, build_moderation_channel_embed, \
    create_default_embed, build_moderation_deleted_embed


def text_filter_is_enabled(ctx):
    """
    A command used to check if the guild has enabled TextFilter
    e.g. @commands.check(koalabot.is_admin)

    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    try:
        result = koalabot.check_guild_has_ext(ctx, "TextFilter")
    except PermissionError:
        result = False

    return result or (str(ctx.author) == koalabot.TEST_USER and koalabot.is_dpytest)


class TextFilter(commands.Cog, name="TextFilter"):
    """
    A discord.py cog with commands pertaining to the a Text Filter for admins to monitor their server
    """

    def __init__(self, bot):
        self.bot = bot
        insert_extension("TextFilter", 0, True, True)
        self.tf_database_manager = TextFilterDBManager(bot)

    @commands.command(name="filter", aliases=["filter_word"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def filter_new_word(self, ctx, word, filter_type="banned", too_many_arguments=None):
        """
        Adds a new word to the filtered text list

        :param ctx: The discord context
        :param word: The first argument and word to be filtered
        :param filter_type: The filter type (banned or risky)
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Something has gone wrong, your word may already be filtered or you have entered the
                command incorrectly. Try again with: `k!filter [filtered_text] [[risky] or [banned]]`"""
        if too_many_arguments is None and type_exists(filter_type):
            await self.filter_text(ctx, word, filter_type, False)
            await ctx.channel.send("*" + word + "* has been filtered as **" + filter_type + "**.")
            return
        raise Exception(error)

    @commands.command(name="filterRegex", aliases=["filter_regex"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def filter_new_regex(self, ctx, regex, filter_type="banned", too_many_arguments=None):
        """
        Adds a new regex to the filtered text list

        :param ctx: The discord context
        :param regex: The first argument and regex to be filtered
        :param filter_type: The filter type (banned or risky)
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = r"""Something has gone wrong, your regex may be invalid, this regex may already be filtered
                or you have entered the command incorrectly. Try again with: `k!filterRegex
                [filtered_regex] [[risky] or [banned]]`. One example for a regex could be to block emails
                with: [a-zA-Z0-9\._]+@herts\.ac\.uk where EMAIL is the university type (e.g herts)"""
        if too_many_arguments is None and type_exists(filter_type):
            try:
                re.compile(regex)
                await self.filter_text(ctx, regex, filter_type, True)
                await ctx.channel.send("*" + regex + "* has been filtered as **" + filter_type + "**.")
                return
            except:
                raise Exception(error)
        raise Exception(error)

    @commands.command(name="unfilter", aliases=["unfilter_word"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def unfilter_word(self, ctx, word, too_many_arguments=None):
        """
        Remove an existing word/test from the filter list

        :param ctx: The discord context
        :param word: The first argument and word to be filtered
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = "Too many arguments, please try again using the following arguments: `k!unfilter [filtered_word]`"
        if too_many_arguments is None:
            await self.unfilter_text(ctx, word)
            await ctx.channel.send("*" + word + "* has been unfiltered.")
            return
        raise Exception(error)

    @commands.command(name="filterList", aliases=["check_filtered_words", "checkFilteredWords"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def check_filtered_words(self, ctx):
        """
        Get a list of filtered words on the current guild.

        :param ctx: The discord context
        :return:
        """
        all_words_and_types = self.get_list_of_words(ctx)
        await ctx.channel.send(embed=build_word_list_embed(ctx, all_words_and_types[0], all_words_and_types[1],
                                                           all_words_and_types[2]))

    @commands.command(name="modChannelAdd", aliases=["setup_mod_channel", "setupModChannel",
                                                     "add_mod_channel", "addModChannel"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def setup_mod_channel(self, ctx, channel_id, too_many_arguments=None):
        """
        Add a mod channel to the current guild

        :param ctx: The discord context
        :param channel_id: The designated channel id for message details
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = "Channel not found or too many arguments, please try again: `k!setupModChannel [channel_id]`"
        channel = self.bot.get_channel(int(extract_id(channel_id)))
        if channel is not None and too_many_arguments is None:
            self.tf_database_manager.new_mod_channel(ctx.guild.id, channel.id)
            await ctx.channel.send(embed=build_moderation_channel_embed(ctx, channel, "Added"))
            return
        raise (Exception(error))

    @commands.command(name="modChannelRemove", aliases=["remove_mod_channel", "deleteModChannel", "removeModChannel"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def remove_mod_channel(self, ctx, channel_id, too_many_arguments=None):
        """
        Remove a mod channel from the guild

        :param ctx: The discord context
        :param channel_id: The designated channel id to be removed
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Channel ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        channel = self.bot.get_channel(int(extract_id(channel_id)))
        if channel is not None and too_many_arguments is None:
            self.tf_database_manager.remove_mod_channel(ctx.guild.id, channel.id)
            await ctx.channel.send(embed=build_moderation_channel_embed(ctx, channel, "Removed"))
            return
        raise Exception(error)

    @commands.command(name="modChannelList", aliases=["list_mod_channels", "listModChannels"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def list_mod_channels(self, ctx):
        """
        Get a list of filtered mod channels in the guild

        :param ctx: The discord context
        :return:
        """
        channels = self.tf_database_manager.get_mod_channel(ctx.guild.id)
        await ctx.channel.send(embed=self.build_channel_list_embed(ctx, channels))

    @commands.command(name="ignoreUser")
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def ignore_user(self, ctx, user, too_many_arguments=None):
        """
        Add a new ignored user to the database

        :param ctx: The discord context
        :param user: The discord mention of the User
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Ignore ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        ignore_id = ctx.message.mentions[0].id
        ignore_exists = self.bot.get_user(int(ignore_id))
        if ignore_exists is not None:
            self.tf_database_manager.new_ignore(ctx.guild.id, 'user', ignore_id)
            await ctx.channel.send("New ignore added: " + user)
            return
        raise (Exception(error))

    @commands.command(name="ignoreChannel")
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def ignore_channel(self, ctx, channel: discord.TextChannel, too_many_arguments=None):
        """
        Add a new ignored channel to the database

        :param ctx: The discord context
        :param channel: The discord mention of the Channel
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        error = """Missing Ignore ID or too many arguments remove a mod channel. If you don't know your Channel ID,
                use `k!listModChannels` to get information on your mod channels."""
        ignore_id = channel.id
        ignore_exists = self.bot.get_channel(int(ignore_id))
        if ignore_exists is not None:
            self.tf_database_manager.new_ignore(ctx.guild.id, 'channel', ignore_id)
            await ctx.channel.send(f"New ignore added: {channel.mention}")
            return
        raise (Exception(error))

    @commands.command(name="unignore", aliases=["remove_ignore", "removeIgnore"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def remove_ignore(self, ctx, ignore, too_many_arguments=None):
        """
        Remove an ignore from the guild

        :param ctx: The discord context
        :param ignore: the ignoreId to be removed
        :param too_many_arguments: Used to check if too many arguments have been given
        :return:
        """
        if len(ctx.message.mentions) > 0:
            ignore_id = ctx.message.mentions[0].id
        elif len(ctx.message.channel_mentions) > 0:
            ignore_id = ctx.message.channel_mentions[0].id
        else:
            raise Exception("No ignore mention found")
        self.tf_database_manager.remove_ignore(ctx.guild.id, ignore_id)
        await ctx.channel.send("Ignore removed: " + str(ignore))
        return

    @commands.command(name="ignoreList", aliases=["list_ignored", "listIgnored"])
    @commands.check(koalabot.is_admin)
    @commands.check(text_filter_is_enabled)
    async def list_ignored(self, ctx):
        """
        Get a list all ignored users/channels

        :param ctx: The discord context
        :return:
        """
        ignored = self.tf_database_manager.get_all_ignored(ctx.guild.id)
        await ctx.channel.send(embed=self.build_ignore_list_embed(ctx, ignored))

    @commands.Cog.listener()
    async def on_message(self, message):
        """
        Upon receiving a message, it is checked for filtered text and is deleted.

        :param message: The newly received message
        :return:
        """
        if message.author.bot:
            return
        if message.content.startswith(koalabot.COMMAND_PREFIX + "filter") or \
                message.content.startswith(koalabot.COMMAND_PREFIX + "unfilter") or \
                message.content.startswith(koalabot.OPT_COMMAND_PREFIX + "filter") or \
                message.content.startswith(koalabot.OPT_COMMAND_PREFIX + "unfilter"):
            return
        elif str(message.channel.type) == 'text' and message.channel.guild is not None:
            censor_list = self.tf_database_manager.get_filtered_text_for_guild(message.channel.guild.id)
            for word, filter_type, is_regex in censor_list:
                if (word in message.content or (
                        is_regex == '1' and re.search(word, message.content))) and not self.is_ignored(message):
                    if filter_type == "risky":
                        await message.author.send("Watch your language! Your message: '*" + message.content + "*' in " +
                                                  message.channel.mention + " contains a 'risky' word. "
                                                                            "This is a warning.")
                        return
                    elif filter_type == "banned":
                        await message.author.send("Watch your language! Your message: '*" + message.content + "*' in " +
                                                  message.channel.mention + " has been deleted by KoalaBot.")
                        await self.send_to_moderation_channels(message)
                        await message.delete()
                        return

    def build_channel_list(self, channels, embed):
        """
        Builds a list of mod channels and adds them to the embed

        :param channels: list of mod channels
        :param embed: The pre-existing embed to add the channel list fields to
        :return embed: the updated embed with the list of channels appended to
        """
        for channel in channels:
            details = self.bot.get_channel(int(channel[0]))
            if details is not None:
                embed.add_field(name="Name & Channel ID", value=details.mention + " " + str(details.id), inline=False)
            else:
                embed.add_field(name="Channel ID", value=channel[0], inline=False)
        return embed

    def build_channel_list_embed(self, ctx, channels):
        """
        Builds the embed that is sent to list all the mod channels

        :param ctx: The discord context
        :param channels: List of channels in the guild
        :return embed with list of mod channels:
        """
        embed = create_default_embed(ctx)
        embed.colour = KOALA_GREEN
        embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
        embed.title = "Koala Moderation - Mod Channels"
        embed = self.build_channel_list(channels, embed)
        return embed

    def is_ignored(self, message):
        """
        Checks if the user/channel should be ignored

        :param message: The newly received message
        :return boolean if should be ignored or not:
        """
        ignore_list_users = self.tf_database_manager.get_ignore_list_users(message.guild.id)
        ignore_list_channels = self.tf_database_manager.get_ignore_list_channels(message.guild.id)
        return message.channel.id in ignore_list_channels or message.author.id in ignore_list_users

    async def filter_text(self, ctx, text, filter_type, is_regex):
        """
        Calls to the datbase to filter a word

        :param ctx: the discord context
        :param text: the word to be filtered
        :param filter_type: the filter_type of the word to be added
        :param is_regex: boolean of if the text is regex
        """
        self.tf_database_manager.new_filtered_text(ctx.guild.id, text, filter_type, is_regex)

    async def unfilter_text(self, ctx, word):
        """
        Calls to the database to unfilter a word

        :param ctx: The discord context
        :param word: The word to be unfiltered
        """
        self.tf_database_manager.remove_filter_text(ctx.guild.id, word)

    def is_moderation_channel_available(self, guild_id):
        """
        Checks if any mod channels exist to be sent to

        :param guild_id: The guild to retrieve mod channels from
        :return: boolean true if mod channel exists, false otherwise
        """
        channels = self.tf_database_manager.get_mod_channel(guild_id)
        return len(channels) > 0

    async def send_to_moderation_channels(self, message):
        """
        Send details about deleted message to mod channels

        :param message: The message in question which is being deleted
        """
        if self.is_moderation_channel_available(message.guild.id):
            channels = self.tf_database_manager.get_mod_channel(message.guild.id)
            for each_channel in channels:
                channel = self.bot.get_channel(int(each_channel[0]))
                await channel.send(embed=build_moderation_deleted_embed(message))

    def get_list_of_words(self, ctx):
        """
        Gets a list of filtered words and corresponding types in a guild

        :param ctx: the discord context
        :return [all_words, all_types]: a list containing two lists of filtered words and types
        """
        all_words, all_types, all_regex = "", "", ""
        for word, filter_type, regex in self.tf_database_manager.get_filtered_text_for_guild(ctx.guild.id):
            all_words += word + "\n"
            all_types += filter_type + "\n"
            all_regex += regex + "\n"
        return [all_words, all_types, all_regex]

    def build_ignore_list(self, ignored, embed):
        """
        Builds a formatted list of ignored users/channels

        :param ignored: list of ignored users/channels
        :param embed: The pre-existing embed to add the channel list fields to
        :return embed: the updated embed with the list of channels appended to
        """
        for ig in ignored:
            if ig[2] == 'channel':
                details = self.bot.get_channel(int(ig[3]))
            else:
                details = self.bot.get_user(int(ig[3]))
            if details is not None:
                embed.add_field(name="Name & ID", value=details.mention + " " + str(details.id), inline=False)
            else:
                embed.add_field(name="ID", value=ig[3], inline=False)
        return embed

    def build_ignore_list_embed(self, ctx, channels):
        """
        Builds the embed to list all ignored

        :param ctx: The discord context
        :param channels: List of ignored users/channels
        :return embed with list of mod channels:
        """
        embed = create_default_embed(ctx)
        embed.colour = KOALA_GREEN
        embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
        embed.title = "Koala Moderation - Ignored Users/Channels"
        embed = self.build_ignore_list(channels, embed)
        return embed


async def setup(bot: koalabot) -> None:
    """
    Loads this cog into the selected bot

    :param  bot: The client of the KoalaBot
    """
    await bot.add_cog(TextFilter(bot))

</document_content>
</document>
<document index="116">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/db.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports

# Libs
import discord
from sqlalchemy import select, delete

# Own modules
from koala.db import session_manager
from .models import TextFilter, TextFilterModeration, TextFilterIgnoreList


class TextFilterDBManager:
    """
    A class for interacting with the Koala text filter database
    """

    def __init__(self, bot_client: discord.client):
        """
        Initialises local variables

        :param bot_client:
        """
        self.bot = bot_client


    def new_mod_channel(self, guild_id, channel_id):
        """
        Adds new filtered word for a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param channel_id: The new channel for moderation
        :return:
        """
        with session_manager() as session:
            session.add(TextFilterModeration(channel_id=channel_id, guild_id=guild_id))
            session.commit()

    def new_filtered_text(self, guild_id, filtered_text, filter_type, is_regex):
        """
        Adds new filtered word for a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param filtered_text: The new word to be filtered
        :param filter_type: The filter type (banned or risky)
        :param is_regex: Boolean if filtered text is regex
        :return:
        """
        with session_manager() as session:
            ft_id = str(guild_id) + filtered_text
            if not self.does_word_exist(ft_id):
                session.add(TextFilter(filtered_text_id=ft_id,
                                       guild_id=guild_id,
                                       filtered_text=filtered_text,
                                       filter_type=filter_type,
                                       is_regex=is_regex))
                session.commit()
                return
            raise Exception("Filtered word already exists")

    def remove_filter_text(self, guild_id, filtered_text):
        """
        Remove filtered word from a guild

        :param guild_id: Guild ID to retrieve filtered words from
        :param filtered_text: The new word to be filtered
        :return:
        """
        with session_manager() as session:
            ft_id = str(guild_id) + filtered_text
            if self.does_word_exist(ft_id):
                session.execute(delete(TextFilter).filter_by(filtered_text_id=ft_id))
                session.commit()
                return
            raise Exception("Filtered word does not exist")

    def new_ignore(self, guild_id, ignore_type, ignore):
        """
        Add new ignore to database

        :param guild_id: Guild ID to associate ignore to
        :param ignore_type: The type of ignore to add
        :param ignore: Ignore ID to be added
        """
        with session_manager() as session:
            ignore_id = str(guild_id) + str(ignore)
            if not self.does_ignore_exist(ignore_id):
                session.add(TextFilterIgnoreList(ignore_id=ignore_id, guild_id=guild_id,
                                                 ignore_type=ignore_type, ignore=ignore))
                session.commit()
                return
            raise Exception("Ignore already exists")

    def remove_ignore(self, guild_id, ignore):
        """
        Remove ignore from database

        :param guild_id: The guild_id to delete the ignore from
        :param ignore: the ignore id to be deleted
        """
        with session_manager() as session:
            ignore_id = str(guild_id) + str(ignore)
            if self.does_ignore_exist(ignore_id):
                session.execute(delete(TextFilterIgnoreList).filter_by(ignore_id=ignore_id))
                session.commit()
                return
            raise Exception("Ignore does not exist")

    def get_filtered_text_for_guild(self, guild_id):
        """
        Retrieves all filtered words for a specific guild and formats into a nice list of words

        :param guild_id: Guild ID to retrieve filtered words from:
        :return: list of filtered words
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilter).filter_by(guild_id=guild_id)).scalars()
            return [(row.filtered_text, row.filter_type, str(int(row.is_regex))) for row in rows]

    def get_ignore_list_channels(self, guild_id):
        """
        Get lists of ignored channels

        :param guild_id: The guild id to get the list from
        :return: list of ignored channels
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="channel")).all()
            return [row[0] for row in rows]

    def get_ignore_list_users(self, guild_id):
        """
        Get lists of ignored users

        :param guild_id: The guild id to get the list from
        :return: list of ignored users
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="user")).all()
            return [row[0] for row in rows]

    def get_all_ignored(self, guild_id):
        with session_manager() as session:
            rows = session.execute(select(TextFilterIgnoreList.ignore_id, TextFilterIgnoreList.guild_id,
                                          TextFilterIgnoreList.ignore_type, TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="channel")).all()
            rows += session.execute(select(TextFilterIgnoreList.ignore_id, TextFilterIgnoreList.guild_id,
                                          TextFilterIgnoreList.ignore_type, TextFilterIgnoreList.ignore)
                                   .filter_by(guild_id=guild_id, ignore_type="user")).all()
            return rows

    def get_mod_channel(self, guild_id):
        """
        Gets specific mod channels given a guild id

        :param guild_id: Guild ID to retrieve mod channel from
        :return: list of mod channels
        """
        with session_manager() as session:
            rows = session.execute(select(TextFilterModeration.channel_id)
                                   .filter_by(guild_id=guild_id)).all()
            return rows

    def remove_mod_channel(self, guild_id, channel_id):
        """
        Removes a specific mod channel in a guild

        :param guild_id: Guild ID to remove mod channel from
        :param channel_id: Mod channel to be removed
        :return:
        """
        with session_manager() as session:
            session.execute(delete(TextFilterModeration)
                            .filter_by(guild_id=guild_id, channel_id=channel_id))
            session.commit()

    def does_word_exist(self, ft_id):
        """
        Checks if word exists in database given an ID

        :param ft_id: filtered text id of word to be removed
        :return boolean of whether the word exists or not:
        """
        with session_manager() as session:
            return len(session.execute(select(TextFilter)
                                       .filter_by(filtered_text_id=ft_id)).all()) > 0

    def does_ignore_exist(self, ignore_id):
        """
        Checks if ignore exists in database given an ID

        :param ignore_id: ignore id of ignore to be removed
        :return boolean of whether the ignore exists or not:
        """
        with session_manager() as session:
            return len(session.execute(select(TextFilterIgnoreList)
                                       .filter_by(ignore_id=ignore_id)).all()) > 0

</document_content>
</document>
<document index="117">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="118">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/models.py</source>
<document_content>
from sqlalchemy import Column, VARCHAR, BOOLEAN

from koala.models import mapper_registry, DiscordSnowflake


@mapper_registry.mapped
class TextFilter:
    __tablename__ = 'TextFilter'
    filtered_text_id = Column(VARCHAR(100, collation="utf8mb4_unicode_520_ci"), primary_key=True)
    guild_id = Column(DiscordSnowflake)
    filtered_text = Column(VARCHAR(100, collation="utf8mb4_unicode_520_ci"))
    filter_type = Column(VARCHAR(10))
    is_regex = Column(BOOLEAN)

    def __repr__(self):
        return "<TextFilter(%s, %s, %s, %s, %s)>" % \
               (self.filtered_text_id, self.guild_id, self.filtered_text, self.filter_type, self.is_regex)


@mapper_registry.mapped
class TextFilterModeration:
    __tablename__ = 'TextFilterModeration'
    channel_id = Column(DiscordSnowflake, primary_key=True)
    guild_id = Column(DiscordSnowflake)

    def __repr__(self):
        return "<TextFilterModeration(%s, %s)>" % \
               (self.channel_id, self.guild_id)


@mapper_registry.mapped
class TextFilterIgnoreList:
    __tablename__ = 'TextFilterIgnoreList'
    ignore_id = Column(VARCHAR(40), primary_key=True)
    guild_id = Column(DiscordSnowflake)
    ignore_type = Column(VARCHAR(10))
    ignore = Column(DiscordSnowflake)

    def __repr__(self):
        return "<TextFilterIgnoreList(%s, %s, %s, %s)>" % \
               (self.ignore_id, self.guild_id, self.ignore_type, self.ignore)

</document_content>
</document>
<document index="119">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/text_filter/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Text Filter Code
Created by: Stefan Cooper
"""

# Built-in/Generic Imports

# Libs
import discord

# Own modules
from koala.colours import KOALA_GREEN


def type_exists(filter_type):
    """
    Validates the inputted filter_type

    :param filter_type: The filter type to be checked
    :return: boolean checking if the filter type can be handled by the system, checks for risky, banned or email
    """
    return filter_type == "risky" or filter_type == "banned"


def build_moderation_channel_embed(ctx, channel, action):
    """
    Builds a moderation embed which display some information about the mod channel being created/removed

    :param ctx: The discord context
    :param channel: The channel to be created/removed
    :param action: either "Added" or "Removed" to tell the user what happened to the mod channel
    :return embed: The moderation embed to be sent to the user
    """
    embed = create_default_embed(ctx)
    embed.title = "Koala Moderation - Mod Channel " + action
    embed.add_field(name="Channel Name", value=channel.mention)
    embed.add_field(name="Channel ID", value=channel.id)
    return embed


def build_word_list_embed(ctx, all_words, all_types, all_regex):
    """
    Builds the embed that is sent to list all the filtered words

    :param ctx: The discord context
    :param all_words: List of all the filtered words in the guild
    :param all_types: List of all the corresponding filter types for the words in the guild
    :param all_regex: List of all regex in the guild
    :return embed with information about the deleted message:
    """
    embed = create_default_embed(ctx)
    embed.title = "Koala Moderation - Filtered Words"
    if not all_words and not all_types and not all_regex:
        embed.add_field(name="No words found", value="For more help with using the Text Filter try k!help TextFilter")
    else:
        embed.add_field(name="Banned Words", value=all_words)
        embed.add_field(name="Filter Types", value=all_types)
        embed.add_field(name="Is Regex?", value=all_regex)
    return embed


def create_default_embed(ctx):
    """
    Creates a default embed that all embeds share

    :param ctx: The discord context
    :return embed with basic information which should be built upon:
    """
    embed = discord.Embed()
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {ctx.guild.id}")
    return embed


def build_moderation_deleted_embed(message):
    """
    Builds the embed that is sent after a message is deleted for containing a banned word

    :param message: the message object to be deleted
    :return embed with information about the deleted message:
    """
    embed = create_default_embed(message)
    embed.title = "Koala Moderation - Message Deleted"
    embed.add_field(name="Reason", value="Contained banned word")
    embed.add_field(name="User", value=message.author.mention)
    embed.add_field(name="Channel", value=message.channel.mention)
    embed.add_field(name="Message", value=message.content)
    embed.add_field(name="Timestamp", value=message.created_at)
    return embed

</document_content>
</document>
<document index="120">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/__init__.py</source>
<document_content>
from . import api
from . import cog
from .cog import BaseCog


async def setup(bot):
    await cog.setup(bot)
    api.setup(bot)

</document_content>
</document>
<document index="121">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/api.py</source>
<document_content>
# Futures
# Built-in/Generic Imports
# Libs
from http.client import CREATED

import discord
from aiohttp import web
from discord.ext.commands import Bot

from koala.rest.api import parse_request, build_response
from koala.utils import convert_iso_datetime
# Own modules
from . import core
from .log import logger

# Constants
BASE_ENDPOINT = 'base'
ACTIVITY_ENDPOINT = 'activity' # PUT
SCHEDULED_ACTIVITY_ENDPOINT = 'scheduled-activity' # POST

PING_ENDPOINT = 'ping'
SUPPORT_ENDPOINT = 'support'
GET_VERSION_ENDPOINT = 'version'
LOAD_COG_ENDPOINT = 'load-cog'
UNLOAD_COG_ENDPOINT = 'unload-cog'
ENABLE_EXTENSION_ENDPOINT = 'enable-extension'
DISABLE_EXTENSION_ENDPOINT = 'disable-extension'
EXTENSIONS_ENDPOINT = 'extensions'

# Variables

class BaseEndpoint:
    """
    The API endpoints for BaseCog
    """
    def __init__(self, bot):
        self._bot = bot

    def register(self, app):
        """
        Register the routes for the given application
        todo: review aiohttp 'views' and see if they are a better idea
        :param app: The aiohttp.web.Application (likely of the sub app)
        :return: app
        """
        app.add_routes([web.get('/{endpoint}'.format(endpoint=SCHEDULED_ACTIVITY_ENDPOINT), self.get_activities),
                        web.put('/{endpoint}'.format(endpoint=ACTIVITY_ENDPOINT), self.put_set_activity),
                        web.put('/{endpoint}'.format(endpoint=SCHEDULED_ACTIVITY_ENDPOINT), self.put_schedule_activity),
                        web.get('/{endpoint}'.format(endpoint=PING_ENDPOINT), self.get_ping),
                        web.get('/{endpoint}'.format(endpoint=SUPPORT_ENDPOINT), self.get_support_link),
                        web.get('/{endpoint}'.format(endpoint=GET_VERSION_ENDPOINT), self.get_version),
                        web.post('/{endpoint}'.format(endpoint=LOAD_COG_ENDPOINT), self.post_load_cog),
                        web.post('/{endpoint}'.format(endpoint=UNLOAD_COG_ENDPOINT), self.post_unload_cog),
                        web.post('/{endpoint}'.format(endpoint=ENABLE_EXTENSION_ENDPOINT), self.post_enable_extension),
                        web.post('/{endpoint}'.format(endpoint=DISABLE_EXTENSION_ENDPOINT), self.post_disable_extension),
                        web.get('/{endpoint}'.format(endpoint=EXTENSIONS_ENDPOINT), self.get_extensions)])
        return app

    @parse_request
    async def get_activities(self, show_all: bool):
        """
        Get all the scheduled activities
        :param show_all: If you wish to see a time restricted version or not
        :return: The list of ScheduledActivities
        """
        return core.activity_list(show_all=show_all)

    @parse_request(raw_response=True)
    async def put_set_activity(self, activity_type, name, url):
        """
        Put a given activity as the discord bot's activity
        :param activity_type: activity type (playing, watching, streaming, ...)
        :param name: The content of the activity
        :param url: The url to use (for streaming)
        :return:
        """
        try:
            activity_type = getActivityType(activity_type)
            await core.activity_set(activity_type, name, url, self._bot)
        except BaseException as e:
            error = 'Error setting activity: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))
        return build_response(CREATED, {'message': 'Activity set'})

    @parse_request(raw_response=True)
    async def put_schedule_activity(self, activity_type, message, url, start_time, end_time):
        """
        Put a given activity as a scheduled activity
        :param activity_type: activity type (playing, watching, streaming, ...)
        :param message: message to be used in sidebar
        :param url: optional url to use (for streaming)
        :param start_time: start time of activity to be used
        :param end_time: end time of activity to be used
        :return:
        """
        try:
            start_time = convert_iso_datetime(start_time)
            end_time = convert_iso_datetime(end_time)
            activity_type = getActivityType(activity_type)
            core.activity_schedule(activity_type, message, url, start_time, end_time)
        except BaseException as e:
            error = 'Error scheduling activity: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))

        return build_response(CREATED, {'message': 'Activity scheduled'})

    @parse_request
    async def get_ping(self):
        """
        Get the latency of the bot
        :return: The ping
        """
        return await core.ping(self._bot)

    @parse_request
    async def get_support_link(self):
        """
        Get the support link of KoalaBot
        :return: The support link
        """
        return core.support_link()

    @parse_request
    async def get_version(self):
        """
        Get the version of KoalaBot
        :return: The version
        """
        return core.get_version()

    @parse_request
    async def post_load_cog(self, extension):
        """
        Loads a cog from the cogs folder
        :param extension: name of the cog
        :return:
        """
        try:
            await core.load_cog(self._bot, extension)
        except BaseException as e:
            error = 'Error loading cog: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))

        return {'message': 'Cog loaded'}

    @parse_request
    async def post_unload_cog(self, extension):
        """
        Unloads a cog from the cogs folder
        :param extension: name of the cog
        :return:
        """
        try:
            await core.unload_cog(self._bot, extension)
        except BaseException as e:
            error = 'Error unloading cog: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))

        # if resp == "Sorry, you can't unload the base cog":
        #     return build_response(BAD_REQUEST, {'message': "Sorry, you can't unload the base cog"})
        # else:
        return {'message': 'Cog unloaded'}

    @parse_request
    async def post_enable_extension(self, guild_id, koala_ext):
        """
        Enables a koala extension
        :param guild_id: id for the Discord guild
        :param koala_ext: name of the extension
        :return:
        """
        try:
            await core.enable_extension(self._bot, guild_id, koala_ext)
        except BaseException as e:
            print(type(e))
            error = 'Error enabling extension: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))

        return {'message': 'Extension enabled'}

    @parse_request
    async def post_disable_extension(self, guild_id, koala_ext):
        """
        Disables a koala extension onto a server
        :param guild_id: id for the Discord guild
        :param koala_ext: name of the extension
        :return:
        """
        try:
            await core.disable_extension(self._bot, guild_id, koala_ext)
        except BaseException as e:
            print(type(e))
            error = 'Error disabling extension: {}'.format(handleActivityError(e))
            logger.error(error)
            raise web.HTTPUnprocessableEntity(reason="{}".format(error))

        return {'message': 'Extension disabled'}

    @parse_request
    async def get_extensions(self, guild_id):
        """
        Gets enabled koala extensions of a guild
        :param guild_id: id of the Discord guild
        :return:
        """
        return await core.get_available_extensions(guild_id)



def getActivityType(activity_type):
    return discord.ActivityType[activity_type]


def handleActivityError(error):
    if type(error) == KeyError:
        return 'Invalid activity type'
    elif type(error) == discord.ext.commands.errors.BadArgument:
        return 'Bad start / end time'
    elif type(error) == discord.ext.commands.errors.ExtensionNotFound:
        return 'Invalid extension'
    elif type(error) == discord.ext.commands.errors.ExtensionNotLoaded:
        return 'Extension not loaded'
    elif type(error) == discord.ext.commands.errors.ExtensionAlreadyLoaded:
        return 'Already loaded'
    elif type(error) == NotImplementedError and str(error).endswith("not an enabled extension"):
        return 'Extension not enabled'
    elif type(error) == NotImplementedError and str(error).endswith("not a valid extension"):
        return 'Invalid extension'
    elif type(error) == discord.ext.commands.errors.ExtensionFailed:
        return 'Failed to load'
    elif type(error) == discord.ext.commands.errors.ExtensionError and str(error).endswith("base cog"):
        return "Sorry, you can't unload the base cog"
    return 'Unknown error'


def setup(bot: Bot):
    """
    Load this cog to the KoalaBot.
    :param bot: the bot client for KoalaBot
    """
    sub_app = web.Application()
    endpoint = BaseEndpoint(bot)
    endpoint.register(sub_app)
    getattr(bot, "koala_web_app").add_subapp('/{extension}'.format(extension=BASE_ENDPOINT), sub_app)
    logger.info("Base API is ready.")

</document_content>
</document>
<document index="122">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/cog.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Cog code and additional base cog functions

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs

import discord
from discord import app_commands
from discord.ext import commands, tasks
# Own modules
from discord.ext.commands import BadArgument

import koalabot
from koala.utils import convert_iso_datetime
from . import core
from .log import logger
from .utils import AUTO_UPDATE_ACTIVITY_DELAY


# Constants

# Variables


def convert_activity_type(argument):
    try:
        return discord.ActivityType[argument]
    except KeyError:
        raise BadArgument('Unknown activity type %s' % argument)


class BaseCogSlash(commands.Cog, name='Koala'):
    """
    Temporary slash command cog. This will be used to get the new discord dev badge ;)
    """
    @app_commands.command(name="support", description="KoalaBot Support server link")
    async def support(self, interaction: discord.Interaction):
        """
        KoalaBot Support server link
        :param interaction:
        """
        await interaction.response.send_message(core.support_link())


class BaseCog(commands.Cog, name='KoalaBot'):
    """
        A discord.py cog with general commands useful to managers of the bot and servers
    """

    def __init__(self, bot: commands.Bot):
        """
        Initialises local variables
        :param bot: The bot client for this cog
        """
        self.bot = bot
        self._last_member = None
        self.started = False
        self.current_activity = None

    @commands.Cog.listener()
    async def on_ready(self):
        """
        Ran after all cogs have been started and bot is ready
        """
        core.activity_clear_current()
        await self.update_activity()
        core.add_all_guilds(self.bot)
        self.update_activity.start()
        self.started = True
        logger.info("Bot is ready.")



    @commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild):
        """
        On bot joining guild, add this guild to the database of guild welcome messages.
        :param guild: Guild KoalaBot just joined
        """
        core.add_guild(guild.id)
        logger.info(f"KoalaBot joined new guild, id = {guild.id}, name = {guild.name}.")

    @commands.group(name="activity")
    @commands.check(koalabot.is_owner)
    async def activity_group(self, ctx: commands.Context):
        """
        Group of commands for activity functionality.
        :param ctx: Context of the command
        :return:
        """

    @activity_group.command(name="set")
    @commands.check(koalabot.is_owner)
    async def activity_set(self, ctx, new_activity: convert_activity_type, name: str, url: str = None):
        """
        Change the activity of the bot
        :param ctx: Context of the command
        :param new_activity: The new activity of the bot
        :param name: The name of the activity
        :param url: url for streaming
        """
        await core.activity_set(new_activity, name, url, bot=self.bot)
        await ctx.send(f"I am now {new_activity.name} {name}")

    @activity_group.command(name="schedule")
    @commands.check(koalabot.is_owner)
    async def activity_schedule(self, ctx, new_activity: convert_activity_type, message: str,
                                start_time: convert_iso_datetime, end_time: convert_iso_datetime, url: str = None):
        """
        Schedule an activity
        :param ctx: Context of the command
        :param new_activity: activity type (watching, playing etc.)
        :param message: message
        :param start_time: iso format start time
        :param end_time: iso format end time
        :param url: url
        """
        core.activity_schedule(new_activity, message, url, start_time, end_time)
        await ctx.send("Activity saved")

    @activity_group.command(name="list")
    @commands.check(koalabot.is_owner)
    async def activity_list(self, ctx, show_all: bool = False):
        """
        List scheduled activities
        :param ctx: Context of the command
        :param show_all: false=future activities, true=all activities
        """
        activities = core.activity_list(show_all)
        result = "Activities:"
        for activity in activities:
            result += "\n%s, %s, %s, %s, %s, %s" % (activity.activity_id, activity.activity_type.name,
                                                    activity.stream_url, activity.message, activity.time_start,
                                                    activity.time_end)
        await ctx.send(result)

    @activity_group.command(name="remove")
    @commands.check(koalabot.is_owner)
    async def activity_remove(self, ctx, activity_id: int):
        """
        Remove an existing activity
        :param ctx: Context of the command
        :param activity_id: Activity ID
        """
        activity = core.activity_remove(activity_id)
        result = "Removed:"
        result += "\n%s, %s, %s, %s, %s, %s" % (activity.activity_id, activity.activity_type.name,
                                                activity.stream_url, activity.message, activity.time_start,
                                                activity.time_end)
        await ctx.send(result)

    @tasks.loop(minutes=AUTO_UPDATE_ACTIVITY_DELAY)
    async def update_activity(self):
        """
        Loop for updating the activity of the bot according to scheduled activities
        """
        try:
            await core.activity_set_current_scheduled(self.bot)
        except Exception as err:
            logger.error("Error in update_activity loop %s" % err, exc_info=err)

    @commands.command()
    async def ping(self, ctx):
        """
        Returns the ping of the bot
        :param ctx: Context of the command
        """
        await ctx.send(await core.ping(self.bot))

    @commands.command()
    async def support(self, ctx):
        """
        KoalaBot Support server link
        :param ctx: Context of the command
        """
        await ctx.send(core.support_link())

    @commands.command(name="clear")
    @commands.check(koalabot.is_admin)
    async def clear(self, ctx, amount: int = 1):
        """
        Clears a given number of messages from the given channel
        :param ctx: Context of the command
        :param amount: Amount of lines to delete
        """
        await core.purge(self.bot, ctx.channel.id, amount)

    @commands.command(name="loadCog", aliases=["load_cog"])
    @commands.check(koalabot.is_owner)
    async def load_cog(self, ctx, extension):
        """
        Loads a cog from the cogs folder
        :param ctx: Context of the command
        :param extension: The name of the cog
        """
        await ctx.send(await core.load_cog(self.bot, extension))

    @commands.command(name="unloadCog", aliases=["unload_cog"])
    @commands.check(koalabot.is_owner)
    async def unload_cog(self, ctx, extension):
        """
        Unloads a running cog
        :param ctx: Context of the command
        :param extension: The name of the cog
        """
        await ctx.send(await core.unload_cog(self.bot, extension))

    @commands.command(name="enableExt", aliases=["enable_koala_ext"])
    @commands.check(koalabot.is_admin)
    async def enable_koala_ext(self, ctx, koala_extension):
        """
        Enables a koala extension onto a server, all grants all extensions
        :param ctx: Context of the command
        :param koala_extension: The name of the koala
        """
        await ctx.send(embed=await core.enable_extension(self.bot, ctx.message.guild.id, koala_extension))

    @commands.command(name="disableExt", aliases=["disable_koala_ext"])
    @commands.check(koalabot.is_admin)
    async def disable_koala_ext(self, ctx, koala_extension):
        """
        Disables a koala extension onto a server
        :param ctx: Context of the command
        :param koala_extension: The name of the koala
        """
        await ctx.send(embed=await core.disable_extension(self.bot, ctx.message.guild.id, koala_extension))

    @commands.command(name="listExt", aliases=["list_koala_ext"])
    @commands.check(koalabot.is_admin)
    async def list_koala_ext(self, ctx):
        """
        Lists the enabled koala extensions of a server
        :param ctx: Context of the command
        """
        await ctx.send(embed=await core.list_enabled_extensions(ctx.message.guild.id))

    @commands.command(name="version")
    @commands.check(koalabot.is_owner)
    async def version(self, ctx):
        """
        Get the version of KoalaBot
        """
        await ctx.send(core.get_version())


async def setup(bot: koalabot) -> None:
    """
    Load this cog to the KoalaBot.

    :param bot: the bot client for KoalaBot
    """
    await bot.add_cog(BaseCog(bot))
    await bot.add_cog(BaseCogSlash())
    logger.info("BaseCog is ready.")

</document_content>
</document>
<document index="123">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/core.py</source>
<document_content>
import datetime
from typing import List, Optional

import discord
from discord.ext.commands import Bot
from sqlalchemy import select, exists
from sqlalchemy.orm import Session

import koalabot
from koala.db import assign_session, get_all_available_guild_extensions, get_enabled_guild_extensions, \
    give_guild_extension, remove_guild_extension
from . import db
from .log import logger
from .models import ScheduledActivities
from .utils import DEFAULT_ACTIVITY, activity_eq, list_ext_embed
from ...models import GuildExtensions, Guilds

# Constants

# Variables
current_activity = None


def activity_clear_current():
    global current_activity
    current_activity = None


async def activity_set(activity_type: discord.ActivityType, name: str, url: Optional[str], bot: Bot):
    """
    Set presence for this bot to the given presence
    :param activity_type:
    :param name:
    :param url:
    :param bot:
    :return:
    """
    new_activity = discord.Activity(type=activity_type, name=name, url=url)
    await bot.change_presence(activity=new_activity)


@assign_session
def activity_schedule(activity_type: discord.ActivityType, message: str, url: Optional[str], start_time: datetime.datetime,
                      end_time: datetime.datetime, **kwargs):
    """
    Schedule an activity to be used for a timed presence
    :param activity_type:
    :param message:
    :param url:
    :param start_time:
    :param end_time:
    :param kwargs:
    :return:
    """
    db.add_scheduled_activity(activity_type, message, url, start_time, end_time, **kwargs)


@assign_session
def activity_list(show_all: bool, **kwargs) -> List[ScheduledActivities]:
    """
    Get a list of all scheduled activity
    :param show_all:
    :param kwargs:
    :return:
    """
    return db.get_scheduled_activities(False, not show_all, **kwargs)


@assign_session
def activity_remove(activity_id: int, **kwargs) -> ScheduledActivities:
    """
    Remove a scheduled activity
    :param activity_id:
    :param kwargs:
    :return:
    """
    return db.remove_scheduled_activities(activity_id, **kwargs)


@assign_session
async def activity_set_current_scheduled(bot: Bot, **kwargs):
    """
    Set the current scheduled activity as the bot presence
    :param bot:
    :param kwargs:
    :return:
    """
    activities = db.get_scheduled_activities(True, True, **kwargs)
    if len(activities) > 1:
        logger.warn("Multiple activities found for this timeslot, %s" % activities)

    if len(activities) != 0:
        activity = activities[0]
        new_activity = discord.Activity(
            type=activity.activity_type, name=activity.message, url=activity.stream_url)
    else:
        new_activity = DEFAULT_ACTIVITY

    global current_activity
    if not activity_eq(new_activity, current_activity):
        await bot.change_presence(activity=new_activity)
        logger.info("Auto changing bot presence: %s" % new_activity)
        current_activity = new_activity


async def ping(bot: Bot):
    """
    Returns the ping of the bot
    :param bot:
    :return:
    """
    return f"Pong! {round(bot.latency * 1000)}ms"


def support_link():
    """
    Returns the link for KoalaBot Support server
    :return:
    """
    return f"Join our support server for more help! https://discord.gg/5etEjVd"


async def purge(bot: Bot, channel_id, amount):
    """
    Purges a number of messages from the channel
    :param channel:
    :param amount:
    :return:
    """
    channel = bot.get_channel(channel_id)
    return await channel.purge(limit=amount+1)


async def load_cog(bot: Bot, extension):
    """
    Loads a cog from the cogs folder
    :param extension:
    :param package:
    :return:
    """
    await bot.load_extension("."+extension, package=koalabot.COGS_PACKAGE)
    return f'{extension} Cog Loaded'


async def unload_cog(bot: Bot, extension):
    """
    Unloads a cog from the cogs folder
    :param extension:
    :param package:
    :return:
    """
    if extension == "base" or extension == "BaseCog":
        raise discord.ext.commands.errors.ExtensionError(message=f"Sorry, you can't unload the base cog", name=extension)
    else:
        await bot.unload_extension("."+extension, package=koalabot.COGS_PACKAGE)
        return f'{extension} Cog Unloaded'


@assign_session
async def enable_extension(bot: Bot, guild_id, koala_extension, **kwargs):
    """
    Enables a koala extension
    :param guild_id:
    :param koala_extension:
    :return:
    """
    if koala_extension.lower() in ["all"]:
        available_extensions = get_all_available_guild_extensions(guild_id, **kwargs)
        for ext in available_extensions:
            give_guild_extension(guild_id, ext, **kwargs)

        embed = list_ext_embed(guild_id, **kwargs)
        embed.title = "All extensions enabled"

    else:
        give_guild_extension(guild_id, koala_extension, **kwargs)
        embed = list_ext_embed(guild_id, **kwargs)
        embed.title = koala_extension + " enabled"

    return embed


@assign_session
async def disable_extension(bot: Bot, guild_id, koala_extension, *, session: Session):
    """
    Disables a koala extension
    :param guild_id:
    :param koala_extension:
    :return:
    """

    if koala_extension.lower() == "all":
        all_ext = get_enabled_guild_extensions(guild_id, session=session)
        for ext in all_ext:
            remove_guild_extension(guild_id, ext, session=session)
    else:
        enabled_ext = session.execute(select(GuildExtensions)
                                      .filter_by(guild_id=guild_id, extension_id=koala_extension)).scalar()
        if enabled_ext is None:
            raise NotImplementedError(f"{koala_extension} is not an enabled extension")
        koala_extension = enabled_ext.extension_id
        remove_guild_extension(guild_id, koala_extension, session=session)
    embed = list_ext_embed(guild_id, session=session)
    embed.title = koala_extension + " disabled"

    return embed


@assign_session
async def list_enabled_extensions(guild_id, **kwargs):
    """
    Lists enabled koala extensions
    :param guild_id:
    :return:
    """
    embed = list_ext_embed(guild_id, **kwargs)
    return embed


@assign_session
async def get_available_extensions(guild_id, **kwargs):
    """
        Gets all koala extensions of a guild
        :param guild_id:
        :return:
        """
    return get_all_available_guild_extensions(guild_id, **kwargs)


def get_version():
    """
    Returns version of KoalaBot
    :return:
    """
    return "version: "+koalabot.__version__


@assign_session
def add_all_guilds(bot: koalabot.KoalaBot, *, session: Session):
    guilds = bot.guilds
    for guild in guilds:
        db_guild = session.execute(select(Guilds).where(Guilds.guild_id == guild.id)).one_or_none()
        if db_guild is None:
            session.add(Guilds(guild_id=guild.id, subscription=0))
    session.commit()


@assign_session
def add_guild(guild_id: int, *, session: Session):
    db_guild = session.execute(select(Guilds).where(Guilds.guild_id == guild_id)).one_or_none()
    if db_guild is None:
        session.add(Guilds(guild_id=guild_id, subscription=0))
        session.commit()

</document_content>
</document>
<document index="124">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/db.py</source>
<document_content>
import datetime
from typing import List, Optional

import discord
import sqlalchemy.orm
from sqlalchemy import select

from koala.cogs.base.models import ScheduledActivities
from koala.db import assign_session


@assign_session
def add_scheduled_activity(activity_type: discord.ActivityType, message: str, url: Optional[str],
                           time_start: datetime.datetime, time_end: datetime.datetime,
                           session: sqlalchemy.orm.Session) -> ScheduledActivities:
    """
    Add scheduled activity to database
    :param activity_type:
    :param message:
    :param url:
    :param time_start:
    :param time_end:
    :param session:
    :return:
    """
    activity = ScheduledActivities(activity_type=activity_type, message=message, stream_url=url, time_start=time_start,
                                   time_end=time_end)
    session.add(activity)
    session.commit()
    return activity


@assign_session
def get_scheduled_activities(start_time_restricted: bool, end_time_restricted: bool,
                             session: sqlalchemy.orm.Session) -> List[ScheduledActivities]:
    """
    Get all scheduled activities
    :param start_time_restricted:
    :param end_time_restricted:
    :param session:
    :return:
    """
    current_time = datetime.datetime.now()
    query = select(ScheduledActivities)
    if start_time_restricted:
        query = query.where(ScheduledActivities.time_start <= current_time)
    if end_time_restricted:
        query = query.where(ScheduledActivities.time_end >= current_time)

    return session.execute(query).scalars().all()


@assign_session
def remove_scheduled_activities(activity_id: int, session: sqlalchemy.orm.Session) -> ScheduledActivities:
    """
    Delete a specified scheduled activity from a database
    :param activity_id:
    :param session:
    :return:
    """
    activity = session.execute(select(ScheduledActivities).filter_by(activity_id=activity_id)).scalar()
    session.delete(activity)
    session.commit()
    return activity

</document_content>
</document>
<document index="125">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/log.py</source>
<document_content>
from koala.log import get_logger

logger = get_logger(__name__)

</document_content>
</document>
<document index="126">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/models.py</source>
<document_content>
# Futures
# Built-in/Generic Imports
# Libs
from discord import ActivityType
from sqlalchemy import Column, TIMESTAMP, VARCHAR, INT, types

# Own modules
from koala.models import mapper_registry, BaseModel


# Constants

# Variables
class DiscordActivityType(types.TypeDecorator):
    """
    Uses discord.ActivityType for python, but INT for storing in db
    """

    impl = types.INT

    cache_ok = True

    def process_bind_param(self, value, dialect):
        return value.value if value is not None else None

    def process_literal_param(self, value, dialect):
        return value.value if value is not None else None

    def process_result_value(self, value, dialect):
        return ActivityType(value) if value is not None else None

    def copy(self, **kw):
        return DiscordActivityType()

    @property
    def python_type(self):
        return ActivityType


@mapper_registry.mapped
class ScheduledActivities(BaseModel):
    __tablename__ = 'ScheduledActivities'
    activity_id = Column(INT, primary_key=True, autoincrement=True)
    activity_type = Column(DiscordActivityType, comment="-1: unknown, 0: Playing, 1: Streaming, 2: Listening, "
                                                        "3: Watching, 4: Custom, 5: Competing")
    stream_url = Column(VARCHAR(100), nullable=True)
    message = Column(VARCHAR(100, collation="utf8mb4_unicode_520_ci"))
    time_start = Column(TIMESTAMP)
    time_end = Column(TIMESTAMP)

    def __repr__(self):
        return "<ScheduledActivities(%s, %s, %s)>" % \
               (self.activity_id, self.activity_type, self.message)

</document_content>
</document>
<document index="127">
<source>/Users/malcolm/dev/KoalaBot/koala/cogs/base/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Cog code and additional base cog functions

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports

# Libs
import discord

# Own modules
import koalabot
from koala.colours import KOALA_GREEN
from koala.db import get_enabled_guild_extensions, get_all_available_guild_extensions

# Constants
DEFAULT_ACTIVITY = discord.Activity(type=discord.ActivityType.playing, name=f"{koalabot.COMMAND_PREFIX}help koalabot.uk")
AUTO_UPDATE_ACTIVITY_DELAY = 1
# Variables


def list_ext_embed(guild_id, **kwargs):
    """
    Creates a discord embed of enabled and disabled extensions
    :param guild_id: The discord guild id of the server
    :return: The finished discord embed
    """
    embed = discord.Embed()
    embed.title = "Enabled extensions"
    embed.colour = KOALA_GREEN
    embed.set_footer(text=f"Guild ID: {guild_id}")
    enabled_results = get_enabled_guild_extensions(guild_id, **kwargs)
    all_results = get_all_available_guild_extensions(guild_id, **kwargs)
    enabled = ""
    disabled = ""
    for result in enabled_results:
        enabled += f"{result}\n"
        try:
            all_results.remove(result)
        except ValueError:
            pass
    for result in all_results:
        disabled += f"{result}\n"
    if enabled != "":
        embed.add_field(name=":white_check_mark: Enabled", value=enabled)
    if disabled != "":
        embed.add_field(name=":negative_squared_cross_mark: Disabled", value=disabled)
    return embed


def activity_eq(activity1: discord.Activity, activity2: discord.Activity) -> bool:
    return activity1 and activity2 \
           and activity1.type == activity2.type \
           and activity1.name == activity2.name \
           and activity1.url == activity2.url

</document_content>
</document>
<document index="128">
<source>/Users/malcolm/dev/KoalaBot/koalabot.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Code
Run this to start the Bot

Commented using reStructuredText (reST)
"""
__author__ = "KoalaBotUK"
__copyright__ = "Copyright (c) 2020 KoalaBotUK"
__credits__ = ["See full list of developers at: https://koalabot.uk/"]
__license__ = "MIT License"
__version__ = "1.0.0"
__maintainer__ = "Jack Draper"
__status__ = "Production"  # "Prototype", "Development", or "Production"

# Futures
# Built-in/Generic Imports
import asyncio
import time

import discord
# Libs
from aiohttp import web
import aiohttp_cors
from discord.ext import commands

from koala import env
# Own modules
from koala.db import extension_enabled
from koala.env import BOT_TOKEN, BOT_OWNER, API_PORT
from koala.errors import KoalaException
from koala.log import logger
from koala.utils import error_embed

# Constants
COMMAND_PREFIX = "k!"
OPT_COMMAND_PREFIX = "K!"
STREAMING_URL = "https://twitch.tv/thenuel"
COGS_PACKAGE = "koala.cogs"
TEST_USER = "TestUser#0001"  # Test user for dpytest
TEST_BOT_USER = "FakeApp#0001"  # Test bot user for dpytest
KOALA_GREEN = discord.Colour.from_rgb(0, 170, 110)
PERMISSION_ERROR_TEXT = "This guild does not have this extension enabled, go to http://koalabot.uk, " \
                        "or use `k!help enableExt` to enable it"
KOALA_IMAGE_URL = "https://cdn.discordapp.com/attachments/737280260541907015/752024535985029240/discord1.png"
ENABLED_COGS = ["base", "announce", "colour_role", "insights", "intro_cog", "react_for_role", "text_filter",
                "twitch_alert", "verification", "voting"]

# Variables
intent = discord.Intents.default()
intent.guilds = True        # on_guild_join, on_guild_remove
intent.members = True       # on_member_join
intent.reactions = True     # on_raw_reaction_add
intent.messages = True      # on_message
intent.message_content = True
is_dpytest = False


class KoalaBot(commands.Bot):
    """
    The commands.Bot subclass for Koala
    """
    async def setup_hook(self) -> None:
        """
        To perform asynchronous setup after the bot is logged in but before it has connected to the Websocket.
        """
        logger.debug("hook setup")
        await self.tree.sync()

    async def on_command_error(self, ctx, error: Exception):
        if ctx.guild is None:
            guild_id = "UNKNOWN"
            logger.warn("Unknown guild ID threw exception", exc_info=error)
        else:
            guild_id = ctx.guild.id

        if error.__class__ in [KoalaException,
                               commands.MissingRequiredArgument,
                               commands.CommandNotFound]:
            await ctx.send(embed=error_embed(description=error))
        if error.__class__ in [commands.CheckFailure]:
            await ctx.send(embed=error_embed(error_type=str(type(error).__name__),
                                             description=str(
                                                 error) + "\nPlease ensure you have administrator permissions, "
                                                          "and have enabled this extension."))
        elif isinstance(error, commands.CommandOnCooldown):
            await ctx.send(embed=error_embed(description=f"{ctx.author.mention}, this command is still on cooldown for "
                                                         f"{str(error.retry_after)}s."))
        elif isinstance(error, commands.errors.ChannelNotFound):
            await ctx.send(
                embed=error_embed(description=f"The channel ID provided is either invalid, or not in this server."))
        elif isinstance(error, commands.CommandInvokeError):
            logger.error("CommandInvokeError(%s), guild_id: %s, message: %s", error.original, guild_id, ctx.message,
                         exc_info=error)
            await ctx.send(embed=error_embed(description=error.original))
        else:
            logger.error(f"Unexpected Error in guild %s : %s", guild_id, error, exc_info=error)
            await ctx.send(embed=error_embed(
                description=f"An unexpected error occurred, please contact an administrator Timestamp: {time.time()}"))  # FIXME: better timestamp
            raise error


def is_owner(ctx: commands.Context):
    """
    A command used to check if the user of a command is the owner, or the testing bot.
    The command also allows Senior Devs of KoalaBot to use owner only commands (as given by Admin role in the dev portal)
    e.g. @commands.check(koalabot.is_owner)
    :param ctx: The context of the message
    :return: True if owner or test, False otherwise
    """
    if is_dm_channel(ctx):
        return False
    elif BOT_OWNER is not None:
        return ctx.author.id in BOT_OWNER or is_dpytest
    else:
        return ctx.bot.is_owner(ctx.author) or is_dpytest


def is_admin(ctx):
    """
    A command used to check if the user of a command is the admin, or the testing bot
    e.g. @commands.check(koalabot.is_admin)
    :param ctx: The context of the message
    :return: True if admin or test, False otherwise
    """
    if is_dm_channel(ctx):
        return False
    else:
        return ctx.author.guild_permissions.administrator or is_dpytest


def is_dm_channel(ctx):
    return isinstance(ctx.channel, discord.channel.DMChannel)


def is_guild_channel(ctx):
    return ctx.guild is not None


async def load_all_cogs(bot):
    """
    Loads all cogs in ENABLED_COGS into the client
    """

    for cog in ENABLED_COGS:
        try:
            await bot.load_extension("."+cog, package=COGS_PACKAGE)
        except commands.errors.ExtensionAlreadyLoaded:
            await bot.reload_extension("."+cog, package=COGS_PACKAGE)

    logger.info("All cogs loaded")


async def dm_group_message(members: [discord.Member], message: str):
    """
    DMs members in a list of members
    :param members: list of members to DM
    :param message: The message to send to the group
    :return: how many were dm'ed successfully.
    """
    count = 0
    for member in members:
        try:
            await member.send(message)
            count = count + 1
        except Exception:  # In case of user dms being closed
            pass
    return count


def check_guild_has_ext(ctx, extension_id):
    """
    A check for if a guild has a given koala extension
    :param ctx: A discord context
    :param extension_id: The koala extension ID
    :return: True if has ext
    """
    if is_dm_channel(ctx):
        return False
    if (not extension_enabled(ctx.message.guild.id, extension_id)) and (not is_dpytest):
        raise PermissionError(PERMISSION_ERROR_TEXT)
    return True


async def run_bot():
    app = web.Application()

    bot = KoalaBot(command_prefix=[COMMAND_PREFIX, OPT_COMMAND_PREFIX], intents=intent)
    setattr(bot, "koala_web_app", app)
    await load_all_cogs(bot)

    cors = aiohttp_cors.setup(app, defaults={
        env.FRONTEND_URL: aiohttp_cors.ResourceOptions(
                expose_headers="*", allow_headers="*")
    })
    for route in list(app.router.routes()):
        cors.add(route)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', API_PORT)
    await site.start()

    try:
        async with bot:
            await bot.start(BOT_TOKEN)

    except Exception:
        bot.close(),
        raise

    finally:
        await runner.cleanup()

if __name__ == '__main__': # pragma: no cover
    # loop = asyncio.get_event_loop()
    asyncio.run(run_bot())

</document_content>
</document>
<document index="129">
<source>/Users/malcolm/dev/KoalaBot/koala/utils.py</source>
<document_content>
#!/usr/bin/env python

"""
Koala Bot Base Cog code and additional base cog functions

Commented using reStructuredText (reST)
"""
# Futures

# Built-in/Generic Imports
import argparse
import datetime
import typing
from pathlib import PurePath
# Libs
from typing import Tuple, Optional

import discord
from discord.ext import commands
from discord.ext.commands import BadArgument

# Own modules
from koala.colours import ERROR_RED

# Constants
ID_LENGTH = 18
TIMEOUT_TIME = 60


# Variables

# Koala Constants


def error_embed(description, error_type=None):
    """
    Creates a discord embed for error messages
    :param description: The description of the error
    :param error_type: The error type (e.g. FileNotFoundError)
    :return: The completed embed
    """
    if isinstance(description, BaseException) and error_type is None:
        return discord.Embed(title=str(type(description).__name__), description=str(description), colour=ERROR_RED)
    elif error_type is None:
        return discord.Embed(title="Error", description=str(description), colour=ERROR_RED)
    else:
        return discord.Embed(title=error_type, description=str(description), colour=ERROR_RED)


def is_channel_in_guild(bot: discord.client, guild_id, channel_id):
    return bot.get_channel(int(channel_id)) in bot.get_guild(guild_id).channels


def is_int(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


def extract_id(raw_id):
    if type(raw_id) is str and raw_id[0] == "<":
        while not is_int(raw_id[0]):
            raw_id = raw_id[1:]
        return int(raw_id[:-1])
    elif is_int(raw_id):
        return int(raw_id)
    else:
        raise TypeError("ID given is not a valid ID")


async def wait_for_message(bot: discord.Client, ctx: commands.Context, timeout: float = TIMEOUT_TIME) \
        -> Tuple[Optional[discord.Message], Optional[discord.TextChannel]]:
    """
        Wraps bot.wait_for with message event, checking that message author is the original context author. Has default
        timeout of 60 seconds.
        :param bot: Koala Bot client
        :param ctx: Context of the original command
        :param timeout: Time to wait before raising TimeoutError
        :return: If a message (msg) was received, returns a tuple (msg, None). Else returns (None, ctx.channel)
        """
    try:
        msg = await bot.wait_for('message', timeout=timeout, check=lambda message: message.author == ctx.author)
    except (Exception, TypeError):
        return None, ctx.channel
    if not msg:
        return msg, ctx.channel
    return msg, None


def format_config_path(directory: str, *filename: str):
    """
    Format the path to be used by the database.

    This will be parsed directly into sqlite3 create connection.

    :param directory: The directory for the database file
    :param filename: The filename of the given database
    """
    if not directory:
        directory = ""

    return str(PurePath(directory, *filename))


def __parse_args(args):
    """
    Uses argparse to return a parser of all given arguments when running koalabot.py

    :param args: sys.argv[1:]
    :return: parsed argparse
    """
    parser = argparse.ArgumentParser(description='Start the KoalaBot Discord bot')
    parser.add_argument('--config', help="Config & database directory")
    args, unknown = parser.parse_known_args(args)
    return args


def convert_iso_datetime(argument):
    try:
        return datetime.datetime.fromisoformat(argument)
    except ValueError:
        raise BadArgument('Invalid ISO format "%s", instead use the format "2020-01-01 00:00:00"' % argument)



def cast(type_class, value):
    if isinstance(value, dict):
        return type_class(**value)
    elif typing.get_origin(type_class) == list:
        return [cast(type_class.__args__[0], v) for v in list(value)]
    if typing.get_origin(type_class) == dict:
        return {cast(type_class.__args__[0], k): cast(type_class.__args__[1], v) for k, v in dict(value)}
    if typing.get_origin(type_class) is not None:
        return typing.get_origin(type_class)(type_class)
    else:
        return type_class(value)


</document_content>
</document>
</documents>
