<documents>
<document index="1">
<source>/Users/malcolm/dev/bossjones/sandbox_agent/tests/test_bot.py</source>
<document_content>
from __future__ import annotations

import pathlib

from collections.abc import AsyncGenerator
from io import BytesIO
from typing import TYPE_CHECKING, Any

import discord
import discord.ext.test as dpytest
import pytest_asyncio

from discord import Attachment, File, Message
from discord.client import _LoopSentinel
from discord.ext.commands import Cog, command
from loguru import logger as LOGGER
from PIL import Image
from vcr.request import Request as VCRRequest

import pytest

from sandbox_agent.aio_settings import aiosettings
from sandbox_agent.bot import SandboxAgent
from sandbox_agent.utils.file_operations import create_temp_directory, download_image


if TYPE_CHECKING:
    from _pytest.capture import CaptureFixture
    from _pytest.fixtures import FixtureRequest
    from _pytest.logging import LogCaptureFixture
    from _pytest.monkeypatch import MonkeyPatch

    from pytest_mock.plugin import MockerFixture


@pytest_asyncio.fixture
async def mockbot(request: FixtureRequest) -> AsyncGenerator[SandboxAgent, None]:
    """
    Fixture to create a mock SandboxAgent for testing.

    This fixture sets up a SandboxAgent instance, configures it for testing,
    and yields it for use in tests. After the test, it performs cleanup.

    Args:
    ----
        request (FixtureRequest): The pytest request object.

    Yields:
    ------
        AsyncGenerator[SandboxAgent, None]: An instance of SandboxAgent configured for testing.

    """
    test_bot: SandboxAgent = SandboxAgent()

    # set up the loop
    if isinstance(test_bot.loop, _LoopSentinel):  # type: ignore
        await test_bot._async_setup_hook()  # type: ignore

    marks = request.function.pytestmark
    mark = None
    for mark in marks:
        if mark.name == "cogs":
            break

    if mark is not None:
        for extension in mark.args:
            await test_bot.load_extension("tests.internal." + extension)

    dpytest.configure(test_bot)

    yield test_bot

    # Teardown
    await dpytest.empty_queue()  # empty the global message queue as test teardown


@pytest_asyncio.fixture(autouse=True)
async def cleanup() -> AsyncGenerator[None, None]:
    """
    Fixture to clean up the global message queue after each test.

    This fixture is automatically used for all tests and ensures that
    the global message queue is emptied after each test run.

    Yields:
    ------
        AsyncGenerator[None, None]: Yields control back to the test.

    """
    yield
    await dpytest.empty_queue()




@pytest.mark.asyncio()
async def test_check_for_attachments_tenor_gif(mockbot: SandboxAgent, mocker: MockerFixture) -> None:
    """
    Test the check_for_attachments method with a Tenor GIF URL.

    This test verifies that the method correctly identifies and processes a Tenor GIF URL.

    Args:
    ----
        mockbot (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.

    """
    message = mocker.MagicMock(spec=Message)
    message.content = "Check out this GIF https://tenor.com/view/funny-cat-dancing-gif-12345"
    message.author.display_name = "TestUser"

    result = await mockbot.check_for_attachments(message)
    expected = "Check out this GIF  [TestUser posts an animated funny cat dancing gif]"
    assert result == expected


@pytest.mark.asyncio()
async def test_check_for_attachments_image_url(mockbot: SandboxAgent, mocker: MockerFixture) -> None:
    """
    Test the check_for_attachments method with an image URL.

    This test verifies that the method correctly identifies and processes an image URL.

    Args:
    ----
        mockbot (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.

    """
    message = mocker.MagicMock(spec=Message)
    message.content = "https://example.com/image.jpg"

    mock_process_image = mocker.patch.object(mockbot, "process_image")
    result = await mockbot.check_for_attachments(message)

    assert result == "https://example.com/image.jpg"
    mock_process_image.assert_called_once_with("https://example.com/image.jpg")


@pytest.mark.asyncio()
async def test_verify_file_jpg(mockbot: SandboxAgent) -> None:
    """
    Test file verification for JPG files.

    This test sends a JPG file to a channel and verifies that it's correctly attached to the message.

    Args:
    ----
        mockbot (SandboxAgent): The SandboxAgent instance.

    """
    guild = mockbot.guilds[0]
    channel = guild.text_channels[0]

    path_ = pathlib.Path(__file__).resolve().parent / "fixtures/screenshot_image_larger00000.JPEG"
    file_ = discord.File(path_)
    await channel.send(file=file_)
    assert dpytest.verify().message().attachment(path_)


@pytest.mark.skip(reason="This test is not yet implemented")
@pytest.mark.flaky()
@pytest.mark.asyncio()
async def test_process_image(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the process_image method of SandboxAgent.

    This test mocks the necessary dependencies and verifies that the image is processed correctly.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    url = "http://example.com/image.jpg"

    mock_download = mocker.patch("sandbox_agent.utils.file_operations.download_image")
    mock_image_open = mocker.patch("PIL.Image.open")
    mock_response = mocker.MagicMock()
    mock_response.content = b"fake image data"
    mock_download.return_value = mock_response
    mock_image = mocker.MagicMock()
    mock_image_open.return_value.convert.return_value = mock_image

    await mockbot.process_image(url)

    mock_download.assert_called_once_with(url)
    mock_image_open.assert_called_once()
    mock_image.convert.assert_called_once_with("RGB")


@pytest.mark.asyncio()
async def test_on_message_bot_message(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the on_message method with a message from a mockbot.

    This test verifies that the method does not process messages from bots.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    mock_message = mocker.AsyncMock(spec=Message)
    mock_message.author.bot = True

    await mockbot.on_message(mock_message)

    mock_message.channel.send.assert_not_called()


@pytest.mark.asyncio()
async def test_on_message_percent_message(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the on_message method with a message starting with a percent sign.

    This test verifies that the method does not process messages starting with a percent sign.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    mock_message = mocker.AsyncMock(spec=Message)
    mock_message.author.bot = False
    mock_message.content = "%some command"

    await mockbot.on_message(mock_message)

    mock_message.channel.send.assert_not_called()


@pytest.mark.asyncio()
async def test_on_message_valid_message(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the on_message method with a valid message.

    This test verifies that the method processes valid messages correctly.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    mock_message = mocker.AsyncMock(spec=Message)
    mock_message.author.bot = False
    mock_message.content = "Hello, bot!"

    mock_process_attachments = mocker.patch.object(mockbot, "process_attachments")
    mock_process_commands = mocker.patch.object(mockbot, "process_commands")
    await mockbot.on_message(mock_message)

    mock_process_attachments.assert_called_once_with(mock_message)
    mock_process_commands.assert_called_once_with(mock_message)



@pytest.mark.asyncio()
async def test_check_for_attachments_no_attachments(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the check_for_attachments method with no attachments.

    This test verifies that the method returns the original message content when there are no attachments.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    message = mocker.MagicMock(spec=Message)
    message.content = "Hello, bot!"
    message.attachments = []

    result = await mockbot.check_for_attachments(message)

    assert result == "Hello, bot!"


@pytest.mark.skip(reason="This test is not yet implemented")
@pytest.mark.flaky()
@pytest.mark.asyncio()
async def test_process_image_invalid_url(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the process_image method with an invalid image URL.

    This test verifies that the method handles invalid image URLs gracefully.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    url = "http://example.com/invalid_image.jpg"

    mock_download = mocker.patch(
        "mockbot.utils.file_operations.download_image", side_effect=Exception("Download failed")
    )

    await mockbot.process_image(url)

    mock_download.assert_called_once_with(url)


@pytest.mark.skip(reason="This test is not yet implemented")
@pytest.mark.flaky()
@pytest.mark.asyncio()
async def test_on_message_exception(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the on_message method when an exception occurs.

    This test verifies that the method handles exceptions gracefully and sends an error message.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    mock_message = mocker.AsyncMock(spec=Message)
    mock_message.author.bot = False
    mock_message.content = "Hello, bot!"

    mock_process_attachments = mocker.patch.object(
        mockbot, "process_attachments", side_effect=Exception("Processing failed")
    )

    await mockbot.on_message(mock_message)

    mock_process_attachments.assert_called_once_with(mock_message)
    mock_message.channel.send.assert_called_once_with("An error occurred while processing the message.")


@pytest.mark.skip(reason="This test is not yet implemented")
@pytest.mark.flaky()
@pytest.mark.asyncio()
async def test_chat_command_empty_message(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the chat command with an empty message.

    This test verifies that the method sends a response indicating that the message is empty.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    ctx = mocker.AsyncMock()
    message = ""

    await mockbot.chat(ctx, message=message)

    ctx.send.assert_called_once_with("Please provide a message to chat with the mockbot.")


@pytest.mark.skip(reason="This test is not yet implemented")
@pytest.mark.flaky()
@pytest.mark.asyncio()
async def test_get_attachments(mockbot: SandboxAgent, mocker: MockerFixture):
    """
    Test the get_attachments method of SandboxAgent.

    This test mocks the necessary dependencies and verifies that the attachment data is retrieved correctly.

    Args:
        sandbox_agent (SandboxAgent): The SandboxAgent instance.
        mocker (MockerFixture): The pytest-mock fixture for mocking.
    """
    message = mocker.MagicMock(spec=Message)
    attachment = mocker.MagicMock(spec=Attachment)
    attachment.filename = "test_file.txt"
    attachment.url = "http://example.com/test_file.txt"
    message.attachments = [attachment]

    mock_attachment_to_dict = mocker.patch(
        "mockbot.utils.attachment_to_dict",
        return_value={"filename": "test_file.txt", "url": "http://example.com/test_file.txt"},
    )

    attachment_data_list_dicts, local_attachment_file_list, local_attachment_data_list_dicts, media_filepaths = (
        mockbot.get_attachments(message)
    )

    assert attachment_data_list_dicts == [{"filename": "test_file.txt", "url": "http://example.com/test_file.txt"}]
    assert local_attachment_file_list == []
    assert local_attachment_data_list_dicts == []
    assert media_filepaths == []
    mock_attachment_to_dict.assert_called_once_with(attachment)


@pytest.mark.integration()
class TestBotWithDPyTest:
    @pytest.mark.asyncio()
    @pytest.mark.cogs("cogs.misc")
    async def test_ping(self, mockbot: SandboxAgent) -> None:
        """
        Test the ping command.

        This test verifies that the bot responds with "Pong !" when the ping command is used.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.

        """
        await dpytest.message(f"{aiosettings.prefix}ping")
        assert dpytest.verify().message().content("Pong !")

    @pytest.mark.cogs("cogs.echo")
    @pytest.mark.asyncio()
    async def test_echo(self, mockbot: SandboxAgent) -> None:
        """
        Test the echo command.

        This test verifies that the bot echoes the message content when the echo command is used.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.

        """
        await dpytest.message(f"{aiosettings.prefix}echo Hello world")
        assert dpytest.verify().message().contains().content("Hello")

    @pytest.mark.skip(reason="This test is not yet implemented")
    @pytest.mark.flaky()
    @pytest.mark.asyncio()
    async def test_on_ready(self, mockbot: SandboxAgent):
        """
        Test the on_ready event.

        This test verifies that the bot logs the 'Logged in as...' message when the on_ready event is triggered.
        """
        with pytest.raises(RuntimeError):
            await mockbot.on_ready()

    @pytest.mark.skip(reason="This test is not yet implemented")
    @pytest.mark.flaky()
    @pytest.mark.asyncio()
    @pytest.mark.discordonly()
    async def test_process_commands_help_command(self, mockbot: SandboxAgent):
        """
        Test the process_commands method with the !help command.

        This test verifies that the bot responds with the help message when the !help command is used.
        """
        message = dpytest.backend.make_message(f"{aiosettings.prefix}help", author=dpytest.backend.make_user(bot=False))
        await dpytest.message(message)

        assert dpytest.verify().message().contains().content("Here are the available commands:")

    @pytest.mark.skip(reason="something wrong with make_message")
    @pytest.mark.flaky()
    @pytest.mark.asyncio()
    @pytest.mark.discordonly()
    async def test_process_commands_unknown_command(self, mockbot: SandboxAgent):
        """
        Test the process_commands method with an unknown command.

        This test verifies that the bot responds with an unknown command message when an unrecognized command is used.
        """
        message = dpytest.backend.make_message(
            f"{aiosettings.prefix}unknown_command", author=dpytest.backend.make_user("FakeApp", "0001", None)
        )
        await dpytest.message(message)

        assert (
            dpytest.verify()
            .message()
            .contains()
            .content(f"Unknown command. Please use {aiosettings.prefix}help to see available commands.")
        )

    @pytest.mark.skip(reason="something wrong with make_message")
    @pytest.mark.flaky()
    @pytest.mark.asyncio()
    @pytest.mark.discordonly()
    async def test_process_commands_chat_command(self, mockbot: SandboxAgent, mocker: MockerFixture):
        """
        Test the process_commands method with the !chat command.

        This test verifies that the bot invokes the chat command when the !chat command is used.
        """


        await dpytest.message(f"{aiosettings.prefix}chat Hello, bot!")
        assert dpytest.verify().message().content("Pong !")


    @pytest.mark.asyncio()
    @pytest.mark.discordonly()
    async def test_verify_file_text(self, mockbot: SandboxAgent):
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        path_ = pathlib.Path(__file__).resolve().parent / "fixtures/loremimpsum.txt"
        file_ = discord.File(path_)
        await channel.send(file=file_)
        assert dpytest.verify().message().attachment(path_)

    @pytest.mark.asyncio()
    @pytest.mark.discordonly()
    async def test_verify_file_jpg(self, mockbot: SandboxAgent):
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        path_ = pathlib.Path(__file__).resolve().parent / "fixtures/unit-tests.jpg"
        file_ = discord.File(path_)
        await channel.send(file=file_)
        assert dpytest.verify().message().attachment(path_)

    @pytest.mark.asyncio()
    async def test_dm_send(self, mockbot: SandboxAgent):
        guild = mockbot.guilds[0]
        await guild.members[0].send("hi")

        assert dpytest.verify().message().content("hi")

    @pytest.mark.skip(reason="something wrong with make_message")
    @pytest.mark.flaky()
    @pytest.mark.asyncio()
    @pytest.mark.cogs("cogs.echo")
    async def test_dm_message(self, mockbot: SandboxAgent):
        guild = mockbot.guilds[0]
        member = guild.members[0]
        dm = await member.create_dm()
        await dpytest.message(f"{aiosettings.prefix}echo Ah-Ha!", dm)

        assert dpytest.verify().message().content("Ah-Ha!")

    # ---------
    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_bot_initialization(self, mockbot: SandboxAgent) -> None:
        """
        Test the initialization of the SandboxAgent.

        This test verifies that the SandboxAgent is correctly initialized with all required components.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.

        """
        assert isinstance(mockbot, SandboxAgent)
        assert mockbot.chat_model is not None
        assert mockbot.embedding_model is not None
        assert mockbot.vector_store is not None
        assert mockbot.agent is not None
        assert mockbot.graph is not None

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_on_ready_logs(self, mockbot: SandboxAgent, capsys: CaptureFixture[str]) -> None:
        """
        Test the on_ready event logging.

        This test verifies that the bot logs the 'Logged in as...' message when the on_ready event is triggered.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.
            capsys (CaptureFixture[str]): Pytest fixture to capture stdout and stderr.

        """
        await mockbot.on_ready()
        captured = capsys.readouterr()
        assert "Logged in as" in captured.out

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    @pytest.mark.cogs("cogs.misc")
    async def test_ping_command(self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture):
        # guild = mockbot.guilds[0]
        # channel = guild.text_channels[0]

        guild = mockbot.guilds[0]
        author: discord.Member = guild.members[0]
        channel = guild.channels[0]
        LOGGER.info(f"guild: {guild}")
        LOGGER.info(f"channel: {channel}")
        LOGGER.info(f"author: {author}")
        message_dict = dpytest.backend.facts.make_message_dict(channel, author, attachments=[])  # type: ignore
        try:
            message: discord.Message = discord.Message(
                state=dpytest.backend.get_state(), channel=channel, data=message_dict
            )  # noqa: E501,F841 (variable never used)
        except Exception as err:
            pytest.fail(str(err))


    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_check_for_attachments_tenor_gif(
        self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture
    ):
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        message = await channel.send("Check out this GIF https://tenor.com/view/funny-cat-dancing-gif-12345")
        result = await mockbot.check_for_attachments(message)

        assert "Check out this GIF  [FakeApp_nick posts an animated funny cat dancing gif]" in result


    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    @pytest.mark.vcronly()
    @pytest.mark.default_cassette("test_process_user_task.yaml")
    @pytest.mark.vcr(
        allow_playback_repeats=True,
        match_on=["method", "scheme", "port", "path", "query", "headers"],
        ignore_localhost=False,
    )
    async def test_process_user_task(
        self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture, vcr: VCRRequest
    ) -> None:
        """
        Test the process_user_task method.

        This test verifies that the bot correctly processes a user task and returns the expected output.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.
            vcr (VCRRequest): The VCR request object for recording/replaying HTTP interactions.

        """
        session_id = "test_session"
        user_task = "Tell me a joke"
        result = await mockbot.process_user_task(session_id, user_task)

        assert isinstance(result, str)
        assert "No response generated by the agent." not in result
        # assert "output" in result
        assert vcr.play_count > 0  # type: ignore

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    @pytest.mark.vcronly()
    @pytest.mark.default_cassette("test_process_user_task_streaming.yaml")
    @pytest.mark.vcr(
        allow_playback_repeats=True,
        match_on=["method", "scheme", "port", "path", "query", "headers"],
        ignore_localhost=False,
    )
    async def test_process_user_task_streaming(
        self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture, vcr: VCRRequest
    ):
        session_id = "test_session"
        user_task = "Tell me a story"

        chunks = []
        async for chunk in mockbot.process_user_task_streaming(session_id, user_task):
            chunks.append(chunk)

        assert len(chunks) > 0
        assert all(isinstance(chunk, str) for chunk in chunks)
        assert vcr.play_count > 0  # type: ignore

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_on_message(self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture) -> None:
        """
        Test the on_message event handler.

        This test verifies that the bot correctly logs received messages.

        Args:
        ----
            mockbot (SandboxAgent): The SandboxAgent instance.
            caplog (LogCaptureFixture): Pytest fixture to capture log messages.

        """
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        message = await channel.send("Test message")
        await mockbot.on_message(message)

        # assert "Received message" in caplog.text
        assert "Dispatching event message" in caplog.text

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_dm_send_messages(self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture):
        guild = mockbot.guilds[0]
        member = guild.members[0]
        await member.send("Test DM")

        assert dpytest.verify().message().content("Test DM")



    @pytest.mark.skip(reason="something wrong with make_message")
    @pytest.mark.flaky()
    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_help_command(self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture):
        await dpytest.message(f"{aiosettings.prefix}help")
        assert dpytest.verify().message().contains().content("Here's a list of available commands")

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_bot_mention(self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture):
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        await channel.send(f"<@{mockbot.user.id}> Hello!")
        assert dpytest.verify().message().contains().content("Hello!")

    @pytest.mark.discordonly()
    @pytest.mark.asyncio()
    async def test_write_attachments_to_disk(
        self, mockbot: SandboxAgent, caplog: LogCaptureFixture, capsys: CaptureFixture, tmp_path
    ):
        guild = mockbot.guilds[0]
        channel = guild.text_channels[0]

        file_path = tmp_path / "test_attachment.txt"
        file_path.write_text("Test attachment content")

        file = discord.File(file_path)
        message = await channel.send("Test message with attachment", file=file)

        await mockbot.write_attachments_to_disk(message)

        assert (tmp_path / "test_attachment.txt").exists()

</document_content>
</document>
<document index="2">
<source>/Users/malcolm/dev/bossjones/sandbox_agent/tests/conftest.py</source>
<document_content>
# pylint: disable=no-member
# pylint: disable=no-member
# pylint: disable=possibly-used-before-assignment
# pyright: reportImportCycles=false
# pyright: reportUndefinedVariable=false
# pyright: reportAttributeAccessIssue=false
# pyright: reportInvalidTypeForm=false
# mypy: disable-error-code="index"
# mypy: disable-error-code="no-redef"
"""Global test fixtures definitions."""

from __future__ import annotations

import copy
import datetime
import functools
import glob
import os
import posixpath
import re
import shutil
import sys

from collections.abc import Generator, Iterable, Iterator
from concurrent.futures import Executor, Future
from dataclasses import dataclass
from http import client
from pathlib import Path, PosixPath
from typing import TYPE_CHECKING, Any, Optional, TypeVar, Union

from _pytest.logging import LogCaptureFixture
from _pytest.monkeypatch import MonkeyPatch
from langchain.text_splitter import CharacterTextSplitter
from langchain_community.document_loaders import TextLoader
from langchain_core.documents import Document
from langchain_openai import OpenAIEmbeddings
from langchain_openai.embeddings import OpenAIEmbeddings
from rich.console import Console
from rich.markdown import Markdown
from vcr import filters

import pytest


if TYPE_CHECKING:
    from _pytest.config import Config as PytestConfig
    from _pytest.fixtures import FixtureRequest
    from _pytest.logging import LogCaptureFixture
    from _pytest.monkeypatch import MonkeyPatch
    from vcr.config import VCR
    from vcr.request import Request as VCRRequest

    from pytest_mock.plugin import MockerFixture

INDEX_NAME = "goobaiunittest"

T = TypeVar("T")

YieldFixture = Generator[T, None, None]


IS_RUNNING_ON_GITHUB_ACTIONS = bool(os.environ.get("GITHUB_ACTOR"))

HERE = os.path.abspath(os.path.dirname(__file__))
FAKE_TIME = datetime.datetime(2020, 12, 25, 17, 5, 55)


class IgnoreOrder:
    """
    pytest helper to test equality of lists/tuples ignoring item order.

    E.g., these asserts pass:
    >>> assert [1, 2, 3, 3] == IgnoreOrder([3, 1, 2, 3])
    >>> assert {"foo": [1, 2, 3]} == {"foo": IgnoreOrder([3, 2, 1])}
    """

    def __init__(self, items: Union[list, tuple], key: Optional[Any] = None) -> None:
        self.items = items
        self.key = key

    def __eq__(self, other: Any) -> bool:
        return type(other) == type(self.items) and sorted(other, key=self.key) == sorted(self.items, key=self.key)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.items!r})"


class RegexMatcher:
    """
    pytest helper to check a string against a regex, especially in nested structures, e.g.:

        >>> assert {"foo": "baaaaa"} == {"foo": RegexMatcher("ba+")}
    """

    def __init__(self, pattern: str, flags: int = 0) -> None:
        self.regex = re.compile(pattern=pattern, flags=flags)

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, str) and bool(self.regex.match(other))

    def __repr__(self) -> str:
        return self.regex.pattern


class DictSubSet:
    """
    pytest helper to check if a dictionary contains a subset of items, e.g.:

    >> assert {"foo": "bar", "meh": 4} == DictSubSet({"foo": "bar"})
    """

    __slots__ = ["items", "_missing", "_differing"]

    # TODO rename/alias to `a_dict_with()` to be more self-explanatory

    def __init__(self, items: Union[dict[Any | str, Any], None] = None, **kwargs: Any) -> None:
        self.items = {**(items or {}), **kwargs}
        self._missing: Optional[dict[Any, Any]] = None
        self._differing: Optional[dict[Any, tuple[Any, Any]]] = None

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, type(self.items)):
            return False
        self._missing = {k: v for k, v in self.items.items() if k not in other}
        self._differing = {k: (v, other[k]) for k, v in self.items.items() if k in other and other[k] != v}
        return not (self._missing or self._differing)

    def __repr__(self) -> str:
        msg = repr(self.items)
        if self._missing:
            msg += f"\n    # Missing: {self._missing}"
        if self._differing:
            msg += f"\n    # Differing: {self._differing}"
        return msg


class ListSubSet:
    """
    pytest helper to check if a list contains a subset of items, e.g.:

    >> assert [1, 2, 3, 666] == ListSubSet([1, 666])
    """

    # TODO: also take item counts into account?
    def __init__(self, items: list[Any]) -> None:
        self.items = items

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, type(self.items)) and all(any(y == x for y in other) for x in self.items)

    def __repr__(self) -> str:
        return repr(self.items)


########################################## vcr ##########################################
@dataclass
class TestContext:
    __test__ = False

    data_path: Path
    out_path: Path
    caplog: Optional[LogCaptureFixture]

    def __post_init__(self) -> None:
        if self.caplog:
            self.caplog.set_level("DEBUG" if sys.gettrace() is not None else "WARNING")

    def set_log_level(self, level: str | int) -> None:
        if not self.caplog:
            raise RuntimeError("No caplog")
        self.caplog.set_level(level)


def patch_env(key: str, fake_value: str, monkeypatch: MonkeyPatch) -> None:
    """
    Patch an environment variable if it doesn't exist.

    Args:
        key (str): The environment variable key.
        fake_value (str): The fake value to set if the variable doesn't exist.
        monkeypatch (MonkeyPatch): The pytest monkeypatch fixture.
    """
    if not os.environ.get(key):
        monkeypatch.setenv(key, fake_value)


def is_opensearch_uri(uri: str) -> bool:
    """
    Check if a URI is an OpenSearch URI.

    Args:
        uri (str): The URI to check.

    Returns:
        bool: True if the URI is an OpenSearch URI, False otherwise.
    """
    return any(x in uri for x in ["opensearch", "es.amazonaws.com"])


def is_llm_uri(uri: str) -> bool:
    """
    Check if a URI is an LLM URI.

    Args:
        uri (str): The URI to check.

    Returns:
        bool: True if the URI is an LLM URI, False otherwise.
    """
    return any(x in uri for x in ["openai", "llm-proxy", "anthropic", "localhost", "127.0.0.1"])


def is_chroma_uri(uri: str) -> bool:
    """
    Check if a URI is a Chroma URI.

    Args:
        uri (str): The URI to check.

    Returns:
        bool: True if the URI is a Chroma URI, False otherwise.
    """
    return any(x in uri for x in ["localhost", "127.0.0.1"])


def request_matcher(r1: VCRRequest, r2: VCRRequest) -> bool:
    """
    Custom matcher to determine if the requests are the same.

    - For internal adobe requests, we match the parts of the multipart request. This is needed as we can't compare the body
        directly as the chunk boundary is generated randomly
    - For opensearch requests, we just match the body
    - For openai, allow llm-proxy
    - For others, we match both uri and body

    Args:
        r1 (VCRRequest): The first request.
        r2 (VCRRequest): The second request.

    Returns:
        bool: True if the requests match, False otherwise.
    """

    if r1.uri == r2.uri:
        if r1.body == r2.body:
            return True
    elif is_opensearch_uri(r1.uri) and is_opensearch_uri(r2.uri):
        return r1.body == r2.body
    elif is_llm_uri(r1.uri) and is_llm_uri(r2.uri):
        return r1.body == r2.body
    elif is_chroma_uri(r1.uri) and is_chroma_uri(r2.uri):
        return r1.body == r2.body

    return False


# SOURCE: https://github.com/kiwicom/pytest-recording/tree/master
def pytest_recording_configure(config: PytestConfig, vcr: VCR) -> None:
    """
    Configure VCR for pytest-recording.

    Args:
        config (PytestConfig): The pytest config object.
        vcr (VCR): The VCR object.
    """
    vcr.register_matcher("request_matcher", request_matcher)
    vcr.match_on = ["request_matcher"]


def filter_response(response: VCRRequest) -> VCRRequest:
    """
    Filter the response before recording.

    If the response has a 'retry-after' header, we set it to 0 to avoid waiting for the retry time.

    Args:
        response (VCRRequest): The response to filter.

    Returns:
        VCRRequest: The filtered response.
    """

    if "retry-after" in response["headers"]:
        response["headers"]["retry-after"] = "0"
    if "x-stainless-arch" in response["headers"]:
        response["headers"]["x-stainless-arch"] = "arm64"

    if "apim-request-id" in response["headers"]:
        response["headers"]["apim-request-id"] = ["9a705e27-2f04-4bd6-abd8-01848165ebbf"]

    if "azureml-model-session" in response["headers"]:
        response["headers"]["azureml-model-session"] = ["d089-20240815073451"]

    if "x-ms-client-request-id" in response["headers"]:
        response["headers"]["x-ms-client-request-id"] = ["9a705e27-2f04-4bd6-abd8-01848165ebbf"]

    if "x-ratelimit-remaining-requests" in response["headers"]:
        response["headers"]["x-ratelimit-remaining-requests"] = ["144"]
    if "x-ratelimit-remaining-tokens" in response["headers"]:
        response["headers"]["x-ratelimit-remaining-tokens"] = ["143324"]
    if "x-request-id" in response["headers"]:
        response["headers"]["x-request-id"] = ["143324"]
    if "Set-Cookie" in response["headers"]:
        response["headers"]["Set-Cookie"] = [
            "__cf_bm=fake;path=/; expires=Tue, 15-Oct-24 23:22:45 GMT; domain=.api.openai.com; HttpOnly;Secure; SameSite=None",
            "_cfuvid=fake;path=/; domain=.api.openai.com; HttpOnly; Secure; SameSite=None",
        ]

    return response


def filter_request(request: VCRRequest) -> Optional[VCRRequest]:
    """
    Filter the request before recording.

    If the request is of type multipart/form-data we don't filter anything, else we perform two additional filterings -
    1. Processes the request body text, replacing today's date with a placeholder.This is necessary to ensure
        consistency in recorded VCR requests. Without this modification, requests would contain varying body text
        with older dates, leading to failures in request body text comparison when executed with new dates.
    2. Filter out specific fields from post data fields

    Args:
        request (VCRRequest): The request to filter.

    Returns:
        Optional[VCRRequest]: The filtered request, or None if the request should be ignored.
    """

    # vcr does not handle multipart/form-data correctly as reported on https://github.com/kevin1024/vcrpy/issues/521
    # so let it pass through as is
    if ctype := request.headers.get("Content-Type"):
        ctype = ctype.decode("utf-8") if isinstance(ctype, bytes) else ctype
        if "multipart/form-data" in ctype:
            return request

    request = copy.deepcopy(request)

    if ".tiktoken" in request.path:
        # request to https://openaipublic.blob.core.windows.net/encodings/cl100k_base.tiktoken
        # can be made by ChatLLMInvoker of venice-gentech
        return None

    # filter dates
    if request.body is not None:
        dummy_date_str = "today's date which is DUMMY_DATE"
        request_body_str = request.body.decode("utf-8")
        matches = re.findall(r"today's date which is \d{4}-\d{2}-\d{2}", request_body_str)
        if len(matches) > 0:
            for match in matches:
                request_body_str = request_body_str.replace(match, dummy_date_str)
            request.body = request_body_str.encode("utf-8")

    # filter fields from post
    filter_post_data_parameters = ["api-version", "client_id", "client_secret", "code", "username", "password"]
    replacements = [p if isinstance(p, tuple) else (p, None) for p in filter_post_data_parameters]
    filter_function = functools.partial(filters.replace_post_data_parameters, replacements=replacements)
    request = filter_function(request)

    return request


# SOURCE: https://github.com/kiwicom/pytest-recording/tree/master?tab=readme-ov-file#configuration
# @pytest.fixture(scope="module")
# @pytest.fixture(scope="function")
@pytest.fixture()
def vcr_config() -> dict[str, Any]:
    """
    VCR configuration fixture.

    Returns:
        dict[str, Any]: The VCR configuration.
    """
    return {
        "filter_headers": [
            ("authorization", "DUMMY_AUTHORIZATION"),
            # ("Set-Cookie", "DUMMY_COOKIE"),
            ("x-api-key", "DUMMY_API_KEY"),
            ("api-key", "DUMMY_API_KEY"),
        ],
        "ignore_localhost": False,
        "filter_query_parameters": [
            "api-version",
            "client_id",
            "client_secret",
            "code",
            "api_key",
        ],
        "before_record_request": filter_request,
        "before_record_response": filter_response,
        # !! DO NOT filter post data via a config here, but add it to the filter_data function above !!
        # We don't match requests on 'headers' and 'host' since they vary a lot
        # We tried not matching on 'body' since a POST request - specifically a request to the extract service - appears
        # to have some differences in the body - but that didn't work. Then we didn't get a match at all. So left as is.
        # See https://vcrpy.readthedocs.io/en/latest/configuration.html#request-matching
        # "match_on": ["method", "scheme", "port", "path", "query", "body", "uri"],
        "match_on": ["method", "scheme", "port", "path", "query", "body"],
    }


@pytest.fixture(name="posixpath_fixture")
def posixpath_fixture(monkeypatch: MonkeyPatch) -> None:
    """
    Fixture to monkeypatch os.path to use posixpath.

    This fixture monkeypatches the `os.path` module to use `posixpath` instead of the default `os.path` module.
    It is useful for testing code that relies on POSIX-style paths, regardless of the operating system.

    Args:
    ----
        monkeypatch (MonkeyPatch): The monkeypatch fixture provided by pytest.

    Returns:
    -------
        None

    """
    monkeypatch.setattr(os, "path", posixpath)


@pytest.fixture(name="user_homedir")
def user_homedir() -> str:
    """
    Fixture to get the user's home directory.

    This fixture returns the path to the user's home directory based on the environment.
    It checks if the `GITHUB_ACTOR` environment variable is set, indicating a GitHub Actions environment.
    If `GITHUB_ACTOR` is set, it returns "/Users/runner" as the home directory.
    Otherwise, it returns "/Users/malcolm" as the default home directory.

    Returns:
    -------
        str: The path to the user's home directory.

    """
    return "/Users/runner" if os.environ.get("GITHUB_ACTOR") else "/Users/malcolm"


# # ---------------------------------------------------------------
# # SOURCE: https://github.com/Zorua162/dpystest_minimal/blob/ebbe7f61c741498b8ea8897fc22a11781e4d67bf/conftest.py#L4
# # ---------------------------------------------------------------


def pytest_sessionfinish(session: pytest.Session, exitstatus: int) -> None:
    """
    Code to execute after all tests.

    Args:
    ----
        session (pytest.Session): The pytest session object.
        exitstatus (int): The exit status code.

    Returns:
    -------
        None

    """
    # dat files are created when using attachments
    print("\n-------------------------\nClean dpytest_*.dat files")
    fileList = glob.glob("./dpytest_*.dat")
    for filePath in fileList:
        try:
            os.remove(filePath)
        except Exception:
            print("Error while deleting file : ", filePath)


@pytest.fixture()
def mock_ebook_txt_file(tmp_path: Path) -> Path:
    """
    Fixture to create a mock text file for testing purposes.

    This fixture creates a temporary directory and copies a test text file into it.
    The path to the mock text file is then returned for use in tests.

    Args:
    ----
        tmp_path (Path): The temporary path provided by pytest.

    Returns:
    -------
        Path: A Path object of the path to the mock text file.

    """
    test_ebook_txt_path: Path = (
        tmp_path / "The Project Gutenberg eBook of A Christmas Carol in Prose; Being a Ghost Story of Christmas.txt"
    )
    shutil.copy(
        "src/sandbox_agent/data/chroma/documents/The Project Gutenberg eBook of A Christmas Carol in Prose; Being a Ghost Story of Christmas.txt",
        test_ebook_txt_path,
    )
    return test_ebook_txt_path


@pytest.fixture()
def mock_text_documents(mock_ebook_txt_file: FixtureRequest) -> list[Document]:
    loader = TextLoader(f"{mock_ebook_txt_file}")
    documents = loader.load()
    text_splitter = CharacterTextSplitter(chunk_size=2000, chunk_overlap=0)
    docs = text_splitter.split_documents(documents)

    # Create a unique ID for each document
    # SOURCE: https://github.com/theonemule/azure-rag-sample/blob/1e37de31678ffbbe5361a8ef3acdb770194f462a/import.py#L4
    for idx, doc in enumerate(docs):
        doc.metadata["id"] = str(idx)

    return docs

</document_content>
</document>
<document index="3">
<source>/Users/malcolm/dev/bossjones/sandbox_agent/src/sandbox_agent/bot.py</source>
<document_content>
# pylint: disable=no-member
# pylint: disable=possibly-used-before-assignment
# pyright: reportImportCycles=false
# pyright: reportUnusedFunction=false
# pyright: reportInvalidTypeForm=false
# mypy: disable-error-code="index"
# mypy: disable-error-code="no-redef"

"""Main bot implementation for the sandbox agent."""

from __future__ import annotations

import asyncio
import datetime
import json
import os
import pathlib
import re
import sys
import traceback
import uuid

from collections import Counter, defaultdict
from collections.abc import AsyncIterator, Coroutine, Iterable
from io import BytesIO
from typing import TYPE_CHECKING, Any, Callable, Dict, List, NoReturn, Optional, Tuple, TypeVar, Union, cast

import aiohttp
import bpdb
import discord
import rich

from codetiming import Timer
from discord.ext import commands
from langchain_chroma import Chroma
from langchain_community.vectorstores import FAISS, PGVector
from langchain_community.vectorstores import Redis as RedisVectorStore
from langchain_core.callbacks import AsyncCallbackHandler, BaseCallbackHandler, StdOutCallbackHandler
from langchain_openai import ChatOpenAI, OpenAI, OpenAIEmbeddings
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langgraph.graph.state import CompiledStateGraph
from langsmith import traceable
from logging_tree import printout
from loguru import logger as LOGGER
from PIL import Image
from starlette.responses import JSONResponse

import sandbox_agent

from sandbox_agent import shell, utils
from sandbox_agent.agents.agent_executor import (
    AgentExecutorFactory,
    AsyncLoggingCallbackHandler,
    format_adaptive_rag_input,
    format_user_input,
    format_user_message,
)
from sandbox_agent.ai.evaluators import Evaluator
from sandbox_agent.ai.workflows import WorkflowFactory
from sandbox_agent.aio_settings import aiosettings
from sandbox_agent.bot_logger import REQUEST_ID_CONTEXTVAR
from sandbox_agent.clients.discord import DiscordClient
from sandbox_agent.clients.discord_client.utils import (
    GoobThreadConfig,
    SurfaceInfo,
    SurfaceType,
    attachment_to_dict,
    close_thread,
    details_from_file,
    download_image,
    extensions,
    file_to_local_data_dict,
    get_logger_tree_printout,
    handle_save_attachment_locally,
    preload_guild_data,
)
from sandbox_agent.constants import (
    ACTIVATE_THREAD_PREFX,
    CHANNEL_ID,
    INACTIVATE_THREAD_PREFIX,
    MAX_CHARS_PER_REPLY_MSG,
    MAX_THREAD_MESSAGES,
)
from sandbox_agent.factories import ChatModelFactory, EmbeddingModelFactory, VectorStoreFactory
from sandbox_agent.types import MessageLikeRepresentation
from sandbox_agent.utils import file_functions, file_operations
from sandbox_agent.utils.context import Context
from sandbox_agent.utils.misc import CURRENTFUNCNAME


LOGGER.add(sys.stderr, level="DEBUG")

DESCRIPTION = """An example bot to showcase the discord.ext.commands extension
module.

There are a number of utility commands being showcased here."""

HERE = os.path.dirname(__file__)

INVITE_LINK = "https://discordapp.com/api/oauth2/authorize?client_id={}&scope=bot&permissions=0"

HOME_PATH = os.environ.get("HOME")

COMMAND_RUNNER = {"dl_thumb": shell.run_coroutine_subprocess}
THREAD_DATA = defaultdict()


class ProxyObject(discord.Object):
    def __init__(self, guild: Optional[discord.abc.Snowflake]):
        """
        Initialize a ProxyObject.

        Args:
            guild (Optional[discord.abc.Snowflake]): The guild associated with the object.
        """
        super().__init__(id=0)
        self.guild: Optional[discord.abc.Snowflake] = guild


class SandboxAgent(DiscordClient):
    user: discord.ClientUser
    command_stats: Counter[str]
    socket_stats: Counter[str]
    command_types_used: Counter[bool]
    logging_handler: Any
    bot_app_info: discord.AppInfo
    old_tree_error = Callable[[discord.Interaction, discord.app_commands.AppCommandError], Coroutine[Any, Any, None]]

    chat_model: ChatOpenAI | None
    embedding_model: OpenAIEmbeddings | None
    vector_store: type(Chroma) | type[FAISS] | None
    agent: CompiledStateGraph | None
    graph: CompiledStateGraph | None

    def __init__(self):
        """Initialize the SandboxAgent."""
        super().__init__()
        self.chat_model = ChatModelFactory.create()
        self.embedding_model = EmbeddingModelFactory.create()
        self.vector_store = VectorStoreFactory.create(aiosettings.vector_store_type)
        self.agent = AgentExecutorFactory.create_plan_and_execute_agent()
        self.graph = WorkflowFactory.create()

    async def setup_hook(self) -> None:
        """
        Asynchronous setup hook for initializing the bot.

        This method is called to perform asynchronous setup tasks for the bot.
        It initializes the aiohttp session, sets up guild prefixes, retrieves
        bot application information, and loads extensions.

        It also sets the intents for members and message content to True.

        Raises
        ------
            Exception: If an extension fails to load, an exception is raised with
                        detailed error information.

        """

        # await super().setup_hook()

        self.session = aiohttp.ClientSession()
        self.prefixes: list[str] = [aiosettings.prefix]

        self.version = sandbox_agent.__version__
        self.guild_data: dict[Any, Any] = {}
        self.intents.members = True
        self.intents.message_content = True

        self.bot_app_info: discord.AppInfo = await self.application_info()
        self.owner_id: int = self.bot_app_info.owner.id  # pyright: ignore[reportAttributeAccessIssue]

        for ext in extensions():
            try:
                await self.load_extension(ext)
            except Exception as ex:
                print(f"Failed to load extension {ext} - exception: {ex}")
                exc_type, exc_value, exc_traceback = sys.exc_info()
                LOGGER.error(f"Error Class: {str(ex.__class__)}")
                output = f"[UNEXPECTED] {type(ex).__name__}: {ex}"
                LOGGER.warning(output)
                LOGGER.error(f"exc_type: {exc_type}")
                LOGGER.error(f"exc_value: {exc_value}")
                traceback.print_tb(exc_traceback)
                raise

        await LOGGER.complete()

    @property
    def owner(self) -> discord.User:
        """
        Retrieve the owner of the bot.

        This property returns the owner of the bot as a discord.User object.
        The owner information is retrieved from the bot's application info.

        Returns
        -------
            discord.User: The owner of the bot.

        """
        return self.bot_app_info.owner  # pyright: ignore[reportAttributeAccessIssue]

    def _clear_gateway_data(self) -> None:
        """
        Clear gateway data older than one week.

        This method removes entries from the `identifies` and `resumes` dictionaries
        that are older than one week. It iterates through each shard's list of dates
        and deletes the entries that are older than the specified time frame.

        Returns
        -------
            None

        """
        one_week_ago = discord.utils.utcnow() - datetime.timedelta(days=7)
        for shard_id, dates in self.identifies.items():
            to_remove = [index for index, dt in enumerate(dates) if dt < one_week_ago]
            for index in reversed(to_remove):
                del dates[index]

        for shard_id, dates in self.resumes.items():
            to_remove = [index for index, dt in enumerate(dates) if dt < one_week_ago]
            for index in reversed(to_remove):
                del dates[index]

    async def before_identify_hook(self, shard_id: int, *, initial: bool) -> None:  # type: ignore
        """
        Perform actions before identifying the shard.

        This method is called before the bot identifies the shard with the Discord gateway.
        It clears old gateway data and appends the current timestamp to the identifies list
        for the given shard ID.

        Args:
        ----
            shard_id (int): The ID of the shard that is about to identify.
            initial (bool): Whether this is the initial identification of the shard.

        Returns:
        -------
            None

        """
        self._clear_gateway_data()
        self.identifies[shard_id].append(discord.utils.utcnow())
        await super().before_identify_hook(shard_id, initial=initial)

    async def on_command_error(self, ctx: Context, error: commands.CommandError) -> None:
        """
        Handle errors raised during command invocation.

        This method is called when an error is raised during the invocation of a command.
        It handles different types of command errors and sends appropriate messages to the user.

        Args:
        ----
            ctx (Context): The context in which the command was invoked.
            error (commands.CommandError): The error that was raised during command invocation.

        Returns:
        -------
            None

        """
        if isinstance(error, commands.NoPrivateMessage):
            await ctx.author.send("This command cannot be used in private messages.")
        elif isinstance(error, commands.DisabledCommand):
            await ctx.author.send("Sorry. This command is disabled and cannot be used.")
        elif isinstance(error, commands.CommandInvokeError):
            original = error.original  # pyright: ignore[reportAttributeAccessIssue]
            if not isinstance(original, discord.HTTPException):
                LOGGER.exception("In %s:", ctx.command.qualified_name, exc_info=original)
        elif isinstance(error, commands.ArgumentParsingError):
            await ctx.send(str(error))

        await LOGGER.complete()

    async def query_member_named(
        self, guild: discord.Guild, argument: str, *, cache: bool = False
    ) -> Optional[discord.Member]:
        """
        Query a member by their name, name + discriminator, or nickname.

        This asynchronous function searches for a member in the specified guild
        by their name, name + discriminator (e.g., username#1234), or nickname.
        It can optionally cache the results of the query.

        Args:
        ----
            guild (discord.Guild): The guild to query the member in.
            argument (str): The name, nickname, or name + discriminator combo to check.
            cache (bool): Whether to cache the results of the query. Defaults to False.

        Returns:
        -------
            Optional[discord.Member]: The member matching the query or None if not found.

        """
        if len(argument) > 5 and argument[-5] == "#":
            username, _, discriminator = argument.rpartition("#")
            members = await guild.query_members(username, limit=100, cache=cache)
            return discord.utils.get(members, name=username, discriminator=discriminator)
        else:
            members = await guild.query_members(argument, limit=100, cache=cache)

            return discord.utils.find(lambda m: m.name == argument or m.nick == argument, members)  # pylint: disable=consider-using-in # pyright: ignore[reportAttributeAccessIssue]

    async def get_or_fetch_member(self, guild: discord.Guild, member_id: int) -> Optional[discord.Member]:
        """
        Retrieve a member from the cache or fetch from the API if not found.

        This asynchronous function attempts to retrieve a member from the cache
        in the specified guild using the provided member ID. If the member is not
        found in the cache, it fetches the member from the Discord API. The function
        handles rate limiting and returns the member if found, or None if not found.

        Args:
        ----
            guild (discord.Guild): The guild to look in.
            member_id (int): The member ID to search for.

        Returns:
        -------
            Optional[discord.Member]: The member if found, or None if not found.

        """
        member = guild.get_member(member_id)
        if member is not None:
            return member

        shard: discord.ShardInfo = self.get_shard(guild.shard_id)  # type: ignore  # will never be None
        if shard.is_ws_ratelimited():
            try:
                member = await guild.fetch_member(member_id)
            except discord.HTTPException:
                return None
            else:
                return member

        members = await guild.query_members(limit=1, user_ids=[member_id], cache=True)
        return members[0] if members else None

    async def resolve_member_ids(
        self, guild: discord.Guild, member_ids: Iterable[int]
    ) -> AsyncIterator[discord.Member]:
        """
        Bulk resolve member IDs to member instances, if possible.

        This asynchronous function attempts to resolve a list of member IDs to their corresponding
        member instances within a specified guild. Members that cannot be resolved are discarded
        from the list. The function yields the resolved members lazily using an asynchronous iterator.

        Note:
        ----
            The order of the resolved members is not guaranteed to be the same as the input order.

        Args:
        ----
            guild (discord.Guild): The guild to resolve members from.
            member_ids (Iterable[int]): An iterable of member IDs to resolve.

        Yields:
        ------
            discord.Member: The resolved members.

        """
        needs_resolution = []
        for member_id in member_ids:
            member = guild.get_member(member_id)
            if member is not None:
                yield member
            else:
                needs_resolution.append(member_id)

        total_need_resolution = len(needs_resolution)
        if total_need_resolution == 1:
            shard: discord.ShardInfo = self.get_shard(guild.shard_id)  # type: ignore  # will never be None
            if shard.is_ws_ratelimited():
                try:
                    member = await guild.fetch_member(needs_resolution[0])
                except discord.HTTPException:
                    pass
                else:
                    yield member
            else:
                members = await guild.query_members(limit=1, user_ids=needs_resolution, cache=True)
                if members:
                    yield members[0]
        elif total_need_resolution <= 100:
            # Only a single resolution call needed here
            resolved = await guild.query_members(limit=100, user_ids=needs_resolution, cache=True)
            for member in resolved:
                yield member
        else:
            # We need to chunk these in bits of 100...
            for index in range(0, total_need_resolution, 100):
                to_resolve = needs_resolution[index : index + 100]
                members = await guild.query_members(limit=100, user_ids=to_resolve, cache=True)
                for member in members:
                    yield member

    async def on_ready(self) -> None:
        """
        Handle the event when the bot is ready.

        This method is called when the bot has successfully logged in and has completed
        its initial setup. It logs the bot's user information, sets the bot's presence,
        and prints the invite link. Additionally, it preloads guild data and logs the
        logger tree structure.

        Returns
        -------
            None

        """
        print(f"Logged in as {self.user} (ID: {self.user.id})")
        print("------")
        self.invite = INVITE_LINK.format(self.user.id)
        self.guild_data = await preload_guild_data()
        print(
            f"""Logged in as {self.user}..
            Serving {len(self.users)} users in {len(self.guilds)} guilds
            Invite: {INVITE_LINK.format(self.user.id)}
        """
        )
        await self.change_presence(status=discord.Status.online, activity=discord.Game(aiosettings.bot_name))

        if not hasattr(self, "uptime"):
            self.uptime = discord.utils.utcnow()

        LOGGER.info(f"Ready: {self.user} (ID: {self.user.id})")

        LOGGER.info("LOGGING TREE:")
        await LOGGER.complete()
        await get_logger_tree_printout()

    async def on_shard_resumed(self, shard_id: int) -> None:
        """
        Handle the event when a shard resumes.

        This method is called when a shard successfully resumes its connection
        to the Discord gateway. It logs the shard ID and the timestamp of the
        resume event.

        Args:
        ----
            shard_id (int): The ID of the shard that resumed.

        Returns:
        -------
            None

        """
        await super().on_shard_resumed(shard_id)  # pyright: ignore[reportUnknownMemberType] # type: ignore

        LOGGER.info("Shard ID %s has resumed...", shard_id)
        self.resumes[shard_id].append(discord.utils.utcnow())
        await LOGGER.complete()

    async def check_for_attachments(self, message: discord.Message) -> str:
        """
        Check a Discord message for attachments and process image URLs.

        This asynchronous function examines a Discord message for attachments,
        processes Tenor GIF URLs, downloads and processes image URLs, and modifies
        the message content based on the extracted information.

        Args:
        ----
            message (discord.Message): The Discord message to check for attachments and process.

        Returns:
        -------
            str: The updated message content with extracted information.

        """
        message_content: str = message.content  # type: ignore
        url_pattern = re.compile(r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+")

        if "https://tenor.com/view/" in message_content:
            # Process Tenor GIF URL
            start_index = message_content.index("https://tenor.com/view/")
            end_index = message_content.find(" ", start_index)
            tenor_url = message_content[start_index:] if end_index == -1 else message_content[start_index:end_index]
            words = tenor_url.split("/")[-1].split("-")[:-1]
            sentence = " ".join(words)
            message_content = (
                f"{message_content.replace(tenor_url, '')} [{message.author.display_name} posts an animated {sentence}]"
            )
            return message_content.strip()
        elif url_pattern.search(message_content):
            # Process image URL
            url = url_pattern.search(message_content).group()
            await self.process_image(url)
        elif message.attachments:  # type: ignore
            # Process attached image
            image_url = message.attachments[0].url  # type: ignore
            await self.process_image(image_url)

        await LOGGER.complete()
        return message_content

    def get_attachments(
        self, message: discord.Message
    ) -> tuple[list[dict[str, Any]], list[str], list[dict[str, Any]], list[str]]:
        """
        Retrieve attachment data from a Discord message.

        This function processes the attachments in a Discord message and converts each attachment
        to a dictionary format. It returns a tuple containing lists of dictionaries and file paths
        for further processing.

        Args:
        ----
            message (discord.Message): The Discord message containing attachments.

        Returns:
        -------
            Tuple[List[Dict[str, Any]], List[str], List[Dict[str, Any]], List[str]]:
            A tuple containing:
                - A list of dictionaries with attachment data.
                - A list of local attachment file paths.
                - A list of dictionaries with local attachment data.
                - A list of media file paths.

        """
        attachment_data_list_dicts = []
        local_attachment_file_list = []
        local_attachment_data_list_dicts = []
        media_filepaths = []

        for attm in message.attachments:  # pyright: ignore[reportAttributeAccessIssue]
            data = attachment_to_dict(attm)
            attachment_data_list_dicts.append(data)

        return attachment_data_list_dicts, local_attachment_file_list, local_attachment_data_list_dicts, media_filepaths

    def prepare_agent_input(
        self, message: Union[discord.Message, discord.Thread], user_real_name: str, surface_info: dict
    ) -> dict[str, Any]:
        """
        Prepare the agent input from the incoming Discord message.

        This function constructs the input dictionary to be sent to the agent based on the
        provided Discord message, user's real name, and surface information. It includes
        the message content, user_name, and any attachments if present.

        Args:
        ----
            message (discord.Message): The Discord message containing the user input.
            user_real_name (str): The real name of the user who sent the message.
            surface_info (Dict): The surface information related to the message.

        Returns:
        -------
            Dict[str, Any]: The input dictionary to be sent to the agent.

        """
        # ctx: Context = await self.get_context(message)  # type: ignore
        if isinstance(message, discord.Thread):
            agent_input = {"user_name": user_real_name, "message": message.starter_message.content}  # pyright: ignore[reportAttributeAccessIssue]
            attachments: list[discord.Attachment] = message.starter_message.attachments  # pyright: ignore[reportAttributeAccessIssue]
        elif isinstance(message, discord.Message):
            agent_input = {"user_name": user_real_name, "message": message.content}  # pyright: ignore[reportAttributeAccessIssue]
            attachments: list[discord.Attachment] = message.attachments  # pyright: ignore[reportAttributeAccessIssue]

        if len(attachments) > 0:  # pyright: ignore[reportAttributeAccessIssue]
            for attachment in attachments:  # pyright: ignore[reportAttributeAccessIssue]
                print(f"attachment -> {attachment}")  # pyright: ignore[reportAttributeAccessIssue]
                agent_input["file_name"] = attachment.filename  # pyright: ignore[reportAttributeAccessIssue]
                if attachment.content_type.startswith("image/"):  # pyright: ignore[reportAttributeAccessIssue]
                    agent_input["image_url"] = attachment.url  # pyright: ignore[reportAttributeAccessIssue]

        agent_input["surface_info"] = surface_info

        return agent_input

    def get_thread_id(self, message: Union[discord.Message, discord.Thread]) -> Optional[int]:
        """
        Get the thread ID from a Discord message or thread object.

        Args:
            message (Union[discord.Message, discord.Thread]): The Discord message or thread object.

        Returns:
            Optional[int]: The thread ID, or None if the message is not part of a thread.
        """
        if isinstance(message, discord.Thread):
            LOGGER.info(f"message is a thread, id: {message.id}")
            return message.id
        elif isinstance(message, discord.Message):
            LOGGER.info(f"message is a message, thread id: {message.thread.id if message.thread else None}")  # type: ignore
            return message.thread.id if message.thread else None  # type: ignore
        return None

    def get_session_id(self, message: Union[discord.Message, discord.Thread]) -> str:
        """
        Generate a session ID for the given message.

        This function generates a session ID based on the message context.
        The session ID is used as a key for the history session and as an identifier for logs.

        Args:
        ----
            message (discord.Message): The message or event dictionary.

        Returns:
        -------
            str: The generated session ID.

        Notes:
        -----
            - If the message is a direct message (DM), the session ID is based on the user ID.
            - If the message is from a guild (server) channel, the session ID is based on the channel ID.

        """
        # ctx: Context = await self.get_context(message)  # type: ignore
        if isinstance(message, discord.Thread):
            is_dm: bool = str(message.starter_message.channel.type) == "private"  # pyright: ignore[reportAttributeAccessIssue]
            user_id: int = message.starter_message.author.id  # pyright: ignore[reportAttributeAccessIssue]
            channel_id = message.starter_message.channel.name  # pyright: ignore[reportAttributeAccessIssue]
        elif isinstance(message, discord.Message):
            is_dm: bool = str(message.channel.type) == "private"  # pyright: ignore[reportAttributeAccessIssue]
            user_id: int = message.author.id  # pyright: ignore[reportAttributeAccessIssue]
            channel_id = message.channel.id  # pyright: ignore[reportAttributeAccessIssue]

        return f"discord_{user_id}" if is_dm else f"discord_{channel_id}"  # pyright: ignore[reportAttributeAccessIssue]

    async def handle_dm_from_user(self, message: discord.Message) -> bool:
        """
        Handle a direct message (DM) from a user.

        This asynchronous function processes a direct message (DM) received from a user.
        It prepares the surface information, constructs the agent input, and processes
        the user task using the AI agent. The function sends a temporary message to the
        user indicating that the request is being processed and then sends the agent's
        response in multiple messages if necessary.

        Args:
        ----
            message (discord.Message): The Discord message object representing the direct message.

        Returns:
        -------
            bool: True if the message was successfully processed, False otherwise.

        Example:
        -------
            >>> await bot.handle_dm_from_user(message)

        """
        ctx: Context = await self.get_context(message)
        user_id = ctx.message.author.id  # pyright: ignore[reportAttributeAccessIssue]
        # import bpdb; bpdb.set_trace()
        # Process DMs
        LOGGER.info("Processing direct message")

        # For direct messages, prepare the surface info
        surface_info = SurfaceInfo(surface=SurfaceType.DISCORD, type="direct_message", source="direct_message")

        # Convert surface_info to dictionary using the utility function
        surface_info_dict = surface_info.__dict__

        user_name = message.author.name  # pyright: ignore[reportAttributeAccessIssue]
        agent_input = self.prepare_agent_input(message, user_name, surface_info_dict)
        session_id = self.get_session_id(message)
        thread_id = self.get_thread_id(message)
        LOGGER.info(f"session_id: {session_id} thread_id: {thread_id} Agent input: {json.dumps(agent_input)}")

        temp_message = (
            "Processing your request, please wait... (this could take up to 1min, depending on the response size)"
        )
        # thread_ts is None for direct messages, so we use the ts of the original message
        orig_msg = await ctx.send(
            # embed=discord.Embed(description=temp_message),
            content=temp_message,
            delete_after=30.0,
        )
        # response = client.chat_postMessage(channel=channel_id, thread_ts=thread_ts, text=temp_message)
        # response_ts = response["ts"]
        # For direct messages, remember chat based on the user:

        #          process_user_task: Must write to at least one of ['input', 'plan', 'past_steps', 'response'] | {}Traceback (most recent call last):

        #   File "/Users/malcolm/dev/bossjones/sandbox_agent/.venv/bin/pytest", line 8, in <module>
        #     sys.exit(console_main())
        # #
        agent_response_text = await self.process_user_task(session_id, str(agent_input), thread_id)

        # Update the slack response with the agent response
        # client.chat_update(channel=channel_id, ts=response_ts, text=agent_response_text)

        # Sometimes the response can be over 2000 characters, so we need to split it
        # into multiple messages, and send them one at a time
        text_splitter = RecursiveCharacterTextSplitter(
            separators=["\n", ".", "?", "!"],
            chunk_size=1000,
            chunk_overlap=0,
            length_function=len,
        )

        responses = text_splitter.split_text(agent_response_text)

        for rsp in responses:
            await message.channel.send(rsp)  # pyright: ignore[reportAttributeAccessIssue]

        # await orig_msg.edit(content=agent_response_text)
        LOGGER.info(f"session_id: {session_id} Agent response: {json.dumps(agent_response_text)}")

        evaluator = Evaluator()

        # Evaluate the response against the question
        eval_result = evaluator.evaluate_prediction(agent_input, agent_response_text)
        # Log the evaluation result
        LOGGER.info(f"session_id: {session_id} Evaluation Result: {eval_result}")
        await LOGGER.complete()
        return True

    async def handle_message_from_channel(self, message: Union[discord.Message, discord.Thread]) -> bool:
        LOGGER.debug(f"message -> {message}")
        rich.inspect(message, all=True)
        # ctx: Context = await self.get_context(message)  # type: ignore
        if isinstance(message, discord.Thread):
            user_id = message.starter_message.author.id
            user_name = message.starter_message.author.name
            channel_id = message.starter_message.channel.name  # pyright: ignore[reportAttributeAccessIssue]
            channel = message.starter_message.channel  # pyright: ignore[reportAttributeAccessIssue]
        elif isinstance(message, discord.Message):
            user_id = message.author.id  # pyright: ignore[reportAttributeAccessIssue]
            user_name = message.author.name  # pyright: ignore[reportAttributeAccessIssue]
            channel_id = message.channel.name  # pyright: ignore[reportAttributeAccessIssue]
            channel = message.channel  # pyright: ignore[reportAttributeAccessIssue]

        # import bpdb; bpdb.set_trace()
        # Process DMs
        LOGGER.info("Processing channel message")

        # For direct messages, prepare the surface info
        surface_info = SurfaceInfo(surface=SurfaceType.DISCORD, type="channel", source=f"{channel_id}")  # pyright: ignore[reportAttributeAccessIssue]

        # Convert surface_info to dictionary using the utility function
        surface_info_dict = surface_info.__dict__

        agent_input = self.prepare_agent_input(message, user_name, surface_info_dict)
        session_id = self.get_session_id(message)  # type: ignore
        thread_id = self.get_thread_id(message)
        LOGGER.info(f"session_id: {session_id} Agent input: {json.dumps(agent_input)}")

        agent_response_text = await self.process_user_task(session_id, str(agent_input), thread_id)

        # Sometimes the response can be over 2000 characters, so we need to split it
        # into multiple messages, and send them one at a time
        text_splitter = RecursiveCharacterTextSplitter(
            separators=["\n", ".", "?", "!"],
            chunk_size=1000,
            chunk_overlap=0,
            length_function=len,
        )

        responses = text_splitter.split_text(agent_response_text)

        # send responses to thread
        for rsp in responses:
            await message.send(rsp)  # pyright: ignore[reportAttributeAccessIssue]

        # await orig_msg.edit(content=agent_response_text)
        LOGGER.info(f"session_id: {session_id} Agent response: {json.dumps(agent_response_text)}")

        # Evaluate the response against the question
        eval_result = Evaluator().evaluate_prediction(agent_input, agent_response_text)
        # Log the evaluation result
        LOGGER.info(f"session_id: {session_id} Evaluation Result: {eval_result}")
        await LOGGER.complete()
        return True

    async def get_context(self, origin: Union[discord.Interaction, discord.Message], /, *, cls=Context) -> Context:
        """
        Retrieve the context for a Discord interaction or message.

        This asynchronous method retrieves the context for a Discord interaction or message
        and returns a Context object. It calls the superclass method to get the context
        based on the provided origin and class type.

        Args:
        ----
            origin (Union[discord.Interaction, discord.Message]): The Discord interaction or message to get the context from.
            cls (Context): The class type for the context object.

        Returns:
        -------
            Context: The context object retrieved for the provided origin.

        """
        return await super().get_context(origin, cls=cls)

    async def process_commands(self, message: discord.Message) -> None:
        """
        Process commands based on the received Discord message.

        This asynchronous function processes commands based on the provided Discord message.
        It retrieves the context for the message, logs information, and then invokes the command handling.
        It includes commented-out sections for potential future functionality like spam control and blacklisting.

        Args:
        ----
            message (discord.Message): The Discord message to process commands from.

        Returns:
        -------
            None

        """
        ctx = await self.get_context(message)

        LOGGER.info(f"ctx = {ctx}")

        # its a dm
        if str(message.channel.type) == "private":  # pyright: ignore[reportAttributeAccessIssue]
            await self.handle_dm_from_user(message)

        # text channel and GPT channel id
        elif str(message.channel.type) == "text" and message.channel.id == 1240294186201124929:  # pyright: ignore[reportAttributeAccessIssue]
            max_tokens = 512
            # let's do all validation and creation of threads here instead.
            try:
                # ignore messages not in a thread
                channel: Union[discord.VoiceChannel, discord.TextChannel, discord.Thread, discord.DMChannel] = (
                    message.channel  # pyright: ignore[reportAttributeAccessIssue]
                )  # pyright: ignore[reportAttributeAccessIssue]

                # if no thread defined, create it
                if not isinstance(channel, discord.Thread):
                    LOGGER.error("if no thread defined, create it")
                    embed = discord.Embed(
                        description=f"<@{ctx.message.author.id}> wants to chat! ",  # pyright: ignore[reportAttributeAccessIssue]
                        color=discord.Color.green(),
                    )
                    embed.add_field(name="model", value=aiosettings.chat_model)
                    embed.add_field(name="temperature", value=aiosettings.llm_temperature, inline=True)
                    embed.add_field(name="max_tokens", value=max_tokens, inline=True)
                    embed.add_field(name=ctx.message.author.name, value=message)  # pyright: ignore[reportAttributeAccessIssue]

                    ctx_message: discord.Message = ctx.message  # pyright: ignore[reportAttributeAccessIssue]

                    LOGGER.debug(f"ctx_message = {ctx_message}")
                    rich.inspect(ctx_message, all=True)

                    # create the thread
                    thread: discord.Thread = await ctx_message.create_thread(
                        name=f"{ACTIVATE_THREAD_PREFX} {ctx.message.author.name[:20]} - {message.content[:30]}",  # pyright: ignore[reportAttributeAccessIssue]
                        # Specifies the slowmode rate limit for user in this channel, in seconds. The maximum value possible is ``21600``. By default no slowmode rate limit if this is ``None``.
                        slowmode_delay=1,
                        # The reason for creating a new thread. Shows up on the audit log.
                        reason="gpt-bot",
                        # The duration in minutes before a thread is automatically hidden from the channel list.
                        # If not provided, the channel's default auto archive duration is used.
                        # Must be one of ``60``, ``1440``, ``4320``, or ``10080``, if provided.
                        auto_archive_duration=60,
                    )
                    THREAD_DATA[thread.id] = GoobThreadConfig(
                        model=aiosettings.chat_model, max_tokens=max_tokens, temperature=aiosettings.llm_temperature
                    )
                # if it is a thread, just set channel equal to thread
                elif isinstance(channel, discord.Thread):  # type: ignore
                    LOGGER.error("channel is a thread")
                    thread: discord.Thread = (
                        channel  # mypy: disable-error-code="no-redef" # type: ignore  # type: ignore
                    )

                # ignore threads that are archived locked or title is not what we want
                if (
                    thread.archived  # pyright: ignore[reportAttributeAccessIssue]
                    or thread.locked  # pyright: ignore[reportAttributeAccessIssue]
                    or not thread.name.startswith(ACTIVATE_THREAD_PREFX)  # pyright: ignore[reportAttributeAccessIssue]
                ):
                    # ignore this thread
                    return

                if thread.message_count > MAX_THREAD_MESSAGES:  # pyright: ignore[reportAttributeAccessIssue]
                    # too many messages, no longer going to reply
                    await close_thread(thread=thread)
                    return
                else:
                    # add info to thread
                    await self.handle_message_from_channel(thread)

            except Exception as ex:
                print(f"{ex}")
                exc_type, exc_value, exc_traceback = sys.exc_info()
                print(f"Error Class: {ex.__class__}")
                output = f"[UNEXPECTED] {type(ex).__name__}: {ex}"
                print(output)
                print(f"exc_type: {exc_type}")
                print(f"exc_value: {exc_value}")
                traceback.print_tb(exc_traceback)
                if aiosettings.dev_mode:
                    bpdb.pm()

        # Invokes the command given under the invocation context and
        # handles all the internal event dispatch mechanisms.
        await self.invoke(ctx)
        await LOGGER.complete()

    async def handle_user_task(self, message: discord.Message) -> JSONResponse:
        """
        Handle a user task received through a Discord message.

        This asynchronous function processes a user task received as a Discord message.
        It determines the surface type of the message (DM or channel), creates a SurfaceInfo
        instance, prepares the agent input, and processes the user task using the AI agent.
        It returns a JSON response with the agent's text response or raises an exception if
        processing fails.

        Args:
        ----
            message (discord.Message): The Discord message containing the user task.

        Returns:
        -------
            JSONResponse: A JSON response containing the agent's text response with a status code of 200 if successful.

        Raises:
        ------
            Exception: If an error occurs during the processing of the user task.

        """
        # Optional surface information
        surface = "discord"
        if isinstance(message.channel, discord.DMChannel):  # pyright: ignore[reportAttributeAccessIssue]
            LOGGER.debug("Message is from a DM channel")
            surface_type = "dm"
            source = "dm"
        elif isinstance(message.channel, discord.TextChannel):  # pyright: ignore[reportAttributeAccessIssue]
            LOGGER.debug("Message is from a text channel")
            surface_type = "channel"
            source = message.channel.name  # pyright: ignore[reportAttributeAccessIssue]

        # Convert surface to SurfaceType enum, default to UNKNOWN if not found
        surface_enum = SurfaceType[surface.upper()] if surface else SurfaceType.UNKNOWN

        # Create an instance of SurfaceInfo
        surface_info = SurfaceInfo(surface=surface_enum, type=surface_type, source=source)

        agent_input = {"user_name": message.author, "message": message.content, "surface_info": surface_info.__dict__}  # pyright: ignore[reportAttributeAccessIssue]

        # Modify the call to process_user_task to pass agent_input
        # if not is_streaming:
        session_id = self.get_session_id(message)  # type: ignore
        thread_id = self.get_thread_id(message)
        LOGGER.info(f"session_id: {session_id} thread_id: {thread_id} Agent input: {json.dumps(agent_input)}")
        try:
            # agent_response_text = await self.process_user_task(REQUEST_ID_CONTEXTVAR.get(), str(agent_input))
            agent_response_text = await self.process_user_task(session_id, agent_input, thread_id)
            return JSONResponse(content={"response": agent_response_text}, status_code=200)
        except Exception as ex:
            LOGGER.exception(f"Failed to process user task: {ex}")
            print(f"Failed to load extension {ex} - exception: {ex}")
            exc_type, exc_value, exc_traceback = sys.exc_info()
            LOGGER.error(f"Error Class: {str(ex.__class__)}")
            output = f"[UNEXPECTED] {type(ex).__name__}: {ex}"
            LOGGER.warning(output)
            LOGGER.error(f"exc_type: {exc_type}")
            LOGGER.error(f"exc_value: {exc_value}")
            traceback.print_tb(exc_traceback)
            raise
        finally:
            await LOGGER.complete()

    async def on_message(self, message: discord.Message) -> None:
        """
        Handle incoming messages and process commands.

        This method is called whenever a message is received. It logs the message details,
        processes any attachments, and then processes the message content as a command if applicable.

        Args:
        ----
            message (discord.Message): The message object received from Discord.

        Returns:
        -------
            None

        """
        LOGGER.info(f"message = {message}")
        LOGGER.info("ITS THIS ONE BOSS")

        LOGGER.info(f"You are in function: {CURRENTFUNCNAME()}")
        LOGGER.info(f"This function's caller was: {CURRENTFUNCNAME(1)}")

        # TODO: This is where all the AI logic is going to go
        LOGGER.info(
            f"Thread message to process - function: {CURRENTFUNCNAME()}, function caller: {CURRENTFUNCNAME(1)}, author: {message.author}, content: '{message.content[:50]}'"  # type: ignore
        )  # pyright: ignore[reportAttributeAccessIssue]
        if message.author.bot:
            LOGGER.info(f"Skipping message from bot itself, message.author.bot = {message.author.bot}")
            return

        # skip messages that start w/ cerebro's prefix
        if message.content.startswith("%"):  # pyright: ignore[reportAttributeAccessIssue]
            LOGGER.info("Skipping message that starts with %")
            return

        # Handle attachments first
        await self.process_attachments(message)
        if message.content.strip() != "":  # pyright: ignore[reportAttributeAccessIssue]
            # NOTE: dptest doesn't like this, disable so we can keep tests # async with message.channel.typing():  # pyright: ignore[reportAttributeAccessIssue]
            # Send everything to AI bot
            await self.process_commands(message)
        await LOGGER.complete()

    async def close(self) -> None:
        """
        Close the bot and its associated resources.

        This asynchronous method performs the necessary cleanup operations
        before shutting down the bot. It closes the aiohttp session and
        calls the superclass's close method to ensure proper shutdown.

        Returns
        -------
            None

        """
        await super().close()
        await self.session.close()

    async def start(self) -> None:  # type: ignore
        """
        Start the bot and connect to Discord.

        This asynchronous method initiates the bot's connection to Discord using the token
        specified in the settings. It ensures that the bot attempts to reconnect if the
        connection is lost.

        The method overrides the default `start` method from the `commands.Bot` class to
        include the bot's specific token and reconnection behavior.

        Returns
        -------
            None

        """
        await super().start(aiosettings.discord_token.get_secret_value(), reconnect=True)

    async def my_background_task(self) -> None:
        """
        Run a background task that sends a counter message to a specific channel every 60 seconds.

        This asynchronous method waits until the bot is ready, then continuously increments a counter
        and sends its value to a predefined Discord channel every 60 seconds. The channel ID is retrieved
        from the bot's settings.

        The method ensures that the task runs indefinitely until the bot is closed.

        Args:
        ----
            None

        Returns:
        -------
            None

        """
        await self.wait_until_ready()
        # """
        # Wait until the bot is ready before starting the monitoring loop.
        # """
        counter = 0
        # """
        # Initialize a counter to keep track of the number of monitoring iterations.
        # """
        # TEMPCHANGE: # channel = self.get_channel(DISCORD_GENERAL_CHANNEL)  # channel ID goes here
        channel = self.get_channel(aiosettings.discord_general_channel)  # channel ID goes here
        while not self.is_closed():
            # """
            # Continuously monitor the worker tasks until the bot is closed.
            # """
            counter += 1
            # """
            # Increment the counter for each monitoring iteration.
            # """
            await channel.send(counter)  # pyright: ignore[reportAttributeAccessIssue]  # type: ignore
            await asyncio.sleep(60)  # task runs every 60 seconds

    async def on_worker_monitor(self) -> None:
        """
        Monitor and log the status of worker tasks.

        This asynchronous method waits until the bot is ready, then continuously
        increments a counter and logs the status of worker tasks every 10 seconds.
        It prints the list of tasks and the number of tasks currently being processed.

        The method ensures that the monitoring runs indefinitely until the bot is closed.

        Returns
        -------
            None

        """
        await self.wait_until_ready()
        counter = 0
        # channel = self.get_channel(DISCORD_GENERAL_CHANNEL)  # channel ID goes here
        while not self.is_closed():
            counter += 1
            # await channel.send(counter)
            print(f" self.tasks = {self.tasks}")
            """
            Print the list of current tasks being processed.
            """
            print(f" len(self.tasks) = {len(self.tasks)}")
            """
            Print the number of tasks currently being processed.
            """
            await asyncio.sleep(10)
            """
            Sleep for 10 seconds before the next monitoring iteration.
            """

    # SOURCE: https://github.com/aronweiler/assistant/blob/a8abd34c6973c21bc248f4782f1428a810daf899/src/discord/rag_bot.py#L90
    async def process_attachments(self, message: discord.Message) -> None:
        """
        Process attachments in a Discord message.

        This asynchronous function processes attachments in a Discord message by downloading each attached file,
        storing it in a temporary directory, and then loading and processing the files. It sends a message to indicate
        the start of processing and handles any errors that occur during the download process.

        Args:
        ----
            message (discord.Message): The Discord message containing attachments to be processed.

        Returns:
        -------
            None

        """
        if len(message.attachments) <= 0:  # type: ignore
            return

        root_temp_dir = file_operations.create_temp_directory()
        uploaded_file_paths = []
        for attachment in message.attachments:  # type: ignore
            LOGGER.debug(f"Downloading file from {attachment.url}")
            file_path = os.path.join(root_temp_dir, attachment.filename)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            async with aiohttp.ClientSession() as session:
                async with session.get(attachment.url) as resp:
                    if resp.status != 200:
                        raise aiohttp.ClientException(f"Error downloading file from {attachment.url}")
                    data = await resp.read()

                    with open(file_path, "wb") as f:
                        f.write(data)

            uploaded_file_paths.append(file_path)

    async def process_image(self, url: str) -> None:
        """
        Process an image from a given URL.

        Args:
            url (str): The URL of the image to process.
        """
        response = await file_operations.download_image(url)
        image = Image.open(BytesIO(response.content)).convert("RGB")  # type: ignore
        # Add any additional image processing logic here

    async def write_attachments_to_disk(self, message: discord.Message) -> None:
        """
        Save attachments from a Discord message to disk.

        This asynchronous function processes the attachments in a Discord message,
        saves them to a temporary directory, and logs the file paths. It also handles
        any errors that occur during the download process.

        Args:
        ----
            message (discord.Message): The Discord message containing attachments to be saved.

        Returns:
        -------
            None

        """
        ctx = await self.get_context(message)
        attachment_data_list_dicts, local_attachment_file_list, local_attachment_data_list_dicts, media_filepaths = (
            self.get_attachments(message)
        )

        tmpdirname = await file_operations.aio_create_temp_directory()

        LOGGER.info(f"tmpdirname = {tmpdirname}")

        with Timer(text="\nTotal elapsed time: {:.1f}"):
            for an_attachment_dict in attachment_data_list_dicts:
                local_attachment_path = await file_operations.handle_save_attachment_locally(
                    an_attachment_dict, tmpdirname
                )
                local_attachment_file_list.append(local_attachment_path)

            for some_file in local_attachment_file_list:
                local_data_dict = file_operations.file_to_local_data_dict(some_file, tmpdirname)
                local_attachment_data_list_dicts.append(local_data_dict)
                path_to_image = file_functions.fix_path(local_data_dict["filename"])
                media_filepaths.append(path_to_image)

            try:
                for media_fpaths in media_filepaths:
                    (
                        full_path_input_file,
                        full_path_output_file,
                        get_timestamp,
                    ) = await file_operations.details_from_file(media_fpaths, cwd=f"{tmpdirname}")
            except Exception as ex:
                await ctx.send(embed=discord.Embed(description="Could not download story...."))
                print(ex)
                exc_type, exc_value, exc_traceback = sys.exc_info()
                LOGGER.error(f"Error Class: {str(ex.__class__)}")
                output = f"[UNEXPECTED] {type(ex).__name__}: {ex}"
                LOGGER.warning(output)
                await ctx.send(embed=discord.Embed(description=output))
                LOGGER.error(f"exc_type: {exc_type}")
                LOGGER.error(f"exc_value: {exc_value}")
                traceback.print_tb(exc_traceback)

            tree_list = file_operations.get_file_tree(tmpdirname)
            rich.print("tree_list ->")
            rich.print(tree_list)

            file_to_upload_list = [f"{p}" for p in tree_list]
            LOGGER.debug(f"{type(self).__name__} -> file_to_upload_list = {file_to_upload_list}")
            rich.print(file_to_upload_list)
            await LOGGER.complete()

    @commands.command()
    async def chat(self, ctx: commands.Context, *, message: str) -> None:  # type: ignore
        """
        Implement chat functionality.

        Args:
            ctx (commands.Context): The command context.
            message (str): The message to process.
        """
        response = await self.chat_model.agenerate([message])
        await ctx.send(response.generations[0][0].text)

    # Add more commands as needed

    @traceable
    async def process_user_task(
        self, session_id: str, user_task: str, thread_id: Optional[int] = None
    ) -> dict[str, Any]:
        """
        Summary:
        Process a user task by invoking an agent executor and returning the output.

        Explanation:
        This function processes a user task by setting up an agent executor with the provided session ID, user task, and thread ID. It then invokes the agent executor with the user task input and returns the output generated by the agent. If an error occurs during processing, it logs the exception and returns an error message.

        Args:
        ----
        - self: The instance of the class.
        - session_id (str): The session ID for the user task.
        - user_task (str): The user task to be processed.
        - thread_id (Optional[int]): The ID of the thread associated with the user task. Defaults to None.

        Returns:
        -------
        - str: The output generated by the agent or an error message if processing fails.

        """
        LOGGER.debug(f"session_id = {session_id}")
        LOGGER.debug(f"user_task = {user_task}")
        LOGGER.debug(f"thread_id = {thread_id}")

        try:
            config = {
                "metadata": {
                    "session_id": session_id,
                    "thread_id": thread_id,
                },
                "callbacks": [StdOutCallbackHandler(), AsyncLoggingCallbackHandler()],
            }
            # inputs: Dict[str, str] = {"input": user_task}

            if aiosettings.agent_type == "adaptive_rag":
                inputs = format_adaptive_rag_input(user_task)
            elif aiosettings.agent_type == "basic":
                inputs: MessageLikeRepresentation = format_user_message(user_task)
            result = await self.graph.ainvoke(inputs, config=config, debug=True)
            LOGGER.error(f"type(result) = {type(result)}")
            # bpdb.set_trace()
            if aiosettings.agent_type == "basic" or aiosettings.agent_type == "advanced":
                # example results for basic:
                #                 >>> rich.print(messages)
                # [
                #     HumanMessage(
                #         content='{\'user_name\': \'ghfghf\', \'message\': "<@fghjghf> what\'s the answer to life the universe and everything", \'surface_info\': {\'surface\': \'discord\', \'type\': \'direct_message\', \'source\': \'direct_message\'}}',
                #         additional_kwargs={},
                #         response_metadata={},
                #         id='699975cd-21a3-40f2-a1d2-5991239755a0'
                #     ),
                #     AIMessage(
                #         content='The answer to life, the universe, and everything is 42.\n\nThis is a reference to Douglas Adams\' popular science fiction series "The Hitchhiker\'s Guide to the Galaxy." In the story, a supercomputer named Deep Thought calculates for 7.5 million years to
                # determine that 42 is the answer to the ultimate question of life, the universe, and everything.\n\nOf course, this is meant to be humorous, as 42 doesn\'t actually explain anything meaningful about life or the universe. The joke is that while we may search for profound
                # cosmic truths, sometimes the answers we find are absurd or unsatisfying.\n\nIn reality, questions about the meaning of life and the nature of the universe are complex philosophical and scientific topics that humanity continues to explore and debate.',
                #         additional_kwargs={},
                #         response_metadata={'id': 'msg_01Kgr2CW8Y8dqFeGJy9h9Fne', 'model': 'claude-3-5-sonnet-20240620', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 78, 'output_tokens': 171}},
                #         id='run-dc720191-97f7-4f3f-b2eb-7c4869244426-0',
                #         usage_metadata={'input_tokens': 78, 'output_tokens': 171, 'total_tokens': 249, 'input_token_details': {}}
                #     )
                # ]

                return result.get("messages", "No response generated by the agent.")[1].content
            elif aiosettings.agent_type == "plan_and_execute":
                return result.get("output", "No response generated by the agent.")
            elif aiosettings.agent_type == "adaptive_rag":
                LOGGER.info(f"sklearnnnnnn result = {result}")
                return result.get("generation", "No response generated by the agent.").content
            else:
                raise ValueError(f"Unsupported agent type: {aiosettings.agent_type}")
        except Exception as e:
            LOGGER.exception(f"Error in process_user_task: {e}")
            return "An error occurred while processing the task."

    @traceable
    async def process_user_task_streaming(
        self,
        session_id: str,
        user_task: str,
        thread_id: Optional[int] = None,
    ) -> AsyncIterator[str]:
        """
        Process the user task by streaming the agent's response.

        This method invokes the agent's workflow graph to process the user's task.
        It streams the agent's response, including tool invocations and the final output,
        as an asynchronous iterator of strings.

        Args:
            session_id (str): The ID of the current session.
            user_task (str): The task provided by the user.
            thread_id (Optional[int], optional): The ID of the current thread. Defaults to None.

        Yields:
            str: The next chunk of the agent's response, including tool invocations and the final output.

        Raises:
            Exception: If an error occurs during the processing of the user task.
        """
        try:
            LOGGER.debug(f"session_id = {session_id}")
            LOGGER.debug(f"user_task = {user_task}")
            LOGGER.debug(f"thread_id = {thread_id}")
            # SOURCE: https://langchain-ai.github.io/langgraph/tutorials/customer-support/customer-support/#flights
            # We the can access the RunnableConfig for a given run to check the passenger_id of the user accessing this application. The LLM never has to provide these explicitly, they are provided for a given invocation of the graph so that each user cannot access other passengers' booking information.
            # agent_executor = self.setup_agent_executor(session_id, user_task)
            config = {
                # # @Web @https://api.python.langchain.com/en/latest/runnables/langchain_core.runnables.config.RunnableConfig.html
                # # tags: List of strings to tag this call and any sub-calls (e.g., a Chain calling an LLM)
                # "tags": ["agent"],
                # # metadata: Dictionary of key-value pairs to store metadata for this call and any sub-calls
                # # Metadata for this call and any sub-calls (eg. a Chain calling an LLM). Keys should be strings, values should be JSON-serializable.
                "metadata": {
                    "session_id": session_id,
                    "thread_id": thread_id,
                },
                # # callbacks: List of callbacks to be called for this call and any sub-calls
                # # Callbacks for this call and any sub-calls (eg. a Chain calling an LLM). Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.
                "callbacks": [StdOutCallbackHandler(), AsyncLoggingCallbackHandler()],
                # "callbacks": [
                #     {
                #         "name": "langsmith",
                #         "session_id": session_id,
                #         "thread_id": thread_id,
                #     }
                # ],
                # # run_name: Name for the tracer run for this call, defaults to the name of the class
                # "run_name": "process_user_task",
                # # max_concurrency: Maximum number of parallel calls to make, defaults to ThreadPoolExecutor's default if not provided
                # "max_concurrency": 1,
                # # recursion_limit: Maximum number of times a call can recurse, defaults to 25 if not provided
                # "recursion_limit": 1,
                # # run_id: Unique identifier for the tracer run for this call, a new UUID will be generated if not provided
                # "run_id": session_id,
                # configurable: Runtime values for attributes previously made configurable on this Runnable or sub-Runnables
                # "configurable": {
                #     # The passenger_id is used in our flight tools to fetch the user's flight information
                #     "passenger_id": "3442 587242",
                #     # Checkpoints are accessed by thread_id
                #     "thread_id": thread_id,
                # }
            }
            # inputs = {"input": user_task}
            if aiosettings.agent_type == "adaptive_rag":
                inputs = format_adaptive_rag_input(user_task)
            elif aiosettings.agent_type == "basic":
                inputs: MessageLikeRepresentation = format_user_message(user_task)
            # agent_executor = self.setup_agent_executor(session_id, user_task)
            # Loop through the agent executor stream
            async for chunk in self.graph.astream_log(inputs, config=config):
                # We want to pull any tool invocation and the tokens for the final response
                for op in chunk.ops:
                    # Extract the tool invocation from the agent executor stream
                    if op["op"] == "add" and "/logs/OpenAIToolsAgentOutputParser/final_output" in op["path"]:
                        try:
                            tool_invocations = op["value"]["output"]
                            for tool_invocation in tool_invocations:
                                # Directly access the 'log' attribute of the tool_invocation object
                                if hasattr(tool_invocation, "log"):
                                    LOGGER.info(f"Tool invocation: {tool_invocation.log}")
                                    yield tool_invocation.log

                        except AttributeError as e:
                            LOGGER.exception(f"An error occurred: {e}")
                            continue

                    # Logic to pull agent response from the streaming output
                    # Target paths ending with 'streamed_output_str/-', and check if 'value' is non-empty
                    if op["op"] == "add" and op["path"].endswith("/streamed_output_str/-") and op["value"]:
                        value = op["value"]  # Directly access the value
                        LOGGER.info(f"Chunk: {value}")
                        yield value

        except Exception as e:
            LOGGER.exception(f"Error in process_user_task_streaming: {e}")
            yield "An error occurred while processing the task."
        finally:
            await LOGGER.complete()

</document_content>
</document>
</documents>
