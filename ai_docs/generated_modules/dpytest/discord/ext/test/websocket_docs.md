
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Module Overview:
The provided module is a mock implementation of a `discord.gateway.DiscordWebSocket`. It overrides a Client's default websocket, allowing the hooking of its methods to update the backend and provide callbacks. The module aims to simplify testing and mocking of Discord bot interactions by simulating the behavior of the actual Discord websocket without sending real data to Discord.

Key Features:
- Mock implementation of `DiscordWebSocket`
- Triggers calls to the `dpytest` backend
- Triggers runner callbacks
- Allows testing of presence changes

Dependencies:
- Python 3.x
- discord.py library

Installation and Setup:
1. Ensure you have Python 3.x installed.
2. Install the required dependencies:
   ```
   pip install discord.py
   ```
3. Include the module in your project directory.

Usage Guide:
To use the `FakeWebSocket` class in your tests:

1. Import the necessary modules:
   ```python
   import discord
   from your_module import FakeWebSocket
   ```

2. Create an instance of `FakeWebSocket`:
   ```python
   fake_websocket = FakeWebSocket()
   ```

3. Use the `FakeWebSocket` instance in your tests to simulate Discord websocket interactions.

Example usage:
```python
# Test changing presence
await fake_websocket.change_presence(activity=discord.Game(name="Testing"), status="online")
```

Testing Guide:
Here are some example test cases for the `FakeWebSocket` class:

Test Case 1: Test sending data through the websocket
```python
# test_fake_websocket.py
import pytest
from your_module import FakeWebSocket

@pytest.mark.asyncio
async def test_send_data(mocker):
    # Test setup
    fake_websocket = FakeWebSocket()
    mocker.patch.object(fake_websocket, '_dispatch')

    # Execute test
    data = {'key': 'value'}
    await fake_websocket.send(data)

    # Assertions
    fake_websocket._dispatch.assert_called_once_with('socket_raw_send', data)
```

Test Case 2: Test changing presence
```python
# test_fake_websocket.py
import pytest
import discord
from your_module import FakeWebSocket

@pytest.mark.asyncio
async def test_change_presence(mocker):
    # Test setup
    fake_websocket = FakeWebSocket()
    mocker.patch.object(FakeWebSocket, 'change_presence', wraps=fake_websocket.change_presence)

    # Execute test
    activity = discord.Game(name="Testing")
    status = "online"
    await fake_websocket.change_presence(activity=activity, status=status)

    # Assertions
    assert fake_websocket.cur_event == "presence"
    assert fake_websocket.event_args == (activity, status, 0.0)
    FakeWebSocket.change_presence.assert_called_once_with(activity=activity, status=status, since=0.0)
```

Testing Best Practices:
- Use pytest as the testing framework
- Utilize proper type annotations in tests
- Create reusable fixtures for common test data
- Use appropriate pytest markers (e.g., `@pytest.mark.asyncio`)
- Implement proper mocking strategies using the `mocker` fixture
- Test both success and error cases
- Ensure proper test isolation and cleanup

Common Test Fixtures:
- `mocker`: Pytest fixture for mocking objects and functions

Error Handling and Edge Cases:
- Test scenarios where `cur_event` is None and `send` method is called, expecting a `ValueError`
- Test with invalid or unexpected data types

Integration Testing:
- Test the integration of `FakeWebSocket` with the `dpytest` backend and ensure callbacks are triggered correctly

Debugging and Troubleshooting:
- Use debugging tools like `pdb` or `ipdb` to set breakpoints and inspect variables during test execution
- Utilize logging to track the flow of execution and identify issues

Remember to:
- Include docstrings for all test functions
- Use descriptive and meaningful test case names
- Keep tests focused and granular
- Ensure proper cleanup and teardown after each test
- Maintain test coverage and update tests as the module evolves
