
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation and testing examples for the module:

# ToolNode Module Documentation

## Module Overview
The ToolNode module provides functionality for handling tool execution in LangChain graphs. It processes tool calls from AI messages and manages tool execution with error handling and state management.

Key features:
- Executes tools called by AI agents in parallel
- Handles tool errors gracefully with customizable error handling
- Supports state injection into tools
- Integrates with LangChain's message and state management
- Provides async and sync execution paths

Dependencies:
- langchain-core
- pydantic
- typing-extensions
- asyncio

## Installation & Setup

```bash
pip install langgraph langchain-core pydantic typing-extensions
```

## Usage Guide

### Basic Usage
```python
from langgraph.prebuilt import ToolNode
from langchain_core.tools import Tool

# Define tools
tools = [
    Tool(
        name="calculator",
        func=lambda x: str(eval(x)),
        description="Calculate mathematical expressions"
    )
]

# Create ToolNode
node = ToolNode(
    tools=tools,
    name="math_tools",
    handle_tool_errors=True
)

# Use in graph
state = {
    "messages": [
        AIMessage(
            tool_calls=[{
                "name": "calculator",
                "args": {"x": "2 + 2"},
                "id": "call_1"
            }]
        )
    ]
}

result = node.invoke(state)
```

### Error Handling
```python
# Custom error handler
def handle_error(e: ValueError) -> str:
    return f"Calculator error: {str(e)}"

node = ToolNode(
    tools=tools,
    handle_tool_errors=handle_error
)

# Or specify error types to handle
node = ToolNode(
    tools=tools,
    handle_tool_errors=(ValueError, TypeError)
)
```

### State Injection
```python
from typing_extensions import Annotated
from langgraph.prebuilt import InjectedState

@tool
def stateful_tool(
    x: str,
    state: Annotated[dict, InjectedState()]
) -> str:
    """Tool that can access graph state"""
    return f"State contains: {state}"

node = ToolNode([stateful_tool])
```

## Testing Guide

### Test Fixtures
```python
# test_tool_node.py
from __future__ import annotations

import pytest
from typing import AsyncGenerator, Generator
from pytest_mock import MockerFixture
from langchain_core.messages import AIMessage, ToolMessage

@pytest.fixture
def tools() -> list[Tool]:
    """Fixture providing test tools"""
    return [
        Tool(
            name="echo",
            func=lambda x: x,
            description="Echo input"
        )
    ]

@pytest.fixture
def tool_node(tools: list[Tool]) -> ToolNode:
    """Fixture providing configured ToolNode"""
    return ToolNode(tools=tools)

@pytest.fixture
def test_state() -> dict:
    """Fixture providing test state"""
    return {
        "messages": [
            AIMessage(
                tool_calls=[{
                    "name": "echo",
                    "args": {"x": "test"},
                    "id": "call_1"
                }]
            )
        ]
    }
```

### Basic Functionality Tests
```python
def test_tool_execution(
    tool_node: ToolNode,
    test_state: dict
) -> None:
    """Test basic tool execution"""
    result = tool_node.invoke(test_state)

    assert "messages" in result
    assert len(result["messages"]) == 1
    assert isinstance(result["messages"][0], ToolMessage)
    assert result["messages"][0].content == "test"

@pytest.mark.asyncio
async def test_async_tool_execution(
    tool_node: ToolNode,
    test_state: dict
) -> None:
    """Test async tool execution"""
    result = await tool_node.ainvoke(test_state)

    assert "messages" in result
    assert len(result["messages"]) == 1
```

### Error Handling Tests
```python
def test_error_handling(
    tools: list[Tool],
    test_state: dict
) -> None:
    """Test custom error handling"""
    def error_handler(e: Exception) -> str:
        return "Custom error"

    node = ToolNode(
        tools=tools,
        handle_tool_errors=error_handler
    )

    # Modify state to trigger error
    test_state["messages"][0].tool_calls[0]["name"] = "invalid_tool"

    result = node.invoke(test_state)
    assert result["messages"][0].status == "error"
    assert result["messages"][0].content == "Custom error"
```

### State Injection Tests
```python
def test_state_injection(
    tool_node: ToolNode,
    test_state: dict
) -> None:
    """Test state injection into tools"""
    @tool
    def state_tool(
        x: str,
        state: Annotated[dict, InjectedState()]
    ) -> str:
        return f"Got state: {state}"

    node = ToolNode([state_tool])
    test_state["messages"][0].tool_calls[0]["name"] = "state_tool"

    result = node.invoke(test_state)
    assert "Got state" in result["messages"][0].content
```

### Integration Tests
```python
def test_graph_integration(
    tool_node: ToolNode,
    test_state: dict
) -> None:
    """Test integration with LangChain graph"""
    from langgraph.graph import StateGraph

    graph = (
        StateGraph()
        .add_node("tools", tool_node)
        .set_entry_point("tools")
        .compile()
    )

    result = graph.invoke(test_state)
    assert "messages" in result
```

## Testing Best Practices

1. Use type hints consistently in tests
2. Create reusable fixtures for common test data
3. Test both sync and async execution paths
4. Test error handling thoroughly
5. Include integration tests with graph components
6. Test edge cases and invalid inputs
7. Use proper assertion messages
8. Test state management and injection
9. Mock external dependencies
10. Test performance with larger message histories

## Performance Testing
```python
def test_parallel_execution(
    tool_node: ToolNode,
    benchmark
) -> None:
    """Benchmark parallel tool execution"""
    state = {
        "messages": [
            AIMessage(
                tool_calls=[
                    {"name": "echo", "args": {"x": str(i)}, "id": f"call_{i}"}
                    for i in range(100)
                ]
            )
        ]
    }

    benchmark(tool_node.invoke, state)
```

The above documentation provides a comprehensive guide for using and testing the ToolNode module. Adjust tests and examples based on specific use cases and requirements.

Would you like me to continue with additional sections or testing examples?
