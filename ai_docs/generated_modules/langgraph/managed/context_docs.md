
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for the `Context` module including test examples.

# Context Module Documentation

## Module Overview
The `Context` module provides a managed context system for handling both synchronous and asynchronous context managers in a unified way. It's designed to manage resource lifecycle within a larger application flow, particularly useful in graph-based operations.

Key Features:
- Supports both sync and async context managers
- Type-safe implementation with generics
- Configurable through factory method
- Runtime context management

Dependencies:
- Python 3.7+
- typing_extensions
- langgraph.managed.base
- langgraph.types

## Installation and Setup
```bash
pip install langgraph
```

## Usage Guide

### Basic Usage
```python
from contextlib import contextmanager
from typing import Iterator

# Create a simple context manager
@contextmanager
def sample_context() -> Iterator[str]:
    value = "test_value"
    try:
        yield value
    finally:
        pass

# Configure Context
context = Context.of(ctx=sample_context)
```

### Async Usage
```python
from contextlib import asynccontextmanager
from typing import AsyncIterator

@asynccontextmanager
async def async_sample_context() -> AsyncIterator[str]:
    value = "async_value"
    try:
        yield value
    finally:
        pass

# Configure async Context
async_context = Context.of(actx=async_sample_context)
```

## Testing Guide

### Test Setup

```python
# test_context.py
from __future__ import annotations

import pytest
from contextlib import asynccontextmanager, contextmanager
from typing import AsyncIterator, Iterator

from your_module import Context, LoopProtocol

# Test fixtures
@pytest.fixture
def mock_loop(mocker):
    """Create a mock loop protocol."""
    loop = mocker.Mock(spec=LoopProtocol)
    loop.config = {}
    return loop

@pytest.fixture
def sync_context():
    """Create a test sync context manager."""
    @contextmanager
    def _context() -> Iterator[str]:
        yield "test_value"
    return _context

@pytest.fixture
def async_context():
    """Create a test async context manager."""
    @asynccontextmanager
    async def _context() -> AsyncIterator[str]:
        yield "async_value"
    return _context
```

### Synchronous Tests

```python
def test_context_sync_creation(sync_context):
    """Test synchronous context creation."""
    context = Context.of(ctx=sync_context)
    assert context is not None
    assert context.config["ctx"] == sync_context

def test_context_sync_enter(mock_loop, sync_context):
    """Test synchronous context entry."""
    context = Context.of(ctx=sync_context)

    with context.enter(mock_loop) as ctx:
        assert isinstance(ctx, Context)
        assert ctx() == "test_value"

def test_context_invalid_creation():
    """Test context creation with invalid parameters."""
    with pytest.raises(ValueError, match="Must provide either sync or async context manager"):
        Context.of()
```

### Asynchronous Tests

```python
@pytest.mark.asyncio
async def test_context_async_creation(async_context):
    """Test asynchronous context creation."""
    context = Context.of(actx=async_context)
    assert context is not None
    assert context.config["actx"] == async_context

@pytest.mark.asyncio
async def test_context_async_enter(mock_loop, async_context):
    """Test asynchronous context entry."""
    context = Context.of(actx=async_context)

    async with context.aenter(mock_loop) as ctx:
        assert isinstance(ctx, Context)
        assert ctx() == "async_value"

@pytest.mark.asyncio
async def test_context_async_fallback(mock_loop, sync_context):
    """Test fallback to sync context in async mode."""
    context = Context.of(ctx=sync_context)

    async with context.aenter(mock_loop) as ctx:
        assert isinstance(ctx, Context)
        assert ctx() == "test_value"
```

### Error Case Tests

```python
def test_context_sync_without_manager(mock_loop):
    """Test synchronous context without context manager."""
    context = Context.of(actx=lambda: None)

    with pytest.raises(ValueError, match="Synchronous context manager not found"):
        with context.enter(mock_loop):
            pass

@pytest.mark.asyncio
async def test_context_async_without_manager(mock_loop):
    """Test asynchronous context without context manager."""
    context = Context(mock_loop, ctx=None, actx=None)

    with pytest.raises(ValueError, match="Asynchronous context manager not found"):
        async with context.aenter(mock_loop):
            pass
```

### Integration Tests

```python
class MockResource:
    def __init__(self):
        self.initialized = False
        self.cleaned_up = False

@contextmanager
def resource_context() -> Iterator[MockResource]:
    resource = MockResource()
    resource.initialized = True
    try:
        yield resource
    finally:
        resource.cleaned_up = True

def test_context_resource_lifecycle(mock_loop):
    """Test complete resource lifecycle."""
    context = Context.of(ctx=resource_context)

    with context.enter(mock_loop) as ctx:
        resource = ctx()
        assert resource.initialized
        assert not resource.cleaned_up

    # After context exit
    assert resource.cleaned_up
```

## Testing Best Practices

1. Always test both sync and async paths
2. Include error cases and edge conditions
3. Verify resource cleanup
4. Test configuration parameters
5. Use appropriate pytest markers
6. Implement proper type hints
7. Test with different Python versions

## Common Test Fixtures

```python
@pytest.fixture
def config_context():
    """Context manager that accepts configuration."""
    @contextmanager
    def _context(config: dict) -> Iterator[dict]:
        yield {"config": config}
    return _context

@pytest.fixture
def error_context():
    """Context manager that raises an error."""
    @contextmanager
    def _context() -> Iterator[None]:
        raise ValueError("Intended error")
        yield
    return _context
```

## Error Handling and Edge Cases

```python
def test_context_error_handling(mock_loop, error_context):
    """Test error handling in context manager."""
    context = Context.of(ctx=error_context)

    with pytest.raises(ValueError, match="Intended error"):
        with context.enter(mock_loop):
            pass
```

This documentation provides a comprehensive guide to using and testing the Context module. Remember to adapt the tests based on your specific use cases and requirements.
