
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and test examples for this logging module configuration.

# Logging Configuration Module Documentation

## Module Overview

This module provides a standardized logging configuration for the "langgraph" application. It creates and configures a logger instance that can be used throughout the application for consistent log handling.

### Key Features
- Centralized logging configuration
- Standard logger instance for the "langgraph" application
- Thread-safe logging implementation
- Compatible with Python's built-in logging module

### Dependencies
- Python 3.7+
- Built-in `logging` module

## Installation and Setup

1. No additional installation is required as this uses Python's built-in logging module
2. Import the module in your application:
```python
from your_package.logging_config import logger
```

## Usage Guide

### Basic Usage

```python
# Import the logger
from your_package.logging_config import logger

# Usage examples
logger.debug("Debug message")
logger.info("Information message")
logger.warning("Warning message")
logger.error("Error message")
logger.critical("Critical message")
```

### Configuration Example

```python
import logging

def configure_logger():
    """Configure the logger with custom settings."""
    logger = logging.getLogger("langgraph")

    # Set logging level
    logger.setLevel(logging.INFO)

    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)

    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)

    # Add handler to logger
    logger.addHandler(console_handler)

    return logger
```

## Testing Guide

### Test Cases

Here's a comprehensive test suite for the logging module:

```python
from __future__ import annotations

import logging
import pytest
from typing import Generator
from _pytest.logging import LogCaptureFixture
from pytest_mock import MockerFixture

@pytest.fixture
def mock_logger() -> Generator[logging.Logger, None, None]:
    """Provide a fresh logger instance for each test.

    Returns:
        Generator[logging.Logger, None, None]: Test logger instance
    """
    logger = logging.getLogger("langgraph")
    # Remove any existing handlers
    logger.handlers = []
    yield logger
    # Cleanup
    logger.handlers = []

def test_logger_name(mock_logger: logging.Logger) -> None:
    """Test that logger name is correctly set.

    Args:
        mock_logger: The test logger instance
    """
    assert mock_logger.name == "langgraph"

def test_logger_level(mock_logger: logging.Logger) -> None:
    """Test default logger level.

    Args:
        mock_logger: The test logger instance
    """
    assert mock_logger.level == logging.WARNING  # Default level

def test_log_message_capture(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test log message capture.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    test_message = "Test log message"
    with caplog.at_level(logging.INFO):
        mock_logger.info(test_message)
        assert test_message in caplog.text

def test_multiple_log_levels(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test logging at multiple levels.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    with caplog.at_level(logging.DEBUG):
        mock_logger.debug("Debug message")
        mock_logger.info("Info message")
        mock_logger.warning("Warning message")
        mock_logger.error("Error message")

        assert "Debug message" in caplog.text
        assert "Info message" in caplog.text
        assert "Warning message" in caplog.text
        assert "Error message" in caplog.text

def test_logger_handler_configuration(
    mock_logger: logging.Logger
) -> None:
    """Test logger handler configuration.

    Args:
        mock_logger: The test logger instance
    """
    handler = logging.StreamHandler()
    mock_logger.addHandler(handler)
    assert len(mock_logger.handlers) == 1
    assert isinstance(mock_logger.handlers[0], logging.StreamHandler)

@pytest.mark.asyncio
async def test_async_logging(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test logging in async context.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    async def async_operation():
        mock_logger.info("Async operation log")

    with caplog.at_level(logging.INFO):
        await async_operation()
        assert "Async operation log" in caplog.text

def test_logger_formatting(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test logger formatting configuration.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(levelname)s: %(message)s')
    handler.setFormatter(formatter)
    mock_logger.addHandler(handler)

    with caplog.at_level(logging.INFO):
        mock_logger.info("Test message")
        assert "INFO: Test message" in caplog.text
```

### Common Test Fixtures

```python
@pytest.fixture
def configured_logger() -> Generator[logging.Logger, None, None]:
    """Provide a configured logger instance.

    Returns:
        Generator[logging.Logger, None, None]: Configured logger instance
    """
    logger = logging.getLogger("langgraph")
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    yield logger

    # Cleanup
    logger.handlers = []
```

## Error Handling and Edge Cases

```python
def test_logger_error_handling(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test logger error handling capabilities.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    with caplog.at_level(logging.ERROR):
        try:
            raise ValueError("Test error")
        except ValueError as e:
            mock_logger.error("Error occurred: %s", str(e))

        assert "Error occurred: Test error" in caplog.text

def test_logger_with_empty_message(
    mock_logger: logging.Logger,
    caplog: LogCaptureFixture
) -> None:
    """Test logging empty messages.

    Args:
        mock_logger: The test logger instance
        caplog: Log capture fixture
    """
    with caplog.at_level(logging.INFO):
        mock_logger.info("")
        assert len(caplog.records) == 1
```

## Debugging and Troubleshooting

Common issues and solutions:

1. Multiple handlers causing duplicate logs:
```python
def remove_duplicate_handlers(logger: logging.Logger) -> None:
    """Remove duplicate handlers from logger.

    Args:
        logger: Logger instance to clean
    """
    seen_handlers = set()
    for handler in logger.handlers[:]:
        if handler not in seen_handlers:
            seen_handlers.add(handler)
        else:
            logger.removeHandler(handler)
```

2. Checking logger configuration:
```python
def test_logger_configuration(
    mock_logger: logging.Logger
) -> None:
    """Test logger configuration state.

    Args:
        mock_logger: The test logger instance
    """
    assert not mock_logger.disabled
    assert mock_logger.propagate
    assert isinstance(mock_logger, logging.Logger)
```

Remember to:
- Always clean up logger handlers after tests
- Use appropriate log levels for different types of messages
- Configure logging early in application startup
- Handle thread safety when logging from multiple threads
- Consider using structured logging for complex applications
