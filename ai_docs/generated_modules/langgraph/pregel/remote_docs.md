
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and test examples for the RemoteGraph module. I'll break this down into clear sections.

# RemoteGraph Module Documentation

## Module Overview

The `RemoteGraph` class is a client implementation for interacting with remote LangGraph Server APIs. It provides functionality to:
- Execute remote graph operations
- Stream results from remote graph executions
- Manage graph states and checkpoints
- Handle remote graph interrupts and exceptions

**Key Features:**
- Async and sync client support
- State management and checkpointing
- Stream-based execution
- Error handling and interrupts
- Graph visualization capabilities

**Dependencies:**
- orjson
- langchain_core
- langgraph_sdk
- typing_extensions

## Installation and Setup

```bash
pip install langgraph-sdk langchain-core typing-extensions orjson
```

## Usage Guide

### Basic Initialization

```python
from langgraph.pregel.remote import RemoteGraph

# Initialize with URL
graph = RemoteGraph(
    "graph_name",
    url="https://api.example.com",
    api_key="your_api_key"
)

# Initialize with custom client
from langgraph_sdk.client import LangGraphClient
client = LangGraphClient(base_url="https://api.example.com")
graph = RemoteGraph("graph_name", client=client)
```

### Executing Graph Operations

```python
# Synchronous execution
result = graph.invoke(
    input={"key": "value"},
    config={"configurable": {"thread_id": "123"}}
)

# Asynchronous execution
async def run_graph():
    result = await graph.ainvoke(
        input={"key": "value"},
        config={"configurable": {"thread_id": "123"}}
    )
    return result
```

### Streaming Results

```python
# Stream results synchronously
for chunk in graph.stream(
    input={"key": "value"},
    stream_mode="values"
):
    print(chunk)

# Stream results asynchronously
async for chunk in graph.astream(
    input={"key": "value"},
    stream_mode="values"
):
    print(chunk)
```

## Testing Guide

### Test Setup

```python
# test_remote_graph.py
import pytest
from unittest.mock import Mock, AsyncMock
from langgraph.pregel.remote import RemoteGraph
from langgraph_sdk.client import LangGraphClient, SyncLangGraphClient

@pytest.fixture
def mock_sync_client():
    client = Mock(spec=SyncLangGraphClient)
    client.assistants = Mock()
    client.threads = Mock()
    client.runs = Mock()
    return client

@pytest.fixture
def mock_async_client():
    client = AsyncMock(spec=LangGraphClient)
    client.assistants = AsyncMock()
    client.threads = AsyncMock()
    client.runs = AsyncMock()
    return client

@pytest.fixture
def remote_graph(mock_sync_client, mock_async_client):
    return RemoteGraph(
        "test_graph",
        client=mock_async_client,
        sync_client=mock_sync_client
    )
```

### Basic Function Tests

```python
def test_invoke_basic(remote_graph, mock_sync_client):
    """Test basic synchronous invocation."""
    mock_sync_client.runs.stream.return_value = [
        Mock(event="values", data={"result": "success"})
    ]

    result = remote_graph.invoke(
        input={"test": "data"}
    )

    assert result == {"result": "success"}
    mock_sync_client.runs.stream.assert_called_once()

@pytest.mark.asyncio
async def test_ainvoke_basic(remote_graph, mock_async_client):
    """Test basic asynchronous invocation."""
    mock_async_client.runs.stream.__aiter__.return_value = [
        Mock(event="values", data={"result": "success"})
    ]

    result = await remote_graph.ainvoke(
        input={"test": "data"}
    )

    assert result == {"result": "success"}
    mock_async_client.runs.stream.assert_called_once()
```

### State Management Tests

```python
def test_get_state(remote_graph, mock_sync_client):
    """Test state retrieval."""
    mock_state = {
        "values": {"key": "value"},
        "next": [],
        "tasks": [],
        "metadata": {},
        "created_at": "2023-01-01T00:00:00Z",
        "checkpoint": {
            "thread_id": "123",
            "checkpoint_ns": "test",
            "checkpoint_id": "456"
        },
        "parent_checkpoint": None
    }

    mock_sync_client.threads.get_state.return_value = mock_state

    state = remote_graph.get_state(
        config={"configurable": {"thread_id": "123"}}
    )

    assert state.values == {"key": "value"}
    mock_sync_client.threads.get_state.assert_called_once()
```

### Error Handling Tests

```python
def test_remote_exception(remote_graph, mock_sync_client):
    """Test remote exception handling."""
    mock_sync_client.runs.stream.return_value = [
        Mock(event="error", data="Remote error occurred")
    ]

    with pytest.raises(RemoteException) as exc_info:
        remote_graph.invoke(input={"test": "data"})

    assert str(exc_info.value) == "Remote error occurred"

@pytest.mark.asyncio
async def test_graph_interrupt(remote_graph, mock_async_client):
    """Test graph interrupt handling."""
    mock_async_client.runs.stream.__aiter__.return_value = [
        Mock(event="updates", data={"__interrupt__": "test_interrupt"})
    ]

    with pytest.raises(GraphInterrupt) as exc_info:
        await remote_graph.ainvoke(input={"test": "data"})

    assert str(exc_info.value) == "test_interrupt"
```

### Stream Mode Tests

```python
def test_stream_modes(remote_graph, mock_sync_client):
    """Test different stream modes."""
    mock_sync_client.runs.stream.return_value = [
        Mock(event="values", data={"step": 1}),
        Mock(event="values", data={"step": 2}),
    ]

    results = list(remote_graph.stream(
        input={"test": "data"},
        stream_mode=["values", "updates"]
    ))

    assert len(results) == 2
    assert results[0]["step"] == 1
    assert results[1]["step"] == 2
```

## Best Practices

1. **Error Handling:**
   - Always handle RemoteException and GraphInterrupt
   - Use try/except blocks for network operations

2. **Configuration Management:**
   - Keep sensitive data (API keys) in environment variables
   - Use config objects for consistent settings

3. **Stream Mode Usage:**
   - Use appropriate stream modes for your use case
   - Handle stream interrupts properly

4. **Testing:**
   - Mock external clients
   - Test both success and error cases
   - Include async and sync tests
   - Test different stream modes

This documentation provides a solid foundation for understanding and using the RemoteGraph module. Let me know if you need any clarification or additional examples!
