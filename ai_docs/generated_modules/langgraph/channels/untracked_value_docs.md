
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for the UntrackedValue module.

# UntrackedValue Module Documentation

## Module Overview
The `UntrackedValue` class is a specialized channel implementation that stores the last value received without maintaining checkpoint history. It's designed for scenarios where only the most recent value is relevant, and historical tracking isn't required.

### Key Features
- Generic type support for stored values
- Optional guard mechanism to control multiple value updates
- No checkpoint history maintenance
- Last-value-only storage

### Dependencies
- typing
- typing_extensions
- langgraph.channels.base
- langgraph.errors

## Installation and Setup
```bash
pip install langgraph
```

## Usage Guide

### Basic Usage
```python
from langgraph.channels import UntrackedValue

# Create an UntrackedValue channel for integers
channel = UntrackedValue(int)

# Update with a single value
channel.update([42])
value = channel.get()  # Returns 42

# Update with new value
channel.update([100])
value = channel.get()  # Returns 100
```

### Guard Behavior
```python
# With guard=True (default)
channel = UntrackedValue(str)
channel.update(["value"])  # OK
channel.update(["value1", "value2"])  # Raises InvalidUpdateError

# With guard=False
channel = UntrackedValue(str, guard=False)
channel.update(["value1", "value2"])  # OK, stores "value2"
```

## Testing Guide

```python
# test_untracked_value.py
from typing import Any

import pytest
from langgraph.channels import UntrackedValue
from langgraph.errors import EmptyChannelError, InvalidUpdateError

@pytest.fixture
def int_channel() -> UntrackedValue[int]:
    """Fixture providing an integer UntrackedValue channel."""
    return UntrackedValue(int)

@pytest.fixture
def unguarded_channel() -> UntrackedValue[Any]:
    """Fixture providing an unguarded UntrackedValue channel."""
    return UntrackedValue(str, guard=False)

def test_basic_value_storage(int_channel: UntrackedValue[int]) -> None:
    """Test basic value storage and retrieval."""
    # Test initial state
    with pytest.raises(EmptyChannelError):
        int_channel.get()

    # Test update and retrieval
    assert int_channel.update([42]) is True
    assert int_channel.get() == 42

def test_value_overwrite(int_channel: UntrackedValue[int]) -> None:
    """Test value overwrite behavior."""
    int_channel.update([42])
    int_channel.update([100])
    assert int_channel.get() == 100

def test_guard_behavior() -> None:
    """Test guard behavior with multiple values."""
    guarded_channel = UntrackedValue(str)

    # Single value should work
    assert guarded_channel.update(["value1"]) is True

    # Multiple values should raise error
    with pytest.raises(InvalidUpdateError):
        guarded_channel.update(["value1", "value2"])

def test_unguarded_behavior(unguarded_channel: UntrackedValue[Any]) -> None:
    """Test unguarded behavior with multiple values."""
    values = ["value1", "value2", "value3"]
    assert unguarded_channel.update(values) is True
    assert unguarded_channel.get() == "value3"

def test_empty_update(int_channel: UntrackedValue[int]) -> None:
    """Test update with empty sequence."""
    assert int_channel.update([]) is False

def test_checkpoint_operations(int_channel: UntrackedValue[int]) -> None:
    """Test checkpoint-related operations."""
    # Checkpoint should always raise EmptyChannelError
    with pytest.raises(EmptyChannelError):
        int_channel.checkpoint()

    # from_checkpoint should return empty channel
    new_channel = int_channel.from_checkpoint(None)
    assert isinstance(new_channel, UntrackedValue)
    with pytest.raises(EmptyChannelError):
        new_channel.get()

def test_equality_comparison() -> None:
    """Test equality comparison between channels."""
    channel1 = UntrackedValue(int)
    channel2 = UntrackedValue(int)
    channel3 = UntrackedValue(int, guard=False)

    assert channel1 == channel2
    assert channel1 != channel3
```

## Testing Best Practices

### Type Safety
- Use proper type annotations throughout tests
- Utilize pytest's type checking plugins
- Test with different value types

### Fixture Usage
```python
@pytest.fixture
def typed_channel(request: pytest.FixtureRequest) -> UntrackedValue[Any]:
    """Parameterized fixture for different value types."""
    return UntrackedValue(request.param)

@pytest.mark.parametrize("typed_channel,test_value", [
    (int, 42),
    (str, "test"),
    (float, 3.14)
], indirect=["typed_channel"])
def test_different_types(
    typed_channel: UntrackedValue[Any],
    test_value: Any
) -> None:
    """Test channel with different value types."""
    typed_channel.update([test_value])
    assert typed_channel.get() == test_value
```

### Error Handling Tests
```python
def test_error_conditions(int_channel: UntrackedValue[int]) -> None:
    """Test various error conditions."""
    # Test accessing empty channel
    with pytest.raises(EmptyChannelError):
        int_channel.get()

    # Test invalid update
    with pytest.raises(InvalidUpdateError):
        int_channel.update([1, 2])
```

## Error Handling and Edge Cases
- Empty channel access
- Multiple value updates with guard enabled
- Type mismatches
- Empty update sequences
- Checkpoint operations

## Performance Considerations
- Minimal memory usage (stores only latest value)
- No checkpoint overhead
- Efficient value updates

## Integration Testing Example
```python
from typing import AsyncGenerator
import pytest
from your_workflow import WorkflowManager

@pytest.mark.asyncio
async def test_workflow_integration(
    workflow: WorkflowManager
) -> None:
    """Test UntrackedValue in workflow context."""
    channel = UntrackedValue(str)
    workflow.register_channel("latest_value", channel)

    await workflow.process_step(["test_value"])
    assert channel.get() == "test_value"
```

## Debugging Tips
- Use print statements or logging to track value updates
- Implement debug assertions for guard conditions
- Monitor channel state during workflow execution
- Use pytest's -v flag for verbose test output

This documentation provides a comprehensive guide for using and testing the UntrackedValue channel implementation, covering all major aspects of its functionality and proper usage patterns.
