
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this deprecation utility module.

# Deprecation Utilities Documentation

## Module Overview
This module provides deprecation warning utilities for Python code, offering decorators to mark classes, functions, and parameters as deprecated. It helps maintain backwards compatibility while guiding users to newer alternatives.

Key features:
- Class and function deprecation decorator
- Parameter deprecation decorator
- Custom deprecation warning class
- Markdown-compatible deprecation notices in docstrings

Dependencies:
- Python 3.7+
- Standard library modules: functools, warnings, typing

## Installation and Setup
The module uses only standard library components, so no additional installation is required beyond Python itself.

```python
# Simply import the needed decorators
from your_module import deprecated, deprecated_parameter
```

## Usage Guide

### Basic Function Deprecation
```python
@deprecated(since="1.0.0", alternative="new_function")
def old_function(x: int) -> int:
    return x + 1

# Using the deprecated function will show a warning:
# UserWarning: old_function is deprecated as of version 1.0.0 and will be removed in a future version. Use new_function instead.
```

### Class Deprecation
```python
@deprecated(
    since="1.0.0",
    alternative="NewClass",
    removal="2.0.0",
    example="\nExample: use `NewClass(x)` instead of `OldClass(x)`"
)
class OldClass:
    def __init__(self, value: int) -> None:
        self.value = value
```

### Parameter Deprecation
```python
@deprecated_parameter(
    arg_name="old_param",
    since="1.0.0",
    alternative="new_param",
    removal="2.0.0"
)
def my_function(new_param: str = "", old_param: str = "") -> str:
    return old_param or new_param
```

## Testing Guide

### Test Setup

```python
# test_deprecation.py
from __future__ import annotations

import warnings
from typing import Generator

import pytest

from your_module import (
    LangGraphDeprecationWarning,
    deprecated,
    deprecated_parameter,
)

@pytest.fixture
def warning_catcher() -> Generator[None, None, None]:
    """Fixture to capture deprecation warnings."""
    with warnings.catch_warnings(record=True) as caught_warnings:
        warnings.simplefilter("always", LangGraphDeprecationWarning)
        yield caught_warnings
```

### Function Deprecation Tests

```python
def test_deprecated_function(warning_catcher: Generator[None, None, None]) -> None:
    """Test deprecation warning for functions."""
    @deprecated(since="1.0.0", alternative="new_function")
    def old_function() -> str:
        return "result"

    # Call deprecated function
    result = old_function()

    # Verify warning
    assert len(warnings.warnings) == 1
    warning = warnings.warnings[0]
    assert issubclass(warning.category, LangGraphDeprecationWarning)
    assert "old_function is deprecated as of version 1.0.0" in str(warning.message)
    assert "Use new_function instead" in str(warning.message)

    # Verify function still works
    assert result == "result"

def test_deprecated_function_docstring() -> None:
    """Test deprecation notice in function docstring."""
    @deprecated(since="1.0.0", alternative="new_function")
    def old_function() -> None:
        """Original docstring."""
        pass

    assert "**Deprecated**" in old_function.__doc__
    assert "Original docstring" in old_function.__doc__
```

### Class Deprecation Tests

```python
def test_deprecated_class(warning_catcher: Generator[None, None, None]) -> None:
    """Test deprecation warning for classes."""
    @deprecated(since="1.0.0", alternative="NewClass")
    class OldClass:
        def __init__(self, value: int) -> None:
            self.value = value

    # Instantiate deprecated class
    instance = OldClass(42)

    # Verify warning
    assert len(warnings.warnings) == 1
    warning = warnings.warnings[0]
    assert issubclass(warning.category, LangGraphDeprecationWarning)
    assert "OldClass is deprecated as of version 1.0.0" in str(warning.message)

    # Verify class still works
    assert instance.value == 42

def test_deprecated_class_docstring() -> None:
    """Test deprecation notice in class docstring."""
    @deprecated(since="1.0.0", alternative="NewClass")
    class OldClass:
        """Original class docstring."""
        pass

    assert "**Deprecated**" in OldClass.__doc__
    assert "Original class docstring" in OldClass.__doc__
```

### Parameter Deprecation Tests

```python
def test_deprecated_parameter(warning_catcher: Generator[None, None, None]) -> None:
    """Test deprecation warning for function parameters."""
    @deprecated_parameter(
        arg_name="old_param",
        since="1.0.0",
        alternative="new_param",
        removal="2.0.0"
    )
    def func(new_param: str = "", old_param: str = "") -> str:
        return old_param or new_param

    # Call function with deprecated parameter
    result = func(old_param="test")

    # Verify warning
    assert len(warnings.warnings) == 1
    warning = warnings.warnings[0]
    assert issubclass(warning.category, LangGraphDeprecationWarning)
    assert "Parameter 'old_param' in function 'func' is deprecated" in str(warning.message)

    # Verify function still works
    assert result == "test"

def test_deprecated_parameter_not_used(
    warning_catcher: Generator[None, None, None]
) -> None:
    """Test no warning when deprecated parameter is not used."""
    @deprecated_parameter(
        arg_name="old_param",
        since="1.0.0",
        alternative="new_param",
        removal="2.0.0"
    )
    def func(new_param: str = "", old_param: str = "") -> str:
        return old_param or new_param

    func(new_param="test")
    assert len(warnings.warnings) == 0
```

### Error Case Tests

```python
def test_invalid_deprecated_decorator_usage() -> None:
    """Test that decorator raises TypeError for invalid objects."""
    with pytest.raises(TypeError, match="Can only add deprecation decorator to classes or callables"):
        @deprecated(since="1.0.0", alternative="something")
        class NonCallable:
            x = 1  # Just a variable, not a callable
```

## Testing Best Practices

1. Always use type annotations in tests
2. Create fixtures for common test scenarios
3. Test both success and error cases
4. Verify warning messages and docstring modifications
5. Test with different Python versions
6. Use pytest.mark.parametrize for multiple test cases
7. Test edge cases and invalid inputs
8. Ensure warning stacklevels are correct
9. Test documentation string concatenation
10. Verify deprecated functionality still works as expected

## Common Issues and Solutions

1. Warning not showing:
   - Ensure warnings filter is set to "always"
   - Check warning category matches
   - Verify stacklevel is correct

2. Docstring issues:
   - Ensure original docstring is preserved
   - Check Markdown formatting
   - Verify multi-line docstrings are handled correctly

3. Type checking:
   - Use proper type annotations
   - Handle generic types correctly
   - Test with mypy or similar tools

This documentation provides a comprehensive guide to using and testing the deprecation utilities. The test examples cover all major use cases and include proper error handling and edge cases.
