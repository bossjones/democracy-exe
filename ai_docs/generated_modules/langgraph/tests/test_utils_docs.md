
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation for the module:

# LangGraph Utils Module Documentation

## Module Overview

This module provides utility functions for type checking, async operations, and field handling in the LangGraph framework. It includes tools for:

- Async function detection and handling
- Type checking and annotation processing
- Field default value handling for TypedDict and similar structures
- Enhanced type hint processing for various Python class types

### Key Features
- Async/sync function detection
- Generator function detection
- Optional type checking
- TypedDict field processing
- Enhanced type hint extraction
- Integration with Pydantic and dataclass structures

### Dependencies
- Python 3.8+
- typing_extensions
- pydantic (optional)
- pytest (for testing)
- langsmith
- langchain-core

## Installation and Setup

```bash
pip install langgraph
```

Required dependencies:
```python
langsmith>=0.0.30
typing_extensions>=4.5.0
pytest>=7.0.0  # for testing
```

## Usage Guide

### Async Function Detection

```python
from langgraph.utils.runnable import is_async_callable

# Check if a function is async
async def my_async_func():
    pass

is_async = is_async_callable(my_async_func)  # Returns True
```

### Optional Type Checking

```python
from langgraph.utils.fields import _is_optional_type
from typing import Optional, List

# Check if a type is Optional
result = _is_optional_type(Optional[List[int]])  # Returns True
result = _is_optional_type(List[int])  # Returns False
```

### Enhanced Type Hints

```python
from langgraph.utils.fields import get_enhanced_type_hints
from typing import TypedDict

class MyConfig(TypedDict):
    name: str
    age: int = 30

hints = list(get_enhanced_type_hints(MyConfig))
# Returns: [('name', str, None, None), ('age', int, 30, None)]
```

## Testing Guide

### Basic Function Testing

```python
import pytest
from langgraph.utils.runnable import is_async_callable, is_async_generator

@pytest.mark.anyio
async def test_async_detection():
    """Test async function detection."""
    async def test_func():
        pass

    assert is_async_callable(test_func)

    def sync_func():
        pass

    assert not is_async_callable(sync_func)
```

### Generator Function Testing

```python
@pytest.mark.anyio
async def test_generator_detection():
    """Test async generator detection."""
    async def async_gen():
        yield

    assert is_async_generator(async_gen)

    def sync_gen():
        yield

    assert not is_async_generator(sync_gen)
```

### Type Checking Tests

```python
def test_optional_type_checking():
    """Test optional type detection."""
    from typing import Optional, List, Union

    assert _is_optional_type(Optional[int])
    assert _is_optional_type(Union[str, None])
    assert not _is_optional_type(List[int])
    assert _is_optional_type(Optional[List[int]])
```

### TypedDict Field Testing

```python
def test_typed_dict_fields():
    """Test TypedDict field handling."""
    from typing import TypedDict, Required, NotRequired

    class TestDict(TypedDict):
        required_field: Required[str]
        optional_field: NotRequired[int]

    annos = TestDict.__annotations__
    assert get_field_default("required_field", annos["required_field"], TestDict) == ...
    assert get_field_default("optional_field", annos["optional_field"], TestDict) is None
```

## Testing Best Practices

1. Use Fixtures for Common Setup
```python
@pytest.fixture
def sample_typed_dict():
    class TestDict(TypedDict):
        field1: str
        field2: int = 42
    return TestDict

def test_with_fixture(sample_typed_dict):
    hints = list(get_enhanced_type_hints(sample_typed_dict))
    assert len(hints) == 2
```

2. Test Edge Cases
```python
def test_edge_cases():
    """Test edge cases for type checking."""
    assert _is_optional_type(None)
    assert not _is_optional_type(type(None))
    assert _is_optional_type(Optional[Any])
```

3. Integration Testing
```python
@pytest.mark.integration
def test_pydantic_integration():
    """Test integration with Pydantic models."""
    from pydantic import BaseModel, Field

    class TestModel(BaseModel):
        field: str = Field(description="Test field")

    hints = list(get_enhanced_type_hints(TestModel))
    assert hints[0][3] == "Test field"  # Check description
```

## Error Handling and Edge Cases

```python
def test_error_handling():
    """Test error handling for invalid types."""
    with pytest.raises(TypeError):
        _is_optional_type(42)  # Invalid type

    with pytest.raises(AttributeError):
        get_enhanced_type_hints(None)
```

## Performance Testing

```python
@pytest.mark.benchmark
def test_type_checking_performance(benchmark):
    """Test performance of type checking."""
    def check_type():
        return _is_optional_type(Optional[List[Dict[str, Any]]])

    result = benchmark(check_type)
    assert result is True
```

## Debugging and Troubleshooting

```python
import logging

def test_with_logging(caplog):
    """Test with logging enabled."""
    caplog.set_level(logging.DEBUG)

    # Your test code here

    assert "Expected debug message" in caplog.text
```

Remember to:
- Add proper type hints to all test functions
- Use appropriate pytest markers
- Include docstrings for all test functions
- Test both success and failure cases
- Handle cleanup properly
- Maintain test isolation

This documentation provides a comprehensive guide to using and testing the module's functionality. Adjust the examples and tests based on your specific needs and use cases.
