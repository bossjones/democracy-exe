
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module, which appears to be testing a RunnableCallable implementation.

# RunnableCallable Test Module Documentation

## Module Overview

This module provides testing for the `RunnableCallable` class, which wraps both synchronous and asynchronous callable functions with optional dependencies on `BaseStore` and `StreamWriter`. The module verifies proper function signature detection and execution behavior.

### Key Features
- Tests function signature detection for store and writer dependencies
- Validates both synchronous and asynchronous function execution
- Ensures proper type handling and return values
- Supports mixed synchronous/asynchronous contexts

### Dependencies
- pytest
- anyio (for async testing)
- langgraph.store.base
- langgraph.types
- langgraph.utils.runnable

## Installation & Setup

```bash
pip install pytest pytest-asyncio anyio langgraph
```

## Usage Guide

The module tests two main aspects of `RunnableCallable`:

1. Function signature detection:
```python
from langgraph.utils.runnable import RunnableCallable

# Create a basic synchronous callable
def sync_func(x: Any) -> str:
    return f"{x}"

runnable = RunnableCallable(sync_func)
result = runnable.invoke("test")  # Returns "test"
```

2. Async function handling:
```python
async def async_func(x: Any) -> str:
    return f"{x}"

runnable = RunnableCallable(func=None, afunc=async_func)
result = await runnable.ainvoke("test")  # Returns "test"
```

## Testing Guide

### 1. Function Signature Detection Tests

```python
# test_runnable_callable.py

import pytest
from langgraph.store.base import BaseStore
from langgraph.types import StreamWriter
from langgraph.utils.runnable import RunnableCallable

pytestmark = pytest.mark.anyio

@pytest.fixture
def store_deps() -> dict[str, bool]:
    """Fixture providing expected store dependency flags."""
    return {
        "with_store": True,
        "awith_store": True,
        "sync": False,
        "async": False,
        "with_writer": False,
        "awith_writer": False,
    }

@pytest.fixture
def writer_deps() -> dict[str, bool]:
    """Fixture providing expected writer dependency flags."""
    return {
        "with_writer": True,
        "awith_writer": True,
        "sync": False,
        "async": False,
        "with_store": False,
        "awith_store": False,
    }

def test_runnable_callable_func_accepts(
    store_deps: dict[str, bool],
    writer_deps: dict[str, bool]
) -> None:
    """Test function signature detection for various callable types.

    Args:
        store_deps: Expected store dependency flags
        writer_deps: Expected writer dependency flags
    """
    def sync_func(x: Any) -> str:
        return f"{x}"

    async def async_func(x: Any) -> str:
        return f"{x}"

    def func_with_store(x: Any, store: BaseStore) -> str:
        return f"{x}"

    # Create test cases
    runnables = {
        "sync": RunnableCallable(sync_func),
        "async": RunnableCallable(func=None, afunc=async_func),
        "with_store": RunnableCallable(func_with_store),
    }

    # Verify dependencies
    for name, runnable in runnables.items():
        assert runnable.func_accepts["store"] == store_deps[name]
        assert runnable.func_accepts["writer"] == writer_deps[name]
```

### 2. Basic Execution Tests

```python
@pytest.mark.asyncio
async def test_runnable_callable_basic() -> None:
    """Test basic synchronous and asynchronous execution."""

    # Test data
    test_input = "test"
    expected_output = "test"

    # Test synchronous execution
    def sync_func(x: Any) -> str:
        return f"{x}"

    runnable_sync = RunnableCallable(sync_func)
    result_sync = runnable_sync.invoke(test_input)
    assert result_sync == expected_output

    # Test asynchronous execution
    async def async_func(x: Any) -> str:
        return f"{x}"

    runnable_async = RunnableCallable(func=None, afunc=async_func)
    result_async = await runnable_async.ainvoke(test_input)
    assert result_async == expected_output
```

### 3. Error Case Tests

```python
def test_runnable_callable_invalid_setup() -> None:
    """Test error cases for invalid RunnableCallable setup."""

    with pytest.raises(ValueError, match="Either func or afunc must be provided"):
        RunnableCallable(func=None, afunc=None)

    with pytest.raises(ValueError, match="Cannot provide both func and afunc"):
        def sync_func(x: Any) -> str:
            return x
        async def async_func(x: Any) -> str:
            return x
        RunnableCallable(func=sync_func, afunc=async_func)
```

### Testing Best Practices

1. Use Type Annotations:
```python
from typing import Any, Callable, Awaitable

def test_typed_functions() -> None:
    func: Callable[[Any], str] = lambda x: str(x)
    afunc: Callable[[Any], Awaitable[str]] = async_func
```

2. Test Isolation:
```python
@pytest.fixture(autouse=True)
def setup_teardown() -> Generator[None, None, None]:
    # Setup
    yield
    # Teardown
```

3. Parameterized Tests:
```python
@pytest.mark.parametrize("input_val,expected", [
    ("test", "test"),
    (123, "123"),
    (None, "None"),
])
def test_runnable_callable_various_inputs(
    input_val: Any,
    expected: str
) -> None:
    def sync_func(x: Any) -> str:
        return f"{x}"
    runnable = RunnableCallable(sync_func)
    assert runnable.invoke(input_val) == expected
```

### Error Handling and Edge Cases

```python
def test_runnable_callable_error_handling() -> None:
    """Test error handling in RunnableCallable."""

    def failing_func(x: Any) -> str:
        raise ValueError("Test error")

    runnable = RunnableCallable(failing_func)

    with pytest.raises(ValueError, match="Test error"):
        runnable.invoke("test")
```

## Debugging Tips

1. Enable pytest verbose output:
```bash
pytest -vv test_runnable_callable.py
```

2. Use logging for debugging:
```python
import logging

def test_with_logging(caplog: LogCaptureFixture) -> None:
    caplog.set_level(logging.DEBUG)
    # Run test
    assert "Debug message" in caplog.text
```

3. Use pytest-asyncio debug mode:
```python
@pytest.mark.asyncio(debug=True)
async def test_async_debug() -> None:
    # Test async functionality
```

Remember to:
- Always test both success and failure cases
- Verify type hints and signatures
- Test with various input types
- Include proper cleanup in fixtures
- Document all test cases clearly
- Use appropriate async/sync contexts
