
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module, which appears to be a collection of flexible comparison classes.

# Flexible Comparison Types Module Documentation

## Module Overview
This module provides a collection of utility classes for flexible comparison operations in Python. It's designed to enable more forgiving and pattern-based comparisons than Python's standard strict equality checks.

Key features:
- Float range comparison (`FloatBetween`)
- String pattern matching (`AnyStr`)
- Flexible dictionary comparison (`AnyDict`)
- Version-agnostic comparison (`AnyVersion`)
- Unordered sequence comparison (`UnsortedSequence`)

Dependencies:
- Python 3.7+
- typing_extensions

## Installation and Setup
```bash
pip install typing-extensions
```

## Usage Guide

### FloatBetween
Allows comparison of float values within a specified range.

```python
from flexible_types import FloatBetween

# Create a float range between 1.0 and 2.0
float_range = FloatBetween(1.0, 2.0)

# Compare values
assert float_range == 1.5  # True
assert float_range == 0.5  # False
assert float_range == 2.5  # False
```

### AnyStr
Enables string comparison based on prefixes or regex patterns.

```python
from flexible_types import AnyStr
import re

# Prefix matching
prefix_matcher = AnyStr("test")
assert prefix_matcher == "test123"  # True
assert prefix_matcher == "abc123"   # False

# Regex matching
pattern_matcher = AnyStr(re.compile(r"^\d{3}"))
assert pattern_matcher == "123abc"  # True
assert pattern_matcher == "abc123"  # False
```

### AnyDict
Provides flexible dictionary comparison with support for pattern matching keys and values.

```python
from flexible_types import AnyDict, AnyStr

# Create a flexible dictionary
flexible_dict = AnyDict({
    AnyStr("user"): "john",
    "age": FloatBetween(20, 30)
})

# Compare with actual data
assert flexible_dict == {
    "user_id": "john",
    "age": 25
}  # True
```

### AnyVersion
Allows comparison with any version-like value.

```python
from flexible_types import AnyVersion

version_matcher = AnyVersion()
assert version_matcher == "1.0.0"  # True
assert version_matcher == 1        # True
assert version_matcher == 1.0      # True
```

### UnsortedSequence
Enables comparison of sequences ignoring order.

```python
from flexible_types import UnsortedSequence

sequence = UnsortedSequence(1, 2, 3)
assert sequence == [3, 1, 2]  # True
assert sequence == [1, 2, 3]  # True
assert sequence == [1, 2, 4]  # False
```

## Testing Guide

```python
# test_flexible_types.py
from __future__ import annotations

import re
import pytest
from typing import Any

from flexible_types import (
    FloatBetween,
    AnyStr,
    AnyDict,
    AnyVersion,
    UnsortedSequence
)

class TestFloatBetween:
    @pytest.fixture
    def float_range(self) -> FloatBetween:
        return FloatBetween(1.0, 2.0)

    def test_valid_comparison(self, float_range: FloatBetween) -> None:
        assert float_range == 1.5
        assert not (float_range == 0.5)
        assert not (float_range == 2.5)

    def test_hash(self, float_range: FloatBetween) -> None:
        assert hash(float_range) == hash((float(1.0), 1.0, 2.0))

class TestAnyStr:
    @pytest.fixture
    def prefix_matcher(self) -> AnyStr:
        return AnyStr("test")

    @pytest.fixture
    def pattern_matcher(self) -> AnyStr:
        return AnyStr(re.compile(r"^\d{3}"))

    def test_prefix_matching(self, prefix_matcher: AnyStr) -> None:
        assert prefix_matcher == "test123"
        assert not (prefix_matcher == "abc123")

    def test_pattern_matching(self, pattern_matcher: AnyStr) -> None:
        assert pattern_matcher == "123abc"
        assert not (pattern_matcher == "abc123")

class TestAnyDict:
    @pytest.fixture
    def flexible_dict(self) -> AnyDict:
        return AnyDict({
            AnyStr("user"): "john",
            "age": FloatBetween(20, 30)
        })

    def test_dict_matching(self, flexible_dict: AnyDict) -> None:
        assert flexible_dict == {
            "user_id": "john",
            "age": 25
        }
        assert not (flexible_dict == {
            "user_id": "jane",
            "age": 25
        })

class TestAnyVersion:
    @pytest.fixture
    def version_matcher(self) -> AnyVersion:
        return AnyVersion()

    def test_version_matching(self, version_matcher: AnyVersion) -> None:
        assert version_matcher == "1.0.0"
        assert version_matcher == 1
        assert version_matcher == 1.0

class TestUnsortedSequence:
    @pytest.fixture
    def sequence(self) -> UnsortedSequence:
        return UnsortedSequence(1, 2, 3)

    def test_sequence_matching(self, sequence: UnsortedSequence) -> None:
        assert sequence == [3, 1, 2]
        assert sequence == [1, 2, 3]
        assert not (sequence == [1, 2, 4])
```

## Testing Best Practices

1. Test each class independently
2. Cover edge cases:
   - Empty strings for AnyStr
   - Boundary values for FloatBetween
   - Empty dictionaries for AnyDict
   - Empty sequences for UnsortedSequence
3. Test type validation
4. Verify hash consistency
5. Test with invalid inputs

## Error Handling and Edge Cases

```python
def test_float_between_edge_cases() -> None:
    with pytest.raises(ValueError):
        FloatBetween(2.0, 1.0)  # min > max

def test_any_str_edge_cases() -> None:
    empty_prefix = AnyStr("")
    assert empty_prefix == ""
    assert empty_prefix == "any string"

def test_any_dict_empty() -> None:
    empty_dict = AnyDict()
    assert empty_dict == {}
    assert not (empty_dict == {"key": "value"})

def test_unsorted_sequence_empty() -> None:
    empty_seq = UnsortedSequence()
    assert empty_seq == []
    assert empty_seq == tuple()
```

## Performance Considerations

1. Hash operations are optimized for dictionary usage
2. Pattern matching in AnyStr uses compiled regex when possible
3. UnsortedSequence uses set operations internally for efficiency

These classes are designed for testing and validation scenarios rather than high-performance computing applications.
