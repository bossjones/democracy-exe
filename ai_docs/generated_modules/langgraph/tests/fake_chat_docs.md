
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for the FakeChatModel module.

# FakeChatModel Documentation

## Module Overview

The `FakeChatModel` is a mock chat model implementation that simulates chat interactions for testing purposes. It inherits from `GenericFakeChatModel` and provides synchronous and asynchronous streaming capabilities.

Key Features:
- Simulated chat responses using predefined messages
- Support for both streaming and non-streaming outputs
- Async and sync implementations
- Tool binding support
- Callback management integration

Dependencies:
- langchain_core.callbacks
- langchain_core.language_models
- langchain_core.messages
- langchain_core.outputs

## Installation and Setup

```bash
pip install langchain-core
```

## Usage Guide

### Basic Usage

```python
from langchain_core.messages import AIMessage
from your_module import FakeChatModel

# Initialize with predefined responses
fake_model = FakeChatModel(
    messages=[
        AIMessage(content="Hello!"),
        AIMessage(content="How can I help?")
    ]
)

# Generate response
result = fake_model.invoke(["User message"])
print(result.content)  # Prints "Hello!"
```

### Streaming Usage

```python
# Synchronous streaming
for chunk in fake_model.stream("Your message"):
    print(chunk.content, end="")

# Async streaming
async for chunk in fake_model.astream("Your message"):
    print(chunk.content, end="")
```

## Testing Guide

### Test Cases

```python
from __future__ import annotations

import pytest
from typing import AsyncIterator, Iterator, List
from langchain_core.messages import AIMessage, BaseMessage
from langchain_core.outputs import ChatGenerationChunk

@pytest.fixture
def fake_chat_model() -> FakeChatModel:
    """Create a FakeChatModel instance with predefined messages."""
    return FakeChatModel(
        messages=[
            AIMessage(content="Hello"),
            AIMessage(content="World")
        ]
    )

def test_basic_generation(fake_chat_model: FakeChatModel):
    """Test basic message generation."""
    messages: List[BaseMessage] = []
    result = fake_chat_model._generate(messages)

    assert len(result.generations) == 1
    assert result.generations[0].message.content == "Hello"

def test_message_rotation(fake_chat_model: FakeChatModel):
    """Test that messages rotate correctly."""
    messages: List[BaseMessage] = []

    # First generation
    result1 = fake_chat_model._generate(messages)
    assert result1.generations[0].message.content == "Hello"

    # Second generation
    result2 = fake_chat_model._generate(messages)
    assert result2.generations[0].message.content == "World"

    # Third generation (should rotate back to first)
    result3 = fake_chat_model._generate(messages)
    assert result3.generations[0].message.content == "Hello"

@pytest.mark.asyncio
async def test_astream(
    fake_chat_model: FakeChatModel
) -> None:
    """Test async streaming functionality."""
    messages: List[BaseMessage] = []
    chunks: List[str] = []

    async for chunk in fake_chat_model._astream(messages):
        assert isinstance(chunk, ChatGenerationChunk)
        chunks.append(chunk.message.content)

    assert "".join(chunks) == "Hello"

def test_stream(fake_chat_model: FakeChatModel):
    """Test synchronous streaming functionality."""
    messages: List[BaseMessage] = []
    chunks: List[str] = []

    for chunk in fake_chat_model._stream(messages):
        assert isinstance(chunk, ChatGenerationChunk)
        chunks.append(chunk.message.content)

    assert "".join(chunks) == "Hello"

@pytest.mark.asyncio
async def test_error_handling(fake_chat_model: FakeChatModel):
    """Test error handling for invalid message types."""
    messages: List[BaseMessage] = []
    fake_chat_model.messages = ["invalid"]  # type: ignore

    with pytest.raises(ValueError):
        async for _ in fake_chat_model._astream(messages):
            pass
```

### Test Fixtures

```python
@pytest.fixture
def mock_callback_manager(mocker):
    """Create a mock callback manager for testing."""
    return mocker.Mock(spec=CallbackManagerForLLMRun)

@pytest.fixture
def mock_async_callback_manager(mocker):
    """Create a mock async callback manager for testing."""
    return mocker.Mock(spec=AsyncCallbackManagerForLLMRun)
```

## Error Handling and Edge Cases

```python
def test_empty_content(fake_chat_model: FakeChatModel):
    """Test handling of empty content."""
    fake_chat_model.messages = [AIMessage(content="")]
    messages: List[BaseMessage] = []

    chunks = list(fake_chat_model._stream(messages))
    assert len(chunks) == 1
    assert chunks[0].message.content == ""

def test_invalid_message_type(fake_chat_model: FakeChatModel):
    """Test handling of invalid message types."""
    messages: List[BaseMessage] = []
    fake_chat_model.messages = [{"content": "invalid"}]  # type: ignore

    with pytest.raises(ValueError):
        fake_chat_model._generate(messages)
```

## Performance Testing

```python
import time

def test_streaming_performance(fake_chat_model: FakeChatModel):
    """Test streaming performance."""
    messages: List[BaseMessage] = []
    start_time = time.time()

    chunk_count = 0
    for _ in fake_chat_model._stream(messages):
        chunk_count += 1

    duration = time.time() - start_time
    assert duration < 1.0  # Should complete within 1 second
    assert chunk_count > 0
```

## Integration Testing

```python
def test_tool_binding():
    """Test tool binding functionality."""
    model = FakeChatModel(messages=[AIMessage(content="Test")])
    tools = [{"name": "test_tool", "function": lambda x: x}]

    bound_model = model.bind_tools(tools)
    assert bound_model == model  # Should return self
```

## Debugging and Troubleshooting

Common issues and solutions:

1. Message Rotation Issues:
   - Reset `i` counter: `model.i = 0`
   - Verify message list length

2. Streaming Issues:
   - Check content type is str
   - Verify callback manager implementation

3. Memory Management:
   - Clear message list: `model.messages = []`
   - Reset state between tests

## Best Practices

1. Always use type hints
2. Implement proper cleanup in tests
3. Use appropriate pytest markers
4. Mock external dependencies
5. Test both success and failure cases
6. Use fixtures for common setup
7. Include async and sync tests
8. Test streaming functionality thoroughly

This documentation provides a comprehensive guide for using and testing the FakeChatModel class. Adjust the examples and tests according to your specific use cases and requirements.
