
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and test examples for this module.

# AnyStr Messages Module Documentation

## Module Overview
This module provides workaround functions for creating Pydantic models with `AnyStr` as the `id` field, specifically designed for unit testing purposes. It addresses a known limitation in Pydantic where the `__eq__` method is ignored on subclassed strings.

### Core Functionality
- Creates wrapper functions for various message types (Document, AIMessage, HumanMessage, ToolMessage)
- Assigns `AnyStr()` as the `id` field post-model creation
- Supports unit testing comparisons for message objects

### Dependencies
- `langchain_core.documents`: For Document class
- `langchain_core.messages`: For message type classes
- `tests.any_str`: For AnyStr implementation

## Installation and Setup
This module is intended for testing purposes and should be included in your project's test suite.

```python
# Required dependencies
pip install langchain-core
```

## Usage Guide

### Basic Usage
```python
from your_module import _AnyIdHumanMessage, _AnyIdAIMessage

# Create a human message
human_msg = _AnyIdHumanMessage(content="Hello, AI!")

# Create an AI message
ai_msg = _AnyIdAIMessage(content="Hello, Human!")

# Messages will have AnyStr() as their id field
assert isinstance(human_msg.id, AnyStr)
assert isinstance(ai_msg.id, AnyStr)
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_any_str_messages.py
from __future__ import annotations

import pytest
from typing import Any, Callable
from langchain_core.documents import Document
from langchain_core.messages import AIMessage, HumanMessage, ToolMessage

from your_module import (
    _AnyIdDocument,
    _AnyIdAIMessage,
    _AnyIdHumanMessage,
    _AnyIdToolMessage,
    AnyStr
)

@pytest.fixture
def message_creators() -> dict[str, Callable[..., Any]]:
    """Fixture providing message creator functions."""
    return {
        "document": _AnyIdDocument,
        "ai_message": _AnyIdAIMessage,
        "human_message": _AnyIdHumanMessage,
        "tool_message": _AnyIdToolMessage,
    }

@pytest.fixture
def message_classes() -> dict[str, type]:
    """Fixture providing message classes."""
    return {
        "document": Document,
        "ai_message": AIMessage,
        "human_message": HumanMessage,
        "tool_message": ToolMessage,
    }

def test_message_creation_with_any_str_id(
    message_creators: dict[str, Callable[..., Any]],
    message_classes: dict[str, type]
) -> None:
    """Test that all message types are created with AnyStr id."""
    for name, creator in message_creators.items():
        # Create message with test content
        message = creator(content="test content")

        # Verify message type
        assert isinstance(message, message_classes[name])

        # Verify id is AnyStr
        assert isinstance(message.id, AnyStr)

def test_message_equality() -> None:
    """Test that messages with AnyStr ids compare correctly."""
    msg1 = _AnyIdHumanMessage(content="test")
    msg2 = _AnyIdHumanMessage(content="test")

    # Messages with same content should be equal
    assert msg1 == msg2

    # Different content should not be equal
    msg3 = _AnyIdHumanMessage(content="different")
    assert msg1 != msg3

@pytest.mark.parametrize("creator_func", [
    _AnyIdDocument,
    _AnyIdAIMessage,
    _AnyIdHumanMessage,
    _AnyIdToolMessage,
])
def test_message_additional_attributes(creator_func: Callable[..., Any]) -> None:
    """Test messages can be created with additional attributes."""
    additional_data = {"metadata": {"key": "value"}, "extra_info": "test"}
    message = creator_func(content="test", **additional_data)

    for key, value in additional_data.items():
        assert getattr(message, key) == value

def test_document_specific_attributes() -> None:
    """Test Document-specific attributes."""
    doc = _AnyIdDocument(
        page_content="test content",
        metadata={"source": "test"}
    )
    assert doc.page_content == "test content"
    assert doc.metadata == {"source": "test"}

@pytest.mark.parametrize("content", [
    "",  # empty string
    "Hello",  # simple string
    "Multi\nLine\nContent",  # multiline
    "Special chars: !@#$%^&*()",  # special characters
])
def test_message_content_variations(content: str) -> None:
    """Test messages with various content types."""
    msg = _AnyIdHumanMessage(content=content)
    assert msg.content == content
```

### Edge Cases and Error Testing
```python
def test_invalid_message_creation() -> None:
    """Test creating messages with invalid parameters."""
    with pytest.raises(ValueError):
        _AnyIdHumanMessage()  # Missing required content

def test_none_content() -> None:
    """Test behavior with None content."""
    with pytest.raises(ValueError):
        _AnyIdHumanMessage(content=None)
```

## Testing Best Practices

1. Use Type Annotations
   - Always include proper type hints
   - Use appropriate return type annotations

2. Fixture Usage
   - Create reusable fixtures for common test data
   - Use parametrize for testing multiple scenarios

3. Edge Cases
   - Test empty strings
   - Test special characters
   - Test missing required fields

4. Comparison Testing
   - Test equality between messages
   - Test inequality scenarios

5. Error Handling
   - Test invalid inputs
   - Verify error messages

## Debugging Tips

1. Message Inspection
```python
import pprint

msg = _AnyIdHumanMessage(content="test")
pprint.pprint(msg.dict())  # Inspect full message structure
```

2. ID Verification
```python
msg = _AnyIdHumanMessage(content="test")
print(f"Message ID type: {type(msg.id)}")
print(f"Message ID value: {msg.id}")
```

## Common Issues and Solutions

1. Message Comparison Issues
   ```python
   # Correct way to compare messages
   msg1 = _AnyIdHumanMessage(content="test")
   msg2 = _AnyIdHumanMessage(content="test")
   assert msg1 == msg2  # Should pass due to AnyStr implementation
   ```

2. Content Type Issues
   ```python
   # Ensure content is string
   content: str = "test"
   msg = _AnyIdHumanMessage(content=content)
   ```

This documentation provides a comprehensive guide for using and testing the AnyStr messages module, with particular focus on its purpose as a testing utility.
