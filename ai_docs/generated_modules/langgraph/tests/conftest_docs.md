
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation for this testing module:

# Testing Module Documentation

## Module Overview

This module provides testing fixtures and utilities for database interactions and checkpointing in a Python application. It supports multiple database backends including PostgreSQL, SQLite, and DuckDB, with both synchronous and asynchronous implementations.

### Key Features:
- Database fixtures for PostgreSQL, SQLite, and DuckDB
- Support for both sync and async operations
- Connection pooling capabilities
- Pipeline operation support
- In-memory store testing
- UUID deterministic testing

### Dependencies:
```
pytest
psycopg
langchain-core
pytest-mock
duckdb
```

## Installation & Setup

1. Install required packages:
```bash
pip install pytest psycopg langchain-core pytest-mock duckdb
```

2. Configure PostgreSQL test instance:
```bash
docker run -d \
  -e POSTGRES_PASSWORD=postgres \
  -p 5442:5432 \
  postgres:latest
```

## Usage Guide

### Basic Fixture Usage

```python
import pytest

def test_with_memory_store(store_in_memory):
    """Test using in-memory store."""
    assert store_in_memory is not None
    # Perform store operations

@pytest.mark.asyncio
async def test_with_postgres(checkpointer_postgres):
    """Test using PostgreSQL checkpointer."""
    assert checkpointer_postgres is not None
    # Perform PostgreSQL operations
```

### Async Context Manager Usage

```python
@pytest.mark.asyncio
async def test_async_store():
    async with awith_store("postgres_aio") as store:
        await store.setup()
        # Perform async store operations
```

## Testing Guide

### 1. Basic Store Tests

```python
import pytest
from typing import Any

def test_store_operations(store_in_memory: Any) -> None:
    """Test basic store operations.

    Args:
        store_in_memory: In-memory store fixture
    """
    # Setup test data
    test_data = {"key": "value"}

    # Test operations
    store_in_memory.set("test_key", test_data)
    result = store_in_memory.get("test_key")

    # Assertions
    assert result == test_data
```

### 2. Async PostgreSQL Tests

```python
@pytest.mark.asyncio
async def test_postgres_async_operations(
    deterministic_uuids: MockerFixture,
) -> None:
    """Test async PostgreSQL operations.

    Args:
        deterministic_uuids: UUID mock fixture
    """
    async with awith_store("postgres_aio") as store:
        # Setup
        test_id = deterministic_uuids()
        test_data = {"id": str(test_id), "value": "test"}

        # Execute
        await store.set(test_id, test_data)
        result = await store.get(test_id)

        # Assert
        assert result == test_data
```

### 3. Connection Pool Tests

```python
@pytest.mark.asyncio
async def test_postgres_pool(
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test PostgreSQL connection pooling.

    Args:
        caplog: Log capture fixture
    """
    async with awith_store("postgres_aio_pool") as store:
        # Multiple concurrent operations
        operations = [
            store.set(f"key_{i}", {"value": i})
            for i in range(5)
        ]
        await asyncio.gather(*operations)

        # Verify all operations succeeded
        for i in range(5):
            result = await store.get(f"key_{i}")
            assert result["value"] == i
```

### 4. Pipeline Tests

```python
def test_postgres_pipeline(store_postgres_pipe):
    """Test PostgreSQL pipeline operations."""
    # Setup
    test_data = [
        ("key1", {"value": "1"}),
        ("key2", {"value": "2"})
    ]

    # Execute in pipeline
    with store_postgres_pipe.pipeline():
        for key, value in test_data:
            store_postgres_pipe.set(key, value)

    # Verify results
    for key, expected in test_data:
        result = store_postgres_pipe.get(key)
        assert result == expected
```

## Testing Best Practices

1. Use Fixtures Appropriately:
```python
@pytest.fixture(scope="function")
def test_data():
    """Provide test data."""
    return {
        "id": str(uuid4()),
        "data": "test_value"
    }
```

2. Implement Proper Cleanup:
```python
@pytest.fixture(scope="function")
def cleanup_db():
    """Clean up test database."""
    yield
    # Cleanup code here
    with Connection.connect(DEFAULT_POSTGRES_URI) as conn:
        conn.execute("DROP DATABASE IF EXISTS test_db")
```

3. Handle Async/Sync Appropriately:
```python
@pytest.mark.asyncio
async def test_async_operation():
    async with awith_store("postgres_aio") as store:
        await store.setup()
        # Test async operations
```

## Common Issues and Solutions

1. Connection Issues:
```python
try:
    async with await AsyncConnection.connect(URI) as conn:
        # Operations
except ConnectionError as e:
    pytest.skip(f"Database connection failed: {e}")
```

2. Version Compatibility:
```python
@pytest.mark.skipif(
    sys.version_info < (3, 10),
    reason="Requires Python 3.10+"
)
async def test_feature():
    # Test implementation
```

3. Resource Cleanup:
```python
@pytest.fixture(autouse=True)
def cleanup_resources():
    yield
    # Cleanup code
```

This documentation covers the main aspects of the testing module. For specific test cases, refer to the fixture definitions and example tests provided above.
