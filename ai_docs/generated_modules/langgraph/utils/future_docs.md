
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this futures chaining module.

# Futures Chain Module Documentation

## Module Overview

This module provides functionality to chain asyncio and concurrent.futures Futures together, allowing state and results to be propagated between them. This is particularly useful when bridging between synchronous and asynchronous code.

### Key Features
- Chain asyncio.Future with concurrent.futures.Future
- Bidirectional state propagation
- Exception conversion between Future types
- Thread-safe operation
- Cancellation support

### Dependencies
- Python 3.7+
- asyncio (standard library)
- concurrent.futures (standard library)

## Installation

This module is self-contained and requires no external dependencies beyond the Python standard library.

```python
# Simply copy the module into your project
from future_chain import chain_future
```

## Usage Guide

### Basic Usage

```python
import asyncio
import concurrent.futures
from future_chain import chain_future

# Create futures
async_future = asyncio.Future()
concurrent_future = concurrent.futures.Future()

# Chain them together
chain_future(async_future, concurrent_future)

# When async_future completes, concurrent_future will receive the result
async_future.set_result("success")
assert concurrent_future.result() == "success"
```

### Error Propagation

```python
async_future = asyncio.Future()
concurrent_future = concurrent.futures.Future()

chain_future(async_future, concurrent_future)
async_future.set_exception(ValueError("test error"))

try:
    concurrent_future.result()
except ValueError as e:
    print(f"Error propagated: {e}")
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_future_chain.py
from __future__ import annotations

import asyncio
import concurrent.futures
import pytest
from typing import Any, Generator
from future_chain import chain_future, _convert_future_exc

@pytest.fixture
def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:
    """Provide an event loop for tests."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def async_future(event_loop: asyncio.AbstractEventLoop) -> asyncio.Future:
    """Create an asyncio Future for testing."""
    return asyncio.Future(loop=event_loop)

@pytest.fixture
def concurrent_future() -> concurrent.futures.Future:
    """Create a concurrent.futures Future for testing."""
    return concurrent.futures.Future()

class TestFutureChain:
    """Test suite for future chaining functionality."""

    @pytest.mark.asyncio
    async def test_basic_result_propagation(
        self,
        async_future: asyncio.Future,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test that results propagate from source to destination."""
        chain_future(async_future, concurrent_future)
        async_future.set_result("test_value")

        assert concurrent_future.result() == "test_value"

    @pytest.mark.asyncio
    async def test_exception_propagation(
        self,
        async_future: asyncio.Future,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test that exceptions propagate correctly."""
        chain_future(async_future, concurrent_future)
        test_error = ValueError("test error")
        async_future.set_exception(test_error)

        with pytest.raises(ValueError, match="test error"):
            concurrent_future.result()

    @pytest.mark.asyncio
    async def test_cancellation_propagation(
        self,
        async_future: asyncio.Future,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test cancellation propagation."""
        chain_future(async_future, concurrent_future)
        concurrent_future.cancel()

        assert async_future.cancelled()
        assert concurrent_future.cancelled()

    @pytest.mark.asyncio
    async def test_invalid_source_type(
        self,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test that invalid source types raise TypeError."""
        with pytest.raises(TypeError, match="A future is required"):
            chain_future("not a future", concurrent_future)

    @pytest.mark.asyncio
    async def test_exception_conversion(self) -> None:
        """Test future exception type conversion."""
        concurrent_exc = concurrent.futures.CancelledError()
        converted_exc = _convert_future_exc(concurrent_exc)

        assert isinstance(converted_exc, asyncio.CancelledError)

    @pytest.mark.asyncio
    async def test_chaining_with_result(
        self,
        event_loop: asyncio.AbstractEventLoop,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test chaining with async operation result."""
        async def async_operation() -> str:
            await asyncio.sleep(0.1)
            return "async result"

        async_future = event_loop.create_task(async_operation())
        chain_future(async_future, concurrent_future)

        # Wait for completion
        event_loop.run_until_complete(async_future)
        assert concurrent_future.result() == "async result"
```

### Additional Test Cases

```python
# test_future_chain_advanced.py

class TestAdvancedFutureChain:
    """Advanced test cases for future chaining."""

    @pytest.mark.asyncio
    async def test_multiple_chains(
        self,
        event_loop: asyncio.AbstractEventLoop,
    ) -> None:
        """Test chaining multiple futures together."""
        source = asyncio.Future(loop=event_loop)
        dest1 = concurrent.futures.Future()
        dest2 = concurrent.futures.Future()

        chain_future(source, dest1)
        chain_future(source, dest2)

        source.set_result("multiple chain test")

        assert dest1.result() == "multiple chain test"
        assert dest2.result() == "multiple chain test"

    @pytest.mark.asyncio
    async def test_chain_completed_future(
        self,
        async_future: asyncio.Future,
        concurrent_future: concurrent.futures.Future,
    ) -> None:
        """Test chaining an already completed future."""
        async_future.set_result("pre-completed")
        chain_future(async_future, concurrent_future)

        assert concurrent_future.result() == "pre-completed"
```

## Error Handling and Edge Cases

The module handles several important edge cases:

1. Thread-safety when dealing with different event loops
2. Proper exception type conversion between Future types
3. Cancellation propagation
4. Invalid Future type detection

### Example Error Handling Test

```python
@pytest.mark.asyncio
async def test_error_handling_edge_cases(
    event_loop: asyncio.AbstractEventLoop,
) -> None:
    """Test various error handling edge cases."""
    source = asyncio.Future(loop=event_loop)
    dest = concurrent.futures.Future()

    # Test with custom exception
    class CustomError(Exception):
        pass

    chain_future(source, dest)
    source.set_exception(CustomError("custom error"))

    with pytest.raises(CustomError, match="custom error"):
        dest.result()
```

## Performance Testing

```python
import time

def test_chaining_performance() -> None:
    """Test the performance of future chaining."""
    start_time = time.perf_counter()

    futures_pairs = [
        (asyncio.Future(), concurrent.futures.Future())
        for _ in range(1000)
    ]

    for async_fut, concurrent_fut in futures_pairs:
        chain_future(async_fut, concurrent_fut)
        async_fut.set_result("test")

    end_time = time.perf_counter()
    duration = end_time - start_time

    # Assert reasonable performance
    assert duration < 1.0, f"Chaining took too long: {duration} seconds"
```

## Best Practices

1. Always handle exceptions when working with chained futures
2. Use type hints to ensure correct Future types
3. Clean up futures properly to avoid memory leaks
4. Consider thread safety when working with multiple event loops
5. Test both synchronous and asynchronous code paths

Remember to run tests with proper coverage:

```bash
pytest --cov=future_chain tests/ --cov-report=term-missing
```

This documentation provides a comprehensive guide to using and testing the futures chaining module. The test cases cover the main functionality, edge cases, and performance considerations.
