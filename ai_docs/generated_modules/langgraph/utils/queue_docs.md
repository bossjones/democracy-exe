
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and test examples for this module.

# Queue Extensions Module Documentation

## Module Overview

This module provides enhanced queue implementations with wait functionality for both synchronous and asynchronous contexts. It includes two main classes:

- `AsyncQueue`: An asynchronous FIFO queue extending `asyncio.Queue`
- `SyncQueue`: A synchronous FIFO queue with wait capability
- `Semaphore`: An internal helper class extending `threading.Semaphore`

### Key Features
- Non-consuming wait operations
- Unbounded FIFO queues
- Type-safe implementations
- Python 3.10+ compatibility
- Thread-safe operations

### Dependencies
- Python 3.6+
- Standard library modules: asyncio, queue, threading, collections

## Installation and Setup

```bash
# No additional installation required - pure Python implementation
# Just copy the module into your project
```

## Usage Guide

### AsyncQueue Example

```python
import asyncio
from queue_extensions import AsyncQueue

async def producer(queue: AsyncQueue):
    await queue.put("item")

async def consumer(queue: AsyncQueue):
    # Wait for item without consuming
    await queue.wait()
    # Now get the item
    item = await queue.get()
    return item

async def main():
    queue = AsyncQueue()
    await producer(queue)
    result = await consumer(queue)
    print(result)  # Output: "item"

asyncio.run(main())
```

### SyncQueue Example

```python
from queue_extensions import SyncQueue
import threading

def producer(queue: SyncQueue):
    queue.put("item")

def consumer(queue: SyncQueue):
    # Wait for item without consuming
    queue.wait()
    # Now get the item
    item = queue.get()
    return item

queue = SyncQueue()
prod_thread = threading.Thread(target=producer, args=(queue,))
cons_thread = threading.Thread(target=consumer, args=(queue,))

prod_thread.start()
cons_thread.start()
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_queue_extensions.py
from __future__ import annotations

import asyncio
import pytest
import threading
import time
from typing import AsyncGenerator, Generator
from queue import Empty

from queue_extensions import AsyncQueue, SyncQueue

# Fixtures
@pytest.fixture
def sync_queue() -> Generator[SyncQueue, None, None]:
    """Provide a clean SyncQueue instance for each test."""
    yield SyncQueue()

@pytest.fixture
async def async_queue() -> AsyncGenerator[AsyncQueue, None]:
    """Provide a clean AsyncQueue instance for each test."""
    yield AsyncQueue()

# AsyncQueue Tests
@pytest.mark.asyncio
async def test_async_queue_wait_basic(async_queue: AsyncQueue):
    """Test basic wait functionality of AsyncQueue."""
    # Setup producer
    async def producer():
        await asyncio.sleep(0.1)
        await async_queue.put("test_item")

    # Start producer
    producer_task = asyncio.create_task(producer())

    # Wait for item
    await async_queue.wait()

    # Verify item is available but not consumed
    assert not async_queue.empty()

    # Get the item
    item = await async_queue.get()
    assert item == "test_item"

    await producer_task

@pytest.mark.asyncio
async def test_async_queue_wait_timeout():
    """Test AsyncQueue wait with timeout."""
    queue = AsyncQueue()

    with pytest.raises(asyncio.TimeoutError):
        await asyncio.wait_for(queue.wait(), timeout=0.1)

# SyncQueue Tests
def test_sync_queue_basic_operations(sync_queue: SyncQueue):
    """Test basic operations of SyncQueue."""
    sync_queue.put("test_item")
    assert not sync_queue.empty()
    assert sync_queue.qsize() == 1

    item = sync_queue.get()
    assert item == "test_item"
    assert sync_queue.empty()

def test_sync_queue_wait_with_timeout(sync_queue: SyncQueue):
    """Test SyncQueue wait with timeout."""
    def delayed_put():
        time.sleep(0.1)
        sync_queue.put("test_item")

    thread = threading.Thread(target=delayed_put)
    thread.start()

    # Wait should succeed
    sync_queue.wait(timeout=0.2)
    assert not sync_queue.empty()

    thread.join()

def test_sync_queue_wait_timeout_raises(sync_queue: SyncQueue):
    """Test SyncQueue wait timeout behavior."""
    with pytest.raises(Empty):
        sync_queue.get(timeout=0.1)

def test_sync_queue_invalid_timeout(sync_queue: SyncQueue):
    """Test invalid timeout values."""
    with pytest.raises(ValueError):
        sync_queue.wait(timeout=-1)

    with pytest.raises(ValueError):
        sync_queue.get(timeout=-1)

# Multi-threading Tests
def test_sync_queue_threaded_operations(sync_queue: SyncQueue):
    """Test SyncQueue in multi-threaded environment."""
    items_to_process = 100
    processed_items = []

    def producer():
        for i in range(items_to_process):
            sync_queue.put(i)
            time.sleep(0.001)

    def consumer():
        while len(processed_items) < items_to_process:
            try:
                item = sync_queue.get(timeout=0.1)
                processed_items.append(item)
            except Empty:
                continue

    # Start threads
    prod_thread = threading.Thread(target=producer)
    cons_thread = threading.Thread(target=consumer)

    prod_thread.start()
    cons_thread.start()

    prod_thread.join()
    cons_thread.join()

    assert len(processed_items) == items_to_process
    assert sorted(processed_items) == list(range(items_to_process))
```

## Testing Best Practices

1. **Isolation**: Each test function tests a single aspect of the functionality
2. **Coverage**: Tests include both success and error cases
3. **Async Testing**: Use `pytest.mark.asyncio` for async tests
4. **Threading**: Properly handle thread cleanup in multi-threaded tests
5. **Timeouts**: Include timeout tests to ensure proper handling
6. **Edge Cases**: Test boundary conditions and invalid inputs

## Error Handling and Edge Cases

Important areas to test:
- Negative timeout values
- Empty queue operations
- Queue operations under heavy load
- Concurrent access patterns
- Exception propagation
- Resource cleanup

## Performance Testing

```python
import pytest
import time

@pytest.mark.benchmark
def test_sync_queue_performance(benchmark):
    """Benchmark SyncQueue operations."""
    def operation():
        queue = SyncQueue()
        for _ in range(1000):
            queue.put(1)
        for _ in range(1000):
            queue.get()

    benchmark(operation)
```

## Debugging Tips

1. Enable debug logging:
```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

2. Use async debugging:
```python
import asyncio
asyncio.get_event_loop().set_debug(True)
```

3. Thread debugging:
```python
import threading
threading.VERBOSE = True
```

## Common Issues and Solutions

1. **Deadlocks**: Always use timeouts in production code
2. **Memory Leaks**: Monitor queue size in long-running applications
3. **Thread Safety**: Use appropriate synchronization primitives
4. **Resource Cleanup**: Properly close/cleanup queues in async context

Remember to run tests with:
```bash
pytest test_queue_extensions.py -v --cov=queue_extensions
```

This documentation covers the essential aspects of using and testing the queue extensions module. Adjust the testing strategies based on your specific use cases and requirements.
