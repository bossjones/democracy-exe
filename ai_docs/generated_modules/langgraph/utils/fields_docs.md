
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this type handling utility module.

# Type Utilities Documentation

## Module Overview
This module provides utilities for analyzing and extracting type information from Python classes, with special support for TypedDict, dataclasses, and Pydantic models. It helps determine field requirements, default values, and metadata from type annotations.

Key features:
- Optional type detection
- Required/NotRequired field analysis
- ReadOnly field detection
- Default value extraction
- Type hint enhancement with metadata

Dependencies:
- Python 3.8+
- typing_extensions
- dataclasses (standard library)

## Installation and Setup

```bash
pip install typing-extensions
```

## Usage Guide

### Working with Optional Types

```python
from typing import Optional, Union
from typing_extensions import Annotated

# Basic usage
def check_optional(type_):
    return _is_optional_type(type_)

# Examples
assert check_optional(Optional[str])  # True
assert check_optional(Union[str, None])  # True
assert check_optional(Annotated[Optional[str], "metadata"])  # True
assert not check_optional(str)  # False
```

### Required/NotRequired Field Detection

```python
from typing_extensions import Required, NotRequired

# Check if field is explicitly marked as required
def check_required(type_):
    return _is_required_type(type_)

# Examples
assert check_required(Required[str]) is True
assert check_required(NotRequired[str]) is False
assert check_required(str) is None
```

### Default Value Extraction

```python
from typing import TypedDict
from dataclasses import dataclass

class UserDict(TypedDict):
    name: str
    age: NotRequired[int]

@dataclass
class UserClass:
    name: str
    age: Optional[int] = None

# Get default values
assert get_field_default("name", str, UserDict) == ...
assert get_field_default("age", NotRequired[int], UserDict) is None
```

## Testing Guide

### Test Setup

```python
# test_type_utils.py
from typing import Optional, Union, Type, Any
from typing_extensions import Annotated, Required, NotRequired, ReadOnly
import pytest
from your_module import (
    _is_optional_type,
    _is_required_type,
    _is_readonly_type,
    get_field_default,
    get_enhanced_type_hints,
)

@pytest.fixture
def sample_typed_dict() -> Type[Any]:
    class TestDict(TypedDict):
        required: str
        optional: NotRequired[int]
    return TestDict

@pytest.fixture
def sample_dataclass() -> Type[Any]:
    @dataclass
    class TestClass:
        name: str
        age: Optional[int] = None
    return TestClass
```

### Optional Type Tests

```python
def test_is_optional_type():
    """Test optional type detection."""
    assert _is_optional_type(Optional[str])
    assert _is_optional_type(Union[str, None])
    assert _is_optional_type(Annotated[Optional[str], "metadata"])
    assert not _is_optional_type(str)
    assert not _is_optional_type(int)

def test_optional_type_edge_cases():
    """Test edge cases for optional type detection."""
    assert _is_optional_type(Union[str, int, None])
    assert not _is_optional_type(Union[str, int])
    assert _is_optional_type(Optional[Any])
```

### Required Type Tests

```python
def test_is_required_type():
    """Test required type detection."""
    assert _is_required_type(Required[str]) is True
    assert _is_required_type(NotRequired[str]) is False
    assert _is_required_type(str) is None

def test_required_type_with_annotations():
    """Test required type detection with annotations."""
    assert _is_required_type(Annotated[Required[str], "metadata"]) is True
    assert _is_required_type(Annotated[NotRequired[str], "metadata"]) is False
```

### Field Default Tests

```python
def test_get_field_default_typed_dict(sample_typed_dict):
    """Test default value extraction from TypedDict."""
    assert get_field_default("required", str, sample_typed_dict) == ...
    assert get_field_default("optional", NotRequired[int], sample_typed_dict) is None

def test_get_field_default_dataclass(sample_dataclass):
    """Test default value extraction from dataclass."""
    assert get_field_default("name", str, sample_dataclass) == ...
    assert get_field_default("age", Optional[int], sample_dataclass) is None

@pytest.mark.parametrize("field_type,expected", [
    (Optional[str], None),
    (Required[str], ...),
    (NotRequired[str], None),
    (str, ...),
])
def test_get_field_default_various_types(field_type, expected):
    """Test default value extraction for various types."""
    assert get_field_default("test", field_type, dict) == expected
```

### Enhanced Type Hints Tests

```python
def test_get_enhanced_type_hints_dataclass(sample_dataclass):
    """Test enhanced type hints extraction from dataclass."""
    hints = list(get_enhanced_type_hints(sample_dataclass))
    assert len(hints) == 2
    assert hints[0] == ("name", str, None, None)
    assert hints[1] == ("age", Optional[int], None, None)

def test_get_enhanced_type_hints_pydantic():
    """Test enhanced type hints extraction from Pydantic model."""
    from pydantic import BaseModel, Field

    class TestModel(BaseModel):
        name: str = Field(..., description="User name")
        age: Optional[int] = Field(None, description="User age")

    hints = list(get_enhanced_type_hints(TestModel))
    assert len(hints) == 2
    assert hints[0] == ("name", str, None, "User name")
    assert hints[1] == ("age", Optional[int], None, "User age")
```

## Testing Best Practices

1. Use parametrized tests for multiple similar test cases
2. Test edge cases and boundary conditions
3. Include both positive and negative test cases
4. Test with different Python type systems (TypedDict, dataclass, Pydantic)
5. Use appropriate fixtures for reusable test data
6. Maintain type annotations in test code
7. Test for proper error handling
8. Document test cases clearly

## Error Handling and Edge Cases

```python
def test_edge_cases():
    """Test edge cases and error handling."""
    # None type
    assert _is_optional_type(None)

    # Invalid types
    assert not _is_optional_type(42)

    # Complex nested types
    assert _is_optional_type(Optional[Union[str, int]])

    # Generic types
    from typing import TypeVar, Generic
    T = TypeVar('T')
    class GenericClass(Generic[T]): pass
    assert not _is_optional_type(GenericClass[str])
```

This documentation provides a solid foundation for understanding and using the type utilities module. The test examples cover the main functionality and edge cases, making it easier to maintain and extend the code.
