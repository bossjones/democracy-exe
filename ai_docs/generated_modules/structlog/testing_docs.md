
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this logging helper module. Here's the structured documentation:

# Structlog Testing Helpers Documentation

## Module Overview

This module provides utilities for testing logging behavior in applications using structlog. It offers tools to capture, inspect, and verify logging output during tests.

Key features:
- Log capture functionality
- Return logging for verification
- Capturing specific log calls
- Thread-safe log testing capabilities

Dependencies:
- Python 3.7+
- structlog core package

## Installation and Setup

```bash
pip install structlog
```

## Usage Guide

### 1. Capturing Logs

The `capture_logs` context manager is the primary tool for testing log output:

```python
from structlog.testing import capture_logs

def test_my_logging():
    with capture_logs() as captured:
        # Your logging code here
        logger.info("test message", extra="data")

        assert captured == [{
            "event": "test message",
            "extra": "data",
            "log_level": "info"
        }]
```

### 2. Using CapturingLogger

For more detailed logging inspection:

```python
from structlog.testing import CapturingLogger, CapturingLoggerFactory

logger = CapturingLogger()
logger.info("test", extra="value")
assert logger.calls[0].method_name == "info"
assert logger.calls[0].args == ("test",)
assert logger.calls[0].kwargs == {"extra": "value"}
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_structlog_testing.py
from __future__ import annotations

import pytest
from typing import Generator

from structlog.testing import (
    capture_logs,
    CapturingLogger,
    CapturingLoggerFactory,
    ReturnLogger,
    LogCapture
)

@pytest.fixture
def capturing_logger() -> CapturingLogger:
    """Provide a fresh CapturingLogger instance.

    Returns:
        CapturingLogger: A new capturing logger instance
    """
    return CapturingLogger()

def test_capture_logs_context() -> None:
    """Test the capture_logs context manager."""
    with capture_logs() as captured:
        logger = ReturnLogger()
        logger.info("test message", extra="data")

        assert len(captured) == 1
        assert captured[0]["event"] == "test message"
        assert captured[0]["extra"] == "data"
        assert captured[0]["log_level"] == "info"

@pytest.mark.asyncio
async def test_async_capture_logs() -> None:
    """Test capturing logs in async context."""
    with capture_logs() as captured:
        logger = ReturnLogger()
        await async_log_operation(logger)

        assert len(captured) > 0
        assert "async_event" in captured[0]

def test_capturing_logger(capturing_logger: CapturingLogger) -> None:
    """Test CapturingLogger functionality.

    Args:
        capturing_logger: The capturing logger fixture
    """
    capturing_logger.info("test", extra="value")
    capturing_logger.error("error", code=500)

    assert len(capturing_logger.calls) == 2
    assert capturing_logger.calls[0].method_name == "info"
    assert capturing_logger.calls[0].kwargs["extra"] == "value"
    assert capturing_logger.calls[1].method_name == "error"
    assert capturing_logger.calls[1].kwargs["code"] == 500

def test_return_logger() -> None:
    """Test ReturnLogger functionality."""
    logger = ReturnLogger()

    # Test single argument
    result = logger.info("test")
    assert result == "test"

    # Test multiple arguments
    result = logger.info("test", extra="value")
    assert result == (("test",), {"extra": "value"})

@pytest.mark.parametrize("log_level,expected_level", [
    ("info", "info"),
    ("error", "error"),
    ("warn", "warning"),  # Test level mapping
    ("exception", "error")  # Test level mapping
])
def test_log_level_mapping(
    log_level: str,
    expected_level: str,
    capturing_logger: CapturingLogger
) -> None:
    """Test log level mapping functionality.

    Args:
        log_level: Input log level
        expected_level: Expected mapped level
        capturing_logger: The capturing logger fixture
    """
    getattr(capturing_logger, log_level)("test")
    assert capturing_logger.calls[0].method_name == log_level

def test_log_capture_thread_safety() -> None:
    """Test thread safety of LogCapture."""
    import threading
    import queue

    results = queue.Queue()

    def logging_thread() -> None:
        with capture_logs() as captured:
            logger = ReturnLogger()
            logger.info("thread test")
            results.put(captured)

    threads = [
        threading.Thread(target=logging_thread)
        for _ in range(3)
    ]

    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()

    while not results.empty():
        captured = results.get()
        assert len(captured) == 1
        assert captured[0]["event"] == "thread test"

@pytest.fixture
def factory() -> Generator[CapturingLoggerFactory, None, None]:
    """Provide a CapturingLoggerFactory instance.

    Yields:
        CapturingLoggerFactory: A new factory instance
    """
    factory = CapturingLoggerFactory()
    yield factory

def test_capturing_logger_factory(factory: CapturingLoggerFactory) -> None:
    """Test CapturingLoggerFactory functionality.

    Args:
        factory: The logger factory fixture
    """
    logger1 = factory()
    logger2 = factory()

    assert logger1 is logger2
    assert logger1 is factory.logger

    logger1.info("test")
    assert len(factory.logger.calls) == 1
```

### Testing Best Practices

1. Always use type hints in test functions
2. Create fixtures for common test scenarios
3. Test both success and error cases
4. Verify log level mappings
5. Test thread safety when relevant
6. Use parametrize for testing multiple scenarios
7. Test async logging scenarios
8. Verify logger factory behavior

### Common Test Fixtures

```python
@pytest.fixture
def structured_log_data() -> dict:
    """Provide structured log data for testing.

    Returns:
        dict: Sample log data
    """
    return {
        "event": "test_event",
        "timestamp": "2024-01-01T00:00:00Z",
        "level": "info",
        "extra_data": {"key": "value"}
    }

@pytest.fixture
def mock_logger(mocker: MockerFixture) -> Any:
    """Provide a mock logger.

    Args:
        mocker: Pytest mocker fixture

    Returns:
        Any: Mocked logger instance
    """
    return mocker.Mock()
```

### Error Handling and Edge Cases

```python
def test_capture_logs_error_handling() -> None:
    """Test error handling in capture_logs."""
    with pytest.raises(Exception):
        with capture_logs() as captured:
            raise Exception("Test error")

    # Verify processors are restored
    from structlog import get_config
    assert len(get_config()["processors"]) > 0

def test_invalid_log_levels() -> None:
    """Test handling of invalid log levels."""
    logger = CapturingLogger()
    logger.invalid_level("test")  # Should work with any method name
    assert logger.calls[0].method_name == "invalid_level"
```

This documentation provides a comprehensive guide to using and testing the structlog testing helpers module. The test examples cover all major functionality and include proper type hints, fixtures, and best practices for testing logging behavior.
