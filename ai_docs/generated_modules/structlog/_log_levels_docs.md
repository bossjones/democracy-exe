
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module following the requested structure.

### Module Overview

This module handles log level management and mapping for structured logging in Python. It provides functionality to:
- Define standard logging levels consistent with Python's stdlib
- Map between level names and numeric values
- Convert method names to standardized level names
- Add log levels to event dictionaries

Key features:
- Stdlib-compatible logging levels
- Bidirectional mapping between level names and values
- Special handling for deprecated and alias log levels
- Integration with structlog's event dictionary system

Dependencies:
- Python 3.7+
- logging (stdlib)

### Installation and Setup

```bash
pip install structlog
```

No additional configuration is needed for basic usage, as this is an internal module of structlog.

### Usage Guide

```python
import logging
from structlog.levels import (
    add_log_level,
    map_method_name,
    NAME_TO_LEVEL,
    LEVEL_TO_NAME
)

# Using level constants
from structlog.levels import DEBUG, INFO, WARNING, ERROR, CRITICAL

# Mapping between names and levels
level_num = NAME_TO_LEVEL["info"]  # Returns 20
level_name = LEVEL_TO_NAME[40]     # Returns "error"

# Method name mapping
mapped_name = map_method_name("warn")  # Returns "warning"
mapped_name = map_method_name("exception")  # Returns "error"

# Adding log level to event dict
logger = logging.getLogger(__name__)
event_dict = {"event": "test"}
event_dict = add_log_level(logger, "info", event_dict)
# Results in: {"event": "test", "level": "info"}
```

### Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_levels.py
from __future__ import annotations

import logging
import pytest

from structlog.levels import (
    add_log_level,
    map_method_name,
    NAME_TO_LEVEL,
    LEVEL_TO_NAME,
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    CRITICAL,
)

@pytest.fixture
def logger() -> logging.Logger:
    """Provide a standard logger instance for tests."""
    return logging.getLogger("test_logger")

@pytest.fixture
def event_dict() -> dict:
    """Provide a sample event dictionary."""
    return {"event": "test_event"}

class TestLevelConstants:
    """Test level constant definitions."""

    def test_level_constants(self) -> None:
        """Verify level constants match stdlib values."""
        assert DEBUG == 10
        assert INFO == 20
        assert WARNING == 30
        assert ERROR == 40
        assert CRITICAL == 50

class TestLevelMapping:
    """Test level name/number mapping."""

    @pytest.mark.parametrize(
        "name,expected_level",
        [
            ("debug", 10),
            ("info", 20),
            ("warning", 30),
            ("error", 40),
            ("critical", 50),
            ("exception", 40),  # exception maps to error
            ("warn", 30),       # warn maps to warning
        ],
    )
    def test_name_to_level_mapping(
        self, name: str, expected_level: int
    ) -> None:
        """Test mapping from names to level numbers."""
        assert NAME_TO_LEVEL[name] == expected_level

    @pytest.mark.parametrize(
        "level,expected_name",
        [
            (10, "debug"),
            (20, "info"),
            (30, "warning"),
            (40, "error"),
            (50, "critical"),
        ],
    )
    def test_level_to_name_mapping(
        self, level: int, expected_name: str
    ) -> None:
        """Test mapping from level numbers to names."""
        assert LEVEL_TO_NAME[level] == expected_name

class TestMethodNameMapping:
    """Test method name mapping functionality."""

    @pytest.mark.parametrize(
        "method_name,expected_name",
        [
            ("warn", "warning"),
            ("warning", "warning"),
            ("exception", "error"),
            ("error", "error"),
            ("info", "info"),
            ("debug", "debug"),
        ],
    )
    def test_map_method_name(
        self, method_name: str, expected_name: str
    ) -> None:
        """Test mapping of method names to standardized names."""
        assert map_method_name(method_name) == expected_name

class TestAddLogLevel:
    """Test add_log_level processor."""

    def test_add_log_level_basic(
        self, logger: logging.Logger, event_dict: dict
    ) -> None:
        """Test basic log level addition."""
        result = add_log_level(logger, "info", event_dict)
        assert result["level"] == "info"
        assert "event" in result

    def test_add_log_level_warn_mapping(
        self, logger: logging.Logger, event_dict: dict
    ) -> None:
        """Test warn level mapping in add_log_level."""
        result = add_log_level(logger, "warn", event_dict)
        assert result["level"] == "warning"

    def test_add_log_level_exception_mapping(
        self, logger: logging.Logger, event_dict: dict
    ) -> None:
        """Test exception level mapping in add_log_level."""
        result = add_log_level(logger, "exception", event_dict)
        assert result["level"] == "error"

```

### Testing Best Practices

1. Use Type Annotations:
   - All test functions and fixtures should include proper type hints
   - Use from `__future__ import annotations` for forward references

2. Parametrize Tests:
   - Use `@pytest.mark.parametrize` for testing multiple input combinations
   - Group related test cases together

3. Fixture Usage:
   - Create fixtures for commonly used objects
   - Keep fixtures focused and simple
   - Use appropriate scope for fixtures

4. Test Organization:
   - Group related tests into classes
   - Use descriptive test names
   - Include docstrings for all test functions

5. Edge Cases:
   - Test deprecated aliases ("warn" → "warning")
   - Test special cases ("exception" → "error")
   - Verify both mapping directions

### Error Handling and Edge Cases

While this module doesn't raise exceptions directly, tests should verify:
- All standard log levels are properly mapped
- Deprecated aliases work as expected
- Special cases are handled correctly
- Dictionary integrity is maintained during processing

### Integration Testing

Since this module is part of structlog's core functionality, integration tests should verify:
- Compatibility with Python's stdlib logging
- Proper interaction with structlog's processor chain
- Correct behavior in real logging scenarios

### Debugging and Troubleshooting

Common issues to watch for:
1. Log level mismatches between stdlib and structlog
2. Incorrect handling of deprecated level names
3. Event dictionary modification issues

Debugging tips:
- Use pytest's `-v` flag for verbose output
- Use `pytest.set_trace()` for debugging specific test cases
- Check event dictionary contents at each processing step

This module is relatively simple but crucial for proper log level handling in structlog. The tests ensure reliable behavior across different logging scenarios and maintain compatibility with Python's standard logging module.
