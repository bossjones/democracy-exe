
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module, which appears to be part of the structlog library and handles exception and stack trace formatting.

# Exception and Stack Trace Formatting Module Documentation

## Module Overview

This module provides utilities for formatting exception information and stack traces in Python applications. It's primarily designed to support structured logging operations by:
- Formatting exception information into readable strings
- Finding and identifying application frames in stack traces
- Formatting stack traces with proper formatting and line endings

Key features:
- Exception formatting with proper traceback information
- Application frame discovery with customizable ignore patterns
- Stack trace formatting similar to Python's built-in logging

Dependencies:
- Python 3.7+
- No external package dependencies
- Uses standard library modules: sys, traceback, io

## Installation and Setup

This module is part of the structlog package. Install via pip:

```bash
pip install structlog
```

## Usage Guide

### Exception Formatting

```python
from structlog._frames import _format_exception

# Format an exception
try:
    1/0
except Exception:
    exc_info = sys.exc_info()
    formatted = _format_exception(exc_info)
    print(formatted)
```

### Finding Application Frames

```python
from structlog._frames import _find_first_app_frame_and_name

# Get the first non-structlog frame
frame, name = _find_first_app_frame_and_name(
    additional_ignores=["my_logging_wrapper"]
)
```

### Stack Trace Formatting

```python
from structlog._frames import _format_stack

# Format current stack trace
frame = sys._getframe()
formatted_stack = _format_stack(frame)
print(formatted_stack)
```

## Testing Guide

### Test Setup

```python
# test_frames.py
from __future__ import annotations

import pytest
import sys

from types import FrameType
from typing import Any, Callable

from structlog._frames import (
    _format_exception,
    _find_first_app_frame_and_name,
    _format_stack,
)

@pytest.fixture
def fake_frame() -> FrameType:
    """Create a fake frame for testing."""
    frame = FrameType(
        f_code=compile("pass", "fake_file.py", "exec"),
        f_globals={"__name__": "test_module"},
        f_locals={},
        f_back=None,
    )
    return frame

@pytest.fixture
def exc_info() -> tuple[type[Exception], Exception, Any]:
    """Create a test exception info tuple."""
    try:
        raise ValueError("Test error")
    except ValueError:
        return sys.exc_info()
```

### Testing Exception Formatting

```python
def test_format_exception(exc_info: tuple[type[Exception], Exception, Any]) -> None:
    """Test exception formatting."""
    result = _format_exception(exc_info)

    assert "ValueError: Test error" in result
    assert "Traceback (most recent call last):" in result

def test_format_exception_none() -> None:
    """Test formatting when no exception exists."""
    result = _format_exception((None, None, None))

    assert result == "MISSING"
```

### Testing Frame Finding

```python
def test_find_first_app_frame_and_name(
    mocker: pytest.MockFixture,
    fake_frame: FrameType,
) -> None:
    """Test finding the first non-structlog frame."""
    def fake_getframe() -> FrameType:
        return fake_frame

    frame, name = _find_first_app_frame_and_name(
        _getframe=fake_getframe
    )

    assert frame is fake_frame
    assert name == "test_module"

def test_find_first_app_frame_with_ignores(
    mocker: pytest.MockFixture,
    fake_frame: FrameType,
) -> None:
    """Test frame finding with additional ignores."""
    fake_frame.f_globals["__name__"] = "structlog.test"
    back_frame = FrameType(
        f_code=compile("pass", "app.py", "exec"),
        f_globals={"__name__": "app"},
        f_locals={},
        f_back=None,
    )
    fake_frame.f_back = back_frame

    def fake_getframe() -> FrameType:
        return fake_frame

    frame, name = _find_first_app_frame_and_name(
        additional_ignores=["extra_ignore"],
        _getframe=fake_getframe,
    )

    assert frame is back_frame
    assert name == "app"
```

### Testing Stack Formatting

```python
def test_format_stack(fake_frame: FrameType) -> None:
    """Test stack trace formatting."""
    result = _format_stack(fake_frame)

    assert "Stack (most recent call last):" in result
    assert "fake_file.py" in result
```

## Testing Best Practices

1. Mock System Functions:
```python
@pytest.fixture
def mock_getframe(mocker: pytest.MockFixture) -> None:
    return mocker.patch("sys._getframe")
```

2. Test Error Cases:
```python
def test_find_first_app_frame_no_name(
    mocker: pytest.MockFixture,
    fake_frame: FrameType,
) -> None:
    """Test behavior when __name__ is missing."""
    fake_frame.f_globals.clear()

    def fake_getframe() -> FrameType:
        return fake_frame

    frame, name = _find_first_app_frame_and_name(
        _getframe=fake_getframe
    )

    assert frame is fake_frame
    assert name == "?"
```

3. Test Edge Cases:
```python
def test_format_stack_empty_frame(fake_frame: FrameType) -> None:
    """Test formatting with minimal frame information."""
    fake_frame.f_code = compile("", "", "exec")
    result = _format_stack(fake_frame)

    assert result.strip() != ""
    assert "Stack (most recent call last):" in result
```

## Error Handling and Edge Cases

The module handles several edge cases:
- Missing exception information
- Missing frame information
- Missing module names
- Empty stack traces

Example error handling test:
```python
def test_format_exception_incomplete_info() -> None:
    """Test formatting with incomplete exception info."""
    exc_info = (ValueError, ValueError("Test"), None)
    result = _format_exception(exc_info)

    assert "ValueError: Test" in result
```

## Performance Considerations

- The module caches frame information where possible
- Avoids unnecessary string operations
- Uses StringIO for efficient string building
- Implements lazy evaluation of stack traces

Remember to handle cleanup of frame references to avoid memory leaks in tests:
```python
@pytest.fixture(autouse=True)
def cleanup_frames() -> None:
    """Clean up frame references after each test."""
    yield
    import gc
    gc.collect()
```

This documentation covers the core functionality and testing approaches for the frame handling module. Adapt the tests and examples based on your specific use cases and requirements.
