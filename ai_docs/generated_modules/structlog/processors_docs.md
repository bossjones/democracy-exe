
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation and test examples for the given Python module:

# Module Overview

This module provides essential log processors for structlog that handle common logging tasks like formatting, rendering, and enriching log events. It's framework-agnostic and can be used with any logging system.

Key features:
- Rendering log events in various formats (JSON, key=value, logfmt)
- Handling timestamps and time formatting
- Exception formatting and pretty printing
- Unicode encoding/decoding
- Stack trace handling
- Callsite parameter enrichment

Main dependencies:
- Python 3.7+
- structlog core

# Installation

```bash
pip install structlog
```

# Usage Guide

## Basic Rendering

```python
from structlog.processors import JSONRenderer, KeyValueRenderer

# JSON rendering
json_renderer = JSONRenderer()
log_entry = json_renderer(None, None, {"event": "test", "status": "ok"})
# Returns: '{"event": "test", "status": "ok"}'

# Key-value rendering
kv_renderer = KeyValueRenderer()
log_entry = kv_renderer(None, None, {"event": "test", "status": "ok"})
# Returns: "event='test' status='ok'"
```

## Timestamp Processing

```python
from structlog.processors import TimeStamper

# ISO format timestamps
timestamper = TimeStamper(fmt="iso")
event_dict = timestamper(None, None, {"event": "test"})
# Adds ISO timestamp: {"event": "test", "timestamp": "2023-01-01T12:00:00Z"}

# Custom format
timestamper = TimeStamper(fmt="%Y-%m-%d %H:%M:%S")
event_dict = timestamper(None, None, {"event": "test"})
# Adds formatted timestamp: {"event": "test", "timestamp": "2023-01-01 12:00:00"}
```

## Exception Handling

```python
from structlog.processors import format_exc_info

try:
    1/0
except Exception:
    event_dict = format_exc_info(None, None, {
        "event": "error",
        "exc_info": True
    })
    # Adds formatted exception info to event_dict
```

# Testing Guide

Here are comprehensive test examples for the key components:

```python
# test_processors.py

from __future__ import annotations

import json
import pytest
from datetime import datetime, timezone
from typing import Any

from structlog.processors import (
    JSONRenderer,
    KeyValueRenderer,
    TimeStamper,
    ExceptionPrettyPrinter
)

class TestJSONRenderer:
    @pytest.fixture
    def renderer(self) -> JSONRenderer:
        return JSONRenderer()

    def test_basic_rendering(self, renderer: JSONRenderer) -> None:
        """Test basic JSON rendering of event dict."""
        event_dict = {"event": "test", "status": "ok"}
        result = renderer(None, None, event_dict)

        assert json.loads(result) == event_dict

    def test_custom_serializer(self) -> None:
        """Test JSON rendering with custom serializer."""
        def custom_serializer(obj: Any, **kw: Any) -> str:
            return json.dumps(obj, indent=2)

        renderer = JSONRenderer(serializer=custom_serializer)
        result = renderer(None, None, {"a": 1})

        assert result == '{\n  "a": 1\n}'

class TestKeyValueRenderer:
    @pytest.fixture
    def renderer(self) -> KeyValueRenderer:
        return KeyValueRenderer()

    def test_basic_rendering(self, renderer: KeyValueRenderer) -> None:
        """Test basic key=value rendering."""
        event_dict = {"a": 1, "b": "test"}
        result = renderer(None, None, event_dict)

        assert result == "a=1 b='test'"

    def test_ordered_keys(self) -> None:
        """Test rendering with ordered keys."""
        renderer = KeyValueRenderer(
            sort_keys=True,
            key_order=["b", "a"]
        )
        result = renderer(None, None, {"a": 1, "b": 2})

        assert result == "b=2 a=1"

class TestTimeStamper:
    @pytest.fixture
    def stamper(self) -> TimeStamper:
        return TimeStamper(fmt="iso", utc=True)

    def test_iso_timestamp(self, stamper: TimeStamper) -> None:
        """Test ISO format timestamp addition."""
        event_dict = stamper(None, None, {"event": "test"})

        timestamp = event_dict["timestamp"]
        # Verify ISO format
        datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
        assert timestamp.endswith("Z")

    def test_custom_format(self) -> None:
        """Test custom timestamp format."""
        stamper = TimeStamper(fmt="%Y-%m-%d", utc=True)
        event_dict = stamper(None, None, {})

        assert len(event_dict["timestamp"]) == 10
        datetime.strptime(event_dict["timestamp"], "%Y-%m-%d")

class TestExceptionHandling:
    @pytest.fixture
    def printer(self) -> ExceptionPrettyPrinter:
        return ExceptionPrettyPrinter()

    def test_exception_formatting(self, printer: ExceptionPrettyPrinter) -> None:
        """Test exception pretty printing."""
        try:
            raise ValueError("test error")
        except ValueError:
            event_dict = printer(None, None, {
                "exc_info": True
            })

        # Exception should be printed and removed
        assert "exc_info" not in event_dict
```

## Testing Best Practices

1. Use type hints consistently
2. Test both success and error cases
3. Use appropriate fixtures for setup
4. Test edge cases and boundary conditions
5. Mock time-dependent operations
6. Use parametrized tests for multiple scenarios
7. Test configuration options
8. Verify output formats match expectations

## Common Fixtures

```python
@pytest.fixture
def event_dict() -> dict[str, Any]:
    """Base event dictionary for testing."""
    return {"event": "test", "status": "ok"}

@pytest.fixture
def mock_datetime(mocker: MockerFixture) -> None:
    """Mock datetime for consistent timestamps."""
    dt = datetime(2023, 1, 1, 12, 0, tzinfo=timezone.utc)
    mocker.patch("datetime.datetime", autospec=True)
    datetime.datetime.now.return_value = dt

@pytest.fixture
def mock_logger() -> Mock:
    """Mock logger for testing."""
    return Mock(spec=logging.Logger)
```

This documentation provides a solid foundation for understanding and testing the processors module. Let me know if you need more specific examples or details about any particular component.
