
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation and testing examples for the `structlog.stdlib` module:

# Module Documentation: structlog.stdlib

## Module Overview

The `structlog.stdlib` module provides integration between structlog and Python's standard library logging module. It enables structured logging with the familiar standard library logging interface while adding structured data capabilities.

Key features:
- Integration with stdlib's `logging` module
- Support for both sync and async logging
- Custom formatters and processors
- Level-based filtering
- Context variable support

Core dependencies:
- Python 3.7+
- logging (stdlib)
- structlog

## Installation and Setup

```bash
pip install structlog
```

Basic configuration:

```python
import structlog
import logging

structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.TimeStamper(),
        structlog.processors.JSONRenderer()
    ],
    wrapper_class=structlog.stdlib.BoundLogger,
    logger_factory=structlog.stdlib.LoggerFactory(),
    cache_logger_on_first_use=True,
)
```

## Usage Guide

### Basic Logging

```python
logger = structlog.get_logger()

# Basic logging
logger.info("User logged in", user_id=123)

# With extra context
logger = logger.bind(request_id="abc-123")
logger.error("Request failed", error_code=500)

# Exception logging
try:
    raise ValueError("Invalid input")
except Exception:
    logger.exception("Error processing request")
```

### Async Logging

```python
import asyncio

async def main():
    logger = structlog.get_logger()

    # Async logging methods
    await logger.ainfo("Starting async operation")
    await logger.adebug("Processing", item_id=123)
    await logger.aerror("Operation failed", error="timeout")

asyncio.run(main())
```

## Testing Guide

### Basic Logger Tests

```python
import pytest
import structlog
from structlog.stdlib import BoundLogger

@pytest.fixture
def logger():
    """Create a test logger instance."""
    return structlog.get_logger()

def test_basic_logging(logger, caplog):
    """Test basic logging functionality."""
    logger.info("test message", key="value")

    assert "test message" in caplog.text
    assert "key=value" in caplog.text
    assert "info" in caplog.text.lower()

@pytest.mark.asyncio
async def test_async_logging(logger, caplog):
    """Test async logging methods."""
    await logger.ainfo("async test", data=123)

    assert "async test" in caplog.text
    assert "data=123" in caplog.text
```

### Testing with Context

```python
@pytest.fixture
def bound_logger(logger):
    """Create a logger with bound context."""
    return logger.bind(context_id="test-123")

def test_bound_context(bound_logger, caplog):
    """Test logging with bound context."""
    bound_logger.info("test with context")

    assert "context_id=test-123" in caplog.text
    assert "test with context" in caplog.text
```

### Testing Processors

```python
from structlog.stdlib import PositionalArgumentsFormatter

def test_positional_args_formatter():
    """Test the PositionalArgumentsFormatter processor."""
    formatter = PositionalArgumentsFormatter()

    event_dict = {
        "event": "Test %s: %s",
        "positional_args": ("arg1", "arg2")
    }

    result = formatter(None, "", event_dict)

    assert result["event"] == "Test arg1: arg2"
    assert "positional_args" not in result

@pytest.mark.asyncio
async def test_exception_logging(logger, caplog):
    """Test exception logging in async context."""
    try:
        raise ValueError("test error")
    except ValueError:
        await logger.aexception("Error occurred")

    assert "Error occurred" in caplog.text
    assert "ValueError" in caplog.text
    assert "test error" in caplog.text
```

### Testing Level Filtering

```python
def test_level_filtering(logger, caplog):
    """Test log level filtering."""
    caplog.set_level(logging.WARNING)

    logger.debug("Debug message")  # Should not appear
    logger.warning("Warning message")  # Should appear

    assert "Debug message" not in caplog.text
    assert "Warning message" in caplog.text
```

### Testing Custom Processors

```python
@pytest.fixture
def custom_processor():
    """Create a custom log processor."""
    def processor(logger, method_name, event_dict):
        event_dict["custom"] = "value"
        return event_dict
    return processor

def test_custom_processor(custom_processor):
    """Test adding a custom processor."""
    structlog.configure(
        processors=[custom_processor],
        wrapper_class=BoundLogger
    )

    logger = structlog.get_logger()
    logger.info("test")

    # Verify processor was applied
    assert logger._context.get("custom") == "value"
```

## Error Handling Tests

```python
def test_drop_event_handling(logger, caplog):
    """Test handling of DropEvent."""
    def dropping_processor(logger, method_name, event_dict):
        raise structlog.DropEvent

    structlog.configure(
        processors=[dropping_processor],
        wrapper_class=BoundLogger
    )

    logger.info("should be dropped")
    assert caplog.text == ""

def test_invalid_level(logger):
    """Test logging with invalid level."""
    with pytest.raises(ValueError):
        logger.log(999, "invalid level")
```

## Integration Tests

```python
def test_stdlib_integration(caplog):
    """Test integration with stdlib logging."""
    stdlib_logger = logging.getLogger("test")
    stdlib_logger.info("stdlib log")

    structlog_logger = structlog.get_logger("test")
    structlog_logger.info("structlog log")

    assert "stdlib log" in caplog.text
    assert "structlog log" in caplog.text

@pytest.mark.asyncio
async def test_async_context_preservation():
    """Test context preservation in async logging."""
    ctx_var = contextvars.ContextVar("request_id")
    ctx_var.set("req-123")

    logger = structlog.get_logger().bind()
    await logger.ainfo("async test")

    # Verify context was preserved
    assert ctx_var.get() == "req-123"
```

This documentation provides a comprehensive guide to using and testing the `structlog.stdlib` module. Let me know if you need additional examples or clarification on any part.
