
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and test examples for this module. I'll break it down into sections:

# Module Documentation

## Module Overview
This module provides logging functionality through various logger classes that write output to files or standard streams. The module includes three main logger types:
- `PrintLogger`: Uses Python's print function for output
- `WriteLogger`: Direct file writing for improved performance
- `BytesLogger`: Handles binary output

Key features:
- Thread-safe logging with file locks
- Support for both text and binary output
- Pickling support for stdout/stderr loggers
- Factory classes for each logger type
- Multiple logging levels (debug, info, warn, etc.)

Dependencies:
- Python 3.7+
- Standard library only (no external dependencies)

## Installation and Setup

```bash
# The module is part of structlog package
pip install structlog
```

## Usage Guide

### Basic Usage

```python
from structlog import PrintLogger, WriteLogger, BytesLogger

# Basic printing to stdout
logger = PrintLogger()
logger.info("Hello, world!")

# Writing to a custom file
with open("app.log", "w") as f:
    logger = WriteLogger(f)
    logger.info("Logging to file")

# Binary logging
bytes_logger = BytesLogger()
bytes_logger.info(b"Binary data")
```

### Using Factory Classes

```python
from structlog import PrintLoggerFactory

# Create a factory
factory = PrintLoggerFactory()

# Get logger instances
logger1 = factory()
logger2 = factory()
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_loggers.py
from __future__ import annotations

import io
import pickle
import pytest
import sys
import threading
from contextlib import contextmanager
from typing import Generator, TextIO, BinaryIO

from structlog import (
    PrintLogger,
    WriteLogger,
    BytesLogger,
    PrintLoggerFactory,
    WriteLoggerFactory,
    BytesLoggerFactory,
)

# Fixtures

@pytest.fixture
def string_io() -> Generator[TextIO, None, None]:
    """Provide a StringIO instance for text logging."""
    stream = io.StringIO()
    yield stream
    stream.close()

@pytest.fixture
def bytes_io() -> Generator[BinaryIO, None, None]:
    """Provide a BytesIO instance for binary logging."""
    stream = io.BytesIO()
    yield stream
    stream.close()

# PrintLogger Tests

def test_print_logger_stdout(capsys: pytest.CaptureFixture) -> None:
    """Test PrintLogger writing to stdout."""
    logger = PrintLogger()
    logger.info("test message")
    captured = capsys.readouterr()
    assert captured.out == "test message\n"

def test_print_logger_custom_file(string_io: TextIO) -> None:
    """Test PrintLogger writing to custom file."""
    logger = PrintLogger(string_io)
    logger.info("test message")
    assert string_io.getvalue() == "test message\n"

def test_print_logger_pickle() -> None:
    """Test PrintLogger pickling support."""
    logger = PrintLogger(sys.stdout)
    pickled = pickle.dumps(logger)
    unpickled = pickle.loads(pickled)
    assert isinstance(unpickled, PrintLogger)
    assert unpickled._file is sys.stdout

@pytest.mark.asyncio
async def test_print_logger_thread_safety(string_io: TextIO) -> None:
    """Test thread-safe logging."""
    logger = PrintLogger(string_io)
    messages = ["message1", "message2", "message3"]
    threads = []

    def log_message(msg: str) -> None:
        logger.info(msg)

    for msg in messages:
        thread = threading.Thread(target=log_message, args=(msg,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    output = string_io.getvalue()
    for msg in messages:
        assert f"{msg}\n" in output

# WriteLogger Tests

def test_write_logger_stdout(capsys: pytest.CaptureFixture) -> None:
    """Test WriteLogger writing to stdout."""
    logger = WriteLogger()
    logger.info("test message")
    captured = capsys.readouterr()
    assert captured.out == "test message\n"

def test_write_logger_custom_file(string_io: TextIO) -> None:
    """Test WriteLogger writing to custom file."""
    logger = WriteLogger(string_io)
    logger.info("test message")
    assert string_io.getvalue() == "test message\n"

# BytesLogger Tests

def test_bytes_logger_stdout(capsys: pytest.CaptureFixture) -> None:
    """Test BytesLogger writing to stdout."""
    logger = BytesLogger(sys.stdout.buffer)
    logger.info(b"test message")
    captured = capsys.readouterr()
    assert captured.out == "test message\n"

def test_bytes_logger_custom_file(bytes_io: BinaryIO) -> None:
    """Test BytesLogger writing to custom file."""
    logger = BytesLogger(bytes_io)
    logger.info(b"test message")
    assert bytes_io.getvalue() == b"test message\n"

# Factory Tests

def test_print_logger_factory() -> None:
    """Test PrintLoggerFactory."""
    factory = PrintLoggerFactory()
    logger = factory()
    assert isinstance(logger, PrintLogger)

def test_write_logger_factory() -> None:
    """Test WriteLoggerFactory."""
    factory = WriteLoggerFactory()
    logger = factory()
    assert isinstance(logger, WriteLogger)

def test_bytes_logger_factory() -> None:
    """Test BytesLoggerFactory."""
    factory = BytesLoggerFactory()
    logger = factory()
    assert isinstance(logger, BytesLogger)

# Error Cases

def test_print_logger_pickle_custom_file(string_io: TextIO) -> None:
    """Test PrintLogger pickling with custom file raises error."""
    logger = PrintLogger(string_io)
    with pytest.raises(pickle.PicklingError):
        pickle.dumps(logger)

def test_write_logger_invalid_deepcopy(string_io: TextIO) -> None:
    """Test WriteLogger deepcopy with custom file raises error."""
    logger = WriteLogger(string_io)
    with pytest.raises(copy.error):
        copy.deepcopy(logger)
```

## Testing Best Practices

1. Thread Safety Testing:
- Test concurrent logging operations
- Verify lock acquisition and release
- Check output consistency

2. Resource Management:
- Use fixtures for file handling
- Ensure proper cleanup
- Test file descriptor leaks

3. Error Handling:
- Test invalid file operations
- Verify pickling restrictions
- Check deepcopy limitations

4. Output Verification:
- Test different log levels
- Verify output format
- Check newline handling

5. Performance Testing:
```python
import time

def test_logger_performance() -> None:
    """Benchmark different logger implementations."""
    message = "test message"
    iterations = 10000

    def benchmark(logger: Any) -> float:
        start = time.time()
        for _ in range(iterations):
            logger.info(message)
        return time.time() - start

    print_time = benchmark(PrintLogger())
    write_time = benchmark(WriteLogger())

    assert write_time < print_time  # WriteLogger should be faster
```

## Error Handling and Edge Cases

1. File Permission Errors:
```python
def test_file_permissions() -> None:
    """Test logging to write-protected file."""
    with pytest.raises(IOError):
        with open("/root/test.log", "w") as f:
            logger = WriteLogger(f)
            logger.info("test")
```

2. Memory Management:
```python
def test_memory_usage() -> None:
    """Test memory usage with large log volumes."""
    logger = WriteLogger()
    large_message = "x" * 1000000
    for _ in range(1000):
        logger.info(large_message)
```

## Integration Testing

```python
def test_structlog_integration() -> None:
    """Test integration with structlog."""
    import structlog

    structlog.configure(
        logger_factory=WriteLoggerFactory(),
        processors=[structlog.processors.JSONRenderer()]
    )

    logger = structlog.get_logger()
    logger.info("test", key="value")
```

Remember to run tests with:
```bash
pytest test_loggers.py -v --cov=structlog.loggers
```

This documentation and test suite provide comprehensive coverage of the module's functionality while following best practices for Python testing and type safety.
