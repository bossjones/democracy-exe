
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation for the tracebacks module:

# Tracebacks Module Documentation

## Module Overview

The tracebacks module provides enhanced exception handling and traceback formatting capabilities with a focus on structured logging. It offers features for:

- Extracting detailed traceback information including local variables
- Formatting exceptions as structured JSON data
- Customizable traceback presentation
- Special handling for syntax errors
- Support for exception chaining
- Secure handling of sensitive data

Key features:
- Custom string representation for sensitive data
- Configurable traceback depth and detail level
- Rich integration for improved representation
- Local variable capture and filtering
- Exception cause tracking

## Installation and Setup

```bash
pip install structlog
```

Dependencies:
- Python 3.7+
- rich (optional) - for enhanced repr formatting
- pytest (for testing)

## Usage Guide

### Basic Usage

```python
from structlog import tracebacks

try:
    1/0
except Exception as e:
    # Extract traceback information
    trace = tracebacks.extract(type(e), e, e.__traceback__)

    # Convert to JSON-serializable format
    formatter = tracebacks.ExceptionDictTransformer(show_locals=True)
    json_trace = formatter((type(e), e, e.__traceback__))
```

### Working with Sensitive Data

```python
from structlog.tracebacks import SecretStr

# Mask sensitive values
password = SecretStr("secret123")
print(repr(password))  # Outputs: *******
```

### Customizing Traceback Output

```python
formatter = tracebacks.ExceptionDictTransformer(
    show_locals=True,
    locals_max_string=50,
    max_frames=20,
    locals_hide_sunder=True,
    locals_hide_dunder=True
)
```

## Testing Guide

### Test Fixtures

```python
@pytest.fixture(autouse=True)
def _unimport_rich(monkeypatch: pytest.MonkeyPatch) -> None:
    """Ensure Rich integration is disabled for consistent testing."""
    monkeypatch.setattr(tracebacks, "rich", None)

@pytest.fixture
def sample_exception() -> tuple[type[Exception], Exception, TracebackType]:
    """Generate a sample exception with traceback for testing."""
    try:
        1/0
    except Exception as e:
        return (type(e), e, e.__traceback__)
```

### Basic Exception Handling Tests

```python
def test_simple_exception():
    """Test basic exception extraction."""
    try:
        line_number = get_next_lineno()
        1/0
    except Exception as e:
        trace = tracebacks.extract(type(e), e, e.__traceback__)

    assert trace.stacks[0].exc_type == "ZeroDivisionError"
    assert trace.stacks[0].exc_value == "division by zero"
    assert trace.stacks[0].frames[0].lineno == line_number
```

### Testing Sensitive Data Handling

```python
def test_secret_str_representation():
    """Test that sensitive data is properly masked."""
    secret = SecretStr("sensitive_value")

    assert repr(secret) == "*******"
    assert str(secret) == "sensitive_value"
```

### Testing Rich Integration

```python
@pytest.mark.parametrize(
    ("use_rich", "data", "expected"),
    [
        (True, "test", "'test'"),
        (False, "test", "'test'"),
    ]
)
def test_rich_formatting(
    use_rich: bool,
    data: Any,
    expected: str,
    monkeypatch: pytest.MonkeyPatch,
):
    """Test Rich integration for improved representation."""
    try:
        import rich
        monkeypatch.setattr(tracebacks, "rich", rich if use_rich else None)

        result = tracebacks.to_repr(data, use_rich=use_rich)
        assert result == expected

    except ImportError:
        pytest.skip("rich not installed")
```

### Testing Error Cases

```python
def test_invalid_formatter_config():
    """Test validation of formatter configuration."""
    with pytest.raises(ValueError, match="max_frames"):
        tracebacks.ExceptionDictTransformer(max_frames=-1)

def test_repr_error_handling():
    """Test handling of objects with broken __repr__."""
    class BrokenRepr:
        def __repr__(self) -> str:
            raise ValueError("repr error")

    obj = BrokenRepr()
    result = tracebacks.to_repr(obj)
    assert result == "<repr-error 'repr error'>"
```

## Error Handling and Edge Cases

### Handling Recursive Exceptions

```python
def test_recursive_exception():
    """Test handling of recursive exceptions."""
    def recursive():
        return recursive()

    try:
        recursive()
    except RecursionError as e:
        trace = tracebacks.extract(type(e), e, e.__traceback__)
        assert "maximum recursion depth exceeded" in trace.stacks[0].exc_value
```

## Performance Considerations

- Use `locals_max_string` to limit memory usage when capturing local variables
- Consider disabling `show_locals` for production environments
- Use `max_frames` to limit traceback depth in resource-constrained environments

## Best Practices

1. Always handle sensitive data using SecretStr
2. Configure appropriate frame limits for your use case
3. Test both simple and complex exception scenarios
4. Consider Rich integration for development environments
5. Use type hints consistently in test code
6. Test both success and error paths
7. Document expected behavior in test docstrings

This documentation provides a foundation for understanding and using the tracebacks module effectively. The test examples demonstrate proper usage patterns and error handling approaches.
