
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this module.

# Module Documentation: Test Utilities

## Module Overview
This module provides shared testing utilities for the structlog ecosystem. It defines common testing resources, including a collection of standard logging methods and a custom exception class for testing scenarios.

### Key Features
- Provides a filtered list of standard logging methods
- Includes a custom exception class for testing
- Integrates with structlog's logging level system

### Dependencies
- structlog >= 23.1.0
- Python >= 3.8

## Installation and Setup

```bash
pip install structlog
```

## Usage Guide

### Standard Logging Methods
The module provides `stdlib_log_methods`, a list of standard logging method names excluding 'notset':

```python
from test_utilities import stdlib_log_methods

# Available methods include: debug, info, warning, error, critical
print(stdlib_log_methods)  # ['debug', 'info', 'warning', 'error', 'critical']
```

### Custom Exception
Use `CustomError` for testing error handling:

```python
from test_utilities import CustomError

def function_under_test():
    raise CustomError("Test error message")
```

## Testing Guide

Here's a comprehensive test suite for the module:

```python
# test_utilities_test.py
from __future__ import annotations

import pytest
from typing import List

from test_utilities import stdlib_log_methods, CustomError


def test_stdlib_log_methods_content() -> None:
    """
    Test that stdlib_log_methods contains expected logging methods.
    """
    expected_methods = ["debug", "info", "warning", "error", "critical"]
    assert isinstance(stdlib_log_methods, list)
    assert sorted(stdlib_log_methods) == sorted(expected_methods)


def test_stdlib_log_methods_excludes_notset() -> None:
    """
    Test that 'notset' is not included in stdlib_log_methods.
    """
    assert "notset" not in stdlib_log_methods


def test_custom_error_instantiation() -> None:
    """
    Test CustomError can be instantiated with a message.
    """
    error_msg = "Test error message"
    error = CustomError(error_msg)
    assert str(error) == error_msg


def test_custom_error_inheritance() -> None:
    """
    Test CustomError inherits from Exception.
    """
    assert issubclass(CustomError, Exception)


@pytest.fixture
def log_methods() -> List[str]:
    """
    Fixture providing stdlib_log_methods for tests.

    Returns:
        List[str]: List of standard logging methods
    """
    return stdlib_log_methods


def test_log_methods_fixture(log_methods: List[str]) -> None:
    """
    Test the log_methods fixture provides expected data.

    Args:
        log_methods: List of logging methods from fixture
    """
    assert len(log_methods) > 0
    assert all(isinstance(method, str) for method in log_methods)


def test_custom_error_in_context() -> None:
    """
    Test CustomError in a context manager.
    """
    with pytest.raises(CustomError) as exc_info:
        raise CustomError("Test exception")
    assert str(exc_info.value) == "Test exception"
```

## Testing Best Practices

### Fixture Usage
Create reusable fixtures for common test scenarios:

```python
@pytest.fixture
def error_factory() -> CustomError:
    """
    Fixture providing a CustomError instance.

    Returns:
        CustomError: Configured error instance
    """
    return CustomError("Test error")
```

### Error Testing
Test various error scenarios:

```python
def test_custom_error_chaining() -> None:
    """
    Test exception chaining with CustomError.
    """
    try:
        try:
            raise ValueError("Original error")
        except ValueError as e:
            raise CustomError("Chained error") from e
    except CustomError as e:
        assert isinstance(e.__cause__, ValueError)
        assert str(e) == "Chained error"
```

## Error Handling and Edge Cases

```python
def test_empty_custom_error() -> None:
    """
    Test CustomError with no message.
    """
    error = CustomError()
    assert str(error) == ""


def test_custom_error_with_non_string_message() -> None:
    """
    Test CustomError with non-string message.
    """
    error = CustomError(123)
    assert str(error) == "123"
```

## Integration Testing

```python
import logging
from typing import Generator
import pytest

@pytest.fixture
def logger() -> Generator[logging.Logger, None, None]:
    """
    Fixture providing a configured logger.

    Yields:
        logging.Logger: Configured logger instance
    """
    logger = logging.getLogger("test_logger")
    logger.setLevel(logging.DEBUG)
    yield logger
    logger.handlers.clear()


def test_log_methods_integration(logger: logging.Logger) -> None:
    """
    Test integration with Python's logging system.

    Args:
        logger: Configured logger instance
    """
    for method in stdlib_log_methods:
        log_func = getattr(logger, method)
        log_func("Test message")
```

## Debugging and Troubleshooting

To debug tests:

```python
import pytest
import pdb

def test_with_debugger() -> None:
    """
    Example of using pdb for debugging.
    """
    error = CustomError("Debug this")
    pdb.set_trace()  # Breakpoint for debugging
    assert isinstance(error, Exception)
```

## Type Hints Usage
The module supports static type checking:

```python
from typing import Type, List

def process_error(error_class: Type[CustomError]) -> None:
    """
    Process error with type hints.

    Args:
        error_class: CustomError class reference
    """
    try:
        raise error_class("Typed error")
    except error_class as e:
        assert isinstance(e, Exception)
```

This documentation provides a comprehensive guide for using and testing the module. Remember to run tests with:

```bash
pytest test_utilities_test.py -v --cov=test_utilities
```

For proper test isolation and coverage reporting, ensure you have pytest and pytest-cov installed:

```bash
pip install pytest pytest-cov
```
