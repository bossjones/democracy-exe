
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this Python module focused on the FilteringLogger functionality.

# FilteringLogger Module Documentation

## Module Overview

The FilteringLogger module provides a logging system with level-based filtering and async support built on top of structlog. It implements both synchronous and asynchronous logging methods with built-in level filtering, string interpolation, and context variable handling.

Key Features:
- Level-based log filtering
- Async logging support
- String interpolation
- Exception handling
- Context variable integration
- Pickle serialization support

Dependencies:
- Python 3.7+
- structlog
- pytest (for testing)
- pytest-asyncio (for async tests)

## Installation and Setup

```bash
pip install structlog
pip install pytest pytest-asyncio  # for testing
```

## Usage Guide

### Basic Usage

```python
import logging
from structlog import make_filtering_bound_logger

# Create a filtered logger at INFO level
logger = make_filtering_bound_logger(logging.INFO)

# Basic logging
logger.info("Hello world")  # Will log
logger.debug("Debug message")  # Won't log (below INFO)

# With string interpolation
logger.info("Hello %s!", "user")  # Will log "Hello user!"

# Exception logging
try:
    raise ValueError("Something went wrong")
except Exception:
    logger.exception("An error occurred")  # Automatically includes exc_info
```

### Async Usage

```python
# Async logging methods
async def async_function():
    logger = make_filtering_bound_logger(logging.INFO)

    await logger.ainfo("Async message")
    await logger.adebug("Won't be logged")
    await logger.aexception("Async error")
```

### Context Variables

```python
from structlog.contextvars import bind_contextvars, clear_contextvars

# Setup context variables
clear_contextvars()
bind_contextvars(user_id="123", session="abc")

# Logging with context
logger.info("User action")  # Will include context variables
```

## Testing Guide

### Basic Test Setup

```python
import pytest
from structlog import make_filtering_bound_logger

@pytest.fixture
def logger_fixture():
    """Create a test logger fixture."""
    return make_filtering_bound_logger(logging.INFO)

def test_basic_logging(logger_fixture, capture_logs):
    """Test basic logging functionality."""
    logger_fixture.info("test message")
    assert len(capture_logs) == 1
    assert capture_logs[0]["event"] == "test message"
```

### Async Test Examples

```python
import pytest

@pytest.mark.asyncio
async def test_async_logging(logger_fixture, capture_logs):
    """Test async logging functionality."""
    await logger_fixture.ainfo("async test")
    assert len(capture_logs) == 1
    assert capture_logs[0]["event"] == "async test"
```

### Testing Log Levels

```python
def test_log_filtering(logger_fixture, capture_logs):
    """Test log level filtering."""
    logger_fixture.debug("debug message")  # Should not log
    logger_fixture.info("info message")    # Should log

    assert len(capture_logs) == 1
    assert capture_logs[0]["event"] == "info message"
```

### Exception Testing

```python
@pytest.mark.asyncio
async def test_exception_logging(logger_fixture, capture_logs):
    """Test exception logging behavior."""
    try:
        raise ValueError("test error")
    except Exception:
        await logger_fixture.aexception("Error occurred")

    assert len(capture_logs) == 1
    assert capture_logs[0]["exc_info"] is not None
```

### Context Variable Testing

```python
def test_context_vars(logger_fixture, capture_logs):
    """Test context variable integration."""
    from structlog.contextvars import bind_contextvars, clear_contextvars

    clear_contextvars()
    bind_contextvars(user="test_user")

    logger_fixture.info("user action")

    assert capture_logs[0]["user"] == "test_user"
```

### String Interpolation Testing

```python
def test_string_interpolation(logger_fixture, capture_logs):
    """Test string interpolation in log messages."""
    logger_fixture.info("Hello %s!", "world")
    assert capture_logs[0]["event"] == "Hello world!"
```

## Testing Best Practices

1. Use Fixtures Effectively:
```python
@pytest.fixture
def clean_context():
    """Ensure clean context variables between tests."""
    clear_contextvars()
    yield
    clear_contextvars()
```

2. Test Isolation:
```python
@pytest.mark.usefixtures("clean_context")
class TestLogging:
    def test_isolated_logging(self, logger_fixture):
        # Each test starts with clean context
        pass
```

3. Error Case Testing:
```python
def test_invalid_log_level(logger_fixture):
    """Test handling of invalid log levels."""
    with pytest.raises(ValueError):
        logger_fixture.log(999, "invalid level")
```

## Error Handling and Edge Cases

```python
def test_missing_event_string(logger_fixture):
    """Test handling of missing event string."""
    with pytest.raises(TypeError):
        logger_fixture.info(missing="event string")

def test_none_message(logger_fixture, capture_logs):
    """Test handling of None as message."""
    logger_fixture.info(None)
    assert capture_logs[0]["event"] is None
```

## Debugging Tips

1. Enable Debug Logging:
```python
logger = make_filtering_bound_logger(logging.DEBUG)
```

2. Use Context Variables for Debugging:
```python
bind_contextvars(debug_mode=True)
```

3. Capture Logs in Tests:
```python
def test_with_log_capture(caplog):
    """Test with log capture."""
    with caplog.at_level(logging.INFO):
        # Your test code
```

This documentation should provide a solid foundation for understanding and testing the FilteringLogger module. Remember to adapt the tests and examples to your specific use cases and requirements.
