
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this structlog testing module.

# Structlog Testing Module Documentation

## Module Overview

This module provides testing utilities for the structlog library, enabling developers to capture and verify logging behavior in their applications.

### Key Features
- Log capture functionality
- Test-specific logger implementations
- Processor management during testing
- Structured log verification

### Dependencies
- pytest
- structlog

## Installation and Setup

```bash
pip install structlog pytest
```

## Usage Guide

### 1. Capturing Logs

The `capture_logs()` context manager allows capturing structured log entries during tests:

```python
from structlog.testing import capture_logs

def test_my_logging():
    with capture_logs() as logs:
        # Your logging code here
        logger.info("test message", extra_field="value")

    assert logs == [{
        "event": "test message",
        "extra_field": "value",
        "log_level": "info"
    }]
```

### 2. Return Logger

The `ReturnLogger` class provides a simple logger that returns the message it receives:

```python
from structlog.testing import ReturnLogger

logger = ReturnLogger()
result = logger.info("test")  # Returns "test"
```

### 3. Capturing Logger

The `CapturingLogger` records all logging calls for verification:

```python
from structlog.testing import CapturingLogger

logger = CapturingLogger()
logger.info("hello", extra=42)

assert logger.calls[0].method_name == "info"
assert logger.calls[0].args == ("hello",)
assert logger.calls[0].kwargs == {"extra": 42}
```

## Testing Guide

### 1. Basic Log Capture Tests

```python
import pytest
from structlog import get_logger
from structlog.testing import capture_logs

def test_basic_logging():
    """Test basic log capture functionality."""
    with capture_logs() as logs:
        logger = get_logger()
        logger.info("test message", data={"key": "value"})

    assert len(logs) == 1
    assert logs[0]["event"] == "test message"
    assert logs[0]["data"] == {"key": "value"}
    assert logs[0]["log_level"] == "info"
```

### 2. Testing Bound Loggers

```python
def test_bound_logger():
    """Test logging with bound context."""
    logger = get_logger().bind(context="test")

    with capture_logs() as logs:
        logger.info("bound message")

    assert logs[0]["context"] == "test"
    assert logs[0]["event"] == "bound message"
```

### 3. Testing Exception Logging

```python
def test_exception_logging():
    """Test exception logging capture."""
    with capture_logs() as logs:
        try:
            raise ValueError("test error")
        except ValueError:
            get_logger().exception("caught error")

    assert logs[0]["log_level"] == "error"
    assert logs[0]["exc_info"] is True
```

### 4. Testing with Fixtures

```python
@pytest.fixture
def capturing_logger():
    """Fixture providing a capturing logger."""
    return CapturingLogger()

def test_logger_calls(capturing_logger):
    """Test logging call capture."""
    capturing_logger.info("test", x=1)
    capturing_logger.error("error", y=2)

    assert len(capturing_logger.calls) == 2
    assert capturing_logger.calls[0].method_name == "info"
    assert capturing_logger.calls[1].kwargs == {"y": 2}
```

### 5. Testing Processor Management

```python
def test_processor_management():
    """Test processor handling during capture."""
    original_processors = get_config()["processors"]

    with capture_logs() as logs:
        assert len(get_config()["processors"]) == 1
        get_logger().info("test")

    assert get_config()["processors"] is original_processors
```

## Testing Best Practices

1. **Isolation**: Always use fresh logger instances in tests
```python
@pytest.fixture(autouse=True)
def clean_structlog():
    """Reset structlog configuration before each test."""
    structlog.reset_defaults()
    yield
```

2. **Context Verification**: Check both log content and context
```python
def test_log_context():
    logger = get_logger().bind(user_id="123")
    with capture_logs() as logs:
        logger.info("user action")
    assert logs[0]["user_id"] == "123"
```

3. **Exception Handling**: Test both normal and error paths
```python
def test_error_logging():
    with capture_logs() as logs:
        with pytest.raises(ValueError):
            get_logger().error("error", exc_info=True)
            raise ValueError()
    assert logs[0]["exc_info"] is True
```

## Common Test Fixtures

```python
@pytest.fixture
def structured_logger():
    """Provide configured structured logger."""
    return get_logger().bind(test_id=str(uuid.uuid4()))

@pytest.fixture
def log_capture():
    """Provide log capture context."""
    with capture_logs() as logs:
        yield logs

@pytest.fixture
def capturing_logger_factory():
    """Provide capturing logger factory."""
    return CapturingLoggerFactory()
```

## Error Handling and Edge Cases

```python
def test_invalid_log_level():
    """Test handling of invalid log levels."""
    logger = ReturnLogger()
    with pytest.raises(AttributeError):
        logger.invalid_level("test")

def test_empty_capture():
    """Test behavior with no logs."""
    with capture_logs() as logs:
        pass
    assert logs == []
```

## Performance Testing

```python
def test_logger_performance(benchmark):
    """Benchmark logging performance."""
    logger = get_logger()

    def log_operation():
        logger.info("test", data={"key": "value"})

    benchmark(log_operation)
```

This documentation provides a comprehensive guide for using and testing the structlog testing module. Each section includes practical examples and best practices for different testing scenarios.
