
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

Here's comprehensive documentation and test examples for the given Python module:

# Module Overview

This module provides processors for structlog that handle text encoding, exception formatting, and logging metadata. The key components are:

- UnicodeEncoder/UnicodeDecoder - Handle text encoding/decoding
- ExceptionPrettyPrinter - Formats exception information
- StackInfoRenderer - Adds stack trace information
- CallsiteParameterAdder - Adds call site metadata to log entries
- EventRenamer - Renames event fields

## Key Features
- Unicode text handling
- Pretty printing of exceptions
- Stack trace capturing
- Call site parameter logging
- Event field renaming

## Dependencies
- structlog
- pytest (for testing)
- simplejson (optional)

# Installation and Setup

```bash
pip install structlog pytest pytest-mock pytest-asyncio
```

# Usage Guide

## Unicode Encoding/Decoding

```python
from structlog.processors import UnicodeEncoder, UnicodeDecoder

# Create encoders/decoders with specific encoding
encoder = UnicodeEncoder(encoding='utf-8')
decoder = UnicodeDecoder(encoding='utf-8')

# Process event dictionaries
encoded = encoder(None, None, {"message": "här"})
decoded = decoder(None, None, {"message": b"h\xc3\xa4r"})
```

## Exception Formatting

```python
from structlog.processors import ExceptionPrettyPrinter
import sys

printer = ExceptionPrettyPrinter(file=sys.stdout)

try:
    raise ValueError("test error")
except ValueError:
    # Format exception info
    event_dict = printer(None, None, {"exc_info": True})
```

## Stack Trace Rendering

```python
from structlog.processors import StackInfoRenderer

renderer = StackInfoRenderer()

# Add stack trace to event dict
event_dict = renderer(None, None, {"stack_info": True})
```

# Testing Guide

Here's comprehensive test coverage for the major components:

## Unicode Encoder Tests

```python
from structlog.processors import UnicodeEncoder
import pytest

class TestUnicodeEncoder:
    def test_encodes_utf8(self):
        """Test UTF-8 encoding of unicode strings."""
        encoder = UnicodeEncoder()
        result = encoder(None, None, {"msg": "här"})

        assert result == {"msg": b"h\xc3\xa4r"}

    def test_custom_encoding(self):
        """Test custom encoding options."""
        encoder = UnicodeEncoder("latin1", "ignore")
        result = encoder(None, None, {"msg": "∞"})

        assert isinstance(result["msg"], bytes)

    def test_bytes_passthrough(self):
        """Test that bytes are passed through unchanged."""
        encoder = UnicodeEncoder()
        input_bytes = b"test"
        result = encoder(None, None, {"msg": input_bytes})

        assert result["msg"] is input_bytes
```

## Exception Printer Tests

```python
from structlog.processors import ExceptionPrettyPrinter
from io import StringIO
import pytest

class TestExceptionPrettyPrinter:
    @pytest.fixture
    def string_output(self):
        return StringIO()

    def test_formats_exception(self, string_output):
        """Test exception formatting."""
        printer = ExceptionPrettyPrinter(file=string_output)

        try:
            raise ValueError("test error")
        except ValueError:
            result = printer(None, None, {"exc_info": True})

        output = string_output.getvalue()
        assert "ValueError: test error" in output
        assert "test_formats_exception" in output

    def test_removes_exc_info(self, string_output):
        """Test exc_info is removed after processing."""
        printer = ExceptionPrettyPrinter(file=string_output)

        try:
            raise ValueError()
        except ValueError:
            result = printer(None, None, {"exc_info": True})

        assert "exc_info" not in result

    @pytest.mark.asyncio
    async def test_async_exception(self, string_output):
        """Test exception handling in async context."""
        printer = ExceptionPrettyPrinter(file=string_output)

        try:
            await self.async_raise()
        except ValueError:
            result = printer(None, None, {"exc_info": True})

        output = string_output.getvalue()
        assert "async_raise" in output

    async def async_raise(self):
        raise ValueError("async error")
```

## CallsiteParameterAdder Tests

```python
import pytest
from structlog.processors import CallsiteParameterAdder
from structlog.stdlib import BoundLogger

class TestCallsiteParameterAdder:
    @pytest.fixture
    def processor(self):
        return CallsiteParameterAdder()

    def test_adds_basic_params(self, processor):
        """Test basic parameter addition."""
        result = processor(None, None, {"event": "test"})

        assert "pathname" in result
        assert "lineno" in result
        assert "func_name" in result

    def test_parameter_filtering(self):
        """Test parameter filtering."""
        processor = CallsiteParameterAdder(
            parameters={"pathname", "lineno"}
        )
        result = processor(None, None, {"event": "test"})

        assert "pathname" in result
        assert "lineno" in result
        assert "func_name" not in result

    @pytest.mark.asyncio
    async def test_async_callsite(self):
        """Test async callsite parameters."""
        processor = CallsiteParameterAdder()

        async def async_log():
            return processor(None, None, {"event": "test"})

        result = await async_log()

        assert "async_log" in result["func_name"]
```

## Best Practices

1. Use pytest fixtures for common setup
2. Test both sync and async code paths
3. Test edge cases and error conditions
4. Use appropriate string encodings in tests
5. Clean up resources (like file handles)
6. Test parameter validation
7. Cover all processor configurations
8. Test integration with structlog

## Common Test Fixtures

```python
@pytest.fixture
def string_output():
    """Provide StringIO for capturing output."""
    return StringIO()

@pytest.fixture
def basic_event_dict():
    """Provide basic event dictionary."""
    return {"event": "test message"}

@pytest.fixture
def logger():
    """Provide configured structlog logger."""
    return structlog.getLogger()
```

## Error Handling

```python
def test_invalid_encoding():
    """Test handling of invalid encoding."""
    with pytest.raises(LookupError):
        UnicodeEncoder(encoding="invalid")

def test_codec_error():
    """Test handling of codec errors."""
    encoder = UnicodeEncoder("ascii", "strict")
    with pytest.raises(UnicodeEncodeError):
        encoder(None, None, {"msg": "här"})
```

This documentation covers the key functionality and testing approaches for the module. The test examples demonstrate best practices for testing structlog processors including async support, error handling, and proper fixture usage.

Let me know if you would like me to expand on any particular aspect!
