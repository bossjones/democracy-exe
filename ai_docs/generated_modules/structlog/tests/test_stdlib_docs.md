
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module, focusing on the stdlib logger integration aspects and testing patterns.

# structlog Stdlib Integration Documentation

## Module Overview

This module provides integration between structlog and Python's standard library logging. It enables structured logging with both sync and async capabilities while maintaining compatibility with stdlib's logging module.

Key features:
- Seamless integration with stdlib logging
- Support for both sync and async logging
- Processor-based formatting
- Level-based filtering
- Context binding
- Exception handling

### Core Components

1. LoggerFactory - Creates stdlib-compatible loggers
2. BoundLogger - Synchronous logging interface
3. AsyncBoundLogger - Asynchronous logging interface
4. ProcessorFormatter - Formats log entries for stdlib compatibility

## Installation and Setup

```bash
pip install structlog
```

Required dependencies:
- Python 3.7+
- structlog
- pytest (for testing)
- pytest-asyncio (for async tests)

## Basic Configuration

```python
import structlog
from structlog.stdlib import BoundLogger, LoggerFactory, ProcessorFormatter

# Basic configuration
structlog.configure(
    processors=[
        structlog.stdlib.add_log_level,
        structlog.processors.JSONRenderer()
    ],
    logger_factory=LoggerFactory(),
    wrapper_class=BoundLogger,
    cache_logger_on_first_use=True
)
```

## Usage Guide

### Sync Logging Example

```python
import structlog

logger = structlog.get_logger()

# Basic logging
logger.info("Hello world", extra_field="value")

# With context
logger.bind(request_id="123").info("Processing request")

# Exception logging
try:
    raise ValueError("Something went wrong")
except Exception:
    logger.exception("Error occurred")
```

### Async Logging Example

```python
import structlog
from structlog.stdlib import AsyncBoundLogger

structlog.configure(
    wrapper_class=AsyncBoundLogger
)

logger = structlog.get_logger()

async def process_request():
    bound_logger = logger.bind(request_id="123")
    await bound_logger.info("Processing async request")
```

## Testing Guide

### Basic Logger Testing

```python
import pytest
from structlog.testing import CapturedCall

@pytest.fixture
def logger():
    return structlog.get_logger()

def test_basic_logging(logger):
    """Test basic logging functionality."""
    logger.info("test message", extra="value")

    # Assert log output
    assert len(logger.calls) == 1
    assert logger.calls[0].method_name == "info"
    assert logger.calls[0].args[0] == "test message"
```

### Testing ProcessorFormatter

```python
import pytest
from structlog.stdlib import ProcessorFormatter
from structlog.processors import JSONRenderer

@pytest.fixture
def processor_formatter():
    return ProcessorFormatter(
        processor=JSONRenderer(),
        keep_exc_info=True
    )

def test_formatter_processes_record(processor_formatter):
    """Test ProcessorFormatter handles log records correctly."""
    record = logging.LogRecord(
        name="test_logger",
        level=logging.INFO,
        pathname="test.py",
        lineno=1,
        msg="Test message",
        args=(),
        exc_info=None
    )

    formatted = processor_formatter.format(record)
    assert isinstance(formatted, str)
    assert "Test message" in formatted
```

### Testing Async Logging

```python
import pytest
import structlog
from structlog.stdlib import AsyncBoundLogger

@pytest.mark.asyncio
class TestAsyncLogging:
    @pytest.fixture
    async def async_logger(self):
        return structlog.get_logger(wrapper_class=AsyncBoundLogger)

    async def test_async_logging(self, async_logger):
        """Test async logging functionality."""
        await async_logger.info("async test")

        # Verify log output
        assert len(async_logger.calls) == 1
        assert async_logger.calls[0].method_name == "info"
```

### Testing Exception Handling

```python
import pytest

def test_exception_logging(logger):
    """Test exception logging behavior."""
    try:
        raise ValueError("Test error")
    except ValueError:
        logger.exception("Error occurred")

    assert len(logger.calls) == 1
    assert logger.calls[0].kwargs.get("exc_info")
    assert "Error occurred" in logger.calls[0].args[0]
```

### Testing Level Filtering

```python
import pytest
from structlog.stdlib import filter_by_level
import logging

def test_level_filtering():
    """Test log level filtering."""
    logger = logging.Logger("test")
    logger.setLevel(logging.WARNING)

    # Should be filtered out
    with pytest.raises(structlog.exceptions.DropEvent):
        filter_by_level(logger, "debug", {})

    # Should pass through
    event_dict = {"event": "test"}
    assert filter_by_level(logger, "error", event_dict) == event_dict
```

### Integration Testing

```python
import pytest
import logging
import structlog

@pytest.fixture
def configure_logging():
    """Configure both structlog and stdlib logging."""
    logging.basicConfig(level=logging.INFO)
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_log_level,
            structlog.processors.JSONRenderer()
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
        cache_logger_on_first_use=True
    )

def test_integrated_logging(configure_logging):
    """Test both structlog and stdlib logging working together."""
    stdlib_logger = logging.getLogger("test")
    struct_logger = structlog.get_logger("test")

    stdlib_logger.info("stdlib log")
    struct_logger.info("structlog log")

    # Add assertions for log output
```

## Best Practices

1. Always use type hints in tests
2. Create fixtures for common test scenarios
3. Test both success and failure cases
4. Use appropriate markers for async tests
5. Clean up resources in teardown
6. Test different log levels
7. Verify context binding
8. Test exception handling
9. Check processor chains
10. Validate output formats

## Error Handling

```python
def test_error_handling():
    """Test error handling in logging."""
    logger = structlog.get_logger()

    # Test invalid log level
    with pytest.raises(ValueError):
        logger.log(999, "Invalid level")

    # Test processor exception
    def failing_processor(logger, method_name, event_dict):
        raise ValueError("Processor error")

    logger = logger.new(processors=[failing_processor])
    with pytest.raises(ValueError):
        logger.info("test")
```

This documentation provides a solid foundation for working with and testing the structlog stdlib integration. Additional sections can be added based on specific needs or use cases.
