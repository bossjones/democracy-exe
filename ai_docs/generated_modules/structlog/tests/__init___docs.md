
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this dual-licensed Python module.

# Module Documentation for Dual-Licensed Python Module

## Module Overview

This module is dual-licensed under both MIT and Apache 2.0 licenses, providing users flexibility in license compliance. The dual licensing allows:
- Commercial use under either license
- Integration with both MIT and Apache 2.0 licensed projects
- License compatibility with a wide range of open source projects

### Key Features
- Dual license compatibility
- SPDX license identifier compliance
- Clear license attribution

### Requirements
- Python 3.7+
- No additional dependencies for core functionality

## Installation and Setup

```bash
# Clone the repository
git clone https://github.com/your-repo/dual-licensed-module.git

# Install using pip
pip install .

# For development installation
pip install -e ".[dev]"
```

## License Verification Examples

```python
def verify_license_header(file_path: str) -> bool:
    """Verify if file contains proper license header.

    Args:
        file_path: Path to source file

    Returns:
        bool: True if valid license header found
    """
    with open(file_path, 'r') as f:
        content = f.read()
        return "SPDX-License-Identifier: MIT OR Apache-2.0" in content
```

## Testing Guide

### 1. License Header Tests

```python
# test_licensing.py
from pathlib import Path
from typing import Generator
import pytest

@pytest.fixture
def sample_file(tmp_path: Path) -> Generator[Path, None, None]:
    """Create sample file with license header.

    Args:
        tmp_path: Pytest temporary directory fixture

    Yields:
        Path: Path to test file
    """
    file_path = tmp_path / "test_file.py"
    content = """# SPDX-License-Identifier: MIT OR Apache-2.0
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the MIT License.

def sample_function():
    pass
"""
    file_path.write_text(content)
    yield file_path

def test_valid_license_header(sample_file: Path) -> None:
    """Test detection of valid license header.

    Args:
        sample_file: Path to test file
    """
    assert verify_license_header(str(sample_file)) is True

def test_missing_license_header(tmp_path: Path) -> None:
    """Test detection of missing license header.

    Args:
        tmp_path: Pytest temporary directory fixture
    """
    invalid_file = tmp_path / "invalid.py"
    invalid_file.write_text("def invalid_function():\n    pass")
    assert verify_license_header(str(invalid_file)) is False
```

### 2. License File Tests

```python
# test_license_files.py
from pathlib import Path
import pytest

def test_license_files_exist(project_root: Path) -> None:
    """Test presence of license files.

    Args:
        project_root: Path to project root directory
    """
    assert (project_root / "LICENSE").exists()
    assert (project_root / "LICENSE-APACHE").exists()
    assert (project_root / "LICENSE-MIT").exists()

@pytest.mark.parametrize("license_file,expected_content", [
    ("LICENSE-MIT", "MIT License"),
    ("LICENSE-APACHE", "Apache License, Version 2.0"),
])
def test_license_content(
    project_root: Path,
    license_file: str,
    expected_content: str
) -> None:
    """Test license file contents.

    Args:
        project_root: Project root directory
        license_file: Name of license file
        expected_content: Expected content snippet
    """
    content = (project_root / license_file).read_text()
    assert expected_content in content
```

### 3. Integration Tests

```python
# test_integration.py
from pathlib import Path
from typing import List
import pytest

def collect_source_files(directory: Path) -> List[Path]:
    """Collect all Python source files.

    Args:
        directory: Directory to scan

    Returns:
        List[Path]: List of Python file paths
    """
    return list(directory.glob("**/*.py"))

@pytest.mark.integration
def test_all_files_have_license_headers(project_root: Path) -> None:
    """Test all source files have license headers.

    Args:
        project_root: Project root directory
    """
    source_files = collect_source_files(project_root / "src")
    for file_path in source_files:
        assert verify_license_header(str(file_path)), \
            f"Missing license header in {file_path}"
```

## Testing Best Practices

1. Use type annotations consistently
2. Create reusable fixtures
3. Parametrize tests where applicable
4. Include both positive and negative test cases
5. Test file system operations safely using tmp_path
6. Use proper test isolation
7. Follow pytest best practices

## Common Fixtures

```python
# conftest.py
from pathlib import Path
import pytest
from typing import Generator

@pytest.fixture
def project_root() -> Path:
    """Provide project root directory.

    Returns:
        Path: Project root directory
    """
    return Path(__file__).parent.parent

@pytest.fixture
def temp_source_file(tmp_path: Path) -> Generator[Path, None, None]:
    """Create temporary source file.

    Args:
        tmp_path: Pytest temporary directory

    Yields:
        Path: Path to temporary file
    """
    file_path = tmp_path / "temp_source.py"
    yield file_path
    if file_path.exists():
        file_path.unlink()
```

## Error Handling and Edge Cases

```python
def test_non_existent_file() -> None:
    """Test handling of non-existent files."""
    with pytest.raises(FileNotFoundError):
        verify_license_header("non_existent.py")

def test_empty_file(tmp_path: Path) -> None:
    """Test handling of empty files.

    Args:
        tmp_path: Pytest temporary directory
    """
    empty_file = tmp_path / "empty.py"
    empty_file.touch()
    assert not verify_license_header(str(empty_file))
```

## Development Tools

```bash
# Run tests
pytest tests/

# Run type checking
mypy src/ tests/

# Run linting
flake8 src/ tests/

# Run all checks
tox
```

## Configuration

```ini
# setup.cfg
[tool:pytest]
testpaths = tests
python_files = test_*.py
markers =
    integration: marks tests as integration tests

[mypy]
python_version = 3.7
strict = True
```

This documentation provides a comprehensive framework for testing and maintaining the dual-licensed module. The testing strategy ensures proper license compliance, file handling, and integration testing while following Python best practices.
