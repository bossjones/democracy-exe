
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for the GreenThreadLocal module.

# Module Documentation for GreenThreadLocal

## Module Overview

The `GreenThreadLocal` module provides thread-local storage functionality specifically for greenlets, similar to Python's `threading.local()`. It ensures that each greenlet has its own isolated storage space for attributes.

### Key Features
- Thread-local storage for greenlets
- Weak reference management to prevent memory leaks
- Compatible with greenlet context switching
- Clean attribute access syntax

### Dependencies
- Python 3.7+
- greenlet

## Installation and Setup

```bash
pip install greenlet
```

## Usage Guide

### Basic Usage

```python
from greenlet_local import GreenThreadLocal
import greenlet

# Create a thread-local storage instance
local_storage = GreenThreadLocal()

# Set attributes
local_storage.counter = 1
local_storage.name = "main"

# Access attributes
print(local_storage.counter)  # 1
print(local_storage.name)    # "main"
```

### Example with Multiple Greenlets

```python
from greenlet import greenlet
from greenlet_local import GreenThreadLocal

local = GreenThreadLocal()

def gr1_func():
    local.value = "greenlet1"
    print(f"gr1: {local.value}")
    gr2.switch()
    print(f"gr1 again: {local.value}")

def gr2_func():
    local.value = "greenlet2"
    print(f"gr2: {local.value}")
    gr1.switch()

gr1 = greenlet(gr1_func)
gr2 = greenlet(gr2_func)
gr1.switch()
```

## Testing Guide

### Test File Structure

```python
# test_greenlet_local.py
from __future__ import annotations

import pytest
from greenlet import greenlet
from typing import Generator
from greenlet_local import GreenThreadLocal

@pytest.fixture
def local_storage() -> Generator[GreenThreadLocal, None, None]:
    """Provide a fresh GreenThreadLocal instance for each test."""
    storage = GreenThreadLocal()
    yield storage

def test_basic_attribute_access(local_storage: GreenThreadLocal) -> None:
    """Test basic attribute setting and getting."""
    local_storage.test_attr = "value"
    assert local_storage.test_attr == "value"

def test_attribute_isolation() -> None:
    """Test that different greenlets have isolated storage."""
    local_storage = GreenThreadLocal()
    results: list[str] = []

    def gr1_func() -> None:
        local_storage.value = "gr1"
        results.append(local_storage.value)
        gr2.switch()
        results.append(local_storage.value)

    def gr2_func() -> None:
        local_storage.value = "gr2"
        results.append(local_storage.value)
        gr1.switch()

    gr1 = greenlet(gr1_func)
    gr2 = greenlet(gr2_func)
    gr1.switch()

    assert results == ["gr1", "gr2", "gr1"]

def test_attribute_error(local_storage: GreenThreadLocal) -> None:
    """Test AttributeError is raised for non-existent attributes."""
    with pytest.raises(AttributeError):
        _ = local_storage.nonexistent

def test_delete_attribute(local_storage: GreenThreadLocal) -> None:
    """Test attribute deletion."""
    local_storage.test_attr = "value"
    del local_storage.test_attr
    with pytest.raises(AttributeError):
        _ = local_storage.test_attr

def test_weak_reference_cleanup() -> None:
    """Test that weak references are properly cleaned up."""
    local_storage = GreenThreadLocal()

    def gr_func() -> None:
        local_storage.value = "test"

    gr = greenlet(gr_func)
    gr.switch()

    initial_dict_size = len(local_storage._weakdict)
    del gr
    assert len(local_storage._weakdict) < initial_dict_size
```

### Memory Leak Testing

```python
def test_no_memory_leaks(local_storage: GreenThreadLocal) -> None:
    """Test that greenlet references are properly cleaned up."""
    import weakref

    gr_refs: list[weakref.ref] = []

    def create_greenlet() -> None:
        def gr_func() -> None:
            local_storage.value = "test"
        gr = greenlet(gr_func)
        gr_refs.append(weakref.ref(gr))
        gr.switch()

    create_greenlet()
    # Force garbage collection
    import gc
    gc.collect()

    assert gr_refs[0]() is None
```

## Error Handling and Edge Cases

```python
def test_concurrent_access() -> None:
    """Test concurrent access from multiple greenlets."""
    local_storage = GreenThreadLocal()
    results: list[tuple[str, str]] = []

    def gr_func(name: str) -> None:
        local_storage.value = f"value_{name}"
        results.append((name, local_storage.value))

    greenlets = [greenlet(lambda n=f"gr{i}": gr_func(n)) for i in range(3)]
    for gr in greenlets:
        gr.switch()

    assert len(results) == 3
    assert all(name in r[1] for r, name in zip(results, ["gr0", "gr1", "gr2"]))
```

## Best Practices

1. Always initialize the GreenThreadLocal instance at module level
2. Use type hints for better code maintainability
3. Clean up references to prevent memory leaks
4. Handle AttributeError appropriately
5. Be aware of greenlet context switches

## Debugging Tips

1. Use `print(local_storage._weakdict)` to inspect the internal storage
2. Monitor greenlet switches using greenlet's debug hooks
3. Use garbage collection debugging:
```python
import gc
gc.set_debug(gc.DEBUG_COLLECTABLE)
```

## Performance Considerations

1. WeakKeyDictionary lookups are performed on every attribute access
2. Memory usage scales with the number of active greenlets
3. Attribute access is slightly slower than normal attribute access due to the indirection

This documentation covers the essential aspects of using and testing the GreenThreadLocal module. The test cases demonstrate proper usage patterns and verify the module's core functionality, including isolation between greenlets and proper cleanup of references.
