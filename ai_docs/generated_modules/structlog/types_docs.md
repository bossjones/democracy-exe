
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this module.

# Module Documentation

## Module Overview

This module serves as a backwards-compatibility layer for structlog's typing definitions. It imports and re-exports type definitions from `structlog.typing` to maintain compatibility with code that may still import from the older location.

### Key Features
- Type definitions for structlog's core components
- Backward compatibility support
- Type hints for logging-related structures

### Dependencies
- Python 3.7+
- structlog core package

## Installation and Setup

```bash
pip install structlog
```

No additional setup required as this is part of the core structlog package.

## Usage Guide

```python
from structlog.types import (
    BindableLogger,
    Context,
    EventDict,
    Processor
)

# Example usage with type annotations
def custom_processor(
    logger: BindableLogger,
    name: str,
    event_dict: EventDict
) -> EventDict:
    """Custom processor with type hints."""
    return event_dict

# Example context usage
context: Context = {
    "user_id": "123",
    "request_id": "abc-456"
}
```

## Type Definitions

### WrappedLogger
Base type for wrapped loggers (typically standard library's Logger instances)

### Context
Dictionary type for structured logging context
```python
Context = Dict[str, Any]
```

### EventDict
Dictionary type for log events
```python
EventDict = Dict[str, Any]
```

### Processor
Type for log processors
```python
Processor = Callable[[WrappedLogger, str, EventDict], EventDict]
```

## Testing Guide

### Test Cases

```python
# test_types.py
from __future__ import annotations

import pytest
from typing import Any, Dict

from structlog.types import (
    BindableLogger,
    Context,
    EventDict,
    Processor,
    WrappedLogger
)

class TestTypeDefinitions:
    def test_context_type_compatibility(self) -> None:
        """Test Context type compatibility."""
        context: Context = {
            "user_id": "123",
            "metadata": {"source": "test"}
        }

        assert isinstance(context, dict)
        assert all(isinstance(k, str) for k in context.keys())

    def test_event_dict_type_compatibility(self) -> None:
        """Test EventDict type compatibility."""
        event_dict: EventDict = {
            "event": "user_login",
            "timestamp": "2023-01-01",
            "data": {"success": True}
        }

        assert isinstance(event_dict, dict)
        assert all(isinstance(k, str) for k in event_dict.keys())

    def test_processor_type_compatibility(self) -> None:
        """Test Processor type compatibility."""
        def sample_processor(
            logger: WrappedLogger,
            name: str,
            event_dict: EventDict
        ) -> EventDict:
            event_dict["processed"] = True
            return event_dict

        # Type checking should pass
        processor: Processor = sample_processor

        # Runtime test
        test_event_dict: EventDict = {"original": True}
        result = processor(None, "test", test_event_dict)

        assert isinstance(result, dict)
        assert result["processed"] is True

class TestExceptionHandling:
    def test_exc_info_type_compatibility(self) -> None:
        """Test ExcInfo type compatibility."""
        try:
            raise ValueError("Test exception")
        except ValueError:
            exc_info = pytest.ExceptionInfo.from_current()

            # ExcInfo should be compatible with exception info tuple
            assert len(exc_info.value.__traceback__.__str__()) > 0

class TestBindableLogger:
    def test_bindable_logger_interface(self) -> None:
        """Test BindableLogger interface compatibility."""
        class CustomLogger:
            def bind(self, **kwargs: Any) -> "CustomLogger":
                return self

        # Type checking should accept CustomLogger as BindableLogger
        logger: BindableLogger = CustomLogger()
        bound_logger = logger.bind(key="value")

        assert isinstance(bound_logger, CustomLogger)
```

### Test Fixtures

```python
# conftest.py
from __future__ import annotations

import pytest
from typing import Generator

@pytest.fixture
def sample_event_dict() -> Generator[EventDict, None, None]:
    """Provide a sample EventDict for testing."""
    event_dict = {
        "event": "test_event",
        "timestamp": "2023-01-01T00:00:00Z",
        "level": "info"
    }
    yield event_dict

@pytest.fixture
def sample_context() -> Generator[Context, None, None]:
    """Provide a sample Context for testing."""
    context = {
        "user_id": "test_user",
        "request_id": "test_request",
        "environment": "testing"
    }
    yield context
```

## Error Handling and Edge Cases

```python
def test_invalid_context_keys() -> None:
    """Test that Context only accepts string keys."""
    with pytest.raises(TypeError):
        invalid_context: Context = {
            1: "invalid",  # type: ignore
            "valid": "value"
        }

def test_processor_chain_typing() -> None:
    """Test processor chain type compatibility."""
    def processor1(
        logger: WrappedLogger,
        name: str,
        event_dict: EventDict
    ) -> EventDict:
        event_dict["proc1"] = True
        return event_dict

    def processor2(
        logger: WrappedLogger,
        name: str,
        event_dict: EventDict
    ) -> EventDict:
        event_dict["proc2"] = True
        return event_dict

    processors: list[Processor] = [processor1, processor2]

    # Test processor chain
    event_dict: EventDict = {}
    for proc in processors:
        event_dict = proc(None, "test", event_dict)

    assert event_dict["proc1"] is True
    assert event_dict["proc2"] is True
```

## Best Practices

1. Always use type annotations with these types
2. Use `from __future__ import annotations` in all files
3. Validate dictionary key types for Context and EventDict
4. Use mypy or similar type checkers to verify type compatibility
5. Test both successful and error cases
6. Include edge case testing
7. Document type requirements in docstrings

## Common Issues and Solutions

1. Type compatibility with third-party loggers:
```python
from typing import Protocol

class ThirdPartyLogger(Protocol):
    def log(self, level: int, msg: str) -> None: ...

# Create adapter to make it compatible with WrappedLogger
class LoggerAdapter:
    def __init__(self, logger: ThirdPartyLogger) -> None:
        self._logger = logger

    def __conform__(self, protocol: Any) -> Any:
        if protocol is WrappedLogger:
            return self
```

2. Handling optional types:
```python
from typing import Optional

def process_exc_info(exc_info: Optional[ExcInfo] = None) -> str:
    """Handle optional exception info."""
    if exc_info is None:
        return ""
    return str(exc_info)
```

This documentation should provide a comprehensive guide for using and testing the type definitions in this module.
