
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this module.

# Module Documentation

## Module Overview

This module provides a base implementation for structured logging with context binding capabilities. It's part of the `structlog` package and implements core logging functionality with the following key features:

- Immutable context carrying
- Context binding and unbinding
- Processor chain execution
- Flexible logger wrapping

### Key Dependencies
- Python 3.7+
- structlog
- typing support

## Installation and Setup

```bash
pip install structlog
```

## Usage Guide

### Basic Usage

```python
from structlog import BoundLoggerBase, get_context
from typing import Any

# Create a basic logger instance
logger = BoundLoggerBase(
    logger=print,  # Simple print function as the wrapped logger
    processors=[],  # No processors
    context={}     # Empty initial context
)

# Bind context
logger_with_context = logger.bind(user_id="123")

# Add more context
logger_with_more_context = logger_with_context.bind(
    request_id="abc123"
)

# Remove context
logger_without_user = logger_with_more_context.unbind("user_id")
```

### Advanced Usage

```python
from typing import Any, Dict

# Custom processor example
def add_timestamp(
    logger: Any,
    method_name: str,
    event_dict: Dict[str, Any]
) -> Dict[str, Any]:
    from datetime import datetime
    event_dict["timestamp"] = datetime.now().isoformat()
    return event_dict

# Create logger with processor
logger = BoundLoggerBase(
    logger=print,
    processors=[add_timestamp],
    context={}
)
```

## Testing Guide

### Basic Test Cases

```python
# test_bound_logger.py
from __future__ import annotations

import pytest
from structlog import BoundLoggerBase
from structlog.exceptions import DropEvent
from typing import Any, Dict, Generator

@pytest.fixture
def mock_logger() -> Generator[Any, None, None]:
    """Provide a mock logger for testing."""
    def logger(*args: Any, **kwargs: Any) -> tuple[Any, Any]:
        return args, kwargs
    yield logger

@pytest.fixture
def bound_logger(mock_logger: Any) -> BoundLoggerBase:
    """Provide a basic BoundLoggerBase instance."""
    return BoundLoggerBase(
        logger=mock_logger,
        processors=[],
        context={}
    )

def test_bind_creates_new_logger_with_updated_context(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that bind() creates a new logger with updated context."""
    new_logger = bound_logger.bind(key="value")

    assert new_logger != bound_logger
    assert new_logger._context == {"key": "value"}
    assert bound_logger._context == {}

def test_unbind_removes_key_from_context(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that unbind() removes specified keys from context."""
    logger_with_context = bound_logger.bind(key1="value1", key2="value2")
    new_logger = logger_with_context.unbind("key1")

    assert "key1" not in new_logger._context
    assert new_logger._context["key2"] == "value2"

@pytest.mark.parametrize(
    "event,event_kw,expected",
    [
        ("test_event", {}, {"event": "test_event"}),
        (None, {"key": "value"}, {"key": "value"}),
        ("test_event", {"key": "value"}, {"event": "test_event", "key": "value"}),
    ]
)
def test_process_event_creates_correct_event_dict(
    bound_logger: BoundLoggerBase,
    event: str | None,
    event_kw: Dict[str, Any],
    expected: Dict[str, Any]
) -> None:
    """Test event processing with various inputs."""
    args, kwargs = bound_logger._process_event("info", event, event_kw)

    assert kwargs == expected
```

### Testing Processors

```python
# test_processors.py
from typing import Any, Dict

import pytest
from structlog import BoundLoggerBase

def test_processor_chain_execution(mock_logger: Any) -> None:
    """Test that processors are executed in order."""
    def processor1(
        logger: Any,
        method_name: str,
        event_dict: Dict[str, Any]
    ) -> Dict[str, Any]:
        event_dict["proc1"] = True
        return event_dict

    def processor2(
        logger: Any,
        method_name: str,
        event_dict: Dict[str, Any]
    ) -> Dict[str, Any]:
        event_dict["proc2"] = True
        return event_dict

    logger = BoundLoggerBase(
        logger=mock_logger,
        processors=[processor1, processor2],
        context={}
    )

    args, kwargs = logger._process_event("info", "test", {})

    assert kwargs["proc1"] is True
    assert kwargs["proc2"] is True
```

### Testing Error Cases

```python
# test_errors.py
import pytest
from structlog import BoundLoggerBase
from structlog.exceptions import DropEvent

def test_unbind_raises_key_error_for_missing_key(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that unbind() raises KeyError for missing keys."""
    with pytest.raises(KeyError):
        bound_logger.unbind("non_existent_key")

def test_try_unbind_ignores_missing_key(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that try_unbind() ignores missing keys."""
    result = bound_logger.try_unbind("non_existent_key")
    assert result._context == {}

def test_invalid_processor_return_value(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that invalid processor return values raise ValueError."""
    def invalid_processor(
        logger: Any,
        method_name: str,
        event_dict: Dict[str, Any]
    ) -> int:
        return 42

    logger = BoundLoggerBase(
        logger=bound_logger._logger,
        processors=[invalid_processor],
        context={}
    )

    with pytest.raises(ValueError):
        logger._process_event("info", "test", {})
```

### Testing Context Management

```python
# test_context.py
from structlog import get_context

def test_get_context_returns_actual_context(
    bound_logger: BoundLoggerBase
) -> None:
    """Test that get_context returns the actual context object."""
    context = get_context(bound_logger)
    assert context is bound_logger._context

def test_context_immutability(bound_logger: BoundLoggerBase) -> None:
    """Test that binding operations don't modify original context."""
    original_context = bound_logger._context.copy()
    bound_logger.bind(key="value")

    assert bound_logger._context == original_context
```

## Testing Best Practices

1. Use type hints consistently
2. Create fixtures for common test scenarios
3. Test both success and failure cases
4. Use parametrize for testing multiple scenarios
5. Test processor chains thoroughly
6. Verify context immutability
7. Test all public methods
8. Include edge cases
9. Test proper cleanup of resources
10. Verify proper exception handling

## Common Issues and Debugging

1. Context Modification
```python
# Wrong
logger._context["key"] = "value"  # Directly modifying context

# Correct
new_logger = logger.bind(key="value")
```

2. Processor Chain Issues
```python
# Debug processor chain
def debug_processor(
    logger: Any,
    method_name: str,
    event_dict: Dict[str, Any]
) -> Dict[str, Any]:
    print(f"Processing: {event_dict}")
    return event_dict
```

This documentation provides a comprehensive guide for using and testing the BoundLoggerBase module. Remember to run tests with proper coverage reporting and maintain type safety throughout the codebase.
