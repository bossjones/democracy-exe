
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this module.

# structlog Native Loggers Documentation

## Module Overview

This module provides high-performance native loggers for structlog with filtering capabilities based on log levels. It includes both synchronous and asynchronous logging methods.

### Key Features
- Level-based filtering at compilation time
- Async/sync logging methods
- Performance optimized implementation
- Pickleable logger classes
- Exception logging support
- Standard logging level support (DEBUG, INFO, WARNING, ERROR, CRITICAL)

### Dependencies
- Python 3.7+
- structlog core package
- asyncio (standard library)
- contextvars (standard library)

## Installation and Setup

```bash
pip install structlog
```

## Usage Guide

### Basic Usage

```python
import structlog
from structlog.stdlib import get_logger

# Create a filtered logger at INFO level
logger = get_logger()
bound_logger = structlog.make_filtering_bound_logger(INFO)

# Synchronous logging
logger.info("This will be logged")  # Will log
logger.debug("This won't be logged")  # Won't log

# Asynchronous logging
async def log_something():
    await logger.ainfo("Async logging")
    await logger.adebug("Won't be logged")
```

### Exception Logging

```python
try:
    raise ValueError("Something went wrong")
except Exception:
    logger.exception("An error occurred")
    # Async version
    await logger.aexception("An async error occurred")
```

## Testing Guide

### Test Setup

```python
# test_loggers.py
from __future__ import annotations

import pytest
import structlog
from structlog.types import FilteringBoundLogger
from structlog._loggers import (
    make_filtering_bound_logger,
    BoundLoggerFilteringAtInfo,
    INFO,
    DEBUG,
)

@pytest.fixture
def info_logger() -> FilteringBoundLogger:
    """Create a logger filtering at INFO level."""
    return make_filtering_bound_logger(INFO)()

@pytest.fixture
def debug_logger() -> FilteringBoundLogger:
    """Create a logger filtering at DEBUG level."""
    return make_filtering_bound_logger(DEBUG)()
```

### Synchronous Logging Tests

```python
def test_info_level_filtering(
    info_logger: FilteringBoundLogger,
    caplog: pytest.LogCaptureFixture
) -> None:
    """Test that INFO level messages are logged while DEBUG are filtered."""
    info_logger.info("info message")
    info_logger.debug("debug message")

    assert "info message" in caplog.text
    assert "debug message" not in caplog.text

def test_exception_logging(
    info_logger: FilteringBoundLogger,
    caplog: pytest.LogCaptureFixture
) -> None:
    """Test exception logging with exc_info."""
    try:
        raise ValueError("test error")
    except ValueError:
        info_logger.exception("caught error")

    assert "caught error" in caplog.text
    assert "ValueError: test error" in caplog.text
```

### Asynchronous Logging Tests

```python
@pytest.mark.asyncio
async def test_async_logging(
    info_logger: FilteringBoundLogger,
    caplog: pytest.LogCaptureFixture
) -> None:
    """Test async logging methods."""
    await info_logger.ainfo("async info")
    await info_logger.adebug("async debug")

    assert "async info" in caplog.text
    assert "async debug" not in caplog.text

@pytest.mark.asyncio
async def test_async_exception_logging(
    info_logger: FilteringBoundLogger,
    caplog: pytest.LogCaptureFixture
) -> None:
    """Test async exception logging."""
    try:
        raise ValueError("async error")
    except ValueError:
        await info_logger.aexception("async caught")

    assert "async caught" in caplog.text
    assert "ValueError: async error" in caplog.text
```

### Level Creation Tests

```python
def test_logger_level_creation() -> None:
    """Test creation of loggers at different levels."""
    debug_logger = make_filtering_bound_logger(DEBUG)
    info_logger = make_filtering_bound_logger(INFO)

    assert isinstance(debug_logger(), BoundLoggerFilteringAtDebug)
    assert isinstance(info_logger(), BoundLoggerFilteringAtInfo)
```

### Performance Tests

```python
import time

def test_logger_performance(info_logger: FilteringBoundLogger) -> None:
    """Test logging performance."""
    start_time = time.perf_counter()

    for _ in range(1000):
        info_logger.info("test message")
        info_logger.debug("filtered message")

    duration = time.perf_counter() - start_time

    assert duration < 1.0  # Should complete within 1 second
```

## Testing Best Practices

1. Use proper type annotations
2. Test both sync and async methods
3. Verify filtering behavior
4. Test exception handling
5. Check performance characteristics
6. Test all log levels
7. Verify context preservation
8. Test pickling capability

### Context Preservation Test

```python
def test_context_preservation(info_logger: FilteringBoundLogger) -> None:
    """Test that bound context is preserved."""
    bound_logger = info_logger.bind(user_id="123")
    with structlog.testing.capture_logs() as captured:
        bound_logger.info("test")

    assert captured[0]["user_id"] == "123"
```

### Pickling Test

```python
import pickle

def test_logger_pickling(info_logger: FilteringBoundLogger) -> None:
    """Test that loggers can be pickled and unpickled."""
    pickled = pickle.dumps(info_logger)
    unpickled = pickle.loads(pickled)

    assert isinstance(unpickled, type(info_logger))
```

## Error Handling

```python
def test_invalid_level_handling() -> None:
    """Test handling of invalid log levels."""
    with pytest.raises(KeyError):
        make_filtering_bound_logger(999)  # Invalid level
```

These tests cover the main functionality of the module while demonstrating proper testing practices. Each test includes proper type hints, docstrings, and assertions. The tests are organized to cover different aspects of the module's functionality, from basic logging to more complex scenarios like async operations and exception handling.
