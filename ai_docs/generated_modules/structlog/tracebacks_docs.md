
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this exception traceback extraction module. I'll break it down into several key sections.

# Exception Traceback Extraction Module Documentation

## Module Overview

This module provides structured exception traceback extraction functionality, converting Python exception information into a structured format suitable for logging and analysis. It's based on the Rich library's traceback handling but can work independently.

### Key Features
- Structured exception information extraction
- Local variable capture with customizable formatting
- Support for nested exceptions (both __cause__ and __context__)
- Syntax error special handling
- Configurable frame limits and local variable display
- Rich library integration (optional)

### Dependencies
- Optional: `rich` library for enhanced repr formatting
- Python 3.7+
- Type hints support

## Installation and Setup

```bash
pip install structlog  # This module is part of structlog
```

Optional Rich integration:
```bash
pip install rich
```

## Usage Guide

### Basic Usage

```python
from structlog.tracebacks import extract, ExceptionDictTransformer

# Basic exception extraction
try:
    1/0
except Exception:
    exc_info = sys.exc_info()
    trace = extract(*exc_info)

# Using the transformer
transformer = ExceptionDictTransformer(show_locals=True)
exception_dict = transformer(exc_info)
```

### Advanced Configuration

```python
transformer = ExceptionDictTransformer(
    show_locals=True,
    locals_max_length=20,
    locals_max_string=100,
    locals_hide_dunder=True,
    locals_hide_sunder=False,
    max_frames=50,
    use_rich=True
)
```

## Testing Guide

### Basic Test Cases

```python
# test_tracebacks.py
from __future__ import annotations

import pytest
from structlog.tracebacks import (
    extract,
    ExceptionDictTransformer,
    Frame,
    Stack,
    Trace,
)

def test_basic_exception_extraction():
    """Test basic exception information extraction."""
    try:
        1/0
    except ZeroDivisionError:
        exc_info = sys.exc_info()
        trace = extract(*exc_info)

        assert isinstance(trace, Trace)
        assert len(trace.stacks) == 1
        assert trace.stacks[0].exc_type == "ZeroDivisionError"

@pytest.mark.parametrize("show_locals", [True, False])
def test_locals_capture(show_locals: bool):
    """Test local variable capture configuration."""
    local_var = "test_value"
    try:
        raise ValueError("test error")
    except ValueError:
        exc_info = sys.exc_info()
        trace = extract(*exc_info, show_locals=show_locals)

        frame = trace.stacks[0].frames[-1]
        if show_locals:
            assert "local_var" in frame.locals
            assert frame.locals["local_var"] == "'test_value'"
        else:
            assert frame.locals is None
```

### Testing Rich Integration

```python
# test_rich_integration.py
import pytest
from structlog.tracebacks import to_repr

@pytest.mark.parametrize(
    "obj,max_length,max_string,expected",
    [
        ([1, 2, 3], 2, None, "[1, 2, ...]"),
        ("long_string", 5, 4, "'long...'+6"),
        ({"key": "value"}, None, None, "{'key': 'value'}"),
    ]
)
def test_rich_repr_formatting(
    obj: Any,
    max_length: int | None,
    max_string: int | None,
    expected: str,
):
    """Test Rich library integration for repr formatting."""
    result = to_repr(
        obj,
        max_length=max_length,
        max_string=max_string,
        use_rich=True
    )
    assert result == expected
```

### Testing Exception Chaining

```python
def test_exception_chaining():
    """Test handling of chained exceptions."""
    try:
        try:
            raise ValueError("inner")
        except ValueError as e:
            raise RuntimeError("outer") from e
    except RuntimeError:
        exc_info = sys.exc_info()
        trace = extract(*exc_info)

        assert len(trace.stacks) == 2
        assert trace.stacks[0].exc_type == "RuntimeError"
        assert trace.stacks[1].exc_type == "ValueError"
        assert trace.stacks[1].is_cause == True
```

### Testing Syntax Error Handling

```python
def test_syntax_error_extraction():
    """Test handling of syntax errors."""
    try:
        exec("invalid python code )")
    except SyntaxError:
        exc_info = sys.exc_info()
        trace = extract(*exc_info)

        assert trace.stacks[0].syntax_error is not None
        assert trace.stacks[0].syntax_error.msg.startswith("invalid syntax")
```

### Test Fixtures

```python
@pytest.fixture
def sample_exception_info() -> ExcInfo:
    """Provide a standard exception info tuple for testing."""
    try:
        raise ValueError("test error")
    except ValueError:
        return sys.exc_info()  # type: ignore

@pytest.fixture
def transformer() -> ExceptionDictTransformer:
    """Provide a configured transformer instance."""
    return ExceptionDictTransformer(
        show_locals=True,
        locals_max_length=10,
        locals_max_string=50
    )
```

## Best Practices

1. Always test with both Rich available and unavailable
2. Test different frame limit configurations
3. Verify local variable capture behavior
4. Check exception chaining handling
5. Test with various string lengths and container sizes
6. Verify syntax error special handling
7. Test path normalization and suppression
8. Verify memory usage with large stack traces

## Error Handling and Edge Cases

```python
def test_invalid_configuration():
    """Test invalid configuration handling."""
    with pytest.raises(ValueError):
        ExceptionDictTransformer(locals_max_length=-1)

    with pytest.raises(ValueError):
        ExceptionDictTransformer(locals_max_string=-1)

    with pytest.raises(ValueError):
        ExceptionDictTransformer(max_frames=1)
```

## Performance Testing

```python
def test_performance_large_stack(benchmark):
    """Test performance with large stack traces."""
    def deep_recursion(n):
        if n == 0:
            raise ValueError("deep error")
        deep_recursion(n-1)

    try:
        deep_recursion(100)
    except ValueError:
        exc_info = sys.exc_info()

    def extract_trace():
        return extract(*exc_info)

    result = benchmark(extract_trace)
    assert len(result.stacks[0].frames) <= MAX_FRAMES
```

This documentation provides a comprehensive guide to using and testing the traceback extraction module. For actual implementation, you'll want to add more specific tests based on your use cases and requirements.
