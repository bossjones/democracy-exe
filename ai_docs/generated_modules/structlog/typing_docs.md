
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this types module.

# Module Overview

The `structlog.types` module provides core type definitions and protocols for the structlog logging system. It defines the fundamental interfaces and type hints used throughout the library.

Key features:
- Type definitions for logging contexts and event dictionaries
- Protocol definitions for bindable loggers
- Support for both synchronous and asynchronous logging
- Exception handling type definitions

## Core Dependencies:
- Python 3.7+
- typing-extensions (for Python <3.8)

# Installation and Setup

```bash
pip install structlog
```

# Usage Guide

## Basic Types

```python
from structlog.types import (
    Context,
    EventDict,
    WrappedLogger,
    Processor,
    ExcInfo
)

# Create a context dictionary
context: Context = {
    "user_id": "123",
    "ip_address": "127.0.0.1"
}

# Create an event dictionary
event_dict: EventDict = {
    "event": "user_login",
    "level": "info",
    **context
}
```

## Working with Bindable Loggers

```python
from structlog.types import BindableLogger

def use_logger(logger: BindableLogger) -> None:
    # Bind new values
    new_logger = logger.bind(request_id="abc123")

    # Create new context
    fresh_logger = new_logger.new(session_id="xyz789")

    # Remove keys
    cleaned_logger = fresh_logger.unbind("request_id")
```

# Testing Guide

## Test Cases

### 1. Context and EventDict Testing

```python
from structlog.types import Context, EventDict
import pytest
from typing import Dict, Any

@pytest.fixture
def sample_context() -> Context:
    return {
        "user_id": "123",
        "timestamp": "2023-01-01T00:00:00Z"
    }

@pytest.fixture
def sample_event_dict(sample_context: Context) -> EventDict:
    return {
        "event": "test_event",
        "level": "info",
        **sample_context
    }

def test_context_usage(sample_context: Context) -> None:
    """Test Context type usage and manipulation."""
    # Test adding new values
    context: Context = {**sample_context, "new_key": "new_value"}

    assert "user_id" in context
    assert context["new_key"] == "new_value"
    assert len(context) == 3

def test_event_dict_manipulation(sample_event_dict: EventDict) -> None:
    """Test EventDict manipulation and properties."""
    # Modify event dict
    sample_event_dict["additional_info"] = "test"

    assert sample_event_dict["event"] == "test_event"
    assert "additional_info" in sample_event_dict
```

### 2. FilteringBoundLogger Testing

```python
from structlog.types import FilteringBoundLogger
from pytest_mock import MockerFixture
import pytest
from typing import AsyncGenerator

class MockFilteringBoundLogger:
    """Mock implementation of FilteringBoundLogger for testing."""
    def __init__(self) -> None:
        self._context = {}

    def bind(self, **new_values: Any) -> "MockFilteringBoundLogger":
        return self

    async def ainfo(self, event: str, *args: Any, **kw: Any) -> None:
        pass

@pytest.fixture
def mock_logger(mocker: MockerFixture) -> FilteringBoundLogger:
    return MockFilteringBoundLogger()  # type: ignore

@pytest.mark.asyncio
async def test_async_logging(
    mock_logger: FilteringBoundLogger,
    caplog: pytest.LogCaptureFixture
) -> None:
    """Test async logging capabilities."""
    await mock_logger.ainfo("test_event", extra="data")
    # Add assertions based on expected behavior
```

### 3. Exception Handling Testing

```python
from structlog.types import ExcInfo, ExceptionTransformer
import pytest
from typing import Tuple, Optional, Type

@pytest.fixture
def sample_exc_info() -> ExcInfo:
    try:
        raise ValueError("Test error")
    except ValueError:
        return pytest.helpers.exc_info()  # type: ignore

def test_exception_transformer(sample_exc_info: ExcInfo) -> None:
    """Test ExceptionTransformer protocol implementation."""

    class TestTransformer:
        def __call__(self, exc_info: ExcInfo) -> str:
            return f"Error: {exc_info[1]}"

    transformer: ExceptionTransformer = TestTransformer()  # type: ignore
    result = transformer(sample_exc_info)

    assert "Error: Test error" in result
```

## Testing Best Practices

1. Type Safety:
```python
def test_type_safety() -> None:
    """Test type annotations and safety."""
    context: Context = {"key": "value"}
    # This should raise a type error in static type checking
    # context: Context = []  # type: ignore
```

2. Edge Cases:
```python
def test_context_edge_cases() -> None:
    """Test edge cases for Context type."""
    empty_context: Context = {}
    nested_context: Context = {
        "outer": {
            "inner": "value"
        }
    }

    assert isinstance(empty_context, dict)
    assert isinstance(nested_context["outer"], dict)
```

## Integration Testing

```python
from structlog import get_logger
from structlog.types import BindableLogger

def test_structlog_integration() -> None:
    """Test integration with structlog library."""
    logger = get_logger()
    assert isinstance(logger, BindableLogger)

    bound_logger = logger.bind(test=True)
    assert bound_logger._context["test"] is True
```

# Error Handling and Edge Cases

```python
def test_invalid_context_operations() -> None:
    """Test invalid operations on Context type."""
    context: Context = {"key": "value"}

    with pytest.raises(KeyError):
        _ = context["nonexistent"]

    with pytest.raises(TypeError):
        context[123] = "invalid"  # type: ignore
```

# Debug and Troubleshooting

```python
import logging

def test_with_debug_logging(caplog: pytest.LogCaptureFixture) -> None:
    """Demonstrate debugging techniques."""
    caplog.set_level(logging.DEBUG)

    # Your test code here

    for record in caplog.records:
        print(f"Level: {record.levelname}, Message: {record.message}")
```

This documentation covers the main aspects of the types module. Remember to:
- Always use type annotations
- Test both success and failure cases
- Include async testing where relevant
- Document all test fixtures and their purpose
- Use appropriate assertions
- Handle cleanup properly

The tests can be run using:
```bash
pytest tests/ -v --cov=structlog.types
```
