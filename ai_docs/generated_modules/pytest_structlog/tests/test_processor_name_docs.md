
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation and testing examples for this module, which appears to be a processor naming utility for structlog.

# Module Documentation: Processor Name Resolution

## Module Overview
This module provides functionality for resolving processor names in a structlog processing pipeline. It handles various types of callables including functions, methods, class methods, static methods, partial functions, and lambda expressions.

### Key Features
- Name resolution for different types of Python callables
- Support for class-based processors
- Handling of partial functions
- Lambda function detection

### Dependencies
- pytest (for testing)
- pytest-structlog
- functools (standard library)

## Installation and Setup

```bash
pip install pytest pytest-structlog
```

## Usage Guide

### Basic Function Processors
```python
from functools import partial

# Simple function processor
def my_processor(logger, method_name, event_dict):
    return event_dict

# Get processor name
from pytest_structlog import _name
processor_name = _name(my_processor)  # Returns "my_processor"
```

### Class-Based Processors
```python
class CustomProcessor:
    def process(self, logger, method_name, event_dict):
        return event_dict

    @classmethod
    def class_process(cls, logger, method_name, event_dict):
        return event_dict

    @staticmethod
    def static_process(logger, method_name, event_dict):
        return event_dict

processor = CustomProcessor()
method_name = _name(processor.process)  # Returns "CustomProcessor.process"
classmethod_name = _name(CustomProcessor.class_process)  # Returns "CustomProcessor.class_process"
staticmethod_name = _name(CustomProcessor.static_process)  # Returns "CustomProcessor.static_process"
```

### Partial Functions
```python
from functools import partial

base_processor = partial(my_processor, method_name="info")
partial_name = _name(base_processor)  # Returns original function name "my_processor"
```

## Testing Guide

### Test Implementation

```python
# test_processor_naming.py
from __future__ import annotations

import pytest
from functools import partial
from typing import Any, Callable

class TestProcessorNaming:
    @pytest.fixture
    def processor_class(self) -> type:
        class TestProcessor:
            def method_proc(self, logger: Any, method_name: str, event_dict: dict) -> dict:
                return event_dict

            @classmethod
            def class_proc(cls, logger: Any, method_name: str, event_dict: dict) -> dict:
                return event_dict

            @staticmethod
            def static_proc(logger: Any, method_name: str, event_dict: dict) -> dict:
                return event_dict

            def __call__(self, logger: Any, method_name: str, event_dict: dict) -> dict:
                return event_dict

        return TestProcessor

    @pytest.fixture
    def function_processor(self) -> Callable:
        def proc(logger: Any, method_name: str, event_dict: dict) -> dict:
            return event_dict
        return proc

    def test_function_processor_name(self, function_processor: Callable) -> None:
        """Test name resolution for simple function processors."""
        assert _name(function_processor) == "proc"

    def test_method_processor_name(self, processor_class: type) -> None:
        """Test name resolution for instance methods."""
        processor = processor_class()
        assert _name(processor.method_proc) == "TestProcessor.method_proc"

    def test_classmethod_processor_name(self, processor_class: type) -> None:
        """Test name resolution for class methods."""
        assert _name(processor_class.class_proc) == "TestProcessor.class_proc"
        processor = processor_class()
        assert _name(processor.class_proc) == "TestProcessor.class_proc"

    def test_staticmethod_processor_name(self, processor_class: type) -> None:
        """Test name resolution for static methods."""
        assert _name(processor_class.static_proc) == "TestProcessor.static_proc"
        processor = processor_class()
        assert _name(processor.static_proc) == "TestProcessor.static_proc"

    def test_callable_class_name(self, processor_class: type) -> None:
        """Test name resolution for callable class instances."""
        processor = processor_class()
        assert _name(processor) == "TestProcessor"

    def test_partial_function_name(self, function_processor: Callable) -> None:
        """Test name resolution for partial functions."""
        partial_proc = partial(function_processor, method_name="info")
        assert _name(partial_proc) == "proc"

    def test_lambda_processor_name(self) -> None:
        """Test name resolution for lambda functions."""
        lambda_proc = lambda logger, method_name, event_dict: event_dict
        assert _name(lambda_proc) == "<lambda>"
```

### Test Coverage Areas

1. Function Processors
   - Simple functions
   - Lambda functions
   - Partial functions

2. Class-Based Processors
   - Instance methods
   - Class methods
   - Static methods
   - Callable instances

### Edge Cases and Error Handling

```python
def test_invalid_processor_type() -> None:
    """Test handling of invalid processor types."""
    with pytest.raises(AttributeError):
        _name(None)

def test_nested_function_name() -> None:
    """Test name resolution for nested functions."""
    def outer():
        def inner(logger, method_name, event_dict):
            return event_dict
        return inner

    assert _name(outer()) == "inner"
```

## Best Practices

1. Type Annotations
   - Use proper type hints for all test functions and fixtures
   - Include return type annotations

2. Fixture Usage
   - Create reusable fixtures for common test scenarios
   - Use appropriate fixture scopes

3. Test Organization
   - Group related tests in classes
   - Use descriptive test names
   - Include docstrings for all test functions

4. Error Handling
   - Test edge cases and invalid inputs
   - Verify error messages and types

## Common Issues and Solutions

1. Name Resolution Failures
   ```python
   # Problem: Processor without __name__ attribute
   # Solution: Implement proper __str__ or __repr__ methods
   class CustomProcessor:
       def __str__(self):
           return "CustomProcessor"
   ```

2. Partial Function Names
   ```python
   # Problem: Losing original function name in complex partials
   # Solution: Access the original function through partial.func
   partial_proc = partial(partial(original_func))
   assert _name(partial_proc) == _name(partial_proc.func.func)
   ```

This documentation covers the core functionality, testing approaches, and best practices for the processor naming module. The test examples provide comprehensive coverage of all supported callable types and common edge cases.
