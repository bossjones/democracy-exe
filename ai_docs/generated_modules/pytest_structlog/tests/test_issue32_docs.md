
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this logging module that handles exception formatting with structlog.

# Exception Logging Module Documentation

## Module Overview

This module provides structured logging capabilities with a focus on exception handling and formatting using `structlog`. It offers two main configuration approaches:
- Standard string-based exception formatting
- Dictionary-based traceback formatting for structured analysis

### Key Features
- Configurable logging setup using structlog
- Exception capturing and formatting
- JSON output formatting
- Support for both string and dict-based traceback formats

### Dependencies
- pytest
- structlog

## Installation and Setup

```bash
# Install required packages
pip install structlog pytest
```

Required dependencies in requirements.txt:
```
structlog>=21.1.0
pytest>=6.0.0
```

## Usage Guide

### Basic Usage

```python
import structlog

# Get a logger instance
logger = structlog.get_logger()

# Log an exception
try:
    # Some operation that might fail
    1 / 0
except Exception:
    logger.exception("An error occurred")
```

### Configuration Options

1. Standard String Traceback:
```python
structlog.configure(
    processors=[
        structlog.processors.format_exc_info,
        structlog.processors.JSONRenderer(),
    ],
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
)
```

2. Dictionary Traceback:
```python
structlog.configure(
    processors=[
        structlog.processors.dict_tracebacks,
        structlog.processors.JSONRenderer(),
    ],
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
)
```

## Testing Guide

### Test File Structure

```python
# test_logging.py
from typing import Generator, List
import pytest
import structlog
from pytest_mock import MockerFixture
from _pytest.logging import LogCaptureFixture

@pytest.fixture
def log() -> Generator[List[dict], None, None]:
    """Fixture to capture log events.

    Returns:
        Generator[List[dict], None, None]: List of captured log events
    """
    events = []

    def capture(_, __, event_dict):
        events.append(event_dict)
        return event_dict

    structlog.configure(
        processors=[capture],
        cache_logger_on_first_use=True,
    )
    yield events
    events.clear()

@pytest.fixture
def stdlib_bound_logger_configure() -> None:
    """Configure structlog with standard string traceback formatting."""
    structlog.configure(
        processors=[
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer(),
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
    )

@pytest.fixture
def stdlib_bound_logger_configure_dict_tb() -> None:
    """Configure structlog with dictionary traceback formatting."""
    structlog.configure(
        processors=[
            structlog.processors.dict_tracebacks,
            structlog.processors.JSONRenderer(),
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
    )

def test_exception_traceback(
    stdlib_bound_logger_configure: None,
    log: List[dict]
) -> None:
    """Test string-based exception traceback formatting.

    Args:
        stdlib_bound_logger_configure: Logger configuration fixture
        log: Log capture fixture
    """
    log_exception()
    [event] = log.events
    err = event["exception"]
    assert err.startswith("Traceback")
    assert "ZeroDivisionError" in err

def test_exception_dict_traceback(
    stdlib_bound_logger_configure_dict_tb: None,
    log: List[dict]
) -> None:
    """Test dictionary-based exception traceback formatting.

    Args:
        stdlib_bound_logger_configure_dict_tb: Logger configuration fixture
        log: Log capture fixture
    """
    log_exception()
    [event] = log.events
    [err] = event["exception"]
    assert isinstance(err, dict)
    assert err["exc_type"] == "ZeroDivisionError"
    assert err["exc_value"] == "division by zero"

# Additional test cases
def test_logger_creation(stdlib_bound_logger_configure: None) -> None:
    """Test logger instance creation."""
    logger = structlog.get_logger()
    assert isinstance(logger, structlog.stdlib.BoundLogger)

def test_multiple_exceptions(
    stdlib_bound_logger_configure_dict_tb: None,
    log: List[dict]
) -> None:
    """Test handling of multiple exceptions."""
    def nested_exception():
        try:
            1 / 0
        except ZeroDivisionError:
            try:
                raise ValueError("Secondary error")
            except ValueError:
                logger = structlog.get_logger()
                logger.exception("Multiple errors")

    nested_exception()
    [event] = log.events
    [err] = event["exception"]
    assert err["exc_type"] == "ValueError"
    assert err["exc_value"] == "Secondary error"
```

### Testing Best Practices

1. Use Fixtures for Setup
- Create reusable fixtures for logger configuration
- Implement log capture fixtures
- Clean up after tests

2. Test Different Configuration Types
- Test string-based traceback formatting
- Test dictionary-based traceback formatting
- Verify JSON output format

3. Edge Cases
- Test multiple nested exceptions
- Test different exception types
- Verify empty exception handling

4. Type Annotations
- Use proper type hints for all test functions and fixtures
- Document return types and parameters

## Error Handling and Edge Cases

```python
def test_empty_exception(
    stdlib_bound_logger_configure: None,
    log: List[dict]
) -> None:
    """Test logging without an active exception."""
    logger = structlog.get_logger()
    logger.error("No exception")
    [event] = log.events
    assert "exception" not in event

def test_custom_exception(
    stdlib_bound_logger_configure_dict_tb: None,
    log: List[dict]
) -> None:
    """Test logging with custom exception."""
    class CustomError(Exception):
        pass

    try:
        raise CustomError("Custom message")
    except CustomError:
        logger = structlog.get_logger()
        logger.exception("Custom error")

    [event] = log.events
    [err] = event["exception"]
    assert err["exc_type"] == "CustomError"
    assert err["exc_value"] == "Custom message"
```

## Debugging and Troubleshooting

Common issues and solutions:

1. Logger Configuration
```python
# Ensure configuration is called before logging
structlog.configure(...)
logger = structlog.get_logger()
```

2. Exception Context
```python
# Always log exceptions within except blocks
try:
    # operation
except Exception:
    logger.exception("message")  # includes traceback
    # NOT: logger.error("message")  # won't include traceback
```

3. Processor Order
```python
# Processor order matters
structlog.configure(
    processors=[
        structlog.processors.format_exc_info,  # must come before
        structlog.processors.JSONRenderer(),   # renderer
    ]
)
```

This documentation provides a comprehensive guide for using and testing the exception logging module. The test examples cover various scenarios and demonstrate best practices for structured logging with exception handling.
