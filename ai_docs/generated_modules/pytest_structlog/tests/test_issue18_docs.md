
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this module, which demonstrates structured logging configuration and testing.

# Structured Logging Test Module Documentation

## Module Overview

This module demonstrates how to configure and test structured logging in Python using `structlog` and `pytest-structlog`. It provides a testing framework for verifying log message formatting and content.

### Key Features
- Structured logging configuration with multiple processors
- Test fixtures for logging setup
- Log capture and assertion capabilities
- Positional argument formatting validation

### Dependencies
- pytest>=7.0.0
- structlog>=22.1.0
- pytest-structlog>=0.5.0

## Installation and Setup

```bash
pip install pytest structlog pytest-structlog
```

## Configuration Details

The module uses a pytest fixture to configure structlog with the following processors:
- Level filtering
- Logger name addition
- Log level addition
- Positional argument formatting
- Timestamp addition
- Stack info rendering
- Exception info formatting
- Console rendering

## Usage Guide

### Basic Configuration

```python
import structlog
import pytest
from pytest_structlog import StructuredLogCapture

logger = structlog.get_logger(__name__)

@pytest.fixture
def stdlib_configure():
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.dev.ConsoleRenderer(),
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
    )
```

### Logging Example

```python
def log_processing_info(items_count: int, duration: float) -> None:
    logger.info(
        "Processed %d CC items in total in %.2f seconds",
        items_count,
        duration
    )
```

## Testing Guide

### Basic Test Cases

```python
from typing import Generator
import pytest
from pytest_structlog import StructuredLogCapture

@pytest.mark.usefixtures("stdlib_configure")
class TestLogging:
    def test_positional_formatting(self, log: StructuredLogCapture) -> None:
        """Test positional argument formatting in log messages.

        Args:
            log: Structured log capture fixture
        """
        items_count = 2
        dt = 0.02
        logger.info(
            "Processed %d CC items in total in %.2f seconds",
            items_count,
            dt
        )
        assert log.has(
            "Processed 2 CC items in total in 0.02 seconds",
            level="info"
        )

    def test_log_levels(self, log: StructuredLogCapture) -> None:
        """Test different log levels.

        Args:
            log: Structured log capture fixture
        """
        logger.debug("Debug message")
        logger.info("Info message")
        logger.warning("Warning message")

        assert log.has("Debug message", level="debug")
        assert log.has("Info message", level="info")
        assert log.has("Warning message", level="warning")
```

### Advanced Test Cases

```python
@pytest.mark.usefixtures("stdlib_configure")
class TestAdvancedLogging:
    def test_exception_logging(
        self,
        log: StructuredLogCapture
    ) -> None:
        """Test exception logging and formatting.

        Args:
            log: Structured log capture fixture
        """
        try:
            raise ValueError("Test error")
        except ValueError:
            logger.exception("An error occurred")

        assert log.has("An error occurred", level="error")
        assert "ValueError: Test error" in str(log.entries)

    def test_structured_context(
        self,
        log: StructuredLogCapture
    ) -> None:
        """Test logging with structured context.

        Args:
            log: Structured log capture fixture
        """
        bound_logger = logger.bind(user_id="123")
        bound_logger.info("User action")

        assert log.has("User action", level="info")
        assert any("user_id" in entry for entry in log.entries)
```

## Testing Best Practices

1. Always use type hints in test functions
2. Use appropriate fixtures for setup and teardown
3. Test different log levels
4. Verify both message content and structure
5. Test exception handling and formatting
6. Check structured context preservation

## Common Fixtures

```python
@pytest.fixture
def sample_data() -> Generator[dict, None, None]:
    """Provide sample data for logging tests.

    Yields:
        Dict containing test data
    """
    data = {
        "items_count": 5,
        "duration": 0.05,
        "user_id": "test_user"
    }
    yield data
```

## Error Handling and Edge Cases

```python
def test_empty_message(
    stdlib_configure,
    log: StructuredLogCapture
) -> None:
    """Test logging empty messages."""
    logger.info("")
    assert log.has("", level="info")

def test_special_characters(
    stdlib_configure,
    log: StructuredLogCapture
) -> None:
    """Test logging messages with special characters."""
    logger.info("Special chars: %s", "!@#$%^&*()")
    assert log.has("Special chars: !@#$%^&*()", level="info")
```

## Debugging Tips

1. Use `print(log.entries)` to inspect captured logs
2. Enable debug logging during tests with:
   ```python
   structlog.configure(
       processors=[...],
       wrapper_class=structlog.stdlib.BoundLogger,
       debug=True
   )
   ```
3. Use pytest's -v flag for verbose output

## Common Issues and Solutions

1. **Missing Logs**: Ensure correct log level configuration
2. **Formatting Issues**: Verify processor order in configuration
3. **Context Loss**: Check bound logger usage
4. **Assertion Failures**: Compare exact string representations

This documentation provides a comprehensive guide to using and testing structured logging with the provided module. Adapt the examples and practices to your specific needs while maintaining type safety and testing best practices.
