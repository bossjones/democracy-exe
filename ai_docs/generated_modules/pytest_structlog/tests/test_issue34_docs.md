
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this pytest plugin module that handles structlog processor configuration.

# Pytest Structlog Processor Configuration Plugin

## Module Overview

This pytest plugin provides flexible configuration options for managing structlog processors during testing. It allows developers to selectively keep or remove specific processors from the structlog configuration, enabling precise control over log processing behavior in tests.

Key features:
- Blacklist mode to evict specific processors
- Whitelist mode to keep only specified processors
- Configuration via pyproject.toml or pytest command line
- Mutual exclusivity enforcement between keep/evict modes

Dependencies:
- pytest >= 7.0.0
- structlog >= 22.0.0
- python >= 3.8

## Installation and Setup

```bash
pip install pytest-structlog-processors
```

Configuration can be done via pyproject.toml:

```toml
[tool.pytest.ini_options]
# Blacklist mode - remove specific processors
structlog_evict = ["JSONRenderer"]

# OR

# Whitelist mode - keep only specific processors
structlog_keep = ["password_nerf"]
```

## Usage Guide

### Basic Usage

The plugin provides two mutually exclusive modes for controlling structlog processors:

1. Blacklist Mode (Evict):
```python
import structlog

def password_processor(logger, log_method, event_dict):
    event_dict.pop("password", None)
    return event_dict

# Configure structlog with processors
structlog.configure(
    processors=[
        password_processor,
        structlog.processors.JSONRenderer(),
    ]
)

# In pyproject.toml:
# structlog_evict = ["JSONRenderer"]
# This keeps password_processor but removes JSONRenderer
```

2. Whitelist Mode (Keep):
```python
# In pyproject.toml:
# structlog_keep = ["password_processor"]
# This keeps only password_processor and removes all others
```

### Testing Examples

Here's a complete test suite demonstrating the plugin's functionality:

```python
# test_structlog_processors.py
from typing import Generator
import pytest
import structlog
from _pytest.logging import LogCaptureFixture

@pytest.fixture
def logger_setup() -> Generator[None, None, None]:
    """Setup structlog configuration for tests."""
    def password_processor(logger, log_method, event_dict):
        event_dict.pop("password", None)
        return event_dict

    structlog.configure(
        processors=[
            password_processor,
            structlog.processors.JSONRenderer(),
        ],
        logger_factory=structlog.stdlib.LoggerFactory(),
        wrapper_class=structlog.stdlib.BoundLogger,
    )
    yield
    structlog.reset_defaults()

def test_password_removal_with_processor(
    logger_setup: None,
    caplog: LogCaptureFixture
) -> None:
    """Test password removal when processor is kept."""
    logger = structlog.get_logger()
    logger.info("login", username="test", password="secret")

    assert "password" not in caplog.text
    assert "username" in caplog.text

@pytest.mark.parametrize("config_mode", [
    "blacklist",
    "whitelist"
])
def test_processor_configuration_modes(
    config_mode: str,
    pytester: pytest.Pytester
) -> None:
    """Test both configuration modes."""
    if config_mode == "blacklist":
        config = "structlog_evict = ['password_processor']"
    else:
        config = "structlog_keep = ['JSONRenderer']"

    pytester.makepyprojecttoml(f"""
        [tool.pytest.ini_options]
        {config}
    """)

    # Add test implementation...
```

## Testing Guide

### Test Categories

1. Configuration Validation Tests:
```python
def test_invalid_configuration(pytester: pytest.Pytester) -> None:
    """Test that invalid configurations raise appropriate errors."""
    pytester.makepyprojecttoml("""
        [tool.pytest.ini_options]
        structlog_keep = ["invalid_processor"]
        structlog_evict = ["another_processor"]
    """)

    result = pytester.runpytest()
    assert result.ret != 0
    assert "mutually exclusive" in result.stderr.str()
```

2. Processor Behavior Tests:
```python
def test_processor_execution_order(logger_setup: None) -> None:
    """Test processor execution order and modifications."""
    logger = structlog.get_logger()
    with structlog.testing.capture_logs() as captured:
        logger.info("test", sensitive="data")
    assert captured[0]["sensitive"] == "data"
```

3. Integration Tests:
```python
def test_integration_with_stdlib_logging(
    logger_setup: None,
    caplog: LogCaptureFixture
) -> None:
    """Test integration with Python's stdlib logging."""
    logger = structlog.get_logger()
    logger.info("test message")
    assert "test message" in caplog.text
```

### Testing Best Practices

1. Use Fixtures for Common Setup:
```python
@pytest.fixture(autouse=True)
def clean_structlog() -> Generator[None, None, None]:
    """Reset structlog configuration after each test."""
    yield
    structlog.reset_defaults()
```

2. Test Edge Cases:
```python
def test_empty_processor_list(pytester: pytest.Pytester) -> None:
    """Test behavior with empty processor configurations."""
    pytester.makepyprojecttoml("""
        [tool.pytest.ini_options]
        structlog_keep = []
    """)
    # Test implementation...
```

3. Test Configuration Combinations:
```python
@pytest.mark.parametrize("config", [
    {"keep": ["proc1"]},
    {"evict": ["proc1", "proc2"]},
    {"keep": []},
])
def test_processor_configurations(
    config: dict,
    pytester: pytest.Pytester
) -> None:
    """Test various processor configurations."""
    # Test implementation...
```

## Error Handling and Debugging

Common issues and solutions:

1. Processor Name Resolution:
```python
def test_processor_name_resolution(pytester: pytest.Pytester) -> None:
    """Test proper handling of processor name resolution."""
    # Test implementation...
```

2. Configuration Validation:
```python
def test_configuration_validation(pytester: pytest.Pytester) -> None:
    """Test configuration validation logic."""
    # Test implementation...
```

## Performance Considerations

- Keep processor chains minimal during testing
- Use appropriate fixtures scopes
- Consider processor execution order

This documentation provides a comprehensive overview of the plugin's functionality and testing approaches. Additional sections can be added based on specific needs or use cases.
