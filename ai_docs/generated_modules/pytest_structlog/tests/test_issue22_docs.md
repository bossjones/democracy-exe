
> [!NOTE]
> Documentation auto-generated by [ai-docs.](https://github.com/connor-john/ai-docs)

I'll create comprehensive documentation for this structlog testing module.

# Structlog Testing Helper Module Documentation

## Module Overview

This module provides utilities for testing applications that use structlog for logging, with a specific focus on verifying logger names in log outputs. It includes fixtures and helper functions to ensure proper logger name injection and verification in tests.

### Key Features
- Automatic logger name injection into log records
- Testing utilities for verifying log messages and metadata
- Integration with pytest and structlog
- Non-intrusive logging configuration management

### Dependencies
- pytest>=7.0.0
- structlog>=22.1.0

## Installation and Setup

```bash
# Install required packages
pip install pytest structlog
```

## Usage Guide

### Basic Usage

```python
# In your application code
import structlog

logger = structlog.get_logger("my-app-logger")

# In your tests
def test_logging_with_name(log):
    logger.info("message", extra_field="value")
    assert log.has("message", extra_field="value", logger="my-app-logger")
```

### Configuration Options

The module provides an `inject_logger_name` fixture that automatically adds logger name processing to structlog's configuration during tests.

## Testing Guide

### Test Cases

1. Basic Logger Name Verification

```python
# test_logging.py
import pytest
import structlog

logger = structlog.get_logger("test-logger")

def test_basic_logging(log):
    """
    Test that logger name is properly captured in log messages.

    Args:
        log: pytest fixture for log capture
    """
    logger.info("test message")
    assert log.has("test message", logger="test-logger")
```

2. Testing with Additional Context

```python
# test_logging_context.py
def test_logging_with_context(log):
    """
    Test logging with additional context fields.

    Args:
        log: pytest fixture for log capture
    """
    logger = structlog.get_logger("context-logger")
    logger.info("event", user_id="123", action="login")
    assert log.has(
        "event",
        logger="context-logger",
        user_id="123",
        action="login"
    )
```

3. Testing Multiple Log Messages

```python
# test_multiple_logs.py
def test_multiple_log_messages(log):
    """
    Test handling of multiple log messages.

    Args:
        log: pytest fixture for log capture
    """
    logger1 = structlog.get_logger("logger1")
    logger2 = structlog.get_logger("logger2")

    logger1.info("msg1")
    logger2.warning("msg2")

    assert log.has("msg1", logger="logger1")
    assert log.has("msg2", logger="logger2")
```

### Test Fixtures

```python
# conftest.py
import pytest
import structlog

@pytest.fixture(autouse=True)
def inject_logger_name(log):
    """
    Automatically inject logger name into log processors.

    Args:
        log: pytest's log capture fixture

    Yields:
        None: Yields control back to the test
    """
    original_processors = structlog.get_config().get("processors", [])
    if structlog.stdlib.add_logger_name not in original_processors:
        processors = [structlog.stdlib.add_logger_name] + original_processors
        log.original_configure(processors=processors)
        yield
        log.original_configure(processors=original_processors)
```

## Error Handling and Edge Cases

1. Testing Missing Logger Names

```python
def test_missing_logger_name(log):
    """Test behavior when logger name is not provided."""
    unnamed_logger = structlog.get_logger()
    unnamed_logger.info("message")
    assert log.has("message")  # Should still capture message
```

2. Testing Logger Name Override

```python
def test_logger_name_override(log):
    """Test behavior when logger name is overridden."""
    logger = structlog.get_logger("original-name")
    logger = logger.bind(logger="override-name")
    logger.info("message")
    assert log.has("message", logger="override-name")
```

## Performance Considerations

```python
def test_logging_performance(benchmark):
    """
    Test logging performance with logger name injection.
    """
    logger = structlog.get_logger("perf-test")

    def log_message():
        logger.info("performance test")

    benchmark(log_message)
```

## Integration Testing

```python
# test_integration.py
def test_integration_with_other_processors(log):
    """
    Test integration with other structlog processors.
    """
    processors = [
        structlog.stdlib.add_logger_name,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]

    structlog.configure(processors=processors)
    logger = structlog.get_logger("integration-test")

    logger.info("test")
    assert log.has("test", logger="integration-test")
```

## Debugging Tips

1. Enable Debug Logging

```python
def test_with_debug(caplog):
    """Enable debug logging for troubleshooting."""
    caplog.set_level("DEBUG")
    logger.debug("debug message")
    assert "debug message" in caplog.text
```

2. Inspect Log Structure

```python
def test_log_structure(log):
    """Inspect the full structure of log messages."""
    logger.info("structured", field="value")
    logs = log.entries
    print(logs)  # For debugging
    assert logs[0]["field"] == "value"
```

## Best Practices

1. Always clean up after tests
2. Use type hints for better code maintainability
3. Keep tests focused and isolated
4. Use meaningful logger names
5. Test both success and error cases
6. Document test purpose and expectations

## Common Issues and Solutions

1. Logger Name Not Appearing
- Ensure the inject_logger_name fixture is running
- Check structlog configuration
- Verify processor order

2. Incorrect Logger Names
- Check logger initialization
- Verify binding order
- Ensure no name conflicts

This documentation provides a comprehensive guide to using and testing the structlog logger name injection module. Adjust the examples and configurations according to your specific needs and requirements.
