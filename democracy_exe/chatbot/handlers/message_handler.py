"""Message processing and LangGraph integration.

This module contains functionality for processing Discord messages and integrating
with LangGraph for AI responses.
"""
from __future__ import annotations

import re

from typing import Any, Optional, Union, cast

import discord

from discord import DMChannel, Message, TextChannel, Thread
from discord.abc import Messageable
from langchain_core.messages import AIMessage, HumanMessage
from langgraph.graph.state import CompiledStateGraph
from loguru import logger
from PIL import Image

from democracy_exe.chatbot.handlers.attachment_handler import AttachmentHandler


class MessageHandler:
    """Handles message processing and AI responses."""

    def __init__(self, bot: Any) -> None:
        """Initialize the message handler.

        Args:
            bot: The Discord bot instance
        """
        self.bot = bot
        self.attachment_handler = AttachmentHandler()

    async def _get_thread(self, message: Message) -> Thread | DMChannel | None:
        """Get or create a thread for the message.

        Args:
            message: The message to get/create a thread for

        Returns:
            Either a Thread object for server channels or DMChannel for direct messages
        """
        channel = message.channel

        # If this is a DM channel, just return it directly
        if isinstance(channel, DMChannel):
            return channel

        # For regular channels, create a thread
        if isinstance(channel, (TextChannel, Thread)):
            try:
                return await channel.create_thread(name="Response", message=message)
            except discord.HTTPException as e:
                logger.error(f"Failed to create thread: {e}")
                return None

        return None

    def _format_inbound_message(self, message: Message) -> HumanMessage:
        """Format a Discord message into a HumanMessage for LangGraph processing.

        Args:
            message: The Discord message to format

        Returns:
            A formatted message ready for LangGraph processing
        """
        if not message.content:
            logger.warning("Message has no content")
            content = ""
        else:
            content = message.content

        guild_str = "" if message.guild is None else f"guild={message.guild}"
        formatted_content = f"""<discord {guild_str} channel={message.channel} author={message.author!r}>
        {content}
        </discord>"""

        logger.debug(f"content: {formatted_content}")
        logger.complete()

        # Get global_name or fallback to name if not available
        author_name = getattr(message.author, "global_name", None) or str(message.author)

        return HumanMessage(
            content=formatted_content,
            name=author_name,
            id=str(message.id)
        )

    def stream_bot_response(
        self,
        graph: CompiledStateGraph,
        user_input: dict[str, list[HumanMessage]] | None = None,
        thread: dict[str, Any] | None = None,
        interruptable: bool = False
    ) -> str:
        """Stream responses from the LangGraph Chatbot.

        Args:
            graph: The compiled state graph to use for generating responses
            user_input: Dictionary containing user messages
            thread: Dictionary containing thread state information
            interruptable: Flag to indicate if streaming can be interrupted

        Returns:
            The concatenated response from all chunks generated by the graph

        Raises:
            Exception: If there's an error processing the response
        """
        if not user_input or "messages" not in user_input:
            raise ValueError("Invalid user input format")

        # Run the graph until the first interruption
        chunks = []
        try:
            for event in graph.stream(user_input, thread, stream_mode="values"):
                logger.debug(event)
                if not event or "messages" not in event:
                    continue

                # this is the response from the LLM
                chunk = event["messages"][-1]
                if isinstance(chunk, AIMessage) and chunk.content:
                    chunks.append(chunk.content)

            response = "".join(chunks)
            if not response:
                response = "I apologize, but I couldn't generate a proper response."

            logger.debug(f"response: {response}")
            return response

        except Exception as e:
            logger.exception("Error streaming bot response")
            raise

    async def check_for_attachments(self, message: Message) -> str:
        """Check a Discord message for attachments and process image URLs.

        Args:
            message: The Discord message to check for attachments and process

        Returns:
            The updated message content with extracted information

        Raises:
            ValueError: If message has no content and no attachments
        """
        if not message.content and not message.attachments:
            raise ValueError("Message has no content or attachments")

        message_content = message.content or ""
        url_pattern = re.compile(r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+")

        try:
            if "https://tenor.com/view/" in message_content:
                return await self._handle_tenor_gif(message, message_content)
            elif url_pattern.match(message_content):
                return await self._handle_url_image(message_content)
            elif message.attachments:
                return await self._handle_attachment_image(message)

            return message_content

        except Exception as e:
            logger.exception("Error processing attachments")
            return message_content

    async def _handle_tenor_gif(self, message: Message, content: str) -> str:
        """Handle Tenor GIF URLs in messages.

        Args:
            message: The Discord message
            content: The message content

        Returns:
            Updated message content with GIF description
        """
        try:
            start_index = content.index("https://tenor.com/view/")
            end_index = content.find(" ", start_index)
            tenor_url = content[start_index:] if end_index == -1 else content[start_index:end_index]

            parts = tenor_url.split("/")
            words = parts[-1].split("-")[:-1]
            sentence = " ".join(words)

            return f"{content} [{message.author.display_name} posts an animated {sentence}]".replace(tenor_url, "")
        except Exception as e:
            logger.error(f"Error processing Tenor GIF: {e}")
            return content

    async def _handle_url_image(self, url: str) -> str:
        """Handle image URLs in messages.

        Args:
            url: The image URL

        Returns:
            The original URL
        """
        try:
            logger.info(f"Processing image URL: {url}")
            response = await self.attachment_handler.download_image(url)
            if response:
                image = Image.open(response).convert("RGB")
                # Process image if needed
            return url
        except Exception as e:
            logger.error(f"Error processing image URL: {e}")
            return url

    async def _handle_attachment_image(self, message: Message) -> str:
        """Handle image attachments in messages.

        Args:
            message: The Discord message with attachments

        Returns:
            The message content
        """
        try:
            if not message.attachments:
                return message.content or ""

            attachment = message.attachments[0]
            if not attachment.content_type or not attachment.content_type.startswith("image/"):
                return message.content or ""

            response = await self.attachment_handler.download_image(attachment.url)
            if response:
                image = Image.open(response).convert("RGB")
                # Process image if needed

            return message.content or ""
        except Exception as e:
            logger.error(f"Error processing attachment: {e}")
            return message.content or ""

    def get_session_id(self, message: Message | Thread) -> str:
        """Generate a session ID for the given message.

        Args:
            message: The message or event dictionary

        Returns:
            The generated session ID

        Raises:
            ValueError: If message type is not supported
        """
        try:
            if isinstance(message, Thread):
                if not message.starter_message:
                    raise ValueError("Thread has no starter message")
                is_dm = str(message.starter_message.channel.type) == "private"
                user_id = message.starter_message.author.id
                channel_id = message.starter_message.channel.name
            elif isinstance(message, Message):
                is_dm = str(message.channel.type) == "private"
                user_id = message.author.id
                channel_id = message.channel.id
            else:
                raise ValueError(f"Unsupported message type: {type(message)}")

            return f"discord_{user_id}" if is_dm else f"discord_{channel_id.id if hasattr(channel_id, 'id') else channel_id}"
        except Exception as e:
            logger.error(f"Error generating session ID: {e}")
            return f"discord_error_{id(message)}"

    def prepare_agent_input(
        self, message: Message | Thread, user_real_name: str, surface_info: dict
    ) -> dict[str, Any]:
        """Prepare the agent input from the incoming Discord message.

        Args:
            message: The Discord message containing the user input
            user_real_name: The real name of the user who sent the message
            surface_info: The surface information related to the message

        Returns:
            The input dictionary to be sent to the agent

        Raises:
            ValueError: If message type is not supported
        """
        try:
            if isinstance(message, Thread):
                if not message.starter_message:
                    raise ValueError("Thread has no starter message")
                agent_input = {
                    "user name": user_real_name,
                    "message": message.starter_message.content or ""
                }
                attachments = message.starter_message.attachments
            elif isinstance(message, Message):
                agent_input = {
                    "user name": user_real_name,
                    "message": message.content or ""
                }
                attachments = message.attachments
            else:
                raise ValueError(f"Unsupported message type: {type(message)}")

            if attachments:
                for attachment in attachments:
                    agent_input["file_name"] = attachment.filename
                    if attachment.content_type and attachment.content_type.startswith("image/"):
                        agent_input["image_url"] = attachment.url

            agent_input["surface_info"] = surface_info
            return agent_input

        except Exception as e:
            logger.error(f"Error preparing agent input: {e}")
            return {
                "user name": user_real_name,
                "message": "Error processing message",
                "surface_info": surface_info
            }
