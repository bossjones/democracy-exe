"""
This type stub file was generated by pyright.
"""

from stone.backends.python_rsrc import stone_base as bb
from dropbox import async_

"""
This namespace contains endpoints and data types for basic file operations.
"""
class AddTagArg(bb.Struct):
    """
    :ivar files.AddTagArg.path: Path to the item to be tagged.
    :ivar files.AddTagArg.tag_text: The value of the tag to add. Will be
        automatically converted to lowercase letters.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., tag_text=...) -> None:
        ...
    
    path = ...
    tag_text = ...


AddTagArg_validator = ...
class BaseTagError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: BaseTagError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


BaseTagError_validator = ...
class AddTagError(BaseTagError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.AddTagError.too_many_tags: The item already has the maximum
        supported number of tags.
    """
    too_many_tags = ...
    def is_too_many_tags(self):
        """
        Check if the union tag is ``too_many_tags``.

        :rtype: bool
        """
        ...
    


AddTagError_validator = ...
class GetMetadataArg(bb.Struct):
    """
    :ivar files.GetMetadataArg.path: The path of a file or folder on Dropbox.
    :ivar files.GetMetadataArg.include_media_info: If true,
        ``FileMetadata.media_info`` is set for photo and video.
    :ivar files.GetMetadataArg.include_deleted: If true,
        :class:`DeletedMetadata` will be returned for deleted file or folder,
        otherwise ``LookupError.not_found`` will be returned.
    :ivar files.GetMetadataArg.include_has_explicit_shared_members: If true, the
        results will include a flag for each file indicating whether or not
        that file has any explicit members.
    :ivar files.GetMetadataArg.include_property_groups: If set to a valid list
        of template IDs, ``FileMetadata.property_groups`` is set if there exists
        property data associated with the file and each of the listed templates.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., include_media_info=..., include_deleted=..., include_has_explicit_shared_members=..., include_property_groups=...) -> None:
        ...
    
    path = ...
    include_media_info = ...
    include_deleted = ...
    include_has_explicit_shared_members = ...
    include_property_groups = ...


GetMetadataArg_validator = ...
class AlphaGetMetadataArg(GetMetadataArg):
    """
    :ivar files.AlphaGetMetadataArg.include_property_templates: If set to a
        valid list of template IDs, ``FileMetadata.property_groups`` is set for
        files with custom properties.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., include_media_info=..., include_deleted=..., include_has_explicit_shared_members=..., include_property_groups=..., include_property_templates=...) -> None:
        ...
    
    include_property_templates = ...


AlphaGetMetadataArg_validator = ...
class GetMetadataError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: GetMetadataError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


GetMetadataError_validator = ...
class AlphaGetMetadataError(GetMetadataError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    @classmethod
    def properties_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``properties_error`` tag
        with value ``val``.

        :param file_properties.LookUpPropertiesError val:
        :rtype: AlphaGetMetadataError
        """
        ...
    
    def is_properties_error(self):
        """
        Check if the union tag is ``properties_error``.

        :rtype: bool
        """
        ...
    
    def get_properties_error(self): # -> None:
        """
        Only call this if :meth:`is_properties_error` is true.

        :rtype: file_properties.LookUpPropertiesError
        """
        ...
    


AlphaGetMetadataError_validator = ...
class CommitInfo(bb.Struct):
    """
    :ivar files.CommitInfo.path: Path in the user's Dropbox to save the file.
    :ivar files.CommitInfo.mode: Selects what to do if the file already exists.
    :ivar files.CommitInfo.autorename: If there's a conflict, as determined by
        ``mode``, have the Dropbox server try to autorename the file to avoid
        conflict.
    :ivar files.CommitInfo.client_modified: The value to store as the
        ``client_modified`` timestamp. Dropbox automatically records the time at
        which the file was written to the Dropbox servers. It can also record an
        additional timestamp, provided by Dropbox desktop clients, mobile
        clients, and API apps of when the file was actually created or modified.
    :ivar files.CommitInfo.mute: Normally, users are made aware of any file
        modifications in their Dropbox account via notifications in the client
        software. If ``True``, this tells the clients that this modification
        shouldn't result in a user notification.
    :ivar files.CommitInfo.property_groups: List of custom properties to add to
        file.
    :ivar files.CommitInfo.strict_conflict: Be more strict about how each
        :class:`WriteMode` detects conflict. For example, always return a
        conflict error when ``mode`` = ``WriteMode.update`` and the given "rev"
        doesn't match the existing file's "rev", even if the existing file has
        been deleted. This also forces a conflict even when the target path
        refers to a file with identical contents.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., mode=..., autorename=..., client_modified=..., mute=..., property_groups=..., strict_conflict=...) -> None:
        ...
    
    path = ...
    mode = ...
    autorename = ...
    client_modified = ...
    mute = ...
    property_groups = ...
    strict_conflict = ...


CommitInfo_validator = ...
class ContentSyncSetting(bb.Struct):
    """
    :ivar files.ContentSyncSetting.id: Id of the item this setting is applied
        to.
    :ivar files.ContentSyncSetting.sync_setting: Setting for this item.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., sync_setting=...) -> None:
        ...
    
    id = ...
    sync_setting = ...


ContentSyncSetting_validator = ...
class ContentSyncSettingArg(bb.Struct):
    """
    :ivar files.ContentSyncSettingArg.id: Id of the item this setting is applied
        to.
    :ivar files.ContentSyncSettingArg.sync_setting: Setting for this item.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., sync_setting=...) -> None:
        ...
    
    id = ...
    sync_setting = ...


ContentSyncSettingArg_validator = ...
class CreateFolderArg(bb.Struct):
    """
    :ivar files.CreateFolderArg.path: Path in the user's Dropbox to create.
    :ivar files.CreateFolderArg.autorename: If there's a conflict, have the
        Dropbox server try to autorename the folder to avoid the conflict.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., autorename=...) -> None:
        ...
    
    path = ...
    autorename = ...


CreateFolderArg_validator = ...
class CreateFolderBatchArg(bb.Struct):
    """
    :ivar files.CreateFolderBatchArg.paths: List of paths to be created in the
        user's Dropbox. Duplicate path arguments in the batch are considered
        only once.
    :ivar files.CreateFolderBatchArg.autorename: If there's a conflict, have the
        Dropbox server try to autorename the folder to avoid the conflict.
    :ivar files.CreateFolderBatchArg.force_async: Whether to force the create to
        happen asynchronously.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, paths=..., autorename=..., force_async=...) -> None:
        ...
    
    paths = ...
    autorename = ...
    force_async = ...


CreateFolderBatchArg_validator = ...
class CreateFolderBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.CreateFolderBatchError.too_many_files: The operation would
        involve too many files or folders.
    """
    _catch_all = ...
    too_many_files = ...
    other = ...
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


CreateFolderBatchError_validator = ...
class CreateFolderBatchJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar CreateFolderBatchResult CreateFolderBatchJobStatus.complete: The batch
        create folder has finished.
    :ivar CreateFolderBatchError CreateFolderBatchJobStatus.failed: The batch
        create folder has failed.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param CreateFolderBatchResult val:
        :rtype: CreateFolderBatchJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param CreateFolderBatchError val:
        :rtype: CreateFolderBatchJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The batch create folder has finished.

        Only call this if :meth:`is_complete` is true.

        :rtype: CreateFolderBatchResult
        """
        ...
    
    def get_failed(self): # -> None:
        """
        The batch create folder has failed.

        Only call this if :meth:`is_failed` is true.

        :rtype: CreateFolderBatchError
        """
        ...
    


CreateFolderBatchJobStatus_validator = ...
class CreateFolderBatchLaunch(async_.LaunchResultBase):
    """
    Result returned by
    :meth:`dropbox.dropbox_client.Dropbox.files_create_folder_batch` that may
    either launch an asynchronous job or complete synchronously.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param CreateFolderBatchResult val:
        :rtype: CreateFolderBatchLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: CreateFolderBatchResult
        """
        ...
    


CreateFolderBatchLaunch_validator = ...
class FileOpsResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self) -> None:
        ...
    


FileOpsResult_validator = ...
class CreateFolderBatchResult(FileOpsResult):
    """
    :ivar files.CreateFolderBatchResult.entries: Each entry in
        ``CreateFolderBatchArg.paths`` will appear at the same position inside
        ``CreateFolderBatchResult.entries``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


CreateFolderBatchResult_validator = ...
class CreateFolderBatchResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param CreateFolderEntryResult val:
        :rtype: CreateFolderBatchResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param CreateFolderEntryError val:
        :rtype: CreateFolderBatchResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: CreateFolderEntryResult
        """
        ...
    
    def get_failure(self): # -> None:
        """
        Only call this if :meth:`is_failure` is true.

        :rtype: CreateFolderEntryError
        """
        ...
    


CreateFolderBatchResultEntry_validator = ...
class CreateFolderEntryError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: CreateFolderEntryError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: WriteError
        """
        ...
    


CreateFolderEntryError_validator = ...
class CreateFolderEntryResult(bb.Struct):
    """
    :ivar files.CreateFolderEntryResult.metadata: Metadata of the created
        folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


CreateFolderEntryResult_validator = ...
class CreateFolderError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: CreateFolderError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: WriteError
        """
        ...
    


CreateFolderError_validator = ...
class CreateFolderResult(FileOpsResult):
    """
    :ivar files.CreateFolderResult.metadata: Metadata of the created folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


CreateFolderResult_validator = ...
class DeleteArg(bb.Struct):
    """
    :ivar files.DeleteArg.path: Path in the user's Dropbox to delete.
    :ivar files.DeleteArg.parent_rev: Perform delete if given "rev" matches the
        existing file's latest "rev". This field does not support deleting a
        folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., parent_rev=...) -> None:
        ...
    
    path = ...
    parent_rev = ...


DeleteArg_validator = ...
class DeleteBatchArg(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


DeleteBatchArg_validator = ...
class DeleteBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.DeleteBatchError.too_many_write_operations: Use
        ``DeleteError.too_many_write_operations``.
        :meth:`dropbox.dropbox_client.Dropbox.files_delete_batch` now provides
        smaller granularity about which entry has failed because of this.
    """
    _catch_all = ...
    too_many_write_operations = ...
    other = ...
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


DeleteBatchError_validator = ...
class DeleteBatchJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar DeleteBatchResult DeleteBatchJobStatus.complete: The batch delete has
        finished.
    :ivar DeleteBatchError DeleteBatchJobStatus.failed: The batch delete has
        failed.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param DeleteBatchResult val:
        :rtype: DeleteBatchJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param DeleteBatchError val:
        :rtype: DeleteBatchJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The batch delete has finished.

        Only call this if :meth:`is_complete` is true.

        :rtype: DeleteBatchResult
        """
        ...
    
    def get_failed(self): # -> None:
        """
        The batch delete has failed.

        Only call this if :meth:`is_failed` is true.

        :rtype: DeleteBatchError
        """
        ...
    


DeleteBatchJobStatus_validator = ...
class DeleteBatchLaunch(async_.LaunchResultBase):
    """
    Result returned by :meth:`dropbox.dropbox_client.Dropbox.files_delete_batch`
    that may either launch an asynchronous job or complete synchronously.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param DeleteBatchResult val:
        :rtype: DeleteBatchLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: DeleteBatchResult
        """
        ...
    


DeleteBatchLaunch_validator = ...
class DeleteBatchResult(FileOpsResult):
    """
    :ivar files.DeleteBatchResult.entries: Each entry in
        ``DeleteBatchArg.entries`` will appear at the same position inside
        ``DeleteBatchResult.entries``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


DeleteBatchResult_validator = ...
class DeleteBatchResultData(bb.Struct):
    """
    :ivar files.DeleteBatchResultData.metadata: Metadata of the deleted object.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


DeleteBatchResultData_validator = ...
class DeleteBatchResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param DeleteBatchResultData val:
        :rtype: DeleteBatchResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param DeleteError val:
        :rtype: DeleteBatchResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: DeleteBatchResultData
        """
        ...
    
    def get_failure(self): # -> None:
        """
        Only call this if :meth:`is_failure` is true.

        :rtype: DeleteError
        """
        ...
    


DeleteBatchResultEntry_validator = ...
class DeleteError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.DeleteError.too_many_write_operations: There are too many write
        operations in user's Dropbox. Please retry this request.
    :ivar files.DeleteError.too_many_files: There are too many files in one
        request. Please retry with fewer files.
    """
    _catch_all = ...
    too_many_write_operations = ...
    too_many_files = ...
    other = ...
    @classmethod
    def path_lookup(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path_lookup`` tag with
        value ``val``.

        :param LookupError val:
        :rtype: DeleteError
        """
        ...
    
    @classmethod
    def path_write(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path_write`` tag with
        value ``val``.

        :param WriteError val:
        :rtype: DeleteError
        """
        ...
    
    def is_path_lookup(self):
        """
        Check if the union tag is ``path_lookup``.

        :rtype: bool
        """
        ...
    
    def is_path_write(self):
        """
        Check if the union tag is ``path_write``.

        :rtype: bool
        """
        ...
    
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path_lookup(self): # -> None:
        """
        Only call this if :meth:`is_path_lookup` is true.

        :rtype: LookupError
        """
        ...
    
    def get_path_write(self): # -> None:
        """
        Only call this if :meth:`is_path_write` is true.

        :rtype: WriteError
        """
        ...
    


DeleteError_validator = ...
class DeleteResult(FileOpsResult):
    """
    :ivar files.DeleteResult.metadata: Metadata of the deleted object.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


DeleteResult_validator = ...
class Metadata(bb.Struct):
    """
    Metadata for a file or folder.

    :ivar files.Metadata.name: The last component of the path (including
        extension). This never contains a slash.
    :ivar files.Metadata.path_lower: The lowercased full path in the user's
        Dropbox. This always starts with a slash. This field will be null if the
        file or folder is not mounted.
    :ivar files.Metadata.path_display: The cased path to be used for display
        purposes only. In rare instances the casing will not correctly match the
        user's filesystem, but this behavior will match the path provided in the
        Core API v1, and at least the last path component will have the correct
        casing. Changes to only the casing of paths won't be returned by
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue`. This
        field will be null if the file or folder is not mounted.
    :ivar files.Metadata.parent_shared_folder_id: Please use
        ``FileSharingInfo.parent_shared_folder_id`` or
        ``FolderSharingInfo.parent_shared_folder_id`` instead.
    :ivar files.Metadata.preview_url: The preview URL of the file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., path_lower=..., path_display=..., parent_shared_folder_id=..., preview_url=...) -> None:
        ...
    
    name = ...
    path_lower = ...
    path_display = ...
    parent_shared_folder_id = ...
    preview_url = ...


Metadata_validator = ...
class DeletedMetadata(Metadata):
    """
    Indicates that there used to be a file or folder at this path, but it no
    longer exists.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., path_lower=..., path_display=..., parent_shared_folder_id=..., preview_url=...) -> None:
        ...
    


DeletedMetadata_validator = ...
class Dimensions(bb.Struct):
    """
    Dimensions for a photo or video.

    :ivar files.Dimensions.height: Height of the photo/video.
    :ivar files.Dimensions.width: Width of the photo/video.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, height=..., width=...) -> None:
        ...
    
    height = ...
    width = ...


Dimensions_validator = ...
class DownloadArg(bb.Struct):
    """
    :ivar files.DownloadArg.path: The path of the file to download.
    :ivar files.DownloadArg.rev: Please specify revision in ``path`` instead.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., rev=...) -> None:
        ...
    
    path = ...
    rev = ...


DownloadArg_validator = ...
class DownloadError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.DownloadError.unsupported_file: This file type cannot be
        downloaded directly; use
        :meth:`dropbox.dropbox_client.Dropbox.files_export` instead.
    """
    _catch_all = ...
    unsupported_file = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: DownloadError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_file(self):
        """
        Check if the union tag is ``unsupported_file``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


DownloadError_validator = ...
class DownloadZipArg(bb.Struct):
    """
    :ivar files.DownloadZipArg.path: The path of the folder to download.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=...) -> None:
        ...
    
    path = ...


DownloadZipArg_validator = ...
class DownloadZipError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.DownloadZipError.too_large: The folder or a file is too large to
        download.
    :ivar files.DownloadZipError.too_many_files: The folder has too many files
        to download.
    """
    _catch_all = ...
    too_large = ...
    too_many_files = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: DownloadZipError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_too_large(self):
        """
        Check if the union tag is ``too_large``.

        :rtype: bool
        """
        ...
    
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


DownloadZipError_validator = ...
class DownloadZipResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


DownloadZipResult_validator = ...
class ExportArg(bb.Struct):
    """
    :ivar files.ExportArg.path: The path of the file to be exported.
    :ivar files.ExportArg.export_format: The file format to which the file
        should be exported. This must be one of the formats listed in the file's
        export_options returned by
        :meth:`dropbox.dropbox_client.Dropbox.files_get_metadata`. If none is
        specified, the default format (specified in export_as in file metadata)
        will be used.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., export_format=...) -> None:
        ...
    
    path = ...
    export_format = ...


ExportArg_validator = ...
class ExportError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ExportError.non_exportable: This file type cannot be exported.
        Use :meth:`dropbox.dropbox_client.Dropbox.files_download` instead.
    :ivar files.ExportError.invalid_export_format: The specified export format
        is not a valid option for this file type.
    :ivar files.ExportError.retry_error: The exportable content is not yet
        available. Please retry later.
    """
    _catch_all = ...
    non_exportable = ...
    invalid_export_format = ...
    retry_error = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ExportError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_non_exportable(self):
        """
        Check if the union tag is ``non_exportable``.

        :rtype: bool
        """
        ...
    
    def is_invalid_export_format(self):
        """
        Check if the union tag is ``invalid_export_format``.

        :rtype: bool
        """
        ...
    
    def is_retry_error(self):
        """
        Check if the union tag is ``retry_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


ExportError_validator = ...
class ExportInfo(bb.Struct):
    """
    Export information for a file.

    :ivar files.ExportInfo.export_as: Format to which the file can be exported
        to.
    :ivar files.ExportInfo.export_options: Additional formats to which the file
        can be exported. These values can be specified as the export_format in
        /files/export.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, export_as=..., export_options=...) -> None:
        ...
    
    export_as = ...
    export_options = ...


ExportInfo_validator = ...
class ExportMetadata(bb.Struct):
    """
    :ivar files.ExportMetadata.name: The last component of the path (including
        extension). This never contains a slash.
    :ivar files.ExportMetadata.size: The file size in bytes.
    :ivar files.ExportMetadata.export_hash: A hash based on the exported file
        content. This field can be used to verify data integrity. Similar to
        content hash. For more information see our `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    :ivar files.ExportMetadata.paper_revision: If the file is a Paper doc, this
        gives the latest doc revision which can be used in
        :meth:`dropbox.dropbox_client.Dropbox.files_paper_update`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., size=..., export_hash=..., paper_revision=...) -> None:
        ...
    
    name = ...
    size = ...
    export_hash = ...
    paper_revision = ...


ExportMetadata_validator = ...
class ExportResult(bb.Struct):
    """
    :ivar files.ExportResult.export_metadata: Metadata for the exported version
        of the file.
    :ivar files.ExportResult.file_metadata: Metadata for the original file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, export_metadata=..., file_metadata=...) -> None:
        ...
    
    export_metadata = ...
    file_metadata = ...


ExportResult_validator = ...
class FileCategory(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.FileCategory.image: jpg, png, gif, and more.
    :ivar files.FileCategory.document: doc, docx, txt, and more.
    :ivar files.FileCategory.pdf: pdf.
    :ivar files.FileCategory.spreadsheet: xlsx, xls, csv, and more.
    :ivar files.FileCategory.presentation: ppt, pptx, key, and more.
    :ivar files.FileCategory.audio: mp3, wav, mid, and more.
    :ivar files.FileCategory.video: mov, wmv, mp4, and more.
    :ivar files.FileCategory.folder: dropbox folder.
    :ivar files.FileCategory.paper: dropbox paper doc.
    :ivar files.FileCategory.others: any file not in one of the categories
        above.
    """
    _catch_all = ...
    image = ...
    document = ...
    pdf = ...
    spreadsheet = ...
    presentation = ...
    audio = ...
    video = ...
    folder = ...
    paper = ...
    others = ...
    other = ...
    def is_image(self):
        """
        Check if the union tag is ``image``.

        :rtype: bool
        """
        ...
    
    def is_document(self):
        """
        Check if the union tag is ``document``.

        :rtype: bool
        """
        ...
    
    def is_pdf(self):
        """
        Check if the union tag is ``pdf``.

        :rtype: bool
        """
        ...
    
    def is_spreadsheet(self):
        """
        Check if the union tag is ``spreadsheet``.

        :rtype: bool
        """
        ...
    
    def is_presentation(self):
        """
        Check if the union tag is ``presentation``.

        :rtype: bool
        """
        ...
    
    def is_audio(self):
        """
        Check if the union tag is ``audio``.

        :rtype: bool
        """
        ...
    
    def is_video(self):
        """
        Check if the union tag is ``video``.

        :rtype: bool
        """
        ...
    
    def is_folder(self):
        """
        Check if the union tag is ``folder``.

        :rtype: bool
        """
        ...
    
    def is_paper(self):
        """
        Check if the union tag is ``paper``.

        :rtype: bool
        """
        ...
    
    def is_others(self):
        """
        Check if the union tag is ``others``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


FileCategory_validator = ...
class FileLock(bb.Struct):
    """
    :ivar files.FileLock.content: The lock description.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, content=...) -> None:
        ...
    
    content = ...


FileLock_validator = ...
class FileLockContent(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.FileLockContent.unlocked: Empty type to indicate no lock.
    :ivar SingleUserLock FileLockContent.single_user: A lock held by a single
        user.
    """
    _catch_all = ...
    unlocked = ...
    other = ...
    @classmethod
    def single_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``single_user`` tag with
        value ``val``.

        :param SingleUserLock val:
        :rtype: FileLockContent
        """
        ...
    
    def is_unlocked(self):
        """
        Check if the union tag is ``unlocked``.

        :rtype: bool
        """
        ...
    
    def is_single_user(self):
        """
        Check if the union tag is ``single_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_single_user(self): # -> None:
        """
        A lock held by a single user.

        Only call this if :meth:`is_single_user` is true.

        :rtype: SingleUserLock
        """
        ...
    


FileLockContent_validator = ...
class FileLockMetadata(bb.Struct):
    """
    :ivar files.FileLockMetadata.is_lockholder: True if caller holds the file
        lock.
    :ivar files.FileLockMetadata.lockholder_name: The display name of the lock
        holder.
    :ivar files.FileLockMetadata.lockholder_account_id: The account ID of the
        lock holder if known.
    :ivar files.FileLockMetadata.created: The timestamp of the lock was created.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, is_lockholder=..., lockholder_name=..., lockholder_account_id=..., created=...) -> None:
        ...
    
    is_lockholder = ...
    lockholder_name = ...
    lockholder_account_id = ...
    created = ...


FileLockMetadata_validator = ...
class FileMetadata(Metadata):
    """
    :ivar files.FileMetadata.id: A unique identifier for the file.
    :ivar files.FileMetadata.client_modified: For files, this is the
        modification time set by the desktop client when the file was added to
        Dropbox. Since this time is not verified (the Dropbox server stores
        whatever the desktop client sends up), this should only be used for
        display purposes (such as sorting) and not, for example, to determine if
        a file has changed or not.
    :ivar files.FileMetadata.server_modified: The last time the file was
        modified on Dropbox.
    :ivar files.FileMetadata.rev: A unique identifier for the current revision
        of a file. This field is the same rev as elsewhere in the API and can be
        used to detect changes and avoid conflicts.
    :ivar files.FileMetadata.size: The file size in bytes.
    :ivar files.FileMetadata.media_info: Additional information if the file is a
        photo or video. This field will not be set on entries returned by
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder`,
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue`, or
        :meth:`dropbox.dropbox_client.Dropbox.files_get_thumbnail_batch`,
        starting December 2, 2019.
    :ivar files.FileMetadata.symlink_info: Set if this file is a symlink.
    :ivar files.FileMetadata.sharing_info: Set if this file is contained in a
        shared folder.
    :ivar files.FileMetadata.is_downloadable: If true, file can be downloaded
        directly; else the file must be exported.
    :ivar files.FileMetadata.export_info: Information about format this file can
        be exported to. This filed must be set if ``is_downloadable`` is set to
        false.
    :ivar files.FileMetadata.property_groups: Additional information if the file
        has custom properties with the property template specified.
    :ivar files.FileMetadata.has_explicit_shared_members: This flag will only be
        present if include_has_explicit_shared_members  is true in
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder` or
        :meth:`dropbox.dropbox_client.Dropbox.files_get_metadata`. If this  flag
        is present, it will be true if this file has any explicit shared
        members. This is different from sharing_info in that this could be true
        in the case where a file has explicit members but is not contained
        within  a shared folder.
    :ivar files.FileMetadata.content_hash: A hash of the file content. This
        field can be used to verify data integrity. For more information see our
        `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    :ivar files.FileMetadata.file_lock_info: If present, the metadata associated
        with the file's current lock.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., id=..., client_modified=..., server_modified=..., rev=..., size=..., path_lower=..., path_display=..., parent_shared_folder_id=..., preview_url=..., media_info=..., symlink_info=..., sharing_info=..., is_downloadable=..., export_info=..., property_groups=..., has_explicit_shared_members=..., content_hash=..., file_lock_info=...) -> None:
        ...
    
    id = ...
    client_modified = ...
    server_modified = ...
    rev = ...
    size = ...
    media_info = ...
    symlink_info = ...
    sharing_info = ...
    is_downloadable = ...
    export_info = ...
    property_groups = ...
    has_explicit_shared_members = ...
    content_hash = ...
    file_lock_info = ...


FileMetadata_validator = ...
class SharingInfo(bb.Struct):
    """
    Sharing info for a file or folder.

    :ivar files.SharingInfo.read_only: True if the file or folder is inside a
        read-only shared folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, read_only=...) -> None:
        ...
    
    read_only = ...


SharingInfo_validator = ...
class FileSharingInfo(SharingInfo):
    """
    Sharing info for a file which is contained by a shared folder.

    :ivar files.FileSharingInfo.parent_shared_folder_id: ID of shared folder
        that holds this file.
    :ivar files.FileSharingInfo.modified_by: The last user who modified the
        file. This field will be null if the user's account has been deleted.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, read_only=..., parent_shared_folder_id=..., modified_by=...) -> None:
        ...
    
    parent_shared_folder_id = ...
    modified_by = ...


FileSharingInfo_validator = ...
class FileStatus(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    active = ...
    deleted = ...
    other = ...
    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        ...
    
    def is_deleted(self):
        """
        Check if the union tag is ``deleted``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


FileStatus_validator = ...
class FolderMetadata(Metadata):
    """
    :ivar files.FolderMetadata.id: A unique identifier for the folder.
    :ivar files.FolderMetadata.shared_folder_id: Please use ``sharing_info``
        instead.
    :ivar files.FolderMetadata.sharing_info: Set if the folder is contained in a
        shared folder or is a shared folder mount point.
    :ivar files.FolderMetadata.property_groups: Additional information if the
        file has custom properties with the property template specified. Note
        that only properties associated with user-owned templates, not
        team-owned templates, can be attached to folders.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., id=..., path_lower=..., path_display=..., parent_shared_folder_id=..., preview_url=..., shared_folder_id=..., sharing_info=..., property_groups=...) -> None:
        ...
    
    id = ...
    shared_folder_id = ...
    sharing_info = ...
    property_groups = ...


FolderMetadata_validator = ...
class FolderSharingInfo(SharingInfo):
    """
    Sharing info for a folder which is contained in a shared folder or is a
    shared folder mount point.

    :ivar files.FolderSharingInfo.parent_shared_folder_id: Set if the folder is
        contained by a shared folder.
    :ivar files.FolderSharingInfo.shared_folder_id: If this folder is a shared
        folder mount point, the ID of the shared folder mounted at this
        location.
    :ivar files.FolderSharingInfo.traverse_only: Specifies that the folder can
        only be traversed and the user can only see a limited subset of the
        contents of this folder because they don't have read access to this
        folder. They do, however, have access to some sub folder.
    :ivar files.FolderSharingInfo.no_access: Specifies that the folder cannot be
        accessed by the user.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, read_only=..., parent_shared_folder_id=..., shared_folder_id=..., traverse_only=..., no_access=...) -> None:
        ...
    
    parent_shared_folder_id = ...
    shared_folder_id = ...
    traverse_only = ...
    no_access = ...


FolderSharingInfo_validator = ...
class GetCopyReferenceArg(bb.Struct):
    """
    :ivar files.GetCopyReferenceArg.path: The path to the file or folder you
        want to get a copy reference to.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=...) -> None:
        ...
    
    path = ...


GetCopyReferenceArg_validator = ...
class GetCopyReferenceError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: GetCopyReferenceError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


GetCopyReferenceError_validator = ...
class GetCopyReferenceResult(bb.Struct):
    """
    :ivar files.GetCopyReferenceResult.metadata: Metadata of the file or folder.
    :ivar files.GetCopyReferenceResult.copy_reference: A copy reference to the
        file or folder.
    :ivar files.GetCopyReferenceResult.expires: The expiration date of the copy
        reference. This value is currently set to be far enough in the future so
        that expiration is effectively not an issue.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=..., copy_reference=..., expires=...) -> None:
        ...
    
    metadata = ...
    copy_reference = ...
    expires = ...


GetCopyReferenceResult_validator = ...
class GetTagsArg(bb.Struct):
    """
    :ivar files.GetTagsArg.paths: Path to the items.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, paths=...) -> None:
        ...
    
    paths = ...


GetTagsArg_validator = ...
class GetTagsResult(bb.Struct):
    """
    :ivar files.GetTagsResult.paths_to_tags: List of paths and their
        corresponding tags.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, paths_to_tags=...) -> None:
        ...
    
    paths_to_tags = ...


GetTagsResult_validator = ...
class GetTemporaryLinkArg(bb.Struct):
    """
    :ivar files.GetTemporaryLinkArg.path: The path to the file you want a
        temporary link to.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=...) -> None:
        ...
    
    path = ...


GetTemporaryLinkArg_validator = ...
class GetTemporaryLinkError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.GetTemporaryLinkError.email_not_verified: This user's email
        address is not verified. This functionality is only available on
        accounts with a verified email address. Users can verify their email
        address `here <https://www.dropbox.com/help/317>`_.
    :ivar files.GetTemporaryLinkError.unsupported_file: Cannot get temporary
        link to this file type; use
        :meth:`dropbox.dropbox_client.Dropbox.files_export` instead.
    :ivar files.GetTemporaryLinkError.not_allowed: The user is not allowed to
        request a temporary link to the specified file. For example, this can
        occur if the file is restricted or if the user's links are `banned
        <https://help.dropbox.com/files-folders/share/banned-links>`_.
    """
    _catch_all = ...
    email_not_verified = ...
    unsupported_file = ...
    not_allowed = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: GetTemporaryLinkError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_email_not_verified(self):
        """
        Check if the union tag is ``email_not_verified``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_file(self):
        """
        Check if the union tag is ``unsupported_file``.

        :rtype: bool
        """
        ...
    
    def is_not_allowed(self):
        """
        Check if the union tag is ``not_allowed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


GetTemporaryLinkError_validator = ...
class GetTemporaryLinkResult(bb.Struct):
    """
    :ivar files.GetTemporaryLinkResult.metadata: Metadata of the file.
    :ivar files.GetTemporaryLinkResult.link: The temporary link which can be
        used to stream content the file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=..., link=...) -> None:
        ...
    
    metadata = ...
    link = ...


GetTemporaryLinkResult_validator = ...
class GetTemporaryUploadLinkArg(bb.Struct):
    """
    :ivar files.GetTemporaryUploadLinkArg.commit_info: Contains the path and
        other optional modifiers for the future upload commit. Equivalent to the
        parameters provided to
        :meth:`dropbox.dropbox_client.Dropbox.files_upload`.
    :ivar files.GetTemporaryUploadLinkArg.duration: How long before this link
        expires, in seconds.  Attempting to start an upload with this link
        longer than this period  of time after link creation will result in an
        error.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, commit_info=..., duration=...) -> None:
        ...
    
    commit_info = ...
    duration = ...


GetTemporaryUploadLinkArg_validator = ...
class GetTemporaryUploadLinkResult(bb.Struct):
    """
    :ivar files.GetTemporaryUploadLinkResult.link: The temporary link which can
        be used to stream a file to a Dropbox location.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, link=...) -> None:
        ...
    
    link = ...


GetTemporaryUploadLinkResult_validator = ...
class GetThumbnailBatchArg(bb.Struct):
    """
    Arguments for
    :meth:`dropbox.dropbox_client.Dropbox.files_get_thumbnail_batch`.

    :ivar files.GetThumbnailBatchArg.entries: List of files to get thumbnails.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


GetThumbnailBatchArg_validator = ...
class GetThumbnailBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.GetThumbnailBatchError.too_many_files: The operation involves
        more than 25 files.
    """
    _catch_all = ...
    too_many_files = ...
    other = ...
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GetThumbnailBatchError_validator = ...
class GetThumbnailBatchResult(bb.Struct):
    """
    :ivar files.GetThumbnailBatchResult.entries: List of files and their
        thumbnails.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


GetThumbnailBatchResult_validator = ...
class GetThumbnailBatchResultData(bb.Struct):
    """
    :ivar files.GetThumbnailBatchResultData.thumbnail: A string containing the
        base64-encoded thumbnail data for this file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=..., thumbnail=...) -> None:
        ...
    
    metadata = ...
    thumbnail = ...


GetThumbnailBatchResultData_validator = ...
class GetThumbnailBatchResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar ThumbnailError GetThumbnailBatchResultEntry.failure: The result for
        this file if it was an error.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param GetThumbnailBatchResultData val:
        :rtype: GetThumbnailBatchResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param ThumbnailError val:
        :rtype: GetThumbnailBatchResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: GetThumbnailBatchResultData
        """
        ...
    
    def get_failure(self): # -> None:
        """
        The result for this file if it was an error.

        Only call this if :meth:`is_failure` is true.

        :rtype: ThumbnailError
        """
        ...
    


GetThumbnailBatchResultEntry_validator = ...
class GpsCoordinates(bb.Struct):
    """
    GPS coordinates for a photo or video.

    :ivar files.GpsCoordinates.latitude: Latitude of the GPS coordinates.
    :ivar files.GpsCoordinates.longitude: Longitude of the GPS coordinates.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, latitude=..., longitude=...) -> None:
        ...
    
    latitude = ...
    longitude = ...


GpsCoordinates_validator = ...
class HighlightSpan(bb.Struct):
    """
    :ivar files.HighlightSpan.highlight_str: String to be determined whether it
        should be highlighted or not.
    :ivar files.HighlightSpan.is_highlighted: The string should be highlighted
        or not.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, highlight_str=..., is_highlighted=...) -> None:
        ...
    
    highlight_str = ...
    is_highlighted = ...


HighlightSpan_validator = ...
class ImportFormat(bb.Union):
    """
    The import format of the incoming Paper doc content.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ImportFormat.html: The provided data is interpreted as standard
        HTML.
    :ivar files.ImportFormat.markdown: The provided data is interpreted as
        markdown.
    :ivar files.ImportFormat.plain_text: The provided data is interpreted as
        plain text.
    """
    _catch_all = ...
    html = ...
    markdown = ...
    plain_text = ...
    other = ...
    def is_html(self):
        """
        Check if the union tag is ``html``.

        :rtype: bool
        """
        ...
    
    def is_markdown(self):
        """
        Check if the union tag is ``markdown``.

        :rtype: bool
        """
        ...
    
    def is_plain_text(self):
        """
        Check if the union tag is ``plain_text``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ImportFormat_validator = ...
class ListFolderArg(bb.Struct):
    """
    :ivar files.ListFolderArg.path: A unique identifier for the file.
    :ivar files.ListFolderArg.recursive: If true, the list folder operation will
        be applied recursively to all subfolders and the response will contain
        contents of all subfolders.
    :ivar files.ListFolderArg.include_media_info: If true,
        ``FileMetadata.media_info`` is set for photo and video. This parameter
        will no longer have an effect starting December 2, 2019.
    :ivar files.ListFolderArg.include_deleted: If true, the results will include
        entries for files and folders that used to exist but were deleted.
    :ivar files.ListFolderArg.include_has_explicit_shared_members: If true, the
        results will include a flag for each file indicating whether or not
        that file has any explicit members.
    :ivar files.ListFolderArg.include_mounted_folders: If true, the results will
        include entries under mounted folders which includes app folder, shared
        folder and team folder.
    :ivar files.ListFolderArg.limit: The maximum number of results to return per
        request. Note: This is an approximate number and there can be slightly
        more entries returned in some cases.
    :ivar files.ListFolderArg.shared_link: A shared link to list the contents
        of. If the link is password-protected, the password must be provided. If
        this field is present, ``ListFolderArg.path`` will be relative to root
        of the shared link. Only non-recursive mode is supported for shared
        link.
    :ivar files.ListFolderArg.include_property_groups: If set to a valid list of
        template IDs, ``FileMetadata.property_groups`` is set if there exists
        property data associated with the file and each of the listed templates.
    :ivar files.ListFolderArg.include_non_downloadable_files: If true, include
        files that are not downloadable, i.e. Google Docs.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., recursive=..., include_media_info=..., include_deleted=..., include_has_explicit_shared_members=..., include_mounted_folders=..., limit=..., shared_link=..., include_property_groups=..., include_non_downloadable_files=...) -> None:
        ...
    
    path = ...
    recursive = ...
    include_media_info = ...
    include_deleted = ...
    include_has_explicit_shared_members = ...
    include_mounted_folders = ...
    limit = ...
    shared_link = ...
    include_property_groups = ...
    include_non_downloadable_files = ...


ListFolderArg_validator = ...
class ListFolderContinueArg(bb.Struct):
    """
    :ivar files.ListFolderContinueArg.cursor: The cursor returned by your last
        call to :meth:`dropbox.dropbox_client.Dropbox.files_list_folder` or
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ListFolderContinueArg_validator = ...
class ListFolderContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ListFolderContinueError.reset: Indicates that the cursor has
        been invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder` to obtain a new
        cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ListFolderContinueError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


ListFolderContinueError_validator = ...
class ListFolderError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ListFolderError
        """
        ...
    
    @classmethod
    def template_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``template_error`` tag with
        value ``val``.

        :param file_properties.TemplateError val:
        :rtype: ListFolderError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_template_error(self):
        """
        Check if the union tag is ``template_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    
    def get_template_error(self): # -> None:
        """
        Only call this if :meth:`is_template_error` is true.

        :rtype: file_properties.TemplateError
        """
        ...
    


ListFolderError_validator = ...
class ListFolderGetLatestCursorResult(bb.Struct):
    """
    :ivar files.ListFolderGetLatestCursorResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue` to see
        what's changed in the folder since your previous query.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ListFolderGetLatestCursorResult_validator = ...
class ListFolderLongpollArg(bb.Struct):
    """
    :ivar files.ListFolderLongpollArg.cursor: A cursor as returned by
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder` or
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue`.
        Cursors retrieved by setting ``ListFolderArg.include_media_info`` to
        ``True`` are not supported.
    :ivar files.ListFolderLongpollArg.timeout: A timeout in seconds. The request
        will block for at most this length of time, plus up to 90 seconds of
        random jitter added to avoid the thundering herd problem. Care should be
        taken when using this parameter, as some network infrastructure does not
        support long timeouts.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=..., timeout=...) -> None:
        ...
    
    cursor = ...
    timeout = ...


ListFolderLongpollArg_validator = ...
class ListFolderLongpollError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ListFolderLongpollError.reset: Indicates that the cursor has
        been invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder` to obtain a new
        cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListFolderLongpollError_validator = ...
class ListFolderLongpollResult(bb.Struct):
    """
    :ivar files.ListFolderLongpollResult.changes: Indicates whether new changes
        are available. If true, call
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue` to
        retrieve the changes.
    :ivar files.ListFolderLongpollResult.backoff: If present, backoff for at
        least this many seconds before calling
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_longpoll` again.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, changes=..., backoff=...) -> None:
        ...
    
    changes = ...
    backoff = ...


ListFolderLongpollResult_validator = ...
class ListFolderResult(bb.Struct):
    """
    :ivar files.ListFolderResult.entries: The files and (direct) subfolders in
        the folder.
    :ivar files.ListFolderResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue` to see
        what's changed in the folder since your previous query.
    :ivar files.ListFolderResult.has_more: If true, then there are more entries
        available. Pass the cursor to
        :meth:`dropbox.dropbox_client.Dropbox.files_list_folder_continue` to
        retrieve the rest.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=..., cursor=..., has_more=...) -> None:
        ...
    
    entries = ...
    cursor = ...
    has_more = ...


ListFolderResult_validator = ...
class ListRevisionsArg(bb.Struct):
    """
    :ivar files.ListRevisionsArg.path: The path to the file you want to see the
        revisions of.
    :ivar files.ListRevisionsArg.mode: Determines the behavior of the API in
        listing the revisions for a given file path or id.
    :ivar files.ListRevisionsArg.limit: The maximum number of revision entries
        returned.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., mode=..., limit=...) -> None:
        ...
    
    path = ...
    mode = ...
    limit = ...


ListRevisionsArg_validator = ...
class ListRevisionsError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ListRevisionsError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


ListRevisionsError_validator = ...
class ListRevisionsMode(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ListRevisionsMode.path: Returns revisions with the same file
        path as identified by the latest file entry at the given file path or
        id.
    :ivar files.ListRevisionsMode.id: Returns revisions with the same file id as
        identified by the latest file entry at the given file path or id.
    """
    _catch_all = ...
    path = ...
    id = ...
    other = ...
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_id(self):
        """
        Check if the union tag is ``id``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListRevisionsMode_validator = ...
class ListRevisionsResult(bb.Struct):
    """
    :ivar files.ListRevisionsResult.is_deleted: If the file identified by the
        latest revision in the response is either deleted or moved.
    :ivar files.ListRevisionsResult.server_deleted: The time of deletion if the
        file was deleted.
    :ivar files.ListRevisionsResult.entries: The revisions for the file. Only
        revisions that are not deleted will show up here.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, is_deleted=..., entries=..., server_deleted=...) -> None:
        ...
    
    is_deleted = ...
    server_deleted = ...
    entries = ...


ListRevisionsResult_validator = ...
class LockConflictError(bb.Struct):
    """
    :ivar files.LockConflictError.lock: The lock that caused the conflict.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, lock=...) -> None:
        ...
    
    lock = ...


LockConflictError_validator = ...
class LockFileArg(bb.Struct):
    """
    :ivar files.LockFileArg.path: Path in the user's Dropbox to a file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=...) -> None:
        ...
    
    path = ...


LockFileArg_validator = ...
class LockFileBatchArg(bb.Struct):
    """
    :ivar files.LockFileBatchArg.entries: List of 'entries'. Each 'entry'
        contains a path of the file which will be locked or queried. Duplicate
        path arguments in the batch are considered only once.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


LockFileBatchArg_validator = ...
class LockFileBatchResult(FileOpsResult):
    """
    :ivar files.LockFileBatchResult.entries: Each Entry in the 'entries' will
        have '.tag' with the operation status (e.g. success), the metadata for
        the file and the lock state after the operation.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


LockFileBatchResult_validator = ...
class LockFileError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar LookupError LockFileError.path_lookup: Could not find the specified
        resource.
    :ivar files.LockFileError.too_many_write_operations: There are too many
        write operations in user's Dropbox. Please retry this request.
    :ivar files.LockFileError.too_many_files: There are too many files in one
        request. Please retry with fewer files.
    :ivar files.LockFileError.no_write_permission: The user does not have
        permissions to change the lock state or access the file.
    :ivar files.LockFileError.cannot_be_locked: Item is a type that cannot be
        locked.
    :ivar files.LockFileError.file_not_shared: Requested file is not currently
        shared.
    :ivar LockConflictError LockFileError.lock_conflict: The user action
        conflicts with an existing lock on the file.
    :ivar files.LockFileError.internal_error: Something went wrong with the job
        on Dropbox's end. You'll need to verify that the action you were taking
        succeeded, and if not, try again. This should happen very rarely.
    """
    _catch_all = ...
    too_many_write_operations = ...
    too_many_files = ...
    no_write_permission = ...
    cannot_be_locked = ...
    file_not_shared = ...
    internal_error = ...
    other = ...
    @classmethod
    def path_lookup(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path_lookup`` tag with
        value ``val``.

        :param LookupError val:
        :rtype: LockFileError
        """
        ...
    
    @classmethod
    def lock_conflict(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``lock_conflict`` tag with
        value ``val``.

        :param LockConflictError val:
        :rtype: LockFileError
        """
        ...
    
    def is_path_lookup(self):
        """
        Check if the union tag is ``path_lookup``.

        :rtype: bool
        """
        ...
    
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_no_write_permission(self):
        """
        Check if the union tag is ``no_write_permission``.

        :rtype: bool
        """
        ...
    
    def is_cannot_be_locked(self):
        """
        Check if the union tag is ``cannot_be_locked``.

        :rtype: bool
        """
        ...
    
    def is_file_not_shared(self):
        """
        Check if the union tag is ``file_not_shared``.

        :rtype: bool
        """
        ...
    
    def is_lock_conflict(self):
        """
        Check if the union tag is ``lock_conflict``.

        :rtype: bool
        """
        ...
    
    def is_internal_error(self):
        """
        Check if the union tag is ``internal_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path_lookup(self): # -> None:
        """
        Could not find the specified resource.

        Only call this if :meth:`is_path_lookup` is true.

        :rtype: LookupError
        """
        ...
    
    def get_lock_conflict(self): # -> None:
        """
        The user action conflicts with an existing lock on the file.

        Only call this if :meth:`is_lock_conflict` is true.

        :rtype: LockConflictError
        """
        ...
    


LockFileError_validator = ...
class LockFileResult(bb.Struct):
    """
    :ivar files.LockFileResult.metadata: Metadata of the file.
    :ivar files.LockFileResult.lock: The file lock state after the operation.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=..., lock=...) -> None:
        ...
    
    metadata = ...
    lock = ...


LockFileResult_validator = ...
class LockFileResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param LockFileResult val:
        :rtype: LockFileResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param LockFileError val:
        :rtype: LockFileResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: LockFileResult
        """
        ...
    
    def get_failure(self): # -> None:
        """
        Only call this if :meth:`is_failure` is true.

        :rtype: LockFileError
        """
        ...
    


LockFileResultEntry_validator = ...
class LookupError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar Optional[str] files.LookupError.malformed_path: The given path does
        not satisfy the required path format. Please refer to the :link:`Path
        formats documentation
        https://www.dropbox.com/developers/documentation/http/documentation#path-formats`
        for more information.
    :ivar files.LookupError.not_found: There is nothing at the given path.
    :ivar files.LookupError.not_file: We were expecting a file, but the given
        path refers to something that isn't a file.
    :ivar files.LookupError.not_folder: We were expecting a folder, but the
        given path refers to something that isn't a folder.
    :ivar files.LookupError.restricted_content: The file cannot be transferred
        because the content is restricted. For example, we might restrict a file
        due to legal requirements.
    :ivar files.LookupError.unsupported_content_type: This operation is not
        supported for this content type.
    :ivar files.LookupError.locked: The given path is locked.
    """
    _catch_all = ...
    not_found = ...
    not_file = ...
    not_folder = ...
    restricted_content = ...
    unsupported_content_type = ...
    locked = ...
    other = ...
    @classmethod
    def malformed_path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``malformed_path`` tag with
        value ``val``.

        :param Optional[str] val:
        :rtype: LookupError
        """
        ...
    
    def is_malformed_path(self):
        """
        Check if the union tag is ``malformed_path``.

        :rtype: bool
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_not_file(self):
        """
        Check if the union tag is ``not_file``.

        :rtype: bool
        """
        ...
    
    def is_not_folder(self):
        """
        Check if the union tag is ``not_folder``.

        :rtype: bool
        """
        ...
    
    def is_restricted_content(self):
        """
        Check if the union tag is ``restricted_content``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_content_type(self):
        """
        Check if the union tag is ``unsupported_content_type``.

        :rtype: bool
        """
        ...
    
    def is_locked(self):
        """
        Check if the union tag is ``locked``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_malformed_path(self): # -> None:
        """
        The given path does not satisfy the required path format. Please refer
        to the `Path formats documentation
        <https://www.dropbox.com/developers/documentation/http/documentation#path-formats>`_
        for more information.

        Only call this if :meth:`is_malformed_path` is true.

        :rtype: Optional[str]
        """
        ...
    


LookupError_validator = ...
class MediaInfo(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.MediaInfo.pending: Indicate the photo/video is still under
        processing and metadata is not available yet.
    :ivar MediaMetadata MediaInfo.metadata: The metadata for the photo/video.
    """
    _catch_all = ...
    pending = ...
    @classmethod
    def metadata(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``metadata`` tag with value
        ``val``.

        :param MediaMetadata val:
        :rtype: MediaInfo
        """
        ...
    
    def is_pending(self):
        """
        Check if the union tag is ``pending``.

        :rtype: bool
        """
        ...
    
    def is_metadata(self):
        """
        Check if the union tag is ``metadata``.

        :rtype: bool
        """
        ...
    
    def get_metadata(self): # -> None:
        """
        The metadata for the photo/video.

        Only call this if :meth:`is_metadata` is true.

        :rtype: MediaMetadata
        """
        ...
    


MediaInfo_validator = ...
class MediaMetadata(bb.Struct):
    """
    Metadata for a photo or video.

    :ivar files.MediaMetadata.dimensions: Dimension of the photo/video.
    :ivar files.MediaMetadata.location: The GPS coordinate of the photo/video.
    :ivar files.MediaMetadata.time_taken: The timestamp when the photo/video is
        taken.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, dimensions=..., location=..., time_taken=...) -> None:
        ...
    
    dimensions = ...
    location = ...
    time_taken = ...


MediaMetadata_validator = ...
class MetadataV2(bb.Union):
    """
    Metadata for a file, folder or other resource types.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def metadata(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``metadata`` tag with value
        ``val``.

        :param Metadata val:
        :rtype: MetadataV2
        """
        ...
    
    def is_metadata(self):
        """
        Check if the union tag is ``metadata``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_metadata(self): # -> None:
        """
        Only call this if :meth:`is_metadata` is true.

        :rtype: Metadata
        """
        ...
    


MetadataV2_validator = ...
class MinimalFileLinkMetadata(bb.Struct):
    """
    :ivar files.MinimalFileLinkMetadata.url: URL of the shared link.
    :ivar files.MinimalFileLinkMetadata.id: Unique identifier for the linked
        file.
    :ivar files.MinimalFileLinkMetadata.path: Full path in the user's Dropbox.
        This always starts with a slash. This field will only be present only if
        the linked file is in the authenticated user's Dropbox.
    :ivar files.MinimalFileLinkMetadata.rev: A unique identifier for the current
        revision of a file. This field is the same rev as elsewhere in the API
        and can be used to detect changes and avoid conflicts.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, url=..., rev=..., id=..., path=...) -> None:
        ...
    
    url = ...
    id = ...
    path = ...
    rev = ...


MinimalFileLinkMetadata_validator = ...
class RelocationBatchArgBase(bb.Struct):
    """
    :ivar files.RelocationBatchArgBase.entries: List of entries to be moved or
        copied. Each entry is :class:`RelocationPath`.
    :ivar files.RelocationBatchArgBase.autorename: If there's a conflict with
        any file, have the Dropbox server try to autorename that file to avoid
        the conflict.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=..., autorename=...) -> None:
        ...
    
    entries = ...
    autorename = ...


RelocationBatchArgBase_validator = ...
class MoveBatchArg(RelocationBatchArgBase):
    """
    :ivar files.MoveBatchArg.allow_ownership_transfer: Allow moves by owner even
        if it would result in an ownership transfer for the content being moved.
        This does not apply to copies.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=..., autorename=..., allow_ownership_transfer=...) -> None:
        ...
    
    allow_ownership_transfer = ...


MoveBatchArg_validator = ...
class MoveIntoFamilyError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.MoveIntoFamilyError.is_shared_folder: Moving shared folder into
        Family Room folder is not allowed.
    """
    _catch_all = ...
    is_shared_folder = ...
    other = ...
    def is_is_shared_folder(self):
        """
        Check if the union tag is ``is_shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MoveIntoFamilyError_validator = ...
class MoveIntoVaultError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.MoveIntoVaultError.is_shared_folder: Moving shared folder into
        Vault is not allowed.
    """
    _catch_all = ...
    is_shared_folder = ...
    other = ...
    def is_is_shared_folder(self):
        """
        Check if the union tag is ``is_shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MoveIntoVaultError_validator = ...
class PaperContentError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.PaperContentError.insufficient_permissions: Your account does
        not have permissions to edit Paper docs.
    :ivar files.PaperContentError.content_malformed: The provided content was
        malformed and cannot be imported to Paper.
    :ivar files.PaperContentError.doc_length_exceeded: The Paper doc would be
        too large, split the content into multiple docs.
    :ivar files.PaperContentError.image_size_exceeded: The imported document
        contains an image that is too large. The current limit is 1MB. This only
        applies to HTML with data URI.
    """
    _catch_all = ...
    insufficient_permissions = ...
    content_malformed = ...
    doc_length_exceeded = ...
    image_size_exceeded = ...
    other = ...
    def is_insufficient_permissions(self):
        """
        Check if the union tag is ``insufficient_permissions``.

        :rtype: bool
        """
        ...
    
    def is_content_malformed(self):
        """
        Check if the union tag is ``content_malformed``.

        :rtype: bool
        """
        ...
    
    def is_doc_length_exceeded(self):
        """
        Check if the union tag is ``doc_length_exceeded``.

        :rtype: bool
        """
        ...
    
    def is_image_size_exceeded(self):
        """
        Check if the union tag is ``image_size_exceeded``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperContentError_validator = ...
class PaperCreateArg(bb.Struct):
    """
    :ivar files.PaperCreateArg.path: The fully qualified path to the location in
        the user's Dropbox where the Paper Doc should be created. This should
        include the document's title and end with .paper.
    :ivar files.PaperCreateArg.import_format: The format of the provided data.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., import_format=...) -> None:
        ...
    
    path = ...
    import_format = ...


PaperCreateArg_validator = ...
class PaperCreateError(PaperContentError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.PaperCreateError.invalid_path: The file could not be saved to
        the specified location.
    :ivar files.PaperCreateError.email_unverified: The user's email must be
        verified to create Paper docs.
    :ivar files.PaperCreateError.invalid_file_extension: The file path must end
        in .paper.
    :ivar files.PaperCreateError.paper_disabled: Paper is disabled for your
        team.
    """
    invalid_path = ...
    email_unverified = ...
    invalid_file_extension = ...
    paper_disabled = ...
    def is_invalid_path(self):
        """
        Check if the union tag is ``invalid_path``.

        :rtype: bool
        """
        ...
    
    def is_email_unverified(self):
        """
        Check if the union tag is ``email_unverified``.

        :rtype: bool
        """
        ...
    
    def is_invalid_file_extension(self):
        """
        Check if the union tag is ``invalid_file_extension``.

        :rtype: bool
        """
        ...
    
    def is_paper_disabled(self):
        """
        Check if the union tag is ``paper_disabled``.

        :rtype: bool
        """
        ...
    


PaperCreateError_validator = ...
class PaperCreateResult(bb.Struct):
    """
    :ivar files.PaperCreateResult.url: URL to open the Paper Doc.
    :ivar files.PaperCreateResult.result_path: The fully qualified path the
        Paper Doc was actually created at.
    :ivar files.PaperCreateResult.file_id: The id to use in Dropbox APIs when
        referencing the Paper Doc.
    :ivar files.PaperCreateResult.paper_revision: The current doc revision.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, url=..., result_path=..., file_id=..., paper_revision=...) -> None:
        ...
    
    url = ...
    result_path = ...
    file_id = ...
    paper_revision = ...


PaperCreateResult_validator = ...
class PaperDocUpdatePolicy(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.PaperDocUpdatePolicy.update: Sets the doc content to the
        provided content if the provided paper_revision matches the latest doc
        revision. Otherwise, returns an error.
    :ivar files.PaperDocUpdatePolicy.overwrite: Sets the doc content to the
        provided content without checking paper_revision.
    :ivar files.PaperDocUpdatePolicy.prepend: Adds the provided content to the
        beginning of the doc without checking paper_revision.
    :ivar files.PaperDocUpdatePolicy.append: Adds the provided content to the
        end of the doc without checking paper_revision.
    """
    _catch_all = ...
    update = ...
    overwrite = ...
    prepend = ...
    append = ...
    other = ...
    def is_update(self):
        """
        Check if the union tag is ``update``.

        :rtype: bool
        """
        ...
    
    def is_overwrite(self):
        """
        Check if the union tag is ``overwrite``.

        :rtype: bool
        """
        ...
    
    def is_prepend(self):
        """
        Check if the union tag is ``prepend``.

        :rtype: bool
        """
        ...
    
    def is_append(self):
        """
        Check if the union tag is ``append``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperDocUpdatePolicy_validator = ...
class PaperUpdateArg(bb.Struct):
    """
    :ivar files.PaperUpdateArg.path: Path in the user's Dropbox to update. The
        path must correspond to a Paper doc or an error will be returned.
    :ivar files.PaperUpdateArg.import_format: The format of the provided data.
    :ivar files.PaperUpdateArg.doc_update_policy: How the provided content
        should be applied to the doc.
    :ivar files.PaperUpdateArg.paper_revision: The latest doc revision. Required
        when doc_update_policy is update. This value must match the current
        revision of the doc or error revision_mismatch will be returned.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., import_format=..., doc_update_policy=..., paper_revision=...) -> None:
        ...
    
    path = ...
    import_format = ...
    doc_update_policy = ...
    paper_revision = ...


PaperUpdateArg_validator = ...
class PaperUpdateError(PaperContentError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.PaperUpdateError.revision_mismatch: The provided revision does
        not match the document head.
    :ivar files.PaperUpdateError.doc_archived: This operation is not allowed on
        archived Paper docs.
    :ivar files.PaperUpdateError.doc_deleted: This operation is not allowed on
        deleted Paper docs.
    """
    revision_mismatch = ...
    doc_archived = ...
    doc_deleted = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: PaperUpdateError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_revision_mismatch(self):
        """
        Check if the union tag is ``revision_mismatch``.

        :rtype: bool
        """
        ...
    
    def is_doc_archived(self):
        """
        Check if the union tag is ``doc_archived``.

        :rtype: bool
        """
        ...
    
    def is_doc_deleted(self):
        """
        Check if the union tag is ``doc_deleted``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


PaperUpdateError_validator = ...
class PaperUpdateResult(bb.Struct):
    """
    :ivar files.PaperUpdateResult.paper_revision: The current doc revision.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, paper_revision=...) -> None:
        ...
    
    paper_revision = ...


PaperUpdateResult_validator = ...
class PathOrLink(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param str val:
        :rtype: PathOrLink
        """
        ...
    
    @classmethod
    def link(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``link`` tag with value
        ``val``.

        :param SharedLinkFileInfo val:
        :rtype: PathOrLink
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_link(self):
        """
        Check if the union tag is ``link``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: str
        """
        ...
    
    def get_link(self): # -> None:
        """
        Only call this if :meth:`is_link` is true.

        :rtype: SharedLinkFileInfo
        """
        ...
    


PathOrLink_validator = ...
class PathToTags(bb.Struct):
    """
    :ivar files.PathToTags.path: Path of the item.
    :ivar files.PathToTags.tags: Tags assigned to this item.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., tags=...) -> None:
        ...
    
    path = ...
    tags = ...


PathToTags_validator = ...
class PhotoMetadata(MediaMetadata):
    """
    Metadata for a photo.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, dimensions=..., location=..., time_taken=...) -> None:
        ...
    


PhotoMetadata_validator = ...
class PreviewArg(bb.Struct):
    """
    :ivar files.PreviewArg.path: The path of the file to preview.
    :ivar files.PreviewArg.rev: Please specify revision in ``path`` instead.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., rev=...) -> None:
        ...
    
    path = ...
    rev = ...


PreviewArg_validator = ...
class PreviewError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar LookupError PreviewError.path: An error occurs when downloading
        metadata for the file.
    :ivar files.PreviewError.in_progress: This preview generation is still in
        progress and the file is not ready  for preview yet.
    :ivar files.PreviewError.unsupported_extension: The file extension is not
        supported preview generation.
    :ivar files.PreviewError.unsupported_content: The file content is not
        supported for preview generation.
    """
    _catch_all = ...
    in_progress = ...
    unsupported_extension = ...
    unsupported_content = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: PreviewError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_in_progress(self):
        """
        Check if the union tag is ``in_progress``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_extension(self):
        """
        Check if the union tag is ``unsupported_extension``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_content(self):
        """
        Check if the union tag is ``unsupported_content``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        An error occurs when downloading metadata for the file.

        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


PreviewError_validator = ...
class PreviewResult(bb.Struct):
    """
    :ivar files.PreviewResult.file_metadata: Metadata corresponding to the file
        received as an argument. Will be populated if the endpoint is called
        with a path (ReadPath).
    :ivar files.PreviewResult.link_metadata: Minimal metadata corresponding to
        the file received as an argument. Will be populated if the endpoint is
        called using a shared link (SharedLinkFileInfo).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, file_metadata=..., link_metadata=...) -> None:
        ...
    
    file_metadata = ...
    link_metadata = ...


PreviewResult_validator = ...
class RelocationPath(bb.Struct):
    """
    :ivar files.RelocationPath.from_path: Path in the user's Dropbox to be
        copied or moved.
    :ivar files.RelocationPath.to_path: Path in the user's Dropbox that is the
        destination.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, from_path=..., to_path=...) -> None:
        ...
    
    from_path = ...
    to_path = ...


RelocationPath_validator = ...
class RelocationArg(RelocationPath):
    """
    :ivar files.RelocationArg.allow_shared_folder: This flag has no effect.
    :ivar files.RelocationArg.autorename: If there's a conflict, have the
        Dropbox server try to autorename the file to avoid the conflict.
    :ivar files.RelocationArg.allow_ownership_transfer: Allow moves by owner
        even if it would result in an ownership transfer for the content being
        moved. This does not apply to copies.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, from_path=..., to_path=..., allow_shared_folder=..., autorename=..., allow_ownership_transfer=...) -> None:
        ...
    
    allow_shared_folder = ...
    autorename = ...
    allow_ownership_transfer = ...


RelocationArg_validator = ...
class RelocationBatchArg(RelocationBatchArgBase):
    """
    :ivar files.RelocationBatchArg.allow_shared_folder: This flag has no effect.
    :ivar files.RelocationBatchArg.allow_ownership_transfer: Allow moves by
        owner even if it would result in an ownership transfer for the content
        being moved. This does not apply to copies.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=..., autorename=..., allow_shared_folder=..., allow_ownership_transfer=...) -> None:
        ...
    
    allow_shared_folder = ...
    allow_ownership_transfer = ...


RelocationBatchArg_validator = ...
class RelocationError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.RelocationError.cant_copy_shared_folder: Shared folders can't be
        copied.
    :ivar files.RelocationError.cant_nest_shared_folder: Your move operation
        would result in nested shared folders.  This is not allowed.
    :ivar files.RelocationError.cant_move_folder_into_itself: You cannot move a
        folder into itself.
    :ivar files.RelocationError.too_many_files: The operation would involve more
        than 10,000 files and folders.
    :ivar files.RelocationError.duplicated_or_nested_paths: There are
        duplicated/nested paths among ``RelocationArg.from_path`` and
        ``RelocationArg.to_path``.
    :ivar files.RelocationError.cant_transfer_ownership: Your move operation
        would result in an ownership transfer. You may reissue the request with
        the field ``RelocationArg.allow_ownership_transfer`` to true.
    :ivar files.RelocationError.insufficient_quota: The current user does not
        have enough space to move or copy the files.
    :ivar files.RelocationError.internal_error: Something went wrong with the
        job on Dropbox's end. You'll need to verify that the action you were
        taking succeeded, and if not, try again. This should happen very rarely.
    :ivar files.RelocationError.cant_move_shared_folder: Can't move the shared
        folder to the given destination.
    :ivar MoveIntoVaultError RelocationError.cant_move_into_vault: Some content
        cannot be moved into Vault under certain circumstances, see detailed
        error.
    :ivar MoveIntoFamilyError RelocationError.cant_move_into_family: Some
        content cannot be moved into the Family Room folder under certain
        circumstances, see detailed error.
    """
    _catch_all = ...
    cant_copy_shared_folder = ...
    cant_nest_shared_folder = ...
    cant_move_folder_into_itself = ...
    too_many_files = ...
    duplicated_or_nested_paths = ...
    cant_transfer_ownership = ...
    insufficient_quota = ...
    internal_error = ...
    cant_move_shared_folder = ...
    other = ...
    @classmethod
    def from_lookup(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``from_lookup`` tag with
        value ``val``.

        :param LookupError val:
        :rtype: RelocationError
        """
        ...
    
    @classmethod
    def from_write(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``from_write`` tag with
        value ``val``.

        :param WriteError val:
        :rtype: RelocationError
        """
        ...
    
    @classmethod
    def to(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``to`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: RelocationError
        """
        ...
    
    @classmethod
    def cant_move_into_vault(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``cant_move_into_vault`` tag
        with value ``val``.

        :param MoveIntoVaultError val:
        :rtype: RelocationError
        """
        ...
    
    @classmethod
    def cant_move_into_family(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``cant_move_into_family``
        tag with value ``val``.

        :param MoveIntoFamilyError val:
        :rtype: RelocationError
        """
        ...
    
    def is_from_lookup(self):
        """
        Check if the union tag is ``from_lookup``.

        :rtype: bool
        """
        ...
    
    def is_from_write(self):
        """
        Check if the union tag is ``from_write``.

        :rtype: bool
        """
        ...
    
    def is_to(self):
        """
        Check if the union tag is ``to``.

        :rtype: bool
        """
        ...
    
    def is_cant_copy_shared_folder(self):
        """
        Check if the union tag is ``cant_copy_shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_cant_nest_shared_folder(self):
        """
        Check if the union tag is ``cant_nest_shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_cant_move_folder_into_itself(self):
        """
        Check if the union tag is ``cant_move_folder_into_itself``.

        :rtype: bool
        """
        ...
    
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_duplicated_or_nested_paths(self):
        """
        Check if the union tag is ``duplicated_or_nested_paths``.

        :rtype: bool
        """
        ...
    
    def is_cant_transfer_ownership(self):
        """
        Check if the union tag is ``cant_transfer_ownership``.

        :rtype: bool
        """
        ...
    
    def is_insufficient_quota(self):
        """
        Check if the union tag is ``insufficient_quota``.

        :rtype: bool
        """
        ...
    
    def is_internal_error(self):
        """
        Check if the union tag is ``internal_error``.

        :rtype: bool
        """
        ...
    
    def is_cant_move_shared_folder(self):
        """
        Check if the union tag is ``cant_move_shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_cant_move_into_vault(self):
        """
        Check if the union tag is ``cant_move_into_vault``.

        :rtype: bool
        """
        ...
    
    def is_cant_move_into_family(self):
        """
        Check if the union tag is ``cant_move_into_family``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_from_lookup(self): # -> None:
        """
        Only call this if :meth:`is_from_lookup` is true.

        :rtype: LookupError
        """
        ...
    
    def get_from_write(self): # -> None:
        """
        Only call this if :meth:`is_from_write` is true.

        :rtype: WriteError
        """
        ...
    
    def get_to(self): # -> None:
        """
        Only call this if :meth:`is_to` is true.

        :rtype: WriteError
        """
        ...
    
    def get_cant_move_into_vault(self): # -> None:
        """
        Some content cannot be moved into Vault under certain circumstances, see
        detailed error.

        Only call this if :meth:`is_cant_move_into_vault` is true.

        :rtype: MoveIntoVaultError
        """
        ...
    
    def get_cant_move_into_family(self): # -> None:
        """
        Some content cannot be moved into the Family Room folder under certain
        circumstances, see detailed error.

        Only call this if :meth:`is_cant_move_into_family` is true.

        :rtype: MoveIntoFamilyError
        """
        ...
    


RelocationError_validator = ...
class RelocationBatchError(RelocationError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.RelocationBatchError.too_many_write_operations: There are too
        many write operations in user's Dropbox. Please retry this request.
    """
    too_many_write_operations = ...
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    


RelocationBatchError_validator = ...
class RelocationBatchErrorEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar RelocationError RelocationBatchErrorEntry.relocation_error: User
        errors that retry won't help.
    :ivar files.RelocationBatchErrorEntry.internal_error: Something went wrong
        with the job on Dropbox's end. You'll need to verify that the action you
        were taking succeeded, and if not, try again. This should happen very
        rarely.
    :ivar files.RelocationBatchErrorEntry.too_many_write_operations: There are
        too many write operations in user's Dropbox. Please retry this request.
    """
    _catch_all = ...
    internal_error = ...
    too_many_write_operations = ...
    other = ...
    @classmethod
    def relocation_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``relocation_error`` tag
        with value ``val``.

        :param RelocationError val:
        :rtype: RelocationBatchErrorEntry
        """
        ...
    
    def is_relocation_error(self):
        """
        Check if the union tag is ``relocation_error``.

        :rtype: bool
        """
        ...
    
    def is_internal_error(self):
        """
        Check if the union tag is ``internal_error``.

        :rtype: bool
        """
        ...
    
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_relocation_error(self): # -> None:
        """
        User errors that retry won't help.

        Only call this if :meth:`is_relocation_error` is true.

        :rtype: RelocationError
        """
        ...
    


RelocationBatchErrorEntry_validator = ...
class RelocationBatchJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar RelocationBatchResult RelocationBatchJobStatus.complete: The copy or
        move batch job has finished.
    :ivar RelocationBatchError RelocationBatchJobStatus.failed: The copy or move
        batch job has failed with exception.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param RelocationBatchResult val:
        :rtype: RelocationBatchJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param RelocationBatchError val:
        :rtype: RelocationBatchJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The copy or move batch job has finished.

        Only call this if :meth:`is_complete` is true.

        :rtype: RelocationBatchResult
        """
        ...
    
    def get_failed(self): # -> None:
        """
        The copy or move batch job has failed with exception.

        Only call this if :meth:`is_failed` is true.

        :rtype: RelocationBatchError
        """
        ...
    


RelocationBatchJobStatus_validator = ...
class RelocationBatchLaunch(async_.LaunchResultBase):
    """
    Result returned by :meth:`dropbox.dropbox_client.Dropbox.files_copy_batch`
    or :meth:`dropbox.dropbox_client.Dropbox.files_move_batch` that may either
    launch an asynchronous job or complete synchronously.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param RelocationBatchResult val:
        :rtype: RelocationBatchLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: RelocationBatchResult
        """
        ...
    


RelocationBatchLaunch_validator = ...
class RelocationBatchResult(FileOpsResult):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


RelocationBatchResult_validator = ...
class RelocationBatchResultData(bb.Struct):
    """
    :ivar files.RelocationBatchResultData.metadata: Metadata of the relocated
        object.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


RelocationBatchResultData_validator = ...
class RelocationBatchResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param Metadata val:
        :rtype: RelocationBatchResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param RelocationBatchErrorEntry val:
        :rtype: RelocationBatchResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: Metadata
        """
        ...
    
    def get_failure(self): # -> None:
        """
        Only call this if :meth:`is_failure` is true.

        :rtype: RelocationBatchErrorEntry
        """
        ...
    


RelocationBatchResultEntry_validator = ...
class RelocationBatchV2JobStatus(async_.PollResultBase):
    """
    Result returned by
    :meth:`dropbox.dropbox_client.Dropbox.files_copy_batch_check` or
    :meth:`dropbox.dropbox_client.Dropbox.files_move_batch_check` that may
    either be in progress or completed with result for each entry.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar RelocationBatchV2Result RelocationBatchV2JobStatus.complete: The copy
        or move batch job has finished.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param RelocationBatchV2Result val:
        :rtype: RelocationBatchV2JobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The copy or move batch job has finished.

        Only call this if :meth:`is_complete` is true.

        :rtype: RelocationBatchV2Result
        """
        ...
    


RelocationBatchV2JobStatus_validator = ...
class RelocationBatchV2Launch(async_.LaunchResultBase):
    """
    Result returned by :meth:`dropbox.dropbox_client.Dropbox.files_copy_batch`
    or :meth:`dropbox.dropbox_client.Dropbox.files_move_batch` that may either
    launch an asynchronous job or complete synchronously.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param RelocationBatchV2Result val:
        :rtype: RelocationBatchV2Launch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: RelocationBatchV2Result
        """
        ...
    


RelocationBatchV2Launch_validator = ...
class RelocationBatchV2Result(FileOpsResult):
    """
    :ivar files.RelocationBatchV2Result.entries: Each entry in
        CopyBatchArg.entries or ``MoveBatchArg.entries`` will appear at the same
        position inside ``RelocationBatchV2Result.entries``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


RelocationBatchV2Result_validator = ...
class RelocationResult(FileOpsResult):
    """
    :ivar files.RelocationResult.metadata: Metadata of the relocated object.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


RelocationResult_validator = ...
class RemoveTagArg(bb.Struct):
    """
    :ivar files.RemoveTagArg.path: Path to the item to tag.
    :ivar files.RemoveTagArg.tag_text: The tag to remove. Will be automatically
        converted to lowercase letters.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., tag_text=...) -> None:
        ...
    
    path = ...
    tag_text = ...


RemoveTagArg_validator = ...
class RemoveTagError(BaseTagError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.RemoveTagError.tag_not_present: That tag doesn't exist at this
        path.
    """
    tag_not_present = ...
    def is_tag_not_present(self):
        """
        Check if the union tag is ``tag_not_present``.

        :rtype: bool
        """
        ...
    


RemoveTagError_validator = ...
class RestoreArg(bb.Struct):
    """
    :ivar files.RestoreArg.path: The path to save the restored file.
    :ivar files.RestoreArg.rev: The revision to restore.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., rev=...) -> None:
        ...
    
    path = ...
    rev = ...


RestoreArg_validator = ...
class RestoreError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar LookupError RestoreError.path_lookup: An error occurs when downloading
        metadata for the file.
    :ivar WriteError RestoreError.path_write: An error occurs when trying to
        restore the file to that path.
    :ivar files.RestoreError.invalid_revision: The revision is invalid. It may
        not exist or may point to a deleted file.
    :ivar files.RestoreError.in_progress: The restore is currently executing,
        but has not yet completed.
    """
    _catch_all = ...
    invalid_revision = ...
    in_progress = ...
    other = ...
    @classmethod
    def path_lookup(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path_lookup`` tag with
        value ``val``.

        :param LookupError val:
        :rtype: RestoreError
        """
        ...
    
    @classmethod
    def path_write(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path_write`` tag with
        value ``val``.

        :param WriteError val:
        :rtype: RestoreError
        """
        ...
    
    def is_path_lookup(self):
        """
        Check if the union tag is ``path_lookup``.

        :rtype: bool
        """
        ...
    
    def is_path_write(self):
        """
        Check if the union tag is ``path_write``.

        :rtype: bool
        """
        ...
    
    def is_invalid_revision(self):
        """
        Check if the union tag is ``invalid_revision``.

        :rtype: bool
        """
        ...
    
    def is_in_progress(self):
        """
        Check if the union tag is ``in_progress``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path_lookup(self): # -> None:
        """
        An error occurs when downloading metadata for the file.

        Only call this if :meth:`is_path_lookup` is true.

        :rtype: LookupError
        """
        ...
    
    def get_path_write(self): # -> None:
        """
        An error occurs when trying to restore the file to that path.

        Only call this if :meth:`is_path_write` is true.

        :rtype: WriteError
        """
        ...
    


RestoreError_validator = ...
class SaveCopyReferenceArg(bb.Struct):
    """
    :ivar files.SaveCopyReferenceArg.copy_reference: A copy reference returned
        by :meth:`dropbox.dropbox_client.Dropbox.files_copy_reference_get`.
    :ivar files.SaveCopyReferenceArg.path: Path in the user's Dropbox that is
        the destination.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, copy_reference=..., path=...) -> None:
        ...
    
    copy_reference = ...
    path = ...


SaveCopyReferenceArg_validator = ...
class SaveCopyReferenceError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SaveCopyReferenceError.invalid_copy_reference: The copy
        reference is invalid.
    :ivar files.SaveCopyReferenceError.no_permission: You don't have permission
        to save the given copy reference. Please make sure this app is same app
        which created the copy reference and the source user is still linked to
        the app.
    :ivar files.SaveCopyReferenceError.not_found: The file referenced by the
        copy reference cannot be found.
    :ivar files.SaveCopyReferenceError.too_many_files: The operation would
        involve more than 10,000 files and folders.
    """
    _catch_all = ...
    invalid_copy_reference = ...
    no_permission = ...
    not_found = ...
    too_many_files = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: SaveCopyReferenceError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_invalid_copy_reference(self):
        """
        Check if the union tag is ``invalid_copy_reference``.

        :rtype: bool
        """
        ...
    
    def is_no_permission(self):
        """
        Check if the union tag is ``no_permission``.

        :rtype: bool
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_too_many_files(self):
        """
        Check if the union tag is ``too_many_files``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: WriteError
        """
        ...
    


SaveCopyReferenceError_validator = ...
class SaveCopyReferenceResult(bb.Struct):
    """
    :ivar files.SaveCopyReferenceResult.metadata: The metadata of the saved file
        or folder in the user's Dropbox.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=...) -> None:
        ...
    
    metadata = ...


SaveCopyReferenceResult_validator = ...
class SaveUrlArg(bb.Struct):
    """
    :ivar files.SaveUrlArg.path: The path in Dropbox where the URL will be saved
        to.
    :ivar files.SaveUrlArg.url: The URL to be saved.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., url=...) -> None:
        ...
    
    path = ...
    url = ...


SaveUrlArg_validator = ...
class SaveUrlError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SaveUrlError.download_failed: Failed downloading the given URL.
        The URL may be  password-protected and the password provided was
        incorrect,  or the link may be disabled.
    :ivar files.SaveUrlError.invalid_url: The given URL is invalid.
    :ivar files.SaveUrlError.not_found: The file where the URL is saved to no
        longer exists.
    """
    _catch_all = ...
    download_failed = ...
    invalid_url = ...
    not_found = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: SaveUrlError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_download_failed(self):
        """
        Check if the union tag is ``download_failed``.

        :rtype: bool
        """
        ...
    
    def is_invalid_url(self):
        """
        Check if the union tag is ``invalid_url``.

        :rtype: bool
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: WriteError
        """
        ...
    


SaveUrlError_validator = ...
class SaveUrlJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar FileMetadata SaveUrlJobStatus.complete: Metadata of the file where the
        URL is saved to.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param FileMetadata val:
        :rtype: SaveUrlJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param SaveUrlError val:
        :rtype: SaveUrlJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Metadata of the file where the URL is saved to.

        Only call this if :meth:`is_complete` is true.

        :rtype: FileMetadata
        """
        ...
    
    def get_failed(self): # -> None:
        """
        Only call this if :meth:`is_failed` is true.

        :rtype: SaveUrlError
        """
        ...
    


SaveUrlJobStatus_validator = ...
class SaveUrlResult(async_.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar FileMetadata SaveUrlResult.complete: Metadata of the file where the
        URL is saved to.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param FileMetadata val:
        :rtype: SaveUrlResult
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Metadata of the file where the URL is saved to.

        Only call this if :meth:`is_complete` is true.

        :rtype: FileMetadata
        """
        ...
    


SaveUrlResult_validator = ...
class SearchArg(bb.Struct):
    """
    :ivar files.SearchArg.path: The path in the user's Dropbox to search. Should
        probably be a folder.
    :ivar files.SearchArg.query: The string to search for. Query string may be
        rewritten to improve relevance of results. The string is split on spaces
        into multiple tokens. For file name searching, the last token is used
        for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
        car").
    :ivar files.SearchArg.start: The starting index within the search results
        (used for paging).
    :ivar files.SearchArg.max_results: The maximum number of search results to
        return.
    :ivar files.SearchArg.mode: The search mode (filename, filename_and_content,
        or deleted_filename). Note that searching file content is only available
        for Dropbox Business accounts.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., query=..., start=..., max_results=..., mode=...) -> None:
        ...
    
    path = ...
    query = ...
    start = ...
    max_results = ...
    mode = ...


SearchArg_validator = ...
class SearchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SearchError.internal_error: Something went wrong, please try
        again.
    """
    _catch_all = ...
    internal_error = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: SearchError
        """
        ...
    
    @classmethod
    def invalid_argument(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_argument`` tag
        with value ``val``.

        :param str val:
        :rtype: SearchError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_invalid_argument(self):
        """
        Check if the union tag is ``invalid_argument``.

        :rtype: bool
        """
        ...
    
    def is_internal_error(self):
        """
        Check if the union tag is ``internal_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    
    def get_invalid_argument(self): # -> None:
        """
        Only call this if :meth:`is_invalid_argument` is true.

        :rtype: str
        """
        ...
    


SearchError_validator = ...
class SearchMatch(bb.Struct):
    """
    :ivar files.SearchMatch.match_type: The type of the match.
    :ivar files.SearchMatch.metadata: The metadata for the matched file or
        folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, match_type=..., metadata=...) -> None:
        ...
    
    match_type = ...
    metadata = ...


SearchMatch_validator = ...
class SearchMatchFieldOptions(bb.Struct):
    """
    :ivar files.SearchMatchFieldOptions.include_highlights: Whether to include
        highlight span from file title.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, include_highlights=...) -> None:
        ...
    
    include_highlights = ...


SearchMatchFieldOptions_validator = ...
class SearchMatchType(bb.Union):
    """
    Indicates what type of match was found for a given item.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SearchMatchType.filename: This item was matched on its file or
        folder name.
    :ivar files.SearchMatchType.content: This item was matched based on its file
        contents.
    :ivar files.SearchMatchType.both: This item was matched based on both its
        contents and its file name.
    """
    _catch_all = ...
    filename = ...
    content = ...
    both = ...
    def is_filename(self):
        """
        Check if the union tag is ``filename``.

        :rtype: bool
        """
        ...
    
    def is_content(self):
        """
        Check if the union tag is ``content``.

        :rtype: bool
        """
        ...
    
    def is_both(self):
        """
        Check if the union tag is ``both``.

        :rtype: bool
        """
        ...
    


SearchMatchType_validator = ...
class SearchMatchTypeV2(bb.Union):
    """
    Indicates what type of match was found for a given item.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SearchMatchTypeV2.filename: This item was matched on its file or
        folder name.
    :ivar files.SearchMatchTypeV2.file_content: This item was matched based on
        its file contents.
    :ivar files.SearchMatchTypeV2.filename_and_content: This item was matched
        based on both its contents and its file name.
    :ivar files.SearchMatchTypeV2.image_content: This item was matched on image
        content.
    """
    _catch_all = ...
    filename = ...
    file_content = ...
    filename_and_content = ...
    image_content = ...
    other = ...
    def is_filename(self):
        """
        Check if the union tag is ``filename``.

        :rtype: bool
        """
        ...
    
    def is_file_content(self):
        """
        Check if the union tag is ``file_content``.

        :rtype: bool
        """
        ...
    
    def is_filename_and_content(self):
        """
        Check if the union tag is ``filename_and_content``.

        :rtype: bool
        """
        ...
    
    def is_image_content(self):
        """
        Check if the union tag is ``image_content``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


SearchMatchTypeV2_validator = ...
class SearchMatchV2(bb.Struct):
    """
    :ivar files.SearchMatchV2.metadata: The metadata for the matched file or
        folder.
    :ivar files.SearchMatchV2.match_type: The type of the match.
    :ivar files.SearchMatchV2.highlight_spans: The list of HighlightSpan
        determines which parts of the file title should be highlighted.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, metadata=..., match_type=..., highlight_spans=...) -> None:
        ...
    
    metadata = ...
    match_type = ...
    highlight_spans = ...


SearchMatchV2_validator = ...
class SearchMode(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SearchMode.filename: Search file and folder names.
    :ivar files.SearchMode.filename_and_content: Search file and folder names as
        well as file contents.
    :ivar files.SearchMode.deleted_filename: Search for deleted file and folder
        names.
    """
    _catch_all = ...
    filename = ...
    filename_and_content = ...
    deleted_filename = ...
    def is_filename(self):
        """
        Check if the union tag is ``filename``.

        :rtype: bool
        """
        ...
    
    def is_filename_and_content(self):
        """
        Check if the union tag is ``filename_and_content``.

        :rtype: bool
        """
        ...
    
    def is_deleted_filename(self):
        """
        Check if the union tag is ``deleted_filename``.

        :rtype: bool
        """
        ...
    


SearchMode_validator = ...
class SearchOptions(bb.Struct):
    """
    :ivar files.SearchOptions.path: Scopes the search to a path in the user's
        Dropbox. Searches the entire Dropbox if not specified.
    :ivar files.SearchOptions.max_results: The maximum number of search results
        to return.
    :ivar files.SearchOptions.order_by: Specified property of the order of
        search results. By default, results are sorted by relevance.
    :ivar files.SearchOptions.file_status: Restricts search to the given file
        status.
    :ivar files.SearchOptions.filename_only: Restricts search to only match on
        filenames.
    :ivar files.SearchOptions.file_extensions: Restricts search to only the
        extensions specified. Only supported for active file search.
    :ivar files.SearchOptions.file_categories: Restricts search to only the file
        categories specified. Only supported for active file search.
    :ivar files.SearchOptions.account_id: Restricts results to the given account
        id.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., max_results=..., order_by=..., file_status=..., filename_only=..., file_extensions=..., file_categories=..., account_id=...) -> None:
        ...
    
    path = ...
    max_results = ...
    order_by = ...
    file_status = ...
    filename_only = ...
    file_extensions = ...
    file_categories = ...
    account_id = ...


SearchOptions_validator = ...
class SearchOrderBy(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    relevance = ...
    last_modified_time = ...
    other = ...
    def is_relevance(self):
        """
        Check if the union tag is ``relevance``.

        :rtype: bool
        """
        ...
    
    def is_last_modified_time(self):
        """
        Check if the union tag is ``last_modified_time``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


SearchOrderBy_validator = ...
class SearchResult(bb.Struct):
    """
    :ivar files.SearchResult.matches: A list (possibly empty) of matches for the
        query.
    :ivar files.SearchResult.more: Used for paging. If true, indicates there is
        another page of results available that can be fetched by calling
        :meth:`dropbox.dropbox_client.Dropbox.files_search` again.
    :ivar files.SearchResult.start: Used for paging. Value to set the start
        argument to when calling
        :meth:`dropbox.dropbox_client.Dropbox.files_search` to fetch the next
        page of results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, matches=..., more=..., start=...) -> None:
        ...
    
    matches = ...
    more = ...
    start = ...


SearchResult_validator = ...
class SearchV2Arg(bb.Struct):
    """
    :ivar files.SearchV2Arg.query: The string to search for. May match across
        multiple fields based on the request arguments.
    :ivar files.SearchV2Arg.options: Options for more targeted search results.
    :ivar files.SearchV2Arg.match_field_options: Options for search results
        match fields.
    :ivar files.SearchV2Arg.include_highlights: Deprecated and moved this option
        to SearchMatchFieldOptions.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, query=..., options=..., match_field_options=..., include_highlights=...) -> None:
        ...
    
    query = ...
    options = ...
    match_field_options = ...
    include_highlights = ...


SearchV2Arg_validator = ...
class SearchV2ContinueArg(bb.Struct):
    """
    :ivar files.SearchV2ContinueArg.cursor: The cursor returned by your last
        call to :meth:`dropbox.dropbox_client.Dropbox.files_search`. Used to
        fetch the next page of results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


SearchV2ContinueArg_validator = ...
class SearchV2Result(bb.Struct):
    """
    :ivar files.SearchV2Result.matches: A list (possibly empty) of matches for
        the query.
    :ivar files.SearchV2Result.has_more: Used for paging. If true, indicates
        there is another page of results available that can be fetched by
        calling :meth:`dropbox.dropbox_client.Dropbox.files_search_continue`
        with the cursor.
    :ivar files.SearchV2Result.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.files_search_continue` to fetch
        the next page of results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, matches=..., has_more=..., cursor=...) -> None:
        ...
    
    matches = ...
    has_more = ...
    cursor = ...


SearchV2Result_validator = ...
class SharedLink(bb.Struct):
    """
    :ivar files.SharedLink.url: Shared link url.
    :ivar files.SharedLink.password: Password for the shared link.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, url=..., password=...) -> None:
        ...
    
    url = ...
    password = ...


SharedLink_validator = ...
class SharedLinkFileInfo(bb.Struct):
    """
    :ivar files.SharedLinkFileInfo.url: The shared link corresponding to either
        a file or shared link to a folder. If it is for a folder shared link, we
        use the path param to determine for which file in the folder the view is
        for.
    :ivar files.SharedLinkFileInfo.path: The path corresponding to a file in a
        shared link to a folder. Required for shared links to folders.
    :ivar files.SharedLinkFileInfo.password: Password for the shared link.
        Required for password-protected shared links to files  unless it can be
        read from a cookie.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, url=..., path=..., password=...) -> None:
        ...
    
    url = ...
    path = ...
    password = ...


SharedLinkFileInfo_validator = ...
class SingleUserLock(bb.Struct):
    """
    :ivar files.SingleUserLock.created: The time the lock was created.
    :ivar files.SingleUserLock.lock_holder_account_id: The account ID of the
        lock holder if known.
    :ivar files.SingleUserLock.lock_holder_team_id: The id of the team of the
        account holder if it exists.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, created=..., lock_holder_account_id=..., lock_holder_team_id=...) -> None:
        ...
    
    created = ...
    lock_holder_account_id = ...
    lock_holder_team_id = ...


SingleUserLock_validator = ...
class SymlinkInfo(bb.Struct):
    """
    :ivar files.SymlinkInfo.target: The target this symlink points to.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, target=...) -> None:
        ...
    
    target = ...


SymlinkInfo_validator = ...
class SyncSetting(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SyncSetting.default: On first sync to members' computers, the
        specified folder will follow its parent folder's setting or otherwise
        follow default sync behavior.
    :ivar files.SyncSetting.not_synced: On first sync to members' computers, the
        specified folder will be set to not sync with selective sync.
    :ivar files.SyncSetting.not_synced_inactive: The specified folder's
        not_synced setting is inactive due to its location or other
        configuration changes. It will follow its parent folder's setting.
    """
    _catch_all = ...
    default = ...
    not_synced = ...
    not_synced_inactive = ...
    other = ...
    def is_default(self):
        """
        Check if the union tag is ``default``.

        :rtype: bool
        """
        ...
    
    def is_not_synced(self):
        """
        Check if the union tag is ``not_synced``.

        :rtype: bool
        """
        ...
    
    def is_not_synced_inactive(self):
        """
        Check if the union tag is ``not_synced_inactive``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


SyncSetting_validator = ...
class SyncSettingArg(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SyncSettingArg.default: On first sync to members' computers, the
        specified folder will follow its parent folder's setting or otherwise
        follow default sync behavior.
    :ivar files.SyncSettingArg.not_synced: On first sync to members' computers,
        the specified folder will be set to not sync with selective sync.
    """
    _catch_all = ...
    default = ...
    not_synced = ...
    other = ...
    def is_default(self):
        """
        Check if the union tag is ``default``.

        :rtype: bool
        """
        ...
    
    def is_not_synced(self):
        """
        Check if the union tag is ``not_synced``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


SyncSettingArg_validator = ...
class SyncSettingsError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.SyncSettingsError.unsupported_combination: Setting this
        combination of sync settings simultaneously is not supported.
    :ivar files.SyncSettingsError.unsupported_configuration: The specified
        configuration is not supported.
    """
    _catch_all = ...
    unsupported_combination = ...
    unsupported_configuration = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: SyncSettingsError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_combination(self):
        """
        Check if the union tag is ``unsupported_combination``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_configuration(self):
        """
        Check if the union tag is ``unsupported_configuration``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


SyncSettingsError_validator = ...
class Tag(bb.Union):
    """
    Tag that can be added in multiple ways.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserGeneratedTag Tag.user_generated_tag: Tag generated by the user.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def user_generated_tag(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_generated_tag`` tag
        with value ``val``.

        :param UserGeneratedTag val:
        :rtype: Tag
        """
        ...
    
    def is_user_generated_tag(self):
        """
        Check if the union tag is ``user_generated_tag``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_user_generated_tag(self): # -> None:
        """
        Tag generated by the user.

        Only call this if :meth:`is_user_generated_tag` is true.

        :rtype: UserGeneratedTag
        """
        ...
    


Tag_validator = ...
class ThumbnailArg(bb.Struct):
    """
    :ivar files.ThumbnailArg.path: The path to the image file you want to
        thumbnail.
    :ivar files.ThumbnailArg.format: The format for the thumbnail image, jpeg
        (default) or png. For  images that are photos, jpeg should be preferred,
        while png is  better for screenshots and digital arts.
    :ivar files.ThumbnailArg.size: The size for the thumbnail image.
    :ivar files.ThumbnailArg.mode: How to resize and crop the image to achieve
        the desired size.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., format=..., size=..., mode=...) -> None:
        ...
    
    path = ...
    format = ...
    size = ...
    mode = ...


ThumbnailArg_validator = ...
class ThumbnailError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar LookupError ThumbnailError.path: An error occurs when downloading
        metadata for the image.
    :ivar files.ThumbnailError.unsupported_extension: The file extension doesn't
        allow conversion to a thumbnail.
    :ivar files.ThumbnailError.unsupported_image: The image cannot be converted
        to a thumbnail.
    :ivar files.ThumbnailError.conversion_error: An error occurs during
        thumbnail conversion.
    """
    _catch_all = ...
    unsupported_extension = ...
    unsupported_image = ...
    conversion_error = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ThumbnailError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_extension(self):
        """
        Check if the union tag is ``unsupported_extension``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_image(self):
        """
        Check if the union tag is ``unsupported_image``.

        :rtype: bool
        """
        ...
    
    def is_conversion_error(self):
        """
        Check if the union tag is ``conversion_error``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        An error occurs when downloading metadata for the image.

        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


ThumbnailError_validator = ...
class ThumbnailFormat(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    jpeg = ...
    png = ...
    def is_jpeg(self):
        """
        Check if the union tag is ``jpeg``.

        :rtype: bool
        """
        ...
    
    def is_png(self):
        """
        Check if the union tag is ``png``.

        :rtype: bool
        """
        ...
    


ThumbnailFormat_validator = ...
class ThumbnailMode(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ThumbnailMode.strict: Scale down the image to fit within the
        given size.
    :ivar files.ThumbnailMode.bestfit: Scale down the image to fit within the
        given size or its transpose.
    :ivar files.ThumbnailMode.fitone_bestfit: Scale down the image to completely
        cover the given size or its transpose.
    """
    _catch_all = ...
    strict = ...
    bestfit = ...
    fitone_bestfit = ...
    def is_strict(self):
        """
        Check if the union tag is ``strict``.

        :rtype: bool
        """
        ...
    
    def is_bestfit(self):
        """
        Check if the union tag is ``bestfit``.

        :rtype: bool
        """
        ...
    
    def is_fitone_bestfit(self):
        """
        Check if the union tag is ``fitone_bestfit``.

        :rtype: bool
        """
        ...
    


ThumbnailMode_validator = ...
class ThumbnailSize(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.ThumbnailSize.w32h32: 32 by 32 px.
    :ivar files.ThumbnailSize.w64h64: 64 by 64 px.
    :ivar files.ThumbnailSize.w128h128: 128 by 128 px.
    :ivar files.ThumbnailSize.w256h256: 256 by 256 px.
    :ivar files.ThumbnailSize.w480h320: 480 by 320 px.
    :ivar files.ThumbnailSize.w640h480: 640 by 480 px.
    :ivar files.ThumbnailSize.w960h640: 960 by 640 px.
    :ivar files.ThumbnailSize.w1024h768: 1024 by 768 px.
    :ivar files.ThumbnailSize.w2048h1536: 2048 by 1536 px.
    """
    _catch_all = ...
    w32h32 = ...
    w64h64 = ...
    w128h128 = ...
    w256h256 = ...
    w480h320 = ...
    w640h480 = ...
    w960h640 = ...
    w1024h768 = ...
    w2048h1536 = ...
    def is_w32h32(self):
        """
        Check if the union tag is ``w32h32``.

        :rtype: bool
        """
        ...
    
    def is_w64h64(self):
        """
        Check if the union tag is ``w64h64``.

        :rtype: bool
        """
        ...
    
    def is_w128h128(self):
        """
        Check if the union tag is ``w128h128``.

        :rtype: bool
        """
        ...
    
    def is_w256h256(self):
        """
        Check if the union tag is ``w256h256``.

        :rtype: bool
        """
        ...
    
    def is_w480h320(self):
        """
        Check if the union tag is ``w480h320``.

        :rtype: bool
        """
        ...
    
    def is_w640h480(self):
        """
        Check if the union tag is ``w640h480``.

        :rtype: bool
        """
        ...
    
    def is_w960h640(self):
        """
        Check if the union tag is ``w960h640``.

        :rtype: bool
        """
        ...
    
    def is_w1024h768(self):
        """
        Check if the union tag is ``w1024h768``.

        :rtype: bool
        """
        ...
    
    def is_w2048h1536(self):
        """
        Check if the union tag is ``w2048h1536``.

        :rtype: bool
        """
        ...
    


ThumbnailSize_validator = ...
class ThumbnailV2Arg(bb.Struct):
    """
    :ivar files.ThumbnailV2Arg.resource: Information specifying which file to
        preview. This could be a path to a file, a shared link pointing to a
        file, or a shared link pointing to a folder, with a relative path.
    :ivar files.ThumbnailV2Arg.format: The format for the thumbnail image, jpeg
        (default) or png. For  images that are photos, jpeg should be preferred,
        while png is  better for screenshots and digital arts.
    :ivar files.ThumbnailV2Arg.size: The size for the thumbnail image.
    :ivar files.ThumbnailV2Arg.mode: How to resize and crop the image to achieve
        the desired size.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, resource=..., format=..., size=..., mode=...) -> None:
        ...
    
    resource = ...
    format = ...
    size = ...
    mode = ...


ThumbnailV2Arg_validator = ...
class ThumbnailV2Error(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar LookupError ThumbnailV2Error.path: An error occurred when downloading
        metadata for the image.
    :ivar files.ThumbnailV2Error.unsupported_extension: The file extension
        doesn't allow conversion to a thumbnail.
    :ivar files.ThumbnailV2Error.unsupported_image: The image cannot be
        converted to a thumbnail.
    :ivar files.ThumbnailV2Error.conversion_error: An error occurred during
        thumbnail conversion.
    :ivar files.ThumbnailV2Error.access_denied: Access to this shared link is
        forbidden.
    :ivar files.ThumbnailV2Error.not_found: The shared link does not exist.
    """
    _catch_all = ...
    unsupported_extension = ...
    unsupported_image = ...
    conversion_error = ...
    access_denied = ...
    not_found = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param LookupError val:
        :rtype: ThumbnailV2Error
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_extension(self):
        """
        Check if the union tag is ``unsupported_extension``.

        :rtype: bool
        """
        ...
    
    def is_unsupported_image(self):
        """
        Check if the union tag is ``unsupported_image``.

        :rtype: bool
        """
        ...
    
    def is_conversion_error(self):
        """
        Check if the union tag is ``conversion_error``.

        :rtype: bool
        """
        ...
    
    def is_access_denied(self):
        """
        Check if the union tag is ``access_denied``.

        :rtype: bool
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        An error occurred when downloading metadata for the image.

        Only call this if :meth:`is_path` is true.

        :rtype: LookupError
        """
        ...
    


ThumbnailV2Error_validator = ...
class UnlockFileArg(bb.Struct):
    """
    :ivar files.UnlockFileArg.path: Path in the user's Dropbox to a file.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=...) -> None:
        ...
    
    path = ...


UnlockFileArg_validator = ...
class UnlockFileBatchArg(bb.Struct):
    """
    :ivar files.UnlockFileBatchArg.entries: List of 'entries'. Each 'entry'
        contains a path of the file which will be unlocked. Duplicate path
        arguments in the batch are considered only once.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


UnlockFileBatchArg_validator = ...
class UploadArg(CommitInfo):
    """
    :ivar files.UploadArg.content_hash: A hash of the file content uploaded in
        this call. If provided and the uploaded content does not match this
        hash, an error will be returned. For more information see our `Content
        hash <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, path=..., mode=..., autorename=..., client_modified=..., mute=..., property_groups=..., strict_conflict=..., content_hash=...) -> None:
        ...
    
    content_hash = ...


UploadArg_validator = ...
class UploadError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UploadWriteFailed UploadError.path: Unable to save the uploaded
        contents to a file.
    :ivar InvalidPropertyGroupError UploadError.properties_error: The supplied
        property group is invalid. The file has uploaded without property
        groups.
    :ivar files.UploadError.payload_too_large: The request payload must be at
        most 150 MB.
    :ivar files.UploadError.content_hash_mismatch: The content received by the
        Dropbox server in this call does not match the provided content hash.
    """
    _catch_all = ...
    payload_too_large = ...
    content_hash_mismatch = ...
    other = ...
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param UploadWriteFailed val:
        :rtype: UploadError
        """
        ...
    
    @classmethod
    def properties_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``properties_error`` tag
        with value ``val``.

        :param file_properties.InvalidPropertyGroupError val:
        :rtype: UploadError
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_properties_error(self):
        """
        Check if the union tag is ``properties_error``.

        :rtype: bool
        """
        ...
    
    def is_payload_too_large(self):
        """
        Check if the union tag is ``payload_too_large``.

        :rtype: bool
        """
        ...
    
    def is_content_hash_mismatch(self):
        """
        Check if the union tag is ``content_hash_mismatch``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_path(self): # -> None:
        """
        Unable to save the uploaded contents to a file.

        Only call this if :meth:`is_path` is true.

        :rtype: UploadWriteFailed
        """
        ...
    
    def get_properties_error(self): # -> None:
        """
        The supplied property group is invalid. The file has uploaded without
        property groups.

        Only call this if :meth:`is_properties_error` is true.

        :rtype: file_properties.InvalidPropertyGroupError
        """
        ...
    


UploadError_validator = ...
class UploadSessionAppendArg(bb.Struct):
    """
    :ivar files.UploadSessionAppendArg.cursor: Contains the upload session ID
        and the offset.
    :ivar files.UploadSessionAppendArg.close: If true, the current session will
        be closed, at which point you won't be able to call
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_append`
        anymore with the current session.
    :ivar files.UploadSessionAppendArg.content_hash: A hash of the file content
        uploaded in this call. If provided and the uploaded content does not
        match this hash, an error will be returned. For more information see our
        `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=..., close=..., content_hash=...) -> None:
        ...
    
    cursor = ...
    close = ...
    content_hash = ...


UploadSessionAppendArg_validator = ...
class UploadSessionLookupError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.UploadSessionLookupError.not_found: The upload session ID was
        not found or has expired. Upload sessions are valid for 7 days.
    :ivar UploadSessionOffsetError UploadSessionLookupError.incorrect_offset:
        The specified offset was incorrect. See the value for the correct
        offset. This error may occur when a previous request was received and
        processed successfully but the client did not receive the response, e.g.
        due to a network error.
    :ivar files.UploadSessionLookupError.closed: You are attempting to append
        data to an upload session that has already been closed (i.e. committed).
    :ivar files.UploadSessionLookupError.not_closed: The session must be closed
        before calling upload_session/finish_batch.
    :ivar files.UploadSessionLookupError.too_large: You can not append to the
        upload session because the size of a file should not reach the max file
        size limit (i.e. 350GB).
    :ivar files.UploadSessionLookupError.concurrent_session_invalid_offset: For
        concurrent upload sessions, offset needs to be multiple of 4194304
        bytes.
    :ivar files.UploadSessionLookupError.concurrent_session_invalid_data_size:
        For concurrent upload sessions, only chunks with size multiple of
        4194304 bytes can be uploaded.
    :ivar files.UploadSessionLookupError.payload_too_large: The request payload
        must be at most 150 MB.
    """
    _catch_all = ...
    not_found = ...
    closed = ...
    not_closed = ...
    too_large = ...
    concurrent_session_invalid_offset = ...
    concurrent_session_invalid_data_size = ...
    payload_too_large = ...
    other = ...
    @classmethod
    def incorrect_offset(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``incorrect_offset`` tag
        with value ``val``.

        :param UploadSessionOffsetError val:
        :rtype: UploadSessionLookupError
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_incorrect_offset(self):
        """
        Check if the union tag is ``incorrect_offset``.

        :rtype: bool
        """
        ...
    
    def is_closed(self):
        """
        Check if the union tag is ``closed``.

        :rtype: bool
        """
        ...
    
    def is_not_closed(self):
        """
        Check if the union tag is ``not_closed``.

        :rtype: bool
        """
        ...
    
    def is_too_large(self):
        """
        Check if the union tag is ``too_large``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_invalid_offset(self):
        """
        Check if the union tag is ``concurrent_session_invalid_offset``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_invalid_data_size(self):
        """
        Check if the union tag is ``concurrent_session_invalid_data_size``.

        :rtype: bool
        """
        ...
    
    def is_payload_too_large(self):
        """
        Check if the union tag is ``payload_too_large``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_incorrect_offset(self): # -> None:
        """
        The specified offset was incorrect. See the value for the correct
        offset. This error may occur when a previous request was received and
        processed successfully but the client did not receive the response, e.g.
        due to a network error.

        Only call this if :meth:`is_incorrect_offset` is true.

        :rtype: UploadSessionOffsetError
        """
        ...
    


UploadSessionLookupError_validator = ...
class UploadSessionAppendError(UploadSessionLookupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.UploadSessionAppendError.content_hash_mismatch: The content
        received by the Dropbox server in this call does not match the provided
        content hash.
    """
    content_hash_mismatch = ...
    def is_content_hash_mismatch(self):
        """
        Check if the union tag is ``content_hash_mismatch``.

        :rtype: bool
        """
        ...
    


UploadSessionAppendError_validator = ...
class UploadSessionCursor(bb.Struct):
    """
    :ivar files.UploadSessionCursor.session_id: The upload session ID (returned
        by :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_start`).
    :ivar files.UploadSessionCursor.offset: Offset in bytes at which data should
        be appended. We use this to make sure upload data isn't lost or
        duplicated in the event of a network error.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., offset=...) -> None:
        ...
    
    session_id = ...
    offset = ...


UploadSessionCursor_validator = ...
class UploadSessionFinishArg(bb.Struct):
    """
    :ivar files.UploadSessionFinishArg.cursor: Contains the upload session ID
        and the offset.
    :ivar files.UploadSessionFinishArg.commit: Contains the path and other
        optional modifiers for the commit.
    :ivar files.UploadSessionFinishArg.content_hash: A hash of the file content
        uploaded in this call. If provided and the uploaded content does not
        match this hash, an error will be returned. For more information see our
        `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=..., commit=..., content_hash=...) -> None:
        ...
    
    cursor = ...
    commit = ...
    content_hash = ...


UploadSessionFinishArg_validator = ...
class UploadSessionFinishBatchArg(bb.Struct):
    """
    :ivar files.UploadSessionFinishBatchArg.entries: Commit information for each
        file in the batch.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


UploadSessionFinishBatchArg_validator = ...
class UploadSessionFinishBatchJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UploadSessionFinishBatchResult
        UploadSessionFinishBatchJobStatus.complete: The
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish_batch`
        has finished.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param UploadSessionFinishBatchResult val:
        :rtype: UploadSessionFinishBatchJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish_batch`
        has finished.

        Only call this if :meth:`is_complete` is true.

        :rtype: UploadSessionFinishBatchResult
        """
        ...
    


UploadSessionFinishBatchJobStatus_validator = ...
class UploadSessionFinishBatchLaunch(async_.LaunchResultBase):
    """
    Result returned by
    :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish_batch`
    that may either launch an asynchronous job or complete synchronously.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param UploadSessionFinishBatchResult val:
        :rtype: UploadSessionFinishBatchLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: UploadSessionFinishBatchResult
        """
        ...
    


UploadSessionFinishBatchLaunch_validator = ...
class UploadSessionFinishBatchResult(bb.Struct):
    """
    :ivar files.UploadSessionFinishBatchResult.entries: Each entry in
        ``UploadSessionFinishBatchArg.entries`` will appear at the same position
        inside ``UploadSessionFinishBatchResult.entries``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=...) -> None:
        ...
    
    entries = ...


UploadSessionFinishBatchResult_validator = ...
class UploadSessionFinishBatchResultEntry(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param FileMetadata val:
        :rtype: UploadSessionFinishBatchResultEntry
        """
        ...
    
    @classmethod
    def failure(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failure`` tag with value
        ``val``.

        :param UploadSessionFinishError val:
        :rtype: UploadSessionFinishBatchResultEntry
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_failure(self):
        """
        Check if the union tag is ``failure``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Only call this if :meth:`is_success` is true.

        :rtype: FileMetadata
        """
        ...
    
    def get_failure(self): # -> None:
        """
        Only call this if :meth:`is_failure` is true.

        :rtype: UploadSessionFinishError
        """
        ...
    


UploadSessionFinishBatchResultEntry_validator = ...
class UploadSessionFinishError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UploadSessionLookupError UploadSessionFinishError.lookup_failed: The
        session arguments are incorrect; the value explains the reason.
    :ivar WriteError UploadSessionFinishError.path: Unable to save the uploaded
        contents to a file. Data has already been appended to the upload
        session. Please retry with empty data body and updated offset.
    :ivar InvalidPropertyGroupError UploadSessionFinishError.properties_error:
        The supplied property group is invalid. The file has uploaded without
        property groups.
    :ivar files.UploadSessionFinishError.too_many_shared_folder_targets: The
        batch request commits files into too many different shared folders.
        Please limit your batch request to files contained in a single shared
        folder.
    :ivar files.UploadSessionFinishError.too_many_write_operations: There are
        too many write operations happening in the user's Dropbox. You should
        retry uploading this file.
    :ivar files.UploadSessionFinishError.concurrent_session_data_not_allowed:
        Uploading data not allowed when finishing concurrent upload session.
    :ivar files.UploadSessionFinishError.concurrent_session_not_closed:
        Concurrent upload sessions need to be closed before finishing.
    :ivar files.UploadSessionFinishError.concurrent_session_missing_data: Not
        all pieces of data were uploaded before trying to finish the session.
    :ivar files.UploadSessionFinishError.payload_too_large: The request payload
        must be at most 150 MB.
    :ivar files.UploadSessionFinishError.content_hash_mismatch: The content
        received by the Dropbox server in this call does not match the provided
        content hash.
    """
    _catch_all = ...
    too_many_shared_folder_targets = ...
    too_many_write_operations = ...
    concurrent_session_data_not_allowed = ...
    concurrent_session_not_closed = ...
    concurrent_session_missing_data = ...
    payload_too_large = ...
    content_hash_mismatch = ...
    other = ...
    @classmethod
    def lookup_failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``lookup_failed`` tag with
        value ``val``.

        :param UploadSessionLookupError val:
        :rtype: UploadSessionFinishError
        """
        ...
    
    @classmethod
    def path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``path`` tag with value
        ``val``.

        :param WriteError val:
        :rtype: UploadSessionFinishError
        """
        ...
    
    @classmethod
    def properties_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``properties_error`` tag
        with value ``val``.

        :param file_properties.InvalidPropertyGroupError val:
        :rtype: UploadSessionFinishError
        """
        ...
    
    def is_lookup_failed(self):
        """
        Check if the union tag is ``lookup_failed``.

        :rtype: bool
        """
        ...
    
    def is_path(self):
        """
        Check if the union tag is ``path``.

        :rtype: bool
        """
        ...
    
    def is_properties_error(self):
        """
        Check if the union tag is ``properties_error``.

        :rtype: bool
        """
        ...
    
    def is_too_many_shared_folder_targets(self):
        """
        Check if the union tag is ``too_many_shared_folder_targets``.

        :rtype: bool
        """
        ...
    
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_data_not_allowed(self):
        """
        Check if the union tag is ``concurrent_session_data_not_allowed``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_not_closed(self):
        """
        Check if the union tag is ``concurrent_session_not_closed``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_missing_data(self):
        """
        Check if the union tag is ``concurrent_session_missing_data``.

        :rtype: bool
        """
        ...
    
    def is_payload_too_large(self):
        """
        Check if the union tag is ``payload_too_large``.

        :rtype: bool
        """
        ...
    
    def is_content_hash_mismatch(self):
        """
        Check if the union tag is ``content_hash_mismatch``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_lookup_failed(self): # -> None:
        """
        The session arguments are incorrect; the value explains the reason.

        Only call this if :meth:`is_lookup_failed` is true.

        :rtype: UploadSessionLookupError
        """
        ...
    
    def get_path(self): # -> None:
        """
        Unable to save the uploaded contents to a file. Data has already been
        appended to the upload session. Please retry with empty data body and
        updated offset.

        Only call this if :meth:`is_path` is true.

        :rtype: WriteError
        """
        ...
    
    def get_properties_error(self): # -> None:
        """
        The supplied property group is invalid. The file has uploaded without
        property groups.

        Only call this if :meth:`is_properties_error` is true.

        :rtype: file_properties.InvalidPropertyGroupError
        """
        ...
    


UploadSessionFinishError_validator = ...
class UploadSessionOffsetError(bb.Struct):
    """
    :ivar files.UploadSessionOffsetError.correct_offset: The offset up to which
        data has been collected.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, correct_offset=...) -> None:
        ...
    
    correct_offset = ...


UploadSessionOffsetError_validator = ...
class UploadSessionStartArg(bb.Struct):
    """
    :ivar files.UploadSessionStartArg.close: If true, the current session will
        be closed, at which point you won't be able to call
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_append`
        anymore with the current session.
    :ivar files.UploadSessionStartArg.session_type: Type of upload session you
        want to start. If not specified, default is
        ``UploadSessionType.sequential``.
    :ivar files.UploadSessionStartArg.content_hash: A hash of the file content
        uploaded in this call. If provided and the uploaded content does not
        match this hash, an error will be returned. For more information see our
        `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, close=..., session_type=..., content_hash=...) -> None:
        ...
    
    close = ...
    session_type = ...
    content_hash = ...


UploadSessionStartArg_validator = ...
class UploadSessionStartBatchArg(bb.Struct):
    """
    :ivar files.UploadSessionStartBatchArg.session_type: Type of upload session
        you want to start. If not specified, default is
        ``UploadSessionType.sequential``.
    :ivar files.UploadSessionStartBatchArg.num_sessions: The number of upload
        sessions to start.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, num_sessions=..., session_type=...) -> None:
        ...
    
    session_type = ...
    num_sessions = ...


UploadSessionStartBatchArg_validator = ...
class UploadSessionStartBatchResult(bb.Struct):
    """
    :ivar files.UploadSessionStartBatchResult.session_ids: A List of unique
        identifiers for the upload session. Pass each session_id to
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_append` and
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_ids=...) -> None:
        ...
    
    session_ids = ...


UploadSessionStartBatchResult_validator = ...
class UploadSessionStartError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.UploadSessionStartError.concurrent_session_data_not_allowed:
        Uploading data not allowed when starting concurrent upload session.
    :ivar files.UploadSessionStartError.concurrent_session_close_not_allowed:
        Can not start a closed concurrent upload session.
    :ivar files.UploadSessionStartError.payload_too_large: The request payload
        must be at most 150 MB.
    :ivar files.UploadSessionStartError.content_hash_mismatch: The content
        received by the Dropbox server in this call does not match the provided
        content hash.
    """
    _catch_all = ...
    concurrent_session_data_not_allowed = ...
    concurrent_session_close_not_allowed = ...
    payload_too_large = ...
    content_hash_mismatch = ...
    other = ...
    def is_concurrent_session_data_not_allowed(self):
        """
        Check if the union tag is ``concurrent_session_data_not_allowed``.

        :rtype: bool
        """
        ...
    
    def is_concurrent_session_close_not_allowed(self):
        """
        Check if the union tag is ``concurrent_session_close_not_allowed``.

        :rtype: bool
        """
        ...
    
    def is_payload_too_large(self):
        """
        Check if the union tag is ``payload_too_large``.

        :rtype: bool
        """
        ...
    
    def is_content_hash_mismatch(self):
        """
        Check if the union tag is ``content_hash_mismatch``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


UploadSessionStartError_validator = ...
class UploadSessionStartResult(bb.Struct):
    """
    :ivar files.UploadSessionStartResult.session_id: A unique identifier for the
        upload session. Pass this to
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_append` and
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=...) -> None:
        ...
    
    session_id = ...


UploadSessionStartResult_validator = ...
class UploadSessionType(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.UploadSessionType.sequential: Pieces of data are uploaded
        sequentially one after another. This is the default behavior.
    :ivar files.UploadSessionType.concurrent: Pieces of data can be uploaded in
        concurrent RPCs in any order.
    """
    _catch_all = ...
    sequential = ...
    concurrent = ...
    other = ...
    def is_sequential(self):
        """
        Check if the union tag is ``sequential``.

        :rtype: bool
        """
        ...
    
    def is_concurrent(self):
        """
        Check if the union tag is ``concurrent``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


UploadSessionType_validator = ...
class UploadWriteFailed(bb.Struct):
    """
    :ivar files.UploadWriteFailed.reason: The reason why the file couldn't be
        saved.
    :ivar files.UploadWriteFailed.upload_session_id: The upload session ID; data
        has already been uploaded to the corresponding upload session and this
        ID may be used to retry the commit with
        :meth:`dropbox.dropbox_client.Dropbox.files_upload_session_finish`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, reason=..., upload_session_id=...) -> None:
        ...
    
    reason = ...
    upload_session_id = ...


UploadWriteFailed_validator = ...
class UserGeneratedTag(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, tag_text=...) -> None:
        ...
    
    tag_text = ...


UserGeneratedTag_validator = ...
class VideoMetadata(MediaMetadata):
    """
    Metadata for a video.

    :ivar files.VideoMetadata.duration: The duration of the video in
        milliseconds.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, dimensions=..., location=..., time_taken=..., duration=...) -> None:
        ...
    
    duration = ...


VideoMetadata_validator = ...
class WriteConflictError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.WriteConflictError.file: There's a file in the way.
    :ivar files.WriteConflictError.folder: There's a folder in the way.
    :ivar files.WriteConflictError.file_ancestor: There's a file at an ancestor
        path, so we couldn't create the required parent folders.
    """
    _catch_all = ...
    file = ...
    folder = ...
    file_ancestor = ...
    other = ...
    def is_file(self):
        """
        Check if the union tag is ``file``.

        :rtype: bool
        """
        ...
    
    def is_folder(self):
        """
        Check if the union tag is ``folder``.

        :rtype: bool
        """
        ...
    
    def is_file_ancestor(self):
        """
        Check if the union tag is ``file_ancestor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


WriteConflictError_validator = ...
class WriteError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar Optional[str] files.WriteError.malformed_path: The given path does not
        satisfy the required path format. Please refer to the :link:`Path
        formats documentation
        https://www.dropbox.com/developers/documentation/http/documentation#path-formats`
        for more information.
    :ivar WriteConflictError WriteError.conflict: Couldn't write to the target
        path because there was something in the way.
    :ivar files.WriteError.no_write_permission: The user doesn't have
        permissions to write to the target location.
    :ivar files.WriteError.insufficient_space: The user doesn't have enough
        available space (bytes) to write more data.
    :ivar files.WriteError.disallowed_name: Dropbox will not save the file or
        folder because of its name.
    :ivar files.WriteError.team_folder: This endpoint cannot move or delete team
        folders.
    :ivar files.WriteError.operation_suppressed: This file operation is not
        allowed at this path.
    :ivar files.WriteError.too_many_write_operations: There are too many write
        operations in user's Dropbox. Please retry this request.
    """
    _catch_all = ...
    no_write_permission = ...
    insufficient_space = ...
    disallowed_name = ...
    team_folder = ...
    operation_suppressed = ...
    too_many_write_operations = ...
    other = ...
    @classmethod
    def malformed_path(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``malformed_path`` tag with
        value ``val``.

        :param Optional[str] val:
        :rtype: WriteError
        """
        ...
    
    @classmethod
    def conflict(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``conflict`` tag with value
        ``val``.

        :param WriteConflictError val:
        :rtype: WriteError
        """
        ...
    
    def is_malformed_path(self):
        """
        Check if the union tag is ``malformed_path``.

        :rtype: bool
        """
        ...
    
    def is_conflict(self):
        """
        Check if the union tag is ``conflict``.

        :rtype: bool
        """
        ...
    
    def is_no_write_permission(self):
        """
        Check if the union tag is ``no_write_permission``.

        :rtype: bool
        """
        ...
    
    def is_insufficient_space(self):
        """
        Check if the union tag is ``insufficient_space``.

        :rtype: bool
        """
        ...
    
    def is_disallowed_name(self):
        """
        Check if the union tag is ``disallowed_name``.

        :rtype: bool
        """
        ...
    
    def is_team_folder(self):
        """
        Check if the union tag is ``team_folder``.

        :rtype: bool
        """
        ...
    
    def is_operation_suppressed(self):
        """
        Check if the union tag is ``operation_suppressed``.

        :rtype: bool
        """
        ...
    
    def is_too_many_write_operations(self):
        """
        Check if the union tag is ``too_many_write_operations``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_malformed_path(self): # -> None:
        """
        The given path does not satisfy the required path format. Please refer
        to the `Path formats documentation
        <https://www.dropbox.com/developers/documentation/http/documentation#path-formats>`_
        for more information.

        Only call this if :meth:`is_malformed_path` is true.

        :rtype: Optional[str]
        """
        ...
    
    def get_conflict(self): # -> None:
        """
        Couldn't write to the target path because there was something in the
        way.

        Only call this if :meth:`is_conflict` is true.

        :rtype: WriteConflictError
        """
        ...
    


WriteError_validator = ...
class WriteMode(bb.Union):
    """
    Your intent when writing a file to some path. This is used to determine what
    constitutes a conflict and what the autorename strategy is. In some
    situations, the conflict behavior is identical: (a) If the target path
    doesn't refer to anything, the file is always written; no conflict. (b) If
    the target path refers to a folder, it's always a conflict. (c) If the
    target path refers to a file with identical contents, nothing gets written;
    no conflict. The conflict checking differs in the case where there's a file
    at the target path with contents different from the contents you're trying
    to write.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar files.WriteMode.add: Do not overwrite an existing file if there is a
        conflict. The autorename strategy is to append a number to the file
        name. For example, "document.txt" might become "document (2).txt".
    :ivar files.WriteMode.overwrite: Always overwrite the existing file. The
        autorename strategy is the same as it is for ``add``.
    :ivar str files.WriteMode.update: Overwrite if the given "rev" matches the
        existing file's "rev". The supplied value should be the latest known
        "rev" of the file, for example, from :type:`FileMetadata`, from when the
        file was last downloaded by the app. This will cause the file on the
        Dropbox servers to be overwritten if the given "rev" matches the
        existing file's current "rev" on the Dropbox servers. The autorename
        strategy is to append the string "conflicted copy" to the file name. For
        example, "document.txt" might become "document (conflicted copy).txt" or
        "document (Panda's conflicted copy).txt".
    """
    _catch_all = ...
    add = ...
    overwrite = ...
    @classmethod
    def update(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``update`` tag with value
        ``val``.

        :param str val:
        :rtype: WriteMode
        """
        ...
    
    def is_add(self):
        """
        Check if the union tag is ``add``.

        :rtype: bool
        """
        ...
    
    def is_overwrite(self):
        """
        Check if the union tag is ``overwrite``.

        :rtype: bool
        """
        ...
    
    def is_update(self):
        """
        Check if the union tag is ``update``.

        :rtype: bool
        """
        ...
    
    def get_update(self): # -> None:
        """
        Overwrite if the given "rev" matches the existing file's "rev". The
        supplied value should be the latest known "rev" of the file, for
        example, from :class:`FileMetadata`, from when the file was last
        downloaded by the app. This will cause the file on the Dropbox servers
        to be overwritten if the given "rev" matches the existing file's current
        "rev" on the Dropbox servers. The autorename strategy is to append the
        string "conflicted copy" to the file name. For example, "document.txt"
        might become "document (conflicted copy).txt" or "document (Panda's
        conflicted copy).txt".

        Only call this if :meth:`is_update` is true.

        :rtype: str
        """
        ...
    


WriteMode_validator = ...
CopyBatchArg_validator = ...
CopyBatchArg = RelocationBatchArgBase
FileId_validator = ...
Id_validator = ...
ListFolderCursor_validator = ...
MalformedPathError_validator = ...
Path_validator = ...
PathOrId_validator = ...
PathR_validator = ...
PathROrId_validator = ...
ReadPath_validator = ...
Rev_validator = ...
SearchV2Cursor_validator = ...
Sha256HexHash_validator = ...
SharedLinkUrl_validator = ...
TagText_validator = ...
WritePath_validator = ...
WritePathOrId_validator = ...
alpha_get_metadata = ...
alpha_upload = ...
copy_v2 = ...
copy = ...
copy_batch_v2 = ...
copy_batch = ...
copy_batch_check_v2 = ...
copy_batch_check = ...
copy_reference_get = ...
copy_reference_save = ...
create_folder_v2 = ...
create_folder = ...
create_folder_batch = ...
create_folder_batch_check = ...
delete_v2 = ...
delete = ...
delete_batch = ...
delete_batch_check = ...
download = ...
download_zip = ...
export = ...
get_file_lock_batch = ...
get_metadata = ...
get_preview = ...
get_temporary_link = ...
get_temporary_upload_link = ...
get_thumbnail = ...
get_thumbnail_v2 = ...
get_thumbnail_batch = ...
list_folder = ...
list_folder_continue = ...
list_folder_get_latest_cursor = ...
list_folder_longpoll = ...
list_revisions = ...
lock_file_batch = ...
move_v2 = ...
move = ...
move_batch_v2 = ...
move_batch = ...
move_batch_check_v2 = ...
move_batch_check = ...
paper_create = ...
paper_update = ...
permanently_delete = ...
properties_add = ...
properties_overwrite = ...
properties_remove = ...
properties_template_get = ...
properties_template_list = ...
properties_update = ...
restore = ...
save_url = ...
save_url_check_job_status = ...
search = ...
search_v2 = ...
search_continue_v2 = ...
tags_add = ...
tags_get = ...
tags_remove = ...
unlock_file_batch = ...
upload = ...
upload_session_append_v2 = ...
upload_session_append = ...
upload_session_finish = ...
upload_session_finish_batch = ...
upload_session_finish_batch_v2 = ...
upload_session_finish_batch_check = ...
upload_session_start = ...
upload_session_start_batch = ...
ROUTES = ...
