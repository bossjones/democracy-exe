"""
This type stub file was generated by pyright.
"""

from stone.backends.python_rsrc import stone_base as bb

"""
This namespace contains endpoints and data types for managing docs and folders in Dropbox Paper.
New Paper users will see docs they create in their filesystem as '.paper' files alongside their other Dropbox content. The /paper endpoints are being deprecated and you'll need to use /files and /sharing endpoints to interact with their Paper content. Read more in the `Paper Migration Guide <https://www.dropbox.com/lp/developers/reference/paper-migration-guide>`_.
"""
class AddMember(bb.Struct):
    """
    :ivar paper.AddMember.permission_level: Permission for the user.
    :ivar paper.AddMember.member: User which should be added to the Paper doc.
        Specify only email address or Dropbox account ID.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member=..., permission_level=...) -> None:
        ...
    
    permission_level = ...
    member = ...


AddMember_validator = ...
class RefPaperDoc(bb.Struct):
    """
    :ivar paper.RefPaperDoc.doc_id: The Paper doc ID.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=...) -> None:
        ...
    
    doc_id = ...


RefPaperDoc_validator = ...
class AddPaperDocUser(RefPaperDoc):
    """
    :ivar paper.AddPaperDocUser.members: User which should be added to the Paper
        doc. Specify only email address or Dropbox account ID.
    :ivar paper.AddPaperDocUser.custom_message: A personal message that will be
        emailed to each successfully added member.
    :ivar paper.AddPaperDocUser.quiet: Clients should set this to true if no
        email message shall be sent to added users.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., members=..., custom_message=..., quiet=...) -> None:
        ...
    
    members = ...
    custom_message = ...
    quiet = ...


AddPaperDocUser_validator = ...
class AddPaperDocUserMemberResult(bb.Struct):
    """
    Per-member result for
    :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_add`.

    :ivar paper.AddPaperDocUserMemberResult.member: One of specified input
        members.
    :ivar paper.AddPaperDocUserMemberResult.result: The outcome of the action on
        this member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member=..., result=...) -> None:
        ...
    
    member = ...
    result = ...


AddPaperDocUserMemberResult_validator = ...
class AddPaperDocUserResult(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.AddPaperDocUserResult.success: User was successfully added to
        the Paper doc.
    :ivar paper.AddPaperDocUserResult.unknown_error: Something unexpected
        happened when trying to add the user to the Paper doc.
    :ivar paper.AddPaperDocUserResult.sharing_outside_team_disabled: The Paper
        doc can be shared only with team members.
    :ivar paper.AddPaperDocUserResult.daily_limit_reached: The daily limit of
        how many users can be added to the Paper doc was reached.
    :ivar paper.AddPaperDocUserResult.user_is_owner: Owner's permissions cannot
        be changed.
    :ivar paper.AddPaperDocUserResult.failed_user_data_retrieval: User data
        could not be retrieved. Clients should retry.
    :ivar paper.AddPaperDocUserResult.permission_already_granted: This user
        already has the correct permission to the Paper doc.
    """
    _catch_all = ...
    success = ...
    unknown_error = ...
    sharing_outside_team_disabled = ...
    daily_limit_reached = ...
    user_is_owner = ...
    failed_user_data_retrieval = ...
    permission_already_granted = ...
    other = ...
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_unknown_error(self):
        """
        Check if the union tag is ``unknown_error``.

        :rtype: bool
        """
        ...
    
    def is_sharing_outside_team_disabled(self):
        """
        Check if the union tag is ``sharing_outside_team_disabled``.

        :rtype: bool
        """
        ...
    
    def is_daily_limit_reached(self):
        """
        Check if the union tag is ``daily_limit_reached``.

        :rtype: bool
        """
        ...
    
    def is_user_is_owner(self):
        """
        Check if the union tag is ``user_is_owner``.

        :rtype: bool
        """
        ...
    
    def is_failed_user_data_retrieval(self):
        """
        Check if the union tag is ``failed_user_data_retrieval``.

        :rtype: bool
        """
        ...
    
    def is_permission_already_granted(self):
        """
        Check if the union tag is ``permission_already_granted``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


AddPaperDocUserResult_validator = ...
class Cursor(bb.Struct):
    """
    :ivar paper.Cursor.value: The actual cursor value.
    :ivar paper.Cursor.expiration: Expiration time of ``value``. Some cursors
        might have expiration time assigned. This is a UTC value after which the
        cursor is no longer valid and the API starts returning an error. If
        cursor expires a new one needs to be obtained and pagination needs to be
        restarted. Some cursors might be short-lived some cursors might be
        long-lived. This really depends on the sorting type and order, e.g.: 1.
        on one hand, listing docs created by the user, sorted by the created
        time ascending will have undefinite expiration because the results
        cannot change while the iteration is happening. This cursor would be
        suitable for long term polling. 2. on the other hand, listing docs
        sorted by the last modified time will have a very short expiration as
        docs do get modified very often and the modified time can be changed
        while the iteration is happening thus altering the results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, value=..., expiration=...) -> None:
        ...
    
    value = ...
    expiration = ...


Cursor_validator = ...
class PaperApiBaseError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperApiBaseError.insufficient_permissions: Your account does
        not have permissions to perform this action. This may be due to it only
        having access to Paper as files in the Dropbox filesystem. For more
        information, refer to the `Paper Migration Guide
        <https://www.dropbox.com/lp/developers/reference/paper-migration-guide>`_.
    """
    _catch_all = ...
    insufficient_permissions = ...
    other = ...
    def is_insufficient_permissions(self):
        """
        Check if the union tag is ``insufficient_permissions``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperApiBaseError_validator = ...
class DocLookupError(PaperApiBaseError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.DocLookupError.doc_not_found: The required doc was not found.
    """
    doc_not_found = ...
    def is_doc_not_found(self):
        """
        Check if the union tag is ``doc_not_found``.

        :rtype: bool
        """
        ...
    


DocLookupError_validator = ...
class DocSubscriptionLevel(bb.Union):
    """
    The subscription level of a Paper doc.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.DocSubscriptionLevel.default: No change email messages unless
        you're the creator.
    :ivar paper.DocSubscriptionLevel.ignore: Ignored: Not shown in pad lists or
        activity and no email message is sent.
    :ivar paper.DocSubscriptionLevel.every: Subscribed: Shown in pad lists and
        activity and change email messages are sent.
    :ivar paper.DocSubscriptionLevel.no_email: Unsubscribed: Shown in pad lists,
        but not in activity and no change email messages are sent.
    """
    _catch_all = ...
    default = ...
    ignore = ...
    every = ...
    no_email = ...
    def is_default(self):
        """
        Check if the union tag is ``default``.

        :rtype: bool
        """
        ...
    
    def is_ignore(self):
        """
        Check if the union tag is ``ignore``.

        :rtype: bool
        """
        ...
    
    def is_every(self):
        """
        Check if the union tag is ``every``.

        :rtype: bool
        """
        ...
    
    def is_no_email(self):
        """
        Check if the union tag is ``no_email``.

        :rtype: bool
        """
        ...
    


DocSubscriptionLevel_validator = ...
class ExportFormat(bb.Union):
    """
    The desired export format of the Paper doc.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ExportFormat.html: The HTML export format.
    :ivar paper.ExportFormat.markdown: The markdown export format.
    """
    _catch_all = ...
    html = ...
    markdown = ...
    other = ...
    def is_html(self):
        """
        Check if the union tag is ``html``.

        :rtype: bool
        """
        ...
    
    def is_markdown(self):
        """
        Check if the union tag is ``markdown``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ExportFormat_validator = ...
class Folder(bb.Struct):
    """
    Data structure representing a Paper folder.

    :ivar paper.Folder.id: Paper folder ID. This ID uniquely identifies the
        folder.
    :ivar paper.Folder.name: Paper folder name.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., name=...) -> None:
        ...
    
    id = ...
    name = ...


Folder_validator = ...
class FolderSharingPolicyType(bb.Union):
    """
    The sharing policy of a Paper folder. The sharing policy of subfolders is
    inherited from the root folder.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.FolderSharingPolicyType.team: Everyone in your team and anyone
        directly invited can access this folder.
    :ivar paper.FolderSharingPolicyType.invite_only: Only people directly
        invited can access this folder.
    """
    _catch_all = ...
    team = ...
    invite_only = ...
    def is_team(self):
        """
        Check if the union tag is ``team``.

        :rtype: bool
        """
        ...
    
    def is_invite_only(self):
        """
        Check if the union tag is ``invite_only``.

        :rtype: bool
        """
        ...
    


FolderSharingPolicyType_validator = ...
class FolderSubscriptionLevel(bb.Union):
    """
    The subscription level of a Paper folder.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.FolderSubscriptionLevel.none: Not shown in activity, no email
        messages.
    :ivar paper.FolderSubscriptionLevel.activity_only: Shown in activity, no
        email messages.
    :ivar paper.FolderSubscriptionLevel.daily_emails: Shown in activity, daily
        email messages.
    :ivar paper.FolderSubscriptionLevel.weekly_emails: Shown in activity, weekly
        email messages.
    """
    _catch_all = ...
    none = ...
    activity_only = ...
    daily_emails = ...
    weekly_emails = ...
    def is_none(self):
        """
        Check if the union tag is ``none``.

        :rtype: bool
        """
        ...
    
    def is_activity_only(self):
        """
        Check if the union tag is ``activity_only``.

        :rtype: bool
        """
        ...
    
    def is_daily_emails(self):
        """
        Check if the union tag is ``daily_emails``.

        :rtype: bool
        """
        ...
    
    def is_weekly_emails(self):
        """
        Check if the union tag is ``weekly_emails``.

        :rtype: bool
        """
        ...
    


FolderSubscriptionLevel_validator = ...
class FoldersContainingPaperDoc(bb.Struct):
    """
    Metadata about Paper folders containing the specififed Paper doc.

    :ivar paper.FoldersContainingPaperDoc.folder_sharing_policy_type: The
        sharing policy of the folder containing the Paper doc.
    :ivar paper.FoldersContainingPaperDoc.folders: The folder path. If present
        the first folder is the root folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, folder_sharing_policy_type=..., folders=...) -> None:
        ...
    
    folder_sharing_policy_type = ...
    folders = ...


FoldersContainingPaperDoc_validator = ...
class ImportFormat(bb.Union):
    """
    The import format of the incoming data.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ImportFormat.html: The provided data is interpreted as standard
        HTML.
    :ivar paper.ImportFormat.markdown: The provided data is interpreted as
        markdown. The first line of the provided document will be used as the
        doc title.
    :ivar paper.ImportFormat.plain_text: The provided data is interpreted as
        plain text. The first line of the provided document will be used as the
        doc title.
    """
    _catch_all = ...
    html = ...
    markdown = ...
    plain_text = ...
    other = ...
    def is_html(self):
        """
        Check if the union tag is ``html``.

        :rtype: bool
        """
        ...
    
    def is_markdown(self):
        """
        Check if the union tag is ``markdown``.

        :rtype: bool
        """
        ...
    
    def is_plain_text(self):
        """
        Check if the union tag is ``plain_text``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ImportFormat_validator = ...
class InviteeInfoWithPermissionLevel(bb.Struct):
    """
    :ivar paper.InviteeInfoWithPermissionLevel.invitee: Email address invited to
        the Paper doc.
    :ivar paper.InviteeInfoWithPermissionLevel.permission_level: Permission
        level for the invitee.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, invitee=..., permission_level=...) -> None:
        ...
    
    invitee = ...
    permission_level = ...


InviteeInfoWithPermissionLevel_validator = ...
class ListDocsCursorError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def cursor_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``cursor_error`` tag with
        value ``val``.

        :param PaperApiCursorError val:
        :rtype: ListDocsCursorError
        """
        ...
    
    def is_cursor_error(self):
        """
        Check if the union tag is ``cursor_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_cursor_error(self): # -> None:
        """
        Only call this if :meth:`is_cursor_error` is true.

        :rtype: PaperApiCursorError
        """
        ...
    


ListDocsCursorError_validator = ...
class ListPaperDocsArgs(bb.Struct):
    """
    :ivar paper.ListPaperDocsArgs.filter_by: Allows user to specify how the
        Paper docs should be filtered.
    :ivar paper.ListPaperDocsArgs.sort_by: Allows user to specify how the Paper
        docs should be sorted.
    :ivar paper.ListPaperDocsArgs.sort_order: Allows user to specify the sort
        order of the result.
    :ivar paper.ListPaperDocsArgs.limit: Size limit per batch. The maximum
        number of docs that can be retrieved per batch is 1000. Higher value
        results in invalid arguments error.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, filter_by=..., sort_by=..., sort_order=..., limit=...) -> None:
        ...
    
    filter_by = ...
    sort_by = ...
    sort_order = ...
    limit = ...


ListPaperDocsArgs_validator = ...
class ListPaperDocsContinueArgs(bb.Struct):
    """
    :ivar paper.ListPaperDocsContinueArgs.cursor: The cursor obtained from
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list` or
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list_continue`. Allows
        for pagination.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ListPaperDocsContinueArgs_validator = ...
class ListPaperDocsFilterBy(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ListPaperDocsFilterBy.docs_accessed: Fetches all Paper doc IDs
        that the user has ever accessed.
    :ivar paper.ListPaperDocsFilterBy.docs_created: Fetches only the Paper doc
        IDs that the user has created.
    """
    _catch_all = ...
    docs_accessed = ...
    docs_created = ...
    other = ...
    def is_docs_accessed(self):
        """
        Check if the union tag is ``docs_accessed``.

        :rtype: bool
        """
        ...
    
    def is_docs_created(self):
        """
        Check if the union tag is ``docs_created``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListPaperDocsFilterBy_validator = ...
class ListPaperDocsResponse(bb.Struct):
    """
    :ivar paper.ListPaperDocsResponse.doc_ids: The list of Paper doc IDs that
        can be used to access the given Paper docs or supplied to other API
        methods. The list is sorted in the order specified by the initial call
        to :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list`.
    :ivar paper.ListPaperDocsResponse.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list_continue` to
        paginate through all files. The cursor preserves all properties as
        specified in the original call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list`.
    :ivar paper.ListPaperDocsResponse.has_more: Will be set to True if a
        subsequent call with the provided cursor to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list_continue` returns
        immediately with some results. If set to False please allow some delay
        before making another call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_list_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_ids=..., cursor=..., has_more=...) -> None:
        ...
    
    doc_ids = ...
    cursor = ...
    has_more = ...


ListPaperDocsResponse_validator = ...
class ListPaperDocsSortBy(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ListPaperDocsSortBy.accessed: Sorts the Paper docs by the time
        they were last accessed.
    :ivar paper.ListPaperDocsSortBy.modified: Sorts the Paper docs by the time
        they were last modified.
    :ivar paper.ListPaperDocsSortBy.created: Sorts the Paper docs by the
        creation time.
    """
    _catch_all = ...
    accessed = ...
    modified = ...
    created = ...
    other = ...
    def is_accessed(self):
        """
        Check if the union tag is ``accessed``.

        :rtype: bool
        """
        ...
    
    def is_modified(self):
        """
        Check if the union tag is ``modified``.

        :rtype: bool
        """
        ...
    
    def is_created(self):
        """
        Check if the union tag is ``created``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListPaperDocsSortBy_validator = ...
class ListPaperDocsSortOrder(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ListPaperDocsSortOrder.ascending: Sorts the search result in
        ascending order.
    :ivar paper.ListPaperDocsSortOrder.descending: Sorts the search result in
        descending order.
    """
    _catch_all = ...
    ascending = ...
    descending = ...
    other = ...
    def is_ascending(self):
        """
        Check if the union tag is ``ascending``.

        :rtype: bool
        """
        ...
    
    def is_descending(self):
        """
        Check if the union tag is ``descending``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListPaperDocsSortOrder_validator = ...
class ListUsersCursorError(PaperApiBaseError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.ListUsersCursorError.doc_not_found: The required doc was not
        found.
    """
    doc_not_found = ...
    @classmethod
    def cursor_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``cursor_error`` tag with
        value ``val``.

        :param PaperApiCursorError val:
        :rtype: ListUsersCursorError
        """
        ...
    
    def is_doc_not_found(self):
        """
        Check if the union tag is ``doc_not_found``.

        :rtype: bool
        """
        ...
    
    def is_cursor_error(self):
        """
        Check if the union tag is ``cursor_error``.

        :rtype: bool
        """
        ...
    
    def get_cursor_error(self): # -> None:
        """
        Only call this if :meth:`is_cursor_error` is true.

        :rtype: PaperApiCursorError
        """
        ...
    


ListUsersCursorError_validator = ...
class ListUsersOnFolderArgs(RefPaperDoc):
    """
    :ivar paper.ListUsersOnFolderArgs.limit: Size limit per batch. The maximum
        number of users that can be retrieved per batch is 1000. Higher value
        results in invalid arguments error.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., limit=...) -> None:
        ...
    
    limit = ...


ListUsersOnFolderArgs_validator = ...
class ListUsersOnFolderContinueArgs(RefPaperDoc):
    """
    :ivar paper.ListUsersOnFolderContinueArgs.cursor: The cursor obtained from
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list` or
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list_continue`.
        Allows for pagination.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., cursor=...) -> None:
        ...
    
    cursor = ...


ListUsersOnFolderContinueArgs_validator = ...
class ListUsersOnFolderResponse(bb.Struct):
    """
    :ivar paper.ListUsersOnFolderResponse.invitees: List of email addresses that
        are invited on the Paper folder.
    :ivar paper.ListUsersOnFolderResponse.users: List of users that are invited
        on the Paper folder.
    :ivar paper.ListUsersOnFolderResponse.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list_continue`
        to paginate through all users. The cursor preserves all properties as
        specified in the original call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list`.
    :ivar paper.ListUsersOnFolderResponse.has_more: Will be set to True if a
        subsequent call with the provided cursor to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list_continue`
        returns immediately with some results. If set to False please allow some
        delay before making another call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_folder_users_list_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, invitees=..., users=..., cursor=..., has_more=...) -> None:
        ...
    
    invitees = ...
    users = ...
    cursor = ...
    has_more = ...


ListUsersOnFolderResponse_validator = ...
class ListUsersOnPaperDocArgs(RefPaperDoc):
    """
    :ivar paper.ListUsersOnPaperDocArgs.limit: Size limit per batch. The maximum
        number of users that can be retrieved per batch is 1000. Higher value
        results in invalid arguments error.
    :ivar paper.ListUsersOnPaperDocArgs.filter_by: Specify this attribute if you
        want to obtain users that have already accessed the Paper doc.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., limit=..., filter_by=...) -> None:
        ...
    
    limit = ...
    filter_by = ...


ListUsersOnPaperDocArgs_validator = ...
class ListUsersOnPaperDocContinueArgs(RefPaperDoc):
    """
    :ivar paper.ListUsersOnPaperDocContinueArgs.cursor: The cursor obtained from
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list` or
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list_continue`.
        Allows for pagination.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., cursor=...) -> None:
        ...
    
    cursor = ...


ListUsersOnPaperDocContinueArgs_validator = ...
class ListUsersOnPaperDocResponse(bb.Struct):
    """
    :ivar paper.ListUsersOnPaperDocResponse.invitees: List of email addresses
        with their respective permission levels that are invited on the Paper
        doc.
    :ivar paper.ListUsersOnPaperDocResponse.users: List of users with their
        respective permission levels that are invited on the Paper folder.
    :ivar paper.ListUsersOnPaperDocResponse.doc_owner: The Paper doc owner. This
        field is populated on every single response.
    :ivar paper.ListUsersOnPaperDocResponse.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list_continue` to
        paginate through all users. The cursor preserves all properties as
        specified in the original call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list`.
    :ivar paper.ListUsersOnPaperDocResponse.has_more: Will be set to True if a
        subsequent call with the provided cursor to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list_continue`
        returns immediately with some results. If set to False please allow some
        delay before making another call to
        :meth:`dropbox.dropbox_client.Dropbox.paper_docs_users_list_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, invitees=..., users=..., doc_owner=..., cursor=..., has_more=...) -> None:
        ...
    
    invitees = ...
    users = ...
    doc_owner = ...
    cursor = ...
    has_more = ...


ListUsersOnPaperDocResponse_validator = ...
class PaperApiCursorError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperApiCursorError.expired_cursor: The provided cursor is
        expired.
    :ivar paper.PaperApiCursorError.invalid_cursor: The provided cursor is
        invalid.
    :ivar paper.PaperApiCursorError.wrong_user_in_cursor: The provided cursor
        contains invalid user.
    :ivar paper.PaperApiCursorError.reset: Indicates that the cursor has been
        invalidated. Call the corresponding non-continue endpoint to obtain a
        new cursor.
    """
    _catch_all = ...
    expired_cursor = ...
    invalid_cursor = ...
    wrong_user_in_cursor = ...
    reset = ...
    other = ...
    def is_expired_cursor(self):
        """
        Check if the union tag is ``expired_cursor``.

        :rtype: bool
        """
        ...
    
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_wrong_user_in_cursor(self):
        """
        Check if the union tag is ``wrong_user_in_cursor``.

        :rtype: bool
        """
        ...
    
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperApiCursorError_validator = ...
class PaperDocCreateArgs(bb.Struct):
    """
    :ivar paper.PaperDocCreateArgs.parent_folder_id: The Paper folder ID where
        the Paper document should be created. The API user has to have write
        access to this folder or error is thrown.
    :ivar paper.PaperDocCreateArgs.import_format: The format of provided data.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, import_format=..., parent_folder_id=...) -> None:
        ...
    
    parent_folder_id = ...
    import_format = ...


PaperDocCreateArgs_validator = ...
class PaperDocCreateError(PaperApiBaseError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperDocCreateError.content_malformed: The provided content was
        malformed and cannot be imported to Paper.
    :ivar paper.PaperDocCreateError.folder_not_found: The specified Paper folder
        is cannot be found.
    :ivar paper.PaperDocCreateError.doc_length_exceeded: The newly created Paper
        doc would be too large. Please split the content into multiple docs.
    :ivar paper.PaperDocCreateError.image_size_exceeded: The imported document
        contains an image that is too large. The current limit is 1MB. This only
        applies to HTML with data URI.
    """
    content_malformed = ...
    folder_not_found = ...
    doc_length_exceeded = ...
    image_size_exceeded = ...
    def is_content_malformed(self):
        """
        Check if the union tag is ``content_malformed``.

        :rtype: bool
        """
        ...
    
    def is_folder_not_found(self):
        """
        Check if the union tag is ``folder_not_found``.

        :rtype: bool
        """
        ...
    
    def is_doc_length_exceeded(self):
        """
        Check if the union tag is ``doc_length_exceeded``.

        :rtype: bool
        """
        ...
    
    def is_image_size_exceeded(self):
        """
        Check if the union tag is ``image_size_exceeded``.

        :rtype: bool
        """
        ...
    


PaperDocCreateError_validator = ...
class PaperDocCreateUpdateResult(bb.Struct):
    """
    :ivar paper.PaperDocCreateUpdateResult.doc_id: Doc ID of the newly created
        doc.
    :ivar paper.PaperDocCreateUpdateResult.revision: The Paper doc revision.
        Simply an ever increasing number.
    :ivar paper.PaperDocCreateUpdateResult.title: The Paper doc title.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., revision=..., title=...) -> None:
        ...
    
    doc_id = ...
    revision = ...
    title = ...


PaperDocCreateUpdateResult_validator = ...
class PaperDocExport(RefPaperDoc):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., export_format=...) -> None:
        ...
    
    export_format = ...


PaperDocExport_validator = ...
class PaperDocExportResult(bb.Struct):
    """
    :ivar paper.PaperDocExportResult.owner: The Paper doc owner's email address.
    :ivar paper.PaperDocExportResult.title: The Paper doc title.
    :ivar paper.PaperDocExportResult.revision: The Paper doc revision. Simply an
        ever increasing number.
    :ivar paper.PaperDocExportResult.mime_type: MIME type of the export. This
        corresponds to :class:`ExportFormat` specified in the request.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, owner=..., title=..., revision=..., mime_type=...) -> None:
        ...
    
    owner = ...
    title = ...
    revision = ...
    mime_type = ...


PaperDocExportResult_validator = ...
class PaperDocPermissionLevel(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperDocPermissionLevel.edit: User will be granted edit
        permissions.
    :ivar paper.PaperDocPermissionLevel.view_and_comment: User will be granted
        view and comment permissions.
    """
    _catch_all = ...
    edit = ...
    view_and_comment = ...
    other = ...
    def is_edit(self):
        """
        Check if the union tag is ``edit``.

        :rtype: bool
        """
        ...
    
    def is_view_and_comment(self):
        """
        Check if the union tag is ``view_and_comment``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperDocPermissionLevel_validator = ...
class PaperDocSharingPolicy(RefPaperDoc):
    """
    :ivar paper.PaperDocSharingPolicy.sharing_policy: The default sharing policy
        to be set for the Paper doc.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., sharing_policy=...) -> None:
        ...
    
    sharing_policy = ...


PaperDocSharingPolicy_validator = ...
class PaperDocUpdateArgs(RefPaperDoc):
    """
    :ivar paper.PaperDocUpdateArgs.doc_update_policy: The policy used for the
        current update call.
    :ivar paper.PaperDocUpdateArgs.revision: The latest doc revision. This value
        must match the head revision or an error code will be returned. This is
        to prevent colliding writes.
    :ivar paper.PaperDocUpdateArgs.import_format: The format of provided data.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., doc_update_policy=..., revision=..., import_format=...) -> None:
        ...
    
    doc_update_policy = ...
    revision = ...
    import_format = ...


PaperDocUpdateArgs_validator = ...
class PaperDocUpdateError(DocLookupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperDocUpdateError.content_malformed: The provided content was
        malformed and cannot be imported to Paper.
    :ivar paper.PaperDocUpdateError.revision_mismatch: The provided revision
        does not match the document head.
    :ivar paper.PaperDocUpdateError.doc_length_exceeded: The newly created Paper
        doc would be too large, split the content into multiple docs.
    :ivar paper.PaperDocUpdateError.image_size_exceeded: The imported document
        contains an image that is too large. The current limit is 1MB. This only
        applies to HTML with data URI.
    :ivar paper.PaperDocUpdateError.doc_archived: This operation is not allowed
        on archived Paper docs.
    :ivar paper.PaperDocUpdateError.doc_deleted: This operation is not allowed
        on deleted Paper docs.
    """
    content_malformed = ...
    revision_mismatch = ...
    doc_length_exceeded = ...
    image_size_exceeded = ...
    doc_archived = ...
    doc_deleted = ...
    def is_content_malformed(self):
        """
        Check if the union tag is ``content_malformed``.

        :rtype: bool
        """
        ...
    
    def is_revision_mismatch(self):
        """
        Check if the union tag is ``revision_mismatch``.

        :rtype: bool
        """
        ...
    
    def is_doc_length_exceeded(self):
        """
        Check if the union tag is ``doc_length_exceeded``.

        :rtype: bool
        """
        ...
    
    def is_image_size_exceeded(self):
        """
        Check if the union tag is ``image_size_exceeded``.

        :rtype: bool
        """
        ...
    
    def is_doc_archived(self):
        """
        Check if the union tag is ``doc_archived``.

        :rtype: bool
        """
        ...
    
    def is_doc_deleted(self):
        """
        Check if the union tag is ``doc_deleted``.

        :rtype: bool
        """
        ...
    


PaperDocUpdateError_validator = ...
class PaperDocUpdatePolicy(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperDocUpdatePolicy.append: The content will be appended to the
        doc.
    :ivar paper.PaperDocUpdatePolicy.prepend: The content will be prepended to
        the doc. The doc title will not be affected.
    :ivar paper.PaperDocUpdatePolicy.overwrite_all: The document will be
        overwitten at the head with the provided content.
    """
    _catch_all = ...
    append = ...
    prepend = ...
    overwrite_all = ...
    other = ...
    def is_append(self):
        """
        Check if the union tag is ``append``.

        :rtype: bool
        """
        ...
    
    def is_prepend(self):
        """
        Check if the union tag is ``prepend``.

        :rtype: bool
        """
        ...
    
    def is_overwrite_all(self):
        """
        Check if the union tag is ``overwrite_all``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


PaperDocUpdatePolicy_validator = ...
class PaperFolderCreateArg(bb.Struct):
    """
    :ivar paper.PaperFolderCreateArg.name: The name of the new Paper folder.
    :ivar paper.PaperFolderCreateArg.parent_folder_id: The encrypted Paper
        folder Id where the new Paper folder should be created. The API user has
        to have write access to this folder or error is thrown. If not supplied,
        the new folder will be created at top level.
    :ivar paper.PaperFolderCreateArg.is_team_folder: Whether the folder to be
        created should be a team folder. This value will be ignored if
        parent_folder_id is supplied, as the new folder will inherit the type
        (private or team folder) from its parent. We will by default create a
        top-level private folder if both parent_folder_id and is_team_folder are
        not supplied.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., parent_folder_id=..., is_team_folder=...) -> None:
        ...
    
    name = ...
    parent_folder_id = ...
    is_team_folder = ...


PaperFolderCreateArg_validator = ...
class PaperFolderCreateError(PaperApiBaseError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.PaperFolderCreateError.folder_not_found: The specified parent
        Paper folder cannot be found.
    :ivar paper.PaperFolderCreateError.invalid_folder_id: The folder id cannot
        be decrypted to valid folder id.
    """
    folder_not_found = ...
    invalid_folder_id = ...
    def is_folder_not_found(self):
        """
        Check if the union tag is ``folder_not_found``.

        :rtype: bool
        """
        ...
    
    def is_invalid_folder_id(self):
        """
        Check if the union tag is ``invalid_folder_id``.

        :rtype: bool
        """
        ...
    


PaperFolderCreateError_validator = ...
class PaperFolderCreateResult(bb.Struct):
    """
    :ivar paper.PaperFolderCreateResult.folder_id: Folder ID of the newly
        created folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, folder_id=...) -> None:
        ...
    
    folder_id = ...


PaperFolderCreateResult_validator = ...
class RemovePaperDocUser(RefPaperDoc):
    """
    :ivar paper.RemovePaperDocUser.member: User which should be removed from the
        Paper doc. Specify only email address or Dropbox account ID.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, doc_id=..., member=...) -> None:
        ...
    
    member = ...


RemovePaperDocUser_validator = ...
class SharingPolicy(bb.Struct):
    """
    Sharing policy of Paper doc.

    :ivar paper.SharingPolicy.public_sharing_policy: This value applies to the
        non-team members.
    :ivar paper.SharingPolicy.team_sharing_policy: This value applies to the
        team members only. The value is null for all personal accounts.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, public_sharing_policy=..., team_sharing_policy=...) -> None:
        ...
    
    public_sharing_policy = ...
    team_sharing_policy = ...


SharingPolicy_validator = ...
class SharingTeamPolicyType(bb.Union):
    """
    The sharing policy type of the Paper doc.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.SharingTeamPolicyType.people_with_link_can_edit: Users who have
        a link to this doc can edit it.
    :ivar paper.SharingTeamPolicyType.people_with_link_can_view_and_comment:
        Users who have a link to this doc can view and comment on it.
    :ivar paper.SharingTeamPolicyType.invite_only: Users must be explicitly
        invited to this doc.
    """
    _catch_all = ...
    people_with_link_can_edit = ...
    people_with_link_can_view_and_comment = ...
    invite_only = ...
    def is_people_with_link_can_edit(self):
        """
        Check if the union tag is ``people_with_link_can_edit``.

        :rtype: bool
        """
        ...
    
    def is_people_with_link_can_view_and_comment(self):
        """
        Check if the union tag is ``people_with_link_can_view_and_comment``.

        :rtype: bool
        """
        ...
    
    def is_invite_only(self):
        """
        Check if the union tag is ``invite_only``.

        :rtype: bool
        """
        ...
    


SharingTeamPolicyType_validator = ...
class SharingPublicPolicyType(SharingTeamPolicyType):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.SharingPublicPolicyType.disabled: Value used to indicate that
        doc sharing is enabled only within team.
    """
    disabled = ...
    def is_disabled(self):
        """
        Check if the union tag is ``disabled``.

        :rtype: bool
        """
        ...
    


SharingPublicPolicyType_validator = ...
class UserInfoWithPermissionLevel(bb.Struct):
    """
    :ivar paper.UserInfoWithPermissionLevel.user: User shared on the Paper doc.
    :ivar paper.UserInfoWithPermissionLevel.permission_level: Permission level
        for the user.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., permission_level=...) -> None:
        ...
    
    user = ...
    permission_level = ...


UserInfoWithPermissionLevel_validator = ...
class UserOnPaperDocFilter(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar paper.UserOnPaperDocFilter.visited: all users who have visited the
        Paper doc.
    :ivar paper.UserOnPaperDocFilter.shared: All uses who are shared on the
        Paper doc. This includes all users who have visited the Paper doc as
        well as those who have not.
    """
    _catch_all = ...
    visited = ...
    shared = ...
    other = ...
    def is_visited(self):
        """
        Check if the union tag is ``visited``.

        :rtype: bool
        """
        ...
    
    def is_shared(self):
        """
        Check if the union tag is ``shared``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


UserOnPaperDocFilter_validator = ...
PaperDocId_validator = ...
docs_archive = ...
docs_create = ...
docs_download = ...
docs_folder_users_list = ...
docs_folder_users_list_continue = ...
docs_get_folder_info = ...
docs_list = ...
docs_list_continue = ...
docs_permanently_delete = ...
docs_sharing_policy_get = ...
docs_sharing_policy_set = ...
docs_update = ...
docs_users_add = ...
docs_users_list = ...
docs_users_list_continue = ...
docs_users_remove = ...
folders_create = ...
ROUTES = ...
