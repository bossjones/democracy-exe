"""
This type stub file was generated by pyright.
"""

from stone.backends.python_rsrc import stone_base as bb
from dropbox import async_, secondary_emails, team_common, users

class DeviceSession(bb.Struct):
    """
    :ivar team.DeviceSession.session_id: The session id.
    :ivar team.DeviceSession.ip_address: The IP address of the last activity
        from this session.
    :ivar team.DeviceSession.country: The country from which the last activity
        from this session was made.
    :ivar team.DeviceSession.created: The time this session was created.
    :ivar team.DeviceSession.updated: The time of the last activity from this
        session.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., ip_address=..., country=..., created=..., updated=...) -> None:
        ...
    
    session_id = ...
    ip_address = ...
    country = ...
    created = ...
    updated = ...


DeviceSession_validator = ...
class ActiveWebSession(DeviceSession):
    """
    Information on active web sessions.

    :ivar team.ActiveWebSession.user_agent: Information on the hosting device.
    :ivar team.ActiveWebSession.os: Information on the hosting operating system.
    :ivar team.ActiveWebSession.browser: Information on the browser used for
        this web session.
    :ivar team.ActiveWebSession.expires: The time this session expires.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., user_agent=..., os=..., browser=..., ip_address=..., country=..., created=..., updated=..., expires=...) -> None:
        ...
    
    user_agent = ...
    os = ...
    browser = ...
    expires = ...


ActiveWebSession_validator = ...
class AddSecondaryEmailResult(bb.Union):
    """
    Result of trying to add a secondary email to a user. 'success' is the only
    value indicating that a secondary email was successfully added to a user.
    The other values explain the type of error that occurred, and include the
    email for which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar secondary_emails.SecondaryEmail team.AddSecondaryEmailResult.success:
        Describes a secondary email that was successfully added to a user.
    :ivar str team.AddSecondaryEmailResult.unavailable: Secondary email is not
        available to be claimed by the user.
    :ivar str team.AddSecondaryEmailResult.already_pending: Secondary email is
        already a pending email for the user.
    :ivar str team.AddSecondaryEmailResult.already_owned_by_user: Secondary
        email is already a verified email for the user.
    :ivar str team.AddSecondaryEmailResult.reached_limit: User already has the
        maximum number of secondary emails allowed.
    :ivar str team.AddSecondaryEmailResult.transient_error: A transient error
        occurred. Please try again later.
    :ivar str team.AddSecondaryEmailResult.too_many_updates: An error occurred
        due to conflicting updates. Please try again later.
    :ivar str team.AddSecondaryEmailResult.unknown_error: An unknown error
        occurred.
    :ivar str team.AddSecondaryEmailResult.rate_limited: Too many emails are
        being sent to this email address. Please try again later.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param secondary_emails.SecondaryEmail val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def unavailable(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``unavailable`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def already_pending(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``already_pending`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def already_owned_by_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``already_owned_by_user``
        tag with value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def reached_limit(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``reached_limit`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def transient_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``transient_error`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def too_many_updates(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``too_many_updates`` tag
        with value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def unknown_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``unknown_error`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    @classmethod
    def rate_limited(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``rate_limited`` tag with
        value ``val``.

        :param str val:
        :rtype: AddSecondaryEmailResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_unavailable(self):
        """
        Check if the union tag is ``unavailable``.

        :rtype: bool
        """
        ...
    
    def is_already_pending(self):
        """
        Check if the union tag is ``already_pending``.

        :rtype: bool
        """
        ...
    
    def is_already_owned_by_user(self):
        """
        Check if the union tag is ``already_owned_by_user``.

        :rtype: bool
        """
        ...
    
    def is_reached_limit(self):
        """
        Check if the union tag is ``reached_limit``.

        :rtype: bool
        """
        ...
    
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    
    def is_too_many_updates(self):
        """
        Check if the union tag is ``too_many_updates``.

        :rtype: bool
        """
        ...
    
    def is_unknown_error(self):
        """
        Check if the union tag is ``unknown_error``.

        :rtype: bool
        """
        ...
    
    def is_rate_limited(self):
        """
        Check if the union tag is ``rate_limited``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a secondary email that was successfully added to a user.

        Only call this if :meth:`is_success` is true.

        :rtype: secondary_emails.SecondaryEmail
        """
        ...
    
    def get_unavailable(self): # -> None:
        """
        Secondary email is not available to be claimed by the user.

        Only call this if :meth:`is_unavailable` is true.

        :rtype: str
        """
        ...
    
    def get_already_pending(self): # -> None:
        """
        Secondary email is already a pending email for the user.

        Only call this if :meth:`is_already_pending` is true.

        :rtype: str
        """
        ...
    
    def get_already_owned_by_user(self): # -> None:
        """
        Secondary email is already a verified email for the user.

        Only call this if :meth:`is_already_owned_by_user` is true.

        :rtype: str
        """
        ...
    
    def get_reached_limit(self): # -> None:
        """
        User already has the maximum number of secondary emails allowed.

        Only call this if :meth:`is_reached_limit` is true.

        :rtype: str
        """
        ...
    
    def get_transient_error(self): # -> None:
        """
        A transient error occurred. Please try again later.

        Only call this if :meth:`is_transient_error` is true.

        :rtype: str
        """
        ...
    
    def get_too_many_updates(self): # -> None:
        """
        An error occurred due to conflicting updates. Please try again later.

        Only call this if :meth:`is_too_many_updates` is true.

        :rtype: str
        """
        ...
    
    def get_unknown_error(self): # -> None:
        """
        An unknown error occurred.

        Only call this if :meth:`is_unknown_error` is true.

        :rtype: str
        """
        ...
    
    def get_rate_limited(self): # -> None:
        """
        Too many emails are being sent to this email address. Please try again
        later.

        Only call this if :meth:`is_rate_limited` is true.

        :rtype: str
        """
        ...
    


AddSecondaryEmailResult_validator = ...
class AddSecondaryEmailsArg(bb.Struct):
    """
    :ivar team.AddSecondaryEmailsArg.new_secondary_emails: List of users and
        secondary emails to add.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, new_secondary_emails=...) -> None:
        ...
    
    new_secondary_emails = ...


AddSecondaryEmailsArg_validator = ...
class AddSecondaryEmailsError(bb.Union):
    """
    Error returned when adding secondary emails fails.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.AddSecondaryEmailsError.secondary_emails_disabled: Secondary
        emails are disabled for the team.
    :ivar team.AddSecondaryEmailsError.too_many_emails: A maximum of 20
        secondary emails can be added in a single call.
    """
    _catch_all = ...
    secondary_emails_disabled = ...
    too_many_emails = ...
    other = ...
    def is_secondary_emails_disabled(self):
        """
        Check if the union tag is ``secondary_emails_disabled``.

        :rtype: bool
        """
        ...
    
    def is_too_many_emails(self):
        """
        Check if the union tag is ``too_many_emails``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


AddSecondaryEmailsError_validator = ...
class AddSecondaryEmailsResult(bb.Struct):
    """
    :ivar team.AddSecondaryEmailsResult.results: List of users and secondary
        email results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, results=...) -> None:
        ...
    
    results = ...


AddSecondaryEmailsResult_validator = ...
class AdminTier(bb.Union):
    """
    Describes which team-related admin permissions a user has.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.AdminTier.team_admin: User is an administrator of the team - has
        all permissions.
    :ivar team.AdminTier.user_management_admin: User can do most user
        provisioning, de-provisioning and management.
    :ivar team.AdminTier.support_admin: User can do a limited set of common
        support tasks for existing users. Note: Dropbox is adding new types of
        admin roles; these may display as support_admin.
    :ivar team.AdminTier.member_only: User is not an admin of the team.
    """
    _catch_all = ...
    team_admin = ...
    user_management_admin = ...
    support_admin = ...
    member_only = ...
    def is_team_admin(self):
        """
        Check if the union tag is ``team_admin``.

        :rtype: bool
        """
        ...
    
    def is_user_management_admin(self):
        """
        Check if the union tag is ``user_management_admin``.

        :rtype: bool
        """
        ...
    
    def is_support_admin(self):
        """
        Check if the union tag is ``support_admin``.

        :rtype: bool
        """
        ...
    
    def is_member_only(self):
        """
        Check if the union tag is ``member_only``.

        :rtype: bool
        """
        ...
    


AdminTier_validator = ...
class ApiApp(bb.Struct):
    """
    Information on linked third party applications.

    :ivar team.ApiApp.app_id: The application unique id.
    :ivar team.ApiApp.app_name: The application name.
    :ivar team.ApiApp.publisher: The application publisher name.
    :ivar team.ApiApp.publisher_url: The publisher's URL.
    :ivar team.ApiApp.linked: The time this application was linked.
    :ivar team.ApiApp.is_app_folder: Whether the linked application uses a
        dedicated folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, app_id=..., app_name=..., is_app_folder=..., publisher=..., publisher_url=..., linked=...) -> None:
        ...
    
    app_id = ...
    app_name = ...
    publisher = ...
    publisher_url = ...
    linked = ...
    is_app_folder = ...


ApiApp_validator = ...
class BaseDfbReport(bb.Struct):
    """
    Base report structure.

    :ivar team.BaseDfbReport.start_date: First date present in the results as
        'YYYY-MM-DD' or None.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=...) -> None:
        ...
    
    start_date = ...


BaseDfbReport_validator = ...
class BaseTeamFolderError(bb.Union):
    """
    Base error that all errors for existing team folders should extend.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def access_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``access_error`` tag with
        value ``val``.

        :param TeamFolderAccessError val:
        :rtype: BaseTeamFolderError
        """
        ...
    
    @classmethod
    def status_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``status_error`` tag with
        value ``val``.

        :param TeamFolderInvalidStatusError val:
        :rtype: BaseTeamFolderError
        """
        ...
    
    @classmethod
    def team_shared_dropbox_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the
        ``team_shared_dropbox_error`` tag with value ``val``.

        :param TeamFolderTeamSharedDropboxError val:
        :rtype: BaseTeamFolderError
        """
        ...
    
    def is_access_error(self):
        """
        Check if the union tag is ``access_error``.

        :rtype: bool
        """
        ...
    
    def is_status_error(self):
        """
        Check if the union tag is ``status_error``.

        :rtype: bool
        """
        ...
    
    def is_team_shared_dropbox_error(self):
        """
        Check if the union tag is ``team_shared_dropbox_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_access_error(self): # -> None:
        """
        Only call this if :meth:`is_access_error` is true.

        :rtype: TeamFolderAccessError
        """
        ...
    
    def get_status_error(self): # -> None:
        """
        Only call this if :meth:`is_status_error` is true.

        :rtype: TeamFolderInvalidStatusError
        """
        ...
    
    def get_team_shared_dropbox_error(self): # -> None:
        """
        Only call this if :meth:`is_team_shared_dropbox_error` is true.

        :rtype: TeamFolderTeamSharedDropboxError
        """
        ...
    


BaseTeamFolderError_validator = ...
class CustomQuotaError(bb.Union):
    """
    Error returned when getting member custom quota.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.CustomQuotaError.too_many_users: A maximum of 1000 users can be
        set for a single call.
    """
    _catch_all = ...
    too_many_users = ...
    other = ...
    def is_too_many_users(self):
        """
        Check if the union tag is ``too_many_users``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


CustomQuotaError_validator = ...
class CustomQuotaResult(bb.Union):
    """
    User custom quota.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserCustomQuotaResult CustomQuotaResult.success: User's custom quota.
    :ivar UserSelectorArg CustomQuotaResult.invalid_user: Invalid user (not in
        team).
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param UserCustomQuotaResult val:
        :rtype: CustomQuotaResult
        """
        ...
    
    @classmethod
    def invalid_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_user`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: CustomQuotaResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_invalid_user(self):
        """
        Check if the union tag is ``invalid_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        User's custom quota.

        Only call this if :meth:`is_success` is true.

        :rtype: UserCustomQuotaResult
        """
        ...
    
    def get_invalid_user(self): # -> None:
        """
        Invalid user (not in team).

        Only call this if :meth:`is_invalid_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    


CustomQuotaResult_validator = ...
class CustomQuotaUsersArg(bb.Struct):
    """
    :ivar team.CustomQuotaUsersArg.users: List of users.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, users=...) -> None:
        ...
    
    users = ...


CustomQuotaUsersArg_validator = ...
class DateRange(bb.Struct):
    """
    Input arguments that can be provided for most reports.

    :ivar team.DateRange.start_date: Optional starting date (inclusive). If
        start_date is None or too long ago, this field will  be set to 6 months
        ago.
    :ivar team.DateRange.end_date: Optional ending date (exclusive).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=..., end_date=...) -> None:
        ...
    
    start_date = ...
    end_date = ...


DateRange_validator = ...
class DateRangeError(bb.Union):
    """
    Errors that can originate from problems in input arguments to reports.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


DateRangeError_validator = ...
class DeleteSecondaryEmailResult(bb.Union):
    """
    Result of trying to delete a secondary email address. 'success' is the only
    value indicating that a secondary email was successfully deleted. The other
    values explain the type of error that occurred, and include the email for
    which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.DeleteSecondaryEmailResult.success: The secondary email was
        successfully deleted.
    :ivar str team.DeleteSecondaryEmailResult.not_found: The email address was
        not found for the user.
    :ivar str team.DeleteSecondaryEmailResult.cannot_remove_primary: The email
        address is the primary email address of the user, and cannot be removed.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param str val:
        :rtype: DeleteSecondaryEmailResult
        """
        ...
    
    @classmethod
    def not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``not_found`` tag with value
        ``val``.

        :param str val:
        :rtype: DeleteSecondaryEmailResult
        """
        ...
    
    @classmethod
    def cannot_remove_primary(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``cannot_remove_primary``
        tag with value ``val``.

        :param str val:
        :rtype: DeleteSecondaryEmailResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_not_found(self):
        """
        Check if the union tag is ``not_found``.

        :rtype: bool
        """
        ...
    
    def is_cannot_remove_primary(self):
        """
        Check if the union tag is ``cannot_remove_primary``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        The secondary email was successfully deleted.

        Only call this if :meth:`is_success` is true.

        :rtype: str
        """
        ...
    
    def get_not_found(self): # -> None:
        """
        The email address was not found for the user.

        Only call this if :meth:`is_not_found` is true.

        :rtype: str
        """
        ...
    
    def get_cannot_remove_primary(self): # -> None:
        """
        The email address is the primary email address of the user, and cannot
        be removed.

        Only call this if :meth:`is_cannot_remove_primary` is true.

        :rtype: str
        """
        ...
    


DeleteSecondaryEmailResult_validator = ...
class DeleteSecondaryEmailsArg(bb.Struct):
    """
    :ivar team.DeleteSecondaryEmailsArg.emails_to_delete: List of users and
        their secondary emails to delete.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, emails_to_delete=...) -> None:
        ...
    
    emails_to_delete = ...


DeleteSecondaryEmailsArg_validator = ...
class DeleteSecondaryEmailsResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, results=...) -> None:
        ...
    
    results = ...


DeleteSecondaryEmailsResult_validator = ...
class DesktopClientSession(DeviceSession):
    """
    Information about linked Dropbox desktop client sessions.

    :ivar team.DesktopClientSession.host_name: Name of the hosting desktop.
    :ivar team.DesktopClientSession.client_type: The Dropbox desktop client
        type.
    :ivar team.DesktopClientSession.client_version: The Dropbox client version.
    :ivar team.DesktopClientSession.platform: Information on the hosting
        platform.
    :ivar team.DesktopClientSession.is_delete_on_unlink_supported: Whether it's
        possible to delete all of the account files upon unlinking.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., host_name=..., client_type=..., client_version=..., platform=..., is_delete_on_unlink_supported=..., ip_address=..., country=..., created=..., updated=...) -> None:
        ...
    
    host_name = ...
    client_type = ...
    client_version = ...
    platform = ...
    is_delete_on_unlink_supported = ...


DesktopClientSession_validator = ...
class DesktopPlatform(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.DesktopPlatform.windows: Official Windows Dropbox desktop client.
    :ivar team.DesktopPlatform.mac: Official Mac Dropbox desktop client.
    :ivar team.DesktopPlatform.linux: Official Linux Dropbox desktop client.
    """
    _catch_all = ...
    windows = ...
    mac = ...
    linux = ...
    other = ...
    def is_windows(self):
        """
        Check if the union tag is ``windows``.

        :rtype: bool
        """
        ...
    
    def is_mac(self):
        """
        Check if the union tag is ``mac``.

        :rtype: bool
        """
        ...
    
    def is_linux(self):
        """
        Check if the union tag is ``linux``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


DesktopPlatform_validator = ...
class DeviceSessionArg(bb.Struct):
    """
    :ivar team.DeviceSessionArg.session_id: The session id.
    :ivar team.DeviceSessionArg.team_member_id: The unique id of the member
        owning the device.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., team_member_id=...) -> None:
        ...
    
    session_id = ...
    team_member_id = ...


DeviceSessionArg_validator = ...
class DevicesActive(bb.Struct):
    """
    Each of the items is an array of values, one value per day. The value is the
    number of devices active within a time window, ending with that day. If
    there is no data for a day, then the value will be None.

    :ivar team.DevicesActive.windows: Array of number of linked windows
        (desktop) clients with activity.
    :ivar team.DevicesActive.macos: Array of number of linked mac (desktop)
        clients with activity.
    :ivar team.DevicesActive.linux: Array of number of linked linus (desktop)
        clients with activity.
    :ivar team.DevicesActive.ios: Array of number of linked ios devices with
        activity.
    :ivar team.DevicesActive.android: Array of number of linked android devices
        with activity.
    :ivar team.DevicesActive.other: Array of number of other linked devices
        (blackberry, windows phone, etc)  with activity.
    :ivar team.DevicesActive.total: Array of total number of linked clients with
        activity.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, windows=..., macos=..., linux=..., ios=..., android=..., other=..., total=...) -> None:
        ...
    
    windows = ...
    macos = ...
    linux = ...
    ios = ...
    android = ...
    other = ...
    total = ...


DevicesActive_validator = ...
class ExcludedUsersListArg(bb.Struct):
    """
    Excluded users list argument.

    :ivar team.ExcludedUsersListArg.limit: Number of results to return per call.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=...) -> None:
        ...
    
    limit = ...


ExcludedUsersListArg_validator = ...
class ExcludedUsersListContinueArg(bb.Struct):
    """
    Excluded users list continue argument.

    :ivar team.ExcludedUsersListContinueArg.cursor: Indicates from what point to
        get the next set of users.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ExcludedUsersListContinueArg_validator = ...
class ExcludedUsersListContinueError(bb.Union):
    """
    Excluded users list continue error.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ExcludedUsersListContinueError.invalid_cursor: The cursor is
        invalid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ExcludedUsersListContinueError_validator = ...
class ExcludedUsersListError(bb.Union):
    """
    Excluded users list error.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ExcludedUsersListError.list_error: An error occurred.
    """
    _catch_all = ...
    list_error = ...
    other = ...
    def is_list_error(self):
        """
        Check if the union tag is ``list_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ExcludedUsersListError_validator = ...
class ExcludedUsersListResult(bb.Struct):
    """
    Excluded users list result.

    :ivar team.ExcludedUsersListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_member_space_limits_excluded_users_list_continue`
        to obtain additional excluded users.
    :ivar team.ExcludedUsersListResult.has_more: Is true if there are additional
        excluded users that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_member_space_limits_excluded_users_list_continue`
        can retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, users=..., has_more=..., cursor=...) -> None:
        ...
    
    users = ...
    cursor = ...
    has_more = ...


ExcludedUsersListResult_validator = ...
class ExcludedUsersUpdateArg(bb.Struct):
    """
    Argument of excluded users update operation. Should include a list of users
    to add/remove (according to endpoint), Maximum size of the list is 1000
    users.

    :ivar team.ExcludedUsersUpdateArg.users: List of users to be added/removed.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, users=...) -> None:
        ...
    
    users = ...


ExcludedUsersUpdateArg_validator = ...
class ExcludedUsersUpdateError(bb.Union):
    """
    Excluded users update error.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ExcludedUsersUpdateError.users_not_in_team: At least one of the
        users is not part of your team.
    :ivar team.ExcludedUsersUpdateError.too_many_users: A maximum of 1000 users
        for each of addition/removal can be supplied.
    """
    _catch_all = ...
    users_not_in_team = ...
    too_many_users = ...
    other = ...
    def is_users_not_in_team(self):
        """
        Check if the union tag is ``users_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_too_many_users(self):
        """
        Check if the union tag is ``too_many_users``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ExcludedUsersUpdateError_validator = ...
class ExcludedUsersUpdateResult(bb.Struct):
    """
    Excluded users update result.

    :ivar team.ExcludedUsersUpdateResult.status: Update status.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, status=...) -> None:
        ...
    
    status = ...


ExcludedUsersUpdateResult_validator = ...
class ExcludedUsersUpdateStatus(bb.Union):
    """
    Excluded users update operation status.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ExcludedUsersUpdateStatus.success: Update successful.
    """
    _catch_all = ...
    success = ...
    other = ...
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ExcludedUsersUpdateStatus_validator = ...
class Feature(bb.Union):
    """
    A set of features that a Dropbox Business account may support.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.Feature.upload_api_rate_limit: The number of upload API calls
        allowed per month.
    :ivar team.Feature.has_team_shared_dropbox: Does this team have a shared
        team root.
    :ivar team.Feature.has_team_file_events: Does this team have file events.
    :ivar team.Feature.has_team_selective_sync: Does this team have team
        selective sync enabled.
    """
    _catch_all = ...
    upload_api_rate_limit = ...
    has_team_shared_dropbox = ...
    has_team_file_events = ...
    has_team_selective_sync = ...
    other = ...
    def is_upload_api_rate_limit(self):
        """
        Check if the union tag is ``upload_api_rate_limit``.

        :rtype: bool
        """
        ...
    
    def is_has_team_shared_dropbox(self):
        """
        Check if the union tag is ``has_team_shared_dropbox``.

        :rtype: bool
        """
        ...
    
    def is_has_team_file_events(self):
        """
        Check if the union tag is ``has_team_file_events``.

        :rtype: bool
        """
        ...
    
    def is_has_team_selective_sync(self):
        """
        Check if the union tag is ``has_team_selective_sync``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


Feature_validator = ...
class FeatureValue(bb.Union):
    """
    The values correspond to entries in :class:`Feature`. You may get different
    value according to your Dropbox Business plan.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def upload_api_rate_limit(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``upload_api_rate_limit``
        tag with value ``val``.

        :param UploadApiRateLimitValue val:
        :rtype: FeatureValue
        """
        ...
    
    @classmethod
    def has_team_shared_dropbox(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``has_team_shared_dropbox``
        tag with value ``val``.

        :param HasTeamSharedDropboxValue val:
        :rtype: FeatureValue
        """
        ...
    
    @classmethod
    def has_team_file_events(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``has_team_file_events`` tag
        with value ``val``.

        :param HasTeamFileEventsValue val:
        :rtype: FeatureValue
        """
        ...
    
    @classmethod
    def has_team_selective_sync(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``has_team_selective_sync``
        tag with value ``val``.

        :param HasTeamSelectiveSyncValue val:
        :rtype: FeatureValue
        """
        ...
    
    def is_upload_api_rate_limit(self):
        """
        Check if the union tag is ``upload_api_rate_limit``.

        :rtype: bool
        """
        ...
    
    def is_has_team_shared_dropbox(self):
        """
        Check if the union tag is ``has_team_shared_dropbox``.

        :rtype: bool
        """
        ...
    
    def is_has_team_file_events(self):
        """
        Check if the union tag is ``has_team_file_events``.

        :rtype: bool
        """
        ...
    
    def is_has_team_selective_sync(self):
        """
        Check if the union tag is ``has_team_selective_sync``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_upload_api_rate_limit(self): # -> None:
        """
        Only call this if :meth:`is_upload_api_rate_limit` is true.

        :rtype: UploadApiRateLimitValue
        """
        ...
    
    def get_has_team_shared_dropbox(self): # -> None:
        """
        Only call this if :meth:`is_has_team_shared_dropbox` is true.

        :rtype: HasTeamSharedDropboxValue
        """
        ...
    
    def get_has_team_file_events(self): # -> None:
        """
        Only call this if :meth:`is_has_team_file_events` is true.

        :rtype: HasTeamFileEventsValue
        """
        ...
    
    def get_has_team_selective_sync(self): # -> None:
        """
        Only call this if :meth:`is_has_team_selective_sync` is true.

        :rtype: HasTeamSelectiveSyncValue
        """
        ...
    


FeatureValue_validator = ...
class FeaturesGetValuesBatchArg(bb.Struct):
    """
    :ivar team.FeaturesGetValuesBatchArg.features: A list of features in
        :class:`Feature`. If the list is empty, this route will return
        :class:`FeaturesGetValuesBatchError`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, features=...) -> None:
        ...
    
    features = ...


FeaturesGetValuesBatchArg_validator = ...
class FeaturesGetValuesBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.FeaturesGetValuesBatchError.empty_features_list: At least one
        :class:`Feature` must be included in the
        :class:`FeaturesGetValuesBatchArg`.features list.
    """
    _catch_all = ...
    empty_features_list = ...
    other = ...
    def is_empty_features_list(self):
        """
        Check if the union tag is ``empty_features_list``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


FeaturesGetValuesBatchError_validator = ...
class FeaturesGetValuesBatchResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, values=...) -> None:
        ...
    
    values = ...


FeaturesGetValuesBatchResult_validator = ...
class GetActivityReport(BaseDfbReport):
    """
    Activity Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar team.GetActivityReport.adds: Array of total number of adds by team
        members.
    :ivar team.GetActivityReport.edits: Array of number of edits by team
        members. If the same user edits the same file multiple times this is
        counted as a single edit.
    :ivar team.GetActivityReport.deletes: Array of total number of deletes by
        team members.
    :ivar team.GetActivityReport.active_users_28_day: Array of the number of
        users who have been active in the last 28 days.
    :ivar team.GetActivityReport.active_users_7_day: Array of the number of
        users who have been active in the last week.
    :ivar team.GetActivityReport.active_users_1_day: Array of the number of
        users who have been active in the last day.
    :ivar team.GetActivityReport.active_shared_folders_28_day: Array of the
        number of shared folders with some activity in the last 28 days.
    :ivar team.GetActivityReport.active_shared_folders_7_day: Array of the
        number of shared folders with some activity in the last week.
    :ivar team.GetActivityReport.active_shared_folders_1_day: Array of the
        number of shared folders with some activity in the last day.
    :ivar team.GetActivityReport.shared_links_created: Array of the number of
        shared links created.
    :ivar team.GetActivityReport.shared_links_viewed_by_team: Array of the
        number of views by team users to shared links created by the team.
    :ivar team.GetActivityReport.shared_links_viewed_by_outside_user: Array of
        the number of views by users outside of the team to shared links created
        by the team.
    :ivar team.GetActivityReport.shared_links_viewed_by_not_logged_in: Array of
        the number of views by non-logged-in users to shared links created by
        the team.
    :ivar team.GetActivityReport.shared_links_viewed_total: Array of the total
        number of views to shared links created by the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=..., adds=..., edits=..., deletes=..., active_users_28_day=..., active_users_7_day=..., active_users_1_day=..., active_shared_folders_28_day=..., active_shared_folders_7_day=..., active_shared_folders_1_day=..., shared_links_created=..., shared_links_viewed_by_team=..., shared_links_viewed_by_outside_user=..., shared_links_viewed_by_not_logged_in=..., shared_links_viewed_total=...) -> None:
        ...
    
    adds = ...
    edits = ...
    deletes = ...
    active_users_28_day = ...
    active_users_7_day = ...
    active_users_1_day = ...
    active_shared_folders_28_day = ...
    active_shared_folders_7_day = ...
    active_shared_folders_1_day = ...
    shared_links_created = ...
    shared_links_viewed_by_team = ...
    shared_links_viewed_by_outside_user = ...
    shared_links_viewed_by_not_logged_in = ...
    shared_links_viewed_total = ...


GetActivityReport_validator = ...
class GetDevicesReport(BaseDfbReport):
    """
    Devices Report Result. Contains subsections for different time ranges of
    activity. Each of the items in each subsection of the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar team.GetDevicesReport.active_1_day: Report of the number of devices
        active in the last day.
    :ivar team.GetDevicesReport.active_7_day: Report of the number of devices
        active in the last 7 days.
    :ivar team.GetDevicesReport.active_28_day: Report of the number of devices
        active in the last 28 days.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=..., active_1_day=..., active_7_day=..., active_28_day=...) -> None:
        ...
    
    active_1_day = ...
    active_7_day = ...
    active_28_day = ...


GetDevicesReport_validator = ...
class GetMembershipReport(BaseDfbReport):
    """
    Membership Report Result. Each of the items in the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar team.GetMembershipReport.team_size: Team size, for each day.
    :ivar team.GetMembershipReport.pending_invites: The number of pending
        invites to the team, for each day.
    :ivar team.GetMembershipReport.members_joined: The number of members that
        joined the team, for each day.
    :ivar team.GetMembershipReport.suspended_members: The number of suspended
        team members, for each day.
    :ivar team.GetMembershipReport.licenses: The total number of licenses the
        team has, for each day.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=..., team_size=..., pending_invites=..., members_joined=..., suspended_members=..., licenses=...) -> None:
        ...
    
    team_size = ...
    pending_invites = ...
    members_joined = ...
    suspended_members = ...
    licenses = ...


GetMembershipReport_validator = ...
class GetStorageReport(BaseDfbReport):
    """
    Storage Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar team.GetStorageReport.total_usage: Sum of the shared, unshared, and
        datastore usages, for each day.
    :ivar team.GetStorageReport.shared_usage: Array of the combined size (bytes)
        of team members' shared folders, for each day.
    :ivar team.GetStorageReport.unshared_usage: Array of the combined size
        (bytes) of team members' root namespaces, for each day.
    :ivar team.GetStorageReport.shared_folders: Array of the number of shared
        folders owned by team members, for each day.
    :ivar team.GetStorageReport.member_storage_map: Array of storage summaries
        of team members' account sizes. Each storage summary is an array of key,
        value pairs, where each pair describes a storage bucket. The key
        indicates the upper bound of the bucket and the value is the number of
        users in that bucket. There is one such summary per day. If there is no
        data for a day, the storage summary will be empty.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, start_date=..., total_usage=..., shared_usage=..., unshared_usage=..., shared_folders=..., member_storage_map=...) -> None:
        ...
    
    total_usage = ...
    shared_usage = ...
    unshared_usage = ...
    shared_folders = ...
    member_storage_map = ...


GetStorageReport_validator = ...
class GroupAccessType(bb.Union):
    """
    Role of a user in group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupAccessType.member: User is a member of the group, but has no
        special permissions.
    :ivar team.GroupAccessType.owner: User can rename the group, and add/remove
        members.
    """
    _catch_all = ...
    member = ...
    owner = ...
    def is_member(self):
        """
        Check if the union tag is ``member``.

        :rtype: bool
        """
        ...
    
    def is_owner(self):
        """
        Check if the union tag is ``owner``.

        :rtype: bool
        """
        ...
    


GroupAccessType_validator = ...
class GroupCreateArg(bb.Struct):
    """
    :ivar team.GroupCreateArg.group_name: Group name.
    :ivar team.GroupCreateArg.add_creator_as_owner: Automatically add the
        creator of the group.
    :ivar team.GroupCreateArg.group_external_id: The creator of a team can
        associate an arbitrary external ID to the group.
    :ivar team.GroupCreateArg.group_management_type: Whether the team can be
        managed by selected users, or only by team admins.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group_name=..., add_creator_as_owner=..., group_external_id=..., group_management_type=...) -> None:
        ...
    
    group_name = ...
    add_creator_as_owner = ...
    group_external_id = ...
    group_management_type = ...


GroupCreateArg_validator = ...
class GroupCreateError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupCreateError.group_name_already_used: The requested group
        name is already being used by another group.
    :ivar team.GroupCreateError.group_name_invalid: Group name is empty or has
        invalid characters.
    :ivar team.GroupCreateError.external_id_already_in_use: The requested
        external ID is already being used by another group.
    :ivar team.GroupCreateError.system_managed_group_disallowed: System-managed
        group cannot be manually created.
    """
    _catch_all = ...
    group_name_already_used = ...
    group_name_invalid = ...
    external_id_already_in_use = ...
    system_managed_group_disallowed = ...
    other = ...
    def is_group_name_already_used(self):
        """
        Check if the union tag is ``group_name_already_used``.

        :rtype: bool
        """
        ...
    
    def is_group_name_invalid(self):
        """
        Check if the union tag is ``group_name_invalid``.

        :rtype: bool
        """
        ...
    
    def is_external_id_already_in_use(self):
        """
        Check if the union tag is ``external_id_already_in_use``.

        :rtype: bool
        """
        ...
    
    def is_system_managed_group_disallowed(self):
        """
        Check if the union tag is ``system_managed_group_disallowed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GroupCreateError_validator = ...
class GroupSelectorError(bb.Union):
    """
    Error that can be raised when :class:`GroupSelector` is used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupSelectorError.group_not_found: No matching group found. No
        groups match the specified group ID.
    """
    _catch_all = ...
    group_not_found = ...
    other = ...
    def is_group_not_found(self):
        """
        Check if the union tag is ``group_not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GroupSelectorError_validator = ...
class GroupSelectorWithTeamGroupError(GroupSelectorError):
    """
    Error that can be raised when :class:`GroupSelector` is used and team groups
    are disallowed from being used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupSelectorWithTeamGroupError.system_managed_group_disallowed:
        This operation is not supported on system-managed groups.
    """
    system_managed_group_disallowed = ...
    def is_system_managed_group_disallowed(self):
        """
        Check if the union tag is ``system_managed_group_disallowed``.

        :rtype: bool
        """
        ...
    


GroupSelectorWithTeamGroupError_validator = ...
class GroupDeleteError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupDeleteError.group_already_deleted: This group has already
        been deleted.
    """
    group_already_deleted = ...
    def is_group_already_deleted(self):
        """
        Check if the union tag is ``group_already_deleted``.

        :rtype: bool
        """
        ...
    


GroupDeleteError_validator = ...
class GroupFullInfo(team_common.GroupSummary):
    """
    Full description of a group.

    :ivar team.GroupFullInfo.members: List of group members.
    :ivar team.GroupFullInfo.created: The group creation time as a UTC timestamp
        in milliseconds since the Unix epoch.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group_name=..., group_id=..., group_management_type=..., created=..., group_external_id=..., member_count=..., members=...) -> None:
        ...
    
    members = ...
    created = ...


GroupFullInfo_validator = ...
class GroupMemberInfo(bb.Struct):
    """
    Profile of group member, and role in group.

    :ivar team.GroupMemberInfo.profile: Profile of group member.
    :ivar team.GroupMemberInfo.access_type: The role that the user has in the
        group.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, profile=..., access_type=...) -> None:
        ...
    
    profile = ...
    access_type = ...


GroupMemberInfo_validator = ...
class GroupMemberSelector(bb.Struct):
    """
    Argument for selecting a group and a single user.

    :ivar team.GroupMemberSelector.group: Specify a group.
    :ivar team.GroupMemberSelector.user: Identity of a user that is a member of
        ``group``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., user=...) -> None:
        ...
    
    group = ...
    user = ...


GroupMemberSelector_validator = ...
class GroupMemberSelectorError(GroupSelectorWithTeamGroupError):
    """
    Error that can be raised when :class:`GroupMemberSelector` is used, and the
    user is required to be a member of the specified group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupMemberSelectorError.member_not_in_group: The specified user
        is not a member of this group.
    """
    member_not_in_group = ...
    def is_member_not_in_group(self):
        """
        Check if the union tag is ``member_not_in_group``.

        :rtype: bool
        """
        ...
    


GroupMemberSelectorError_validator = ...
class GroupMemberSetAccessTypeError(GroupMemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar
        team.GroupMemberSetAccessTypeError.user_cannot_be_manager_of_company_managed_group:
        A company managed group cannot be managed by a user.
    """
    user_cannot_be_manager_of_company_managed_group = ...
    def is_user_cannot_be_manager_of_company_managed_group(self):
        """
        Check if the union tag is ``user_cannot_be_manager_of_company_managed_group``.

        :rtype: bool
        """
        ...
    


GroupMemberSetAccessTypeError_validator = ...
class IncludeMembersArg(bb.Struct):
    """
    :ivar team.IncludeMembersArg.return_members: Whether to return the list of
        members in the group.  Note that the default value will cause all the
        group members  to be returned in the response. This may take a long time
        for large groups.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, return_members=...) -> None:
        ...
    
    return_members = ...


IncludeMembersArg_validator = ...
class GroupMembersAddArg(IncludeMembersArg):
    """
    :ivar team.GroupMembersAddArg.group: Group to which users will be added.
    :ivar team.GroupMembersAddArg.members: List of users to be added to the
        group.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., members=..., return_members=...) -> None:
        ...
    
    group = ...
    members = ...


GroupMembersAddArg_validator = ...
class GroupMembersAddError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupMembersAddError.duplicate_user: You cannot add duplicate
        users. One or more of the members you are trying to add is already a
        member of the group.
    :ivar team.GroupMembersAddError.group_not_in_team: Group is not in this
        team. You cannot add members to a group that is outside of your team.
    :ivar list of [str] team.GroupMembersAddError.members_not_in_team: These
        members are not part of your team. Currently, you cannot add members to
        a group if they are not part of your team, though this may change in a
        subsequent version. To add new members to your Dropbox Business team,
        use the :route:`members/add` endpoint.
    :ivar list of [str] team.GroupMembersAddError.users_not_found: These users
        were not found in Dropbox.
    :ivar team.GroupMembersAddError.user_must_be_active_to_be_owner: A suspended
        user cannot be added to a group as ``GroupAccessType.owner``.
    :ivar list of [str]
        team.GroupMembersAddError.user_cannot_be_manager_of_company_managed_group:
        A company-managed group cannot be managed by a user.
    """
    duplicate_user = ...
    group_not_in_team = ...
    user_must_be_active_to_be_owner = ...
    @classmethod
    def members_not_in_team(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``members_not_in_team`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        ...
    
    @classmethod
    def users_not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``users_not_found`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        ...
    
    @classmethod
    def user_cannot_be_manager_of_company_managed_group(cls, val): # -> Self:
        """
        Create an instance of this class set to the
        ``user_cannot_be_manager_of_company_managed_group`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        ...
    
    def is_duplicate_user(self):
        """
        Check if the union tag is ``duplicate_user``.

        :rtype: bool
        """
        ...
    
    def is_group_not_in_team(self):
        """
        Check if the union tag is ``group_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_members_not_in_team(self):
        """
        Check if the union tag is ``members_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_users_not_found(self):
        """
        Check if the union tag is ``users_not_found``.

        :rtype: bool
        """
        ...
    
    def is_user_must_be_active_to_be_owner(self):
        """
        Check if the union tag is ``user_must_be_active_to_be_owner``.

        :rtype: bool
        """
        ...
    
    def is_user_cannot_be_manager_of_company_managed_group(self):
        """
        Check if the union tag is ``user_cannot_be_manager_of_company_managed_group``.

        :rtype: bool
        """
        ...
    
    def get_members_not_in_team(self): # -> None:
        """
        These members are not part of your team. Currently, you cannot add
        members to a group if they are not part of your team, though this may
        change in a subsequent version. To add new members to your Dropbox
        Business team, use the
        :meth:`dropbox.dropbox_client.Dropbox.team_members_add` endpoint.

        Only call this if :meth:`is_members_not_in_team` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_users_not_found(self): # -> None:
        """
        These users were not found in Dropbox.

        Only call this if :meth:`is_users_not_found` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_user_cannot_be_manager_of_company_managed_group(self): # -> None:
        """
        A company-managed group cannot be managed by a user.

        Only call this if :meth:`is_user_cannot_be_manager_of_company_managed_group` is true.

        :rtype: list of [str]
        """
        ...
    


GroupMembersAddError_validator = ...
class GroupMembersChangeResult(bb.Struct):
    """
    Result returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_groups_members_add` and
    :meth:`dropbox.dropbox_client.Dropbox.team_groups_members_remove`.

    :ivar team.GroupMembersChangeResult.group_info: The group info after member
        change operation has been performed.
    :ivar team.GroupMembersChangeResult.async_job_id: For legacy purposes
        async_job_id will always return one space ' '. Formerly, it was an ID
        that was used to obtain the status of granting/revoking group-owned
        resources. It's no longer necessary because the async processing now
        happens automatically.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group_info=..., async_job_id=...) -> None:
        ...
    
    group_info = ...
    async_job_id = ...


GroupMembersChangeResult_validator = ...
class GroupMembersRemoveArg(IncludeMembersArg):
    """
    :ivar team.GroupMembersRemoveArg.group: Group from which users will be
        removed.
    :ivar team.GroupMembersRemoveArg.users: List of users to be removed from the
        group.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., users=..., return_members=...) -> None:
        ...
    
    group = ...
    users = ...


GroupMembersRemoveArg_validator = ...
class GroupMembersSelectorError(GroupSelectorWithTeamGroupError):
    """
    Error that can be raised when :class:`GroupMembersSelector` is used, and the
    users are required to be members of the specified group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupMembersSelectorError.member_not_in_group: At least one of
        the specified users is not a member of the group.
    """
    member_not_in_group = ...
    def is_member_not_in_group(self):
        """
        Check if the union tag is ``member_not_in_group``.

        :rtype: bool
        """
        ...
    


GroupMembersSelectorError_validator = ...
class GroupMembersRemoveError(GroupMembersSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupMembersRemoveError.group_not_in_team: Group is not in this
        team. You cannot remove members from a group that is outside of your
        team.
    :ivar list of [str] team.GroupMembersRemoveError.members_not_in_team: These
        members are not part of your team.
    :ivar list of [str] team.GroupMembersRemoveError.users_not_found: These
        users were not found in Dropbox.
    """
    group_not_in_team = ...
    @classmethod
    def members_not_in_team(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``members_not_in_team`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersRemoveError
        """
        ...
    
    @classmethod
    def users_not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``users_not_found`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersRemoveError
        """
        ...
    
    def is_group_not_in_team(self):
        """
        Check if the union tag is ``group_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_members_not_in_team(self):
        """
        Check if the union tag is ``members_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_users_not_found(self):
        """
        Check if the union tag is ``users_not_found``.

        :rtype: bool
        """
        ...
    
    def get_members_not_in_team(self): # -> None:
        """
        These members are not part of your team.

        Only call this if :meth:`is_members_not_in_team` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_users_not_found(self): # -> None:
        """
        These users were not found in Dropbox.

        Only call this if :meth:`is_users_not_found` is true.

        :rtype: list of [str]
        """
        ...
    


GroupMembersRemoveError_validator = ...
class GroupMembersSelector(bb.Struct):
    """
    Argument for selecting a group and a list of users.

    :ivar team.GroupMembersSelector.group: Specify a group.
    :ivar team.GroupMembersSelector.users: A list of users that are members of
        ``group``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., users=...) -> None:
        ...
    
    group = ...
    users = ...


GroupMembersSelector_validator = ...
class GroupMembersSetAccessTypeArg(GroupMemberSelector):
    """
    :ivar team.GroupMembersSetAccessTypeArg.access_type: New group access type
        the user will have.
    :ivar team.GroupMembersSetAccessTypeArg.return_members: Whether to return
        the list of members in the group.  Note that the default value will
        cause all the group members  to be returned in the response. This may
        take a long time for large groups.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., user=..., access_type=..., return_members=...) -> None:
        ...
    
    access_type = ...
    return_members = ...


GroupMembersSetAccessTypeArg_validator = ...
class GroupSelector(bb.Union):
    """
    Argument for selecting a single group, either by group_id or by external
    group ID.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.GroupSelector.group_id: Group ID.
    :ivar str team.GroupSelector.group_external_id: External ID of the group.
    """
    _catch_all = ...
    @classmethod
    def group_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``group_id`` tag with value
        ``val``.

        :param str val:
        :rtype: GroupSelector
        """
        ...
    
    @classmethod
    def group_external_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``group_external_id`` tag
        with value ``val``.

        :param str val:
        :rtype: GroupSelector
        """
        ...
    
    def is_group_id(self):
        """
        Check if the union tag is ``group_id``.

        :rtype: bool
        """
        ...
    
    def is_group_external_id(self):
        """
        Check if the union tag is ``group_external_id``.

        :rtype: bool
        """
        ...
    
    def get_group_id(self): # -> None:
        """
        Group ID.

        Only call this if :meth:`is_group_id` is true.

        :rtype: str
        """
        ...
    
    def get_group_external_id(self): # -> None:
        """
        External ID of the group.

        Only call this if :meth:`is_group_external_id` is true.

        :rtype: str
        """
        ...
    


GroupSelector_validator = ...
class GroupUpdateArgs(IncludeMembersArg):
    """
    :ivar team.GroupUpdateArgs.group: Specify a group.
    :ivar team.GroupUpdateArgs.new_group_name: Optional argument. Set group name
        to this if provided.
    :ivar team.GroupUpdateArgs.new_group_external_id: Optional argument. New
        group external ID. If the argument is None, the group's external_id
        won't be updated. If the argument is empty string, the group's external
        id will be cleared.
    :ivar team.GroupUpdateArgs.new_group_management_type: Set new group
        management type, if provided.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., return_members=..., new_group_name=..., new_group_external_id=..., new_group_management_type=...) -> None:
        ...
    
    group = ...
    new_group_name = ...
    new_group_external_id = ...
    new_group_management_type = ...


GroupUpdateArgs_validator = ...
class GroupUpdateError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupUpdateError.group_name_already_used: The requested group
        name is already being used by another group.
    :ivar team.GroupUpdateError.group_name_invalid: Group name is empty or has
        invalid characters.
    :ivar team.GroupUpdateError.external_id_already_in_use: The requested
        external ID is already being used by another group.
    """
    group_name_already_used = ...
    group_name_invalid = ...
    external_id_already_in_use = ...
    def is_group_name_already_used(self):
        """
        Check if the union tag is ``group_name_already_used``.

        :rtype: bool
        """
        ...
    
    def is_group_name_invalid(self):
        """
        Check if the union tag is ``group_name_invalid``.

        :rtype: bool
        """
        ...
    
    def is_external_id_already_in_use(self):
        """
        Check if the union tag is ``external_id_already_in_use``.

        :rtype: bool
        """
        ...
    


GroupUpdateError_validator = ...
class GroupsGetInfoError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupsGetInfoError.group_not_on_team: The group is not on your
        team.
    """
    _catch_all = ...
    group_not_on_team = ...
    other = ...
    def is_group_not_on_team(self):
        """
        Check if the union tag is ``group_not_on_team``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GroupsGetInfoError_validator = ...
class GroupsGetInfoItem(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.GroupsGetInfoItem.id_not_found: An ID that was provided as a
        parameter to :route:`groups/get_info`, and did not match a corresponding
        group. The ID can be a group ID, or an external ID, depending on how the
        method was called.
    :ivar GroupFullInfo GroupsGetInfoItem.group_info: Info about a group.
    """
    _catch_all = ...
    @classmethod
    def id_not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: GroupsGetInfoItem
        """
        ...
    
    @classmethod
    def group_info(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``group_info`` tag with
        value ``val``.

        :param GroupFullInfo val:
        :rtype: GroupsGetInfoItem
        """
        ...
    
    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        ...
    
    def is_group_info(self):
        """
        Check if the union tag is ``group_info``.

        :rtype: bool
        """
        ...
    
    def get_id_not_found(self): # -> None:
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox_client.Dropbox.team_groups_get_info`, and did not
        match a corresponding group. The ID can be a group ID, or an external
        ID, depending on how the method was called.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        ...
    
    def get_group_info(self): # -> None:
        """
        Info about a group.

        Only call this if :meth:`is_group_info` is true.

        :rtype: GroupFullInfo
        """
        ...
    


GroupsGetInfoItem_validator = ...
class GroupsListArg(bb.Struct):
    """
    :ivar team.GroupsListArg.limit: Number of results to return per call.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=...) -> None:
        ...
    
    limit = ...


GroupsListArg_validator = ...
class GroupsListContinueArg(bb.Struct):
    """
    :ivar team.GroupsListContinueArg.cursor: Indicates from what point to get
        the next set of groups.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


GroupsListContinueArg_validator = ...
class GroupsListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupsListContinueError.invalid_cursor: The cursor is invalid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GroupsListContinueError_validator = ...
class GroupsListResult(bb.Struct):
    """
    :ivar team.GroupsListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_groups_list_continue` to
        obtain the additional groups.
    :ivar team.GroupsListResult.has_more: Is true if there are additional groups
        that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_groups_list_continue` can
        retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, groups=..., cursor=..., has_more=...) -> None:
        ...
    
    groups = ...
    cursor = ...
    has_more = ...


GroupsListResult_validator = ...
class GroupsMembersListArg(bb.Struct):
    """
    :ivar team.GroupsMembersListArg.group: The group whose members are to be
        listed.
    :ivar team.GroupsMembersListArg.limit: Number of results to return per call.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, group=..., limit=...) -> None:
        ...
    
    group = ...
    limit = ...


GroupsMembersListArg_validator = ...
class GroupsMembersListContinueArg(bb.Struct):
    """
    :ivar team.GroupsMembersListContinueArg.cursor: Indicates from what point to
        get the next set of groups.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


GroupsMembersListContinueArg_validator = ...
class GroupsMembersListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupsMembersListContinueError.invalid_cursor: The cursor is
        invalid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


GroupsMembersListContinueError_validator = ...
class GroupsMembersListResult(bb.Struct):
    """
    :ivar team.GroupsMembersListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_groups_members_list_continue`
        to obtain additional group members.
    :ivar team.GroupsMembersListResult.has_more: Is true if there are additional
        group members that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_groups_members_list_continue`
        can retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members=..., cursor=..., has_more=...) -> None:
        ...
    
    members = ...
    cursor = ...
    has_more = ...


GroupsMembersListResult_validator = ...
class GroupsPollError(async_.PollError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.GroupsPollError.access_denied: You are not allowed to poll this
        job.
    """
    access_denied = ...
    def is_access_denied(self):
        """
        Check if the union tag is ``access_denied``.

        :rtype: bool
        """
        ...
    


GroupsPollError_validator = ...
class GroupsSelector(bb.Union):
    """
    Argument for selecting a list of groups, either by group_ids, or external
    group IDs.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [str] team.GroupsSelector.group_ids: List of group IDs.
    :ivar list of [str] team.GroupsSelector.group_external_ids: List of external
        IDs of groups.
    """
    _catch_all = ...
    @classmethod
    def group_ids(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``group_ids`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: GroupsSelector
        """
        ...
    
    @classmethod
    def group_external_ids(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``group_external_ids`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupsSelector
        """
        ...
    
    def is_group_ids(self):
        """
        Check if the union tag is ``group_ids``.

        :rtype: bool
        """
        ...
    
    def is_group_external_ids(self):
        """
        Check if the union tag is ``group_external_ids``.

        :rtype: bool
        """
        ...
    
    def get_group_ids(self): # -> None:
        """
        List of group IDs.

        Only call this if :meth:`is_group_ids` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_group_external_ids(self): # -> None:
        """
        List of external IDs of groups.

        Only call this if :meth:`is_group_external_ids` is true.

        :rtype: list of [str]
        """
        ...
    


GroupsSelector_validator = ...
class HasTeamFileEventsValue(bb.Union):
    """
    The value for ``Feature.has_team_file_events``.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar bool team.HasTeamFileEventsValue.enabled: Does this team have file
        events.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def enabled(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``enabled`` tag with value
        ``val``.

        :param bool val:
        :rtype: HasTeamFileEventsValue
        """
        ...
    
    def is_enabled(self):
        """
        Check if the union tag is ``enabled``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_enabled(self): # -> None:
        """
        Does this team have file events.

        Only call this if :meth:`is_enabled` is true.

        :rtype: bool
        """
        ...
    


HasTeamFileEventsValue_validator = ...
class HasTeamSelectiveSyncValue(bb.Union):
    """
    The value for ``Feature.has_team_selective_sync``.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar bool team.HasTeamSelectiveSyncValue.has_team_selective_sync: Does this
        team have team selective sync enabled.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def has_team_selective_sync(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``has_team_selective_sync``
        tag with value ``val``.

        :param bool val:
        :rtype: HasTeamSelectiveSyncValue
        """
        ...
    
    def is_has_team_selective_sync(self):
        """
        Check if the union tag is ``has_team_selective_sync``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_has_team_selective_sync(self): # -> None:
        """
        Does this team have team selective sync enabled.

        Only call this if :meth:`is_has_team_selective_sync` is true.

        :rtype: bool
        """
        ...
    


HasTeamSelectiveSyncValue_validator = ...
class HasTeamSharedDropboxValue(bb.Union):
    """
    The value for ``Feature.has_team_shared_dropbox``.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar bool team.HasTeamSharedDropboxValue.has_team_shared_dropbox: Does this
        team have a shared team root.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def has_team_shared_dropbox(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``has_team_shared_dropbox``
        tag with value ``val``.

        :param bool val:
        :rtype: HasTeamSharedDropboxValue
        """
        ...
    
    def is_has_team_shared_dropbox(self):
        """
        Check if the union tag is ``has_team_shared_dropbox``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_has_team_shared_dropbox(self): # -> None:
        """
        Does this team have a shared team root.

        Only call this if :meth:`is_has_team_shared_dropbox` is true.

        :rtype: bool
        """
        ...
    


HasTeamSharedDropboxValue_validator = ...
class LegalHoldHeldRevisionMetadata(bb.Struct):
    """
    :ivar team.LegalHoldHeldRevisionMetadata.new_filename: The held revision
        filename.
    :ivar team.LegalHoldHeldRevisionMetadata.original_revision_id: The id of the
        held revision.
    :ivar team.LegalHoldHeldRevisionMetadata.original_file_path: The original
        path of the held revision.
    :ivar team.LegalHoldHeldRevisionMetadata.server_modified: The last time the
        file was modified on Dropbox.
    :ivar team.LegalHoldHeldRevisionMetadata.author_member_id: The member id of
        the revision's author.
    :ivar team.LegalHoldHeldRevisionMetadata.author_member_status: The member
        status of the revision's author.
    :ivar team.LegalHoldHeldRevisionMetadata.author_email: The email address of
        the held revision author.
    :ivar team.LegalHoldHeldRevisionMetadata.file_type: The type of the held
        revision's file.
    :ivar team.LegalHoldHeldRevisionMetadata.size: The file size in bytes.
    :ivar team.LegalHoldHeldRevisionMetadata.content_hash: A hash of the file
        content. This field can be used to verify data integrity. For more
        information see our `Content hash
        <https://www.dropbox.com/developers/reference/content-hash>`_ page.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, new_filename=..., original_revision_id=..., original_file_path=..., server_modified=..., author_member_id=..., author_member_status=..., author_email=..., file_type=..., size=..., content_hash=...) -> None:
        ...
    
    new_filename = ...
    original_revision_id = ...
    original_file_path = ...
    server_modified = ...
    author_member_id = ...
    author_member_status = ...
    author_email = ...
    file_type = ...
    size = ...
    content_hash = ...


LegalHoldHeldRevisionMetadata_validator = ...
class LegalHoldPolicy(bb.Struct):
    """
    :ivar team.LegalHoldPolicy.id: The legal hold id.
    :ivar team.LegalHoldPolicy.name: Policy name.
    :ivar team.LegalHoldPolicy.description: A description of the legal hold
        policy.
    :ivar team.LegalHoldPolicy.activation_time: The time at which the legal hold
        was activated.
    :ivar team.LegalHoldPolicy.members: Team members IDs and number of
        permanently deleted members under hold.
    :ivar team.LegalHoldPolicy.status: The current state of the hold.
    :ivar team.LegalHoldPolicy.start_date: Start date of the legal hold policy.
    :ivar team.LegalHoldPolicy.end_date: End date of the legal hold policy.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., name=..., members=..., status=..., start_date=..., description=..., activation_time=..., end_date=...) -> None:
        ...
    
    id = ...
    name = ...
    description = ...
    activation_time = ...
    members = ...
    status = ...
    start_date = ...
    end_date = ...


LegalHoldPolicy_validator = ...
class LegalHoldStatus(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldStatus.active: The legal hold policy is active.
    :ivar team.LegalHoldStatus.released: The legal hold policy was released.
    :ivar team.LegalHoldStatus.activating: The legal hold policy is activating.
    :ivar team.LegalHoldStatus.updating: The legal hold policy is updating.
    :ivar team.LegalHoldStatus.exporting: The legal hold policy is exporting.
    :ivar team.LegalHoldStatus.releasing: The legal hold policy is releasing.
    """
    _catch_all = ...
    active = ...
    released = ...
    activating = ...
    updating = ...
    exporting = ...
    releasing = ...
    other = ...
    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        ...
    
    def is_released(self):
        """
        Check if the union tag is ``released``.

        :rtype: bool
        """
        ...
    
    def is_activating(self):
        """
        Check if the union tag is ``activating``.

        :rtype: bool
        """
        ...
    
    def is_updating(self):
        """
        Check if the union tag is ``updating``.

        :rtype: bool
        """
        ...
    
    def is_exporting(self):
        """
        Check if the union tag is ``exporting``.

        :rtype: bool
        """
        ...
    
    def is_releasing(self):
        """
        Check if the union tag is ``releasing``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


LegalHoldStatus_validator = ...
class LegalHoldsError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsError.unknown_legal_hold_error: There has been an
        unknown legal hold error.
    :ivar team.LegalHoldsError.insufficient_permissions: You don't have
        permissions to perform this action.
    """
    _catch_all = ...
    unknown_legal_hold_error = ...
    insufficient_permissions = ...
    other = ...
    def is_unknown_legal_hold_error(self):
        """
        Check if the union tag is ``unknown_legal_hold_error``.

        :rtype: bool
        """
        ...
    
    def is_insufficient_permissions(self):
        """
        Check if the union tag is ``insufficient_permissions``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


LegalHoldsError_validator = ...
class LegalHoldsGetPolicyArg(bb.Struct):
    """
    :ivar team.LegalHoldsGetPolicyArg.id: The legal hold Id.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=...) -> None:
        ...
    
    id = ...


LegalHoldsGetPolicyArg_validator = ...
class LegalHoldsGetPolicyError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsGetPolicyError.legal_hold_policy_not_found: Legal hold
        policy does not exist for ``LegalHoldsGetPolicyArg.id``.
    """
    legal_hold_policy_not_found = ...
    def is_legal_hold_policy_not_found(self):
        """
        Check if the union tag is ``legal_hold_policy_not_found``.

        :rtype: bool
        """
        ...
    


LegalHoldsGetPolicyError_validator = ...
class LegalHoldsListHeldRevisionResult(bb.Struct):
    """
    :ivar team.LegalHoldsListHeldRevisionResult.entries: List of file entries
        that under the hold.
    :ivar team.LegalHoldsListHeldRevisionResult.cursor: The cursor idicates
        where to continue reading file metadata entries for the next API call.
        When there are no more entries, the cursor will return none. Pass the
        cursor into /2/team/legal_holds/list_held_revisions/continue.
    :ivar team.LegalHoldsListHeldRevisionResult.has_more: True if there are more
        file entries that haven't been returned. You can retrieve them with a
        call to /legal_holds/list_held_revisions_continue.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, entries=..., has_more=..., cursor=...) -> None:
        ...
    
    entries = ...
    cursor = ...
    has_more = ...


LegalHoldsListHeldRevisionResult_validator = ...
class LegalHoldsListHeldRevisionsArg(bb.Struct):
    """
    :ivar team.LegalHoldsListHeldRevisionsArg.id: The legal hold Id.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=...) -> None:
        ...
    
    id = ...


LegalHoldsListHeldRevisionsArg_validator = ...
class LegalHoldsListHeldRevisionsContinueArg(bb.Struct):
    """
    :ivar team.LegalHoldsListHeldRevisionsContinueArg.id: The legal hold Id.
    :ivar team.LegalHoldsListHeldRevisionsContinueArg.cursor: The cursor
        idicates where to continue reading file metadata entries for the next
        API call. When there are no more entries, the cursor will return none.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., cursor=...) -> None:
        ...
    
    id = ...
    cursor = ...


LegalHoldsListHeldRevisionsContinueArg_validator = ...
class LegalHoldsListHeldRevisionsContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar
        team.LegalHoldsListHeldRevisionsContinueError.unknown_legal_hold_error:
        There has been an unknown legal hold error.
    :ivar team.LegalHoldsListHeldRevisionsContinueError.transient_error:
        Temporary infrastructure failure, please retry.
    :ivar team.LegalHoldsListHeldRevisionsContinueError.reset: Indicates that
        the cursor has been invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.team_legal_holds_list_held_revisions_continue`
        again with an empty cursor to obtain a new cursor.
    """
    _catch_all = ...
    unknown_legal_hold_error = ...
    transient_error = ...
    reset = ...
    other = ...
    def is_unknown_legal_hold_error(self):
        """
        Check if the union tag is ``unknown_legal_hold_error``.

        :rtype: bool
        """
        ...
    
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


LegalHoldsListHeldRevisionsContinueError_validator = ...
class LegalHoldsListHeldRevisionsError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsListHeldRevisionsError.transient_error: Temporary
        infrastructure failure, please retry.
    :ivar team.LegalHoldsListHeldRevisionsError.legal_hold_still_empty: The
        legal hold is not holding any revisions yet.
    :ivar team.LegalHoldsListHeldRevisionsError.inactive_legal_hold: Trying to
        list revisions for an inactive legal hold.
    """
    transient_error = ...
    legal_hold_still_empty = ...
    inactive_legal_hold = ...
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    
    def is_legal_hold_still_empty(self):
        """
        Check if the union tag is ``legal_hold_still_empty``.

        :rtype: bool
        """
        ...
    
    def is_inactive_legal_hold(self):
        """
        Check if the union tag is ``inactive_legal_hold``.

        :rtype: bool
        """
        ...
    


LegalHoldsListHeldRevisionsError_validator = ...
class LegalHoldsListPoliciesArg(bb.Struct):
    """
    :ivar team.LegalHoldsListPoliciesArg.include_released: Whether to return
        holds that were released.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, include_released=...) -> None:
        ...
    
    include_released = ...


LegalHoldsListPoliciesArg_validator = ...
class LegalHoldsListPoliciesError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsListPoliciesError.transient_error: Temporary
        infrastructure failure, please retry.
    """
    transient_error = ...
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    


LegalHoldsListPoliciesError_validator = ...
class LegalHoldsListPoliciesResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, policies=...) -> None:
        ...
    
    policies = ...


LegalHoldsListPoliciesResult_validator = ...
class LegalHoldsPolicyCreateArg(bb.Struct):
    """
    :ivar team.LegalHoldsPolicyCreateArg.name: Policy name.
    :ivar team.LegalHoldsPolicyCreateArg.description: A description of the legal
        hold policy.
    :ivar team.LegalHoldsPolicyCreateArg.members: List of team member IDs added
        to the hold.
    :ivar team.LegalHoldsPolicyCreateArg.start_date: start date of the legal
        hold policy.
    :ivar team.LegalHoldsPolicyCreateArg.end_date: end date of the legal hold
        policy.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., members=..., description=..., start_date=..., end_date=...) -> None:
        ...
    
    name = ...
    description = ...
    members = ...
    start_date = ...
    end_date = ...


LegalHoldsPolicyCreateArg_validator = ...
class LegalHoldsPolicyCreateError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsPolicyCreateError.start_date_is_later_than_end_date:
        Start date must be earlier than end date.
    :ivar team.LegalHoldsPolicyCreateError.empty_members_list: The users list
        must have at least one user.
    :ivar team.LegalHoldsPolicyCreateError.invalid_members: Some members in the
        members list are not valid to be placed under legal hold.
    :ivar
        team.LegalHoldsPolicyCreateError.number_of_users_on_hold_is_greater_than_hold_limitation:
        You cannot add more than 5 users in a legal hold.
    :ivar team.LegalHoldsPolicyCreateError.transient_error: Temporary
        infrastructure failure, please retry.
    :ivar team.LegalHoldsPolicyCreateError.name_must_be_unique: The name
        provided is already in use by another legal hold.
    :ivar team.LegalHoldsPolicyCreateError.team_exceeded_legal_hold_quota: Team
        exceeded legal hold quota.
    :ivar team.LegalHoldsPolicyCreateError.invalid_date: The provided date is
        invalid.
    """
    start_date_is_later_than_end_date = ...
    empty_members_list = ...
    invalid_members = ...
    number_of_users_on_hold_is_greater_than_hold_limitation = ...
    transient_error = ...
    name_must_be_unique = ...
    team_exceeded_legal_hold_quota = ...
    invalid_date = ...
    def is_start_date_is_later_than_end_date(self):
        """
        Check if the union tag is ``start_date_is_later_than_end_date``.

        :rtype: bool
        """
        ...
    
    def is_empty_members_list(self):
        """
        Check if the union tag is ``empty_members_list``.

        :rtype: bool
        """
        ...
    
    def is_invalid_members(self):
        """
        Check if the union tag is ``invalid_members``.

        :rtype: bool
        """
        ...
    
    def is_number_of_users_on_hold_is_greater_than_hold_limitation(self):
        """
        Check if the union tag is ``number_of_users_on_hold_is_greater_than_hold_limitation``.

        :rtype: bool
        """
        ...
    
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    
    def is_name_must_be_unique(self):
        """
        Check if the union tag is ``name_must_be_unique``.

        :rtype: bool
        """
        ...
    
    def is_team_exceeded_legal_hold_quota(self):
        """
        Check if the union tag is ``team_exceeded_legal_hold_quota``.

        :rtype: bool
        """
        ...
    
    def is_invalid_date(self):
        """
        Check if the union tag is ``invalid_date``.

        :rtype: bool
        """
        ...
    


LegalHoldsPolicyCreateError_validator = ...
class LegalHoldsPolicyReleaseArg(bb.Struct):
    """
    :ivar team.LegalHoldsPolicyReleaseArg.id: The legal hold Id.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=...) -> None:
        ...
    
    id = ...


LegalHoldsPolicyReleaseArg_validator = ...
class LegalHoldsPolicyReleaseError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar
        team.LegalHoldsPolicyReleaseError.legal_hold_performing_another_operation:
        Legal hold is currently performing another operation.
    :ivar team.LegalHoldsPolicyReleaseError.legal_hold_already_releasing: Legal
        hold is currently performing a release or is already released.
    :ivar team.LegalHoldsPolicyReleaseError.legal_hold_policy_not_found: Legal
        hold policy does not exist for ``LegalHoldsPolicyReleaseArg.id``.
    """
    legal_hold_performing_another_operation = ...
    legal_hold_already_releasing = ...
    legal_hold_policy_not_found = ...
    def is_legal_hold_performing_another_operation(self):
        """
        Check if the union tag is ``legal_hold_performing_another_operation``.

        :rtype: bool
        """
        ...
    
    def is_legal_hold_already_releasing(self):
        """
        Check if the union tag is ``legal_hold_already_releasing``.

        :rtype: bool
        """
        ...
    
    def is_legal_hold_policy_not_found(self):
        """
        Check if the union tag is ``legal_hold_policy_not_found``.

        :rtype: bool
        """
        ...
    


LegalHoldsPolicyReleaseError_validator = ...
class LegalHoldsPolicyUpdateArg(bb.Struct):
    """
    :ivar team.LegalHoldsPolicyUpdateArg.id: The legal hold Id.
    :ivar team.LegalHoldsPolicyUpdateArg.name: Policy new name.
    :ivar team.LegalHoldsPolicyUpdateArg.description: Policy new description.
    :ivar team.LegalHoldsPolicyUpdateArg.members: List of team member IDs to
        apply the policy on.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, id=..., name=..., description=..., members=...) -> None:
        ...
    
    id = ...
    name = ...
    description = ...
    members = ...


LegalHoldsPolicyUpdateArg_validator = ...
class LegalHoldsPolicyUpdateError(LegalHoldsError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.LegalHoldsPolicyUpdateError.transient_error: Temporary
        infrastructure failure, please retry.
    :ivar team.LegalHoldsPolicyUpdateError.inactive_legal_hold: Trying to
        release an inactive legal hold.
    :ivar
        team.LegalHoldsPolicyUpdateError.legal_hold_performing_another_operation:
        Legal hold is currently performing another operation.
    :ivar team.LegalHoldsPolicyUpdateError.invalid_members: Some members in the
        members list are not valid to be placed under legal hold.
    :ivar
        team.LegalHoldsPolicyUpdateError.number_of_users_on_hold_is_greater_than_hold_limitation:
        You cannot add more than 5 users in a legal hold.
    :ivar team.LegalHoldsPolicyUpdateError.empty_members_list: The users list
        must have at least one user.
    :ivar team.LegalHoldsPolicyUpdateError.name_must_be_unique: The name
        provided is already in use by another legal hold.
    :ivar team.LegalHoldsPolicyUpdateError.legal_hold_policy_not_found: Legal
        hold policy does not exist for ``LegalHoldsPolicyUpdateArg.id``.
    """
    transient_error = ...
    inactive_legal_hold = ...
    legal_hold_performing_another_operation = ...
    invalid_members = ...
    number_of_users_on_hold_is_greater_than_hold_limitation = ...
    empty_members_list = ...
    name_must_be_unique = ...
    legal_hold_policy_not_found = ...
    def is_transient_error(self):
        """
        Check if the union tag is ``transient_error``.

        :rtype: bool
        """
        ...
    
    def is_inactive_legal_hold(self):
        """
        Check if the union tag is ``inactive_legal_hold``.

        :rtype: bool
        """
        ...
    
    def is_legal_hold_performing_another_operation(self):
        """
        Check if the union tag is ``legal_hold_performing_another_operation``.

        :rtype: bool
        """
        ...
    
    def is_invalid_members(self):
        """
        Check if the union tag is ``invalid_members``.

        :rtype: bool
        """
        ...
    
    def is_number_of_users_on_hold_is_greater_than_hold_limitation(self):
        """
        Check if the union tag is ``number_of_users_on_hold_is_greater_than_hold_limitation``.

        :rtype: bool
        """
        ...
    
    def is_empty_members_list(self):
        """
        Check if the union tag is ``empty_members_list``.

        :rtype: bool
        """
        ...
    
    def is_name_must_be_unique(self):
        """
        Check if the union tag is ``name_must_be_unique``.

        :rtype: bool
        """
        ...
    
    def is_legal_hold_policy_not_found(self):
        """
        Check if the union tag is ``legal_hold_policy_not_found``.

        :rtype: bool
        """
        ...
    


LegalHoldsPolicyUpdateError_validator = ...
class ListMemberAppsArg(bb.Struct):
    """
    :ivar team.ListMemberAppsArg.team_member_id: The team member id.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=...) -> None:
        ...
    
    team_member_id = ...


ListMemberAppsArg_validator = ...
class ListMemberAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_member_linked_apps`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListMemberAppsError.member_not_found: Member not found.
    """
    _catch_all = ...
    member_not_found = ...
    other = ...
    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListMemberAppsError_validator = ...
class ListMemberAppsResult(bb.Struct):
    """
    :ivar team.ListMemberAppsResult.linked_api_apps: List of third party
        applications linked by this team member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, linked_api_apps=...) -> None:
        ...
    
    linked_api_apps = ...


ListMemberAppsResult_validator = ...
class ListMemberDevicesArg(bb.Struct):
    """
    :ivar team.ListMemberDevicesArg.team_member_id: The team's member id.
    :ivar team.ListMemberDevicesArg.include_web_sessions: Whether to list web
        sessions of the team's member.
    :ivar team.ListMemberDevicesArg.include_desktop_clients: Whether to list
        linked desktop devices of the team's member.
    :ivar team.ListMemberDevicesArg.include_mobile_clients: Whether to list
        linked mobile devices of the team's member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., include_web_sessions=..., include_desktop_clients=..., include_mobile_clients=...) -> None:
        ...
    
    team_member_id = ...
    include_web_sessions = ...
    include_desktop_clients = ...
    include_mobile_clients = ...


ListMemberDevicesArg_validator = ...
class ListMemberDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListMemberDevicesError.member_not_found: Member not found.
    """
    _catch_all = ...
    member_not_found = ...
    other = ...
    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListMemberDevicesError_validator = ...
class ListMemberDevicesResult(bb.Struct):
    """
    :ivar team.ListMemberDevicesResult.active_web_sessions: List of web sessions
        made by this team member.
    :ivar team.ListMemberDevicesResult.desktop_client_sessions: List of desktop
        clients used by this team member.
    :ivar team.ListMemberDevicesResult.mobile_client_sessions: List of mobile
        client used by this team member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, active_web_sessions=..., desktop_client_sessions=..., mobile_client_sessions=...) -> None:
        ...
    
    active_web_sessions = ...
    desktop_client_sessions = ...
    mobile_client_sessions = ...


ListMemberDevicesResult_validator = ...
class ListMembersAppsArg(bb.Struct):
    """
    Arguments for
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`.

    :ivar team.ListMembersAppsArg.cursor: At the first call to the
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ListMembersAppsArg_validator = ...
class ListMembersAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListMembersAppsError.reset: Indicates that the cursor has been
        invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`
        again with an empty cursor to obtain a new cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListMembersAppsError_validator = ...
class ListMembersAppsResult(bb.Struct):
    """
    Information returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`.

    :ivar team.ListMembersAppsResult.apps: The linked applications of each
        member of the team.
    :ivar team.ListMembersAppsResult.has_more: If true, then there are more apps
        available. Pass the cursor to
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`
        to retrieve the rest.
    :ivar team.ListMembersAppsResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_members_linked_apps`
        to receive the next sub list of team's applications.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, apps=..., has_more=..., cursor=...) -> None:
        ...
    
    apps = ...
    has_more = ...
    cursor = ...


ListMembersAppsResult_validator = ...
class ListMembersDevicesArg(bb.Struct):
    """
    :ivar team.ListMembersDevicesArg.cursor: At the first call to the
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_members_devices`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices.
    :ivar team.ListMembersDevicesArg.include_web_sessions: Whether to list web
        sessions of the team members.
    :ivar team.ListMembersDevicesArg.include_desktop_clients: Whether to list
        desktop clients of the team members.
    :ivar team.ListMembersDevicesArg.include_mobile_clients: Whether to list
        mobile clients of the team members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=..., include_web_sessions=..., include_desktop_clients=..., include_mobile_clients=...) -> None:
        ...
    
    cursor = ...
    include_web_sessions = ...
    include_desktop_clients = ...
    include_mobile_clients = ...


ListMembersDevicesArg_validator = ...
class ListMembersDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListMembersDevicesError.reset: Indicates that the cursor has been
        invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_members_devices`
        again with an empty cursor to obtain a new cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListMembersDevicesError_validator = ...
class ListMembersDevicesResult(bb.Struct):
    """
    :ivar team.ListMembersDevicesResult.devices: The devices of each member of
        the team.
    :ivar team.ListMembersDevicesResult.has_more: If true, then there are more
        devices available. Pass the cursor to
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_members_devices`
        to retrieve the rest.
    :ivar team.ListMembersDevicesResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_members_devices`
        to receive the next sub list of team's devices.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, devices=..., has_more=..., cursor=...) -> None:
        ...
    
    devices = ...
    has_more = ...
    cursor = ...


ListMembersDevicesResult_validator = ...
class ListTeamAppsArg(bb.Struct):
    """
    Arguments for
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`.

    :ivar team.ListTeamAppsArg.cursor: At the first call to the
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


ListTeamAppsArg_validator = ...
class ListTeamAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListTeamAppsError.reset: Indicates that the cursor has been
        invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`
        again with an empty cursor to obtain a new cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListTeamAppsError_validator = ...
class ListTeamAppsResult(bb.Struct):
    """
    Information returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`.

    :ivar team.ListTeamAppsResult.apps: The linked applications of each member
        of the team.
    :ivar team.ListTeamAppsResult.has_more: If true, then there are more apps
        available. Pass the cursor to
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`
        to retrieve the rest.
    :ivar team.ListTeamAppsResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_list_team_linked_apps`
        to receive the next sub list of team's applications.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, apps=..., has_more=..., cursor=...) -> None:
        ...
    
    apps = ...
    has_more = ...
    cursor = ...


ListTeamAppsResult_validator = ...
class ListTeamDevicesArg(bb.Struct):
    """
    :ivar team.ListTeamDevicesArg.cursor: At the first call to the
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_team_devices`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices.
    :ivar team.ListTeamDevicesArg.include_web_sessions: Whether to list web
        sessions of the team members.
    :ivar team.ListTeamDevicesArg.include_desktop_clients: Whether to list
        desktop clients of the team members.
    :ivar team.ListTeamDevicesArg.include_mobile_clients: Whether to list mobile
        clients of the team members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=..., include_web_sessions=..., include_desktop_clients=..., include_mobile_clients=...) -> None:
        ...
    
    cursor = ...
    include_web_sessions = ...
    include_desktop_clients = ...
    include_mobile_clients = ...


ListTeamDevicesArg_validator = ...
class ListTeamDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.ListTeamDevicesError.reset: Indicates that the cursor has been
        invalidated. Call
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_team_devices`
        again with an empty cursor to obtain a new cursor.
    """
    _catch_all = ...
    reset = ...
    other = ...
    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


ListTeamDevicesError_validator = ...
class ListTeamDevicesResult(bb.Struct):
    """
    :ivar team.ListTeamDevicesResult.devices: The devices of each member of the
        team.
    :ivar team.ListTeamDevicesResult.has_more: If true, then there are more
        devices available. Pass the cursor to
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_team_devices` to
        retrieve the rest.
    :ivar team.ListTeamDevicesResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_devices_list_team_devices` to
        receive the next sub list of team's devices.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, devices=..., has_more=..., cursor=...) -> None:
        ...
    
    devices = ...
    has_more = ...
    cursor = ...


ListTeamDevicesResult_validator = ...
class MemberAccess(bb.Struct):
    """
    Specify access type a member should have when joined to a group.

    :ivar team.MemberAccess.user: Identity of a user.
    :ivar team.MemberAccess.access_type: Access type.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., access_type=...) -> None:
        ...
    
    user = ...
    access_type = ...


MemberAccess_validator = ...
class MemberAddArgBase(bb.Struct):
    """
    :ivar team.MemberAddArgBase.member_given_name: Member's first name.
    :ivar team.MemberAddArgBase.member_surname: Member's last name.
    :ivar team.MemberAddArgBase.member_external_id: External ID for member.
    :ivar team.MemberAddArgBase.member_persistent_id: Persistent ID for member.
        This field is only available to teams using persistent ID SAML
        configuration.
    :ivar team.MemberAddArgBase.send_welcome_email: Whether to send a welcome
        email to the member. If send_welcome_email is false, no email invitation
        will be sent to the user. This may be useful for apps using single
        sign-on (SSO) flows for onboarding that want to handle announcements
        themselves.
    :ivar team.MemberAddArgBase.is_directory_restricted: Whether a user is
        directory restricted.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member_email=..., member_given_name=..., member_surname=..., member_external_id=..., member_persistent_id=..., send_welcome_email=..., is_directory_restricted=...) -> None:
        ...
    
    member_email = ...
    member_given_name = ...
    member_surname = ...
    member_external_id = ...
    member_persistent_id = ...
    send_welcome_email = ...
    is_directory_restricted = ...


MemberAddArgBase_validator = ...
class MemberAddArg(MemberAddArgBase):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member_email=..., member_given_name=..., member_surname=..., member_external_id=..., member_persistent_id=..., send_welcome_email=..., is_directory_restricted=..., role=...) -> None:
        ...
    
    role = ...


MemberAddArg_validator = ...
class MemberAddResultBase(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.MemberAddResultBase.team_license_limit: Team is already full.
        The organization has no available licenses.
    :ivar str team.MemberAddResultBase.free_team_member_limit_reached: Team is
        already full. The free team member limit has been reached.
    :ivar str team.MemberAddResultBase.user_already_on_team: User is already on
        this team. The provided email address is associated with a user who is
        already a member of (including in recoverable state) or invited to the
        team.
    :ivar str team.MemberAddResultBase.user_on_another_team: User is already on
        another team. The provided email address is associated with a user that
        is already a member or invited to another team.
    :ivar str team.MemberAddResultBase.user_already_paired: User is already
        paired.
    :ivar str team.MemberAddResultBase.user_migration_failed: User migration has
        failed.
    :ivar str team.MemberAddResultBase.duplicate_external_member_id: A user with
        the given external member ID already exists on the team (including in
        recoverable state).
    :ivar str team.MemberAddResultBase.duplicate_member_persistent_id: A user
        with the given persistent ID already exists on the team (including in
        recoverable state).
    :ivar str team.MemberAddResultBase.persistent_id_disabled: Persistent ID is
        only available to teams with persistent ID SAML configuration. Please
        contact Dropbox for more information.
    :ivar str team.MemberAddResultBase.user_creation_failed: User creation has
        failed.
    """
    _catch_all = ...
    @classmethod
    def team_license_limit(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``team_license_limit`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def free_team_member_limit_reached(cls, val): # -> Self:
        """
        Create an instance of this class set to the
        ``free_team_member_limit_reached`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def user_already_on_team(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_already_on_team`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def user_on_another_team(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_on_another_team`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def user_already_paired(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_already_paired`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def user_migration_failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_migration_failed``
        tag with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def duplicate_external_member_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the
        ``duplicate_external_member_id`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def duplicate_member_persistent_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the
        ``duplicate_member_persistent_id`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def persistent_id_disabled(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``persistent_id_disabled``
        tag with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    @classmethod
    def user_creation_failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``user_creation_failed`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResultBase
        """
        ...
    
    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        ...
    
    def is_free_team_member_limit_reached(self):
        """
        Check if the union tag is ``free_team_member_limit_reached``.

        :rtype: bool
        """
        ...
    
    def is_user_already_on_team(self):
        """
        Check if the union tag is ``user_already_on_team``.

        :rtype: bool
        """
        ...
    
    def is_user_on_another_team(self):
        """
        Check if the union tag is ``user_on_another_team``.

        :rtype: bool
        """
        ...
    
    def is_user_already_paired(self):
        """
        Check if the union tag is ``user_already_paired``.

        :rtype: bool
        """
        ...
    
    def is_user_migration_failed(self):
        """
        Check if the union tag is ``user_migration_failed``.

        :rtype: bool
        """
        ...
    
    def is_duplicate_external_member_id(self):
        """
        Check if the union tag is ``duplicate_external_member_id``.

        :rtype: bool
        """
        ...
    
    def is_duplicate_member_persistent_id(self):
        """
        Check if the union tag is ``duplicate_member_persistent_id``.

        :rtype: bool
        """
        ...
    
    def is_persistent_id_disabled(self):
        """
        Check if the union tag is ``persistent_id_disabled``.

        :rtype: bool
        """
        ...
    
    def is_user_creation_failed(self):
        """
        Check if the union tag is ``user_creation_failed``.

        :rtype: bool
        """
        ...
    
    def get_team_license_limit(self): # -> None:
        """
        Team is already full. The organization has no available licenses.

        Only call this if :meth:`is_team_license_limit` is true.

        :rtype: str
        """
        ...
    
    def get_free_team_member_limit_reached(self): # -> None:
        """
        Team is already full. The free team member limit has been reached.

        Only call this if :meth:`is_free_team_member_limit_reached` is true.

        :rtype: str
        """
        ...
    
    def get_user_already_on_team(self): # -> None:
        """
        User is already on this team. The provided email address is associated
        with a user who is already a member of (including in recoverable state)
        or invited to the team.

        Only call this if :meth:`is_user_already_on_team` is true.

        :rtype: str
        """
        ...
    
    def get_user_on_another_team(self): # -> None:
        """
        User is already on another team. The provided email address is
        associated with a user that is already a member or invited to another
        team.

        Only call this if :meth:`is_user_on_another_team` is true.

        :rtype: str
        """
        ...
    
    def get_user_already_paired(self): # -> None:
        """
        User is already paired.

        Only call this if :meth:`is_user_already_paired` is true.

        :rtype: str
        """
        ...
    
    def get_user_migration_failed(self): # -> None:
        """
        User migration has failed.

        Only call this if :meth:`is_user_migration_failed` is true.

        :rtype: str
        """
        ...
    
    def get_duplicate_external_member_id(self): # -> None:
        """
        A user with the given external member ID already exists on the team
        (including in recoverable state).

        Only call this if :meth:`is_duplicate_external_member_id` is true.

        :rtype: str
        """
        ...
    
    def get_duplicate_member_persistent_id(self): # -> None:
        """
        A user with the given persistent ID already exists on the team
        (including in recoverable state).

        Only call this if :meth:`is_duplicate_member_persistent_id` is true.

        :rtype: str
        """
        ...
    
    def get_persistent_id_disabled(self): # -> None:
        """
        Persistent ID is only available to teams with persistent ID SAML
        configuration. Please contact Dropbox for more information.

        Only call this if :meth:`is_persistent_id_disabled` is true.

        :rtype: str
        """
        ...
    
    def get_user_creation_failed(self): # -> None:
        """
        User creation has failed.

        Only call this if :meth:`is_user_creation_failed` is true.

        :rtype: str
        """
        ...
    


MemberAddResultBase_validator = ...
class MemberAddResult(MemberAddResultBase):
    """
    Describes the result of attempting to add a single user to the team.
    'success' is the only value indicating that a user was indeed added to the
    team - the other values explain the type of failure that occurred, and
    include the email of the user for which the operation has failed.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamMemberInfo MemberAddResult.success: Describes a user that was
        successfully added to the team.
    """
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param TeamMemberInfo val:
        :rtype: MemberAddResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a user that was successfully added to the team.

        Only call this if :meth:`is_success` is true.

        :rtype: TeamMemberInfo
        """
        ...
    


MemberAddResult_validator = ...
class MemberAddV2Arg(MemberAddArgBase):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member_email=..., member_given_name=..., member_surname=..., member_external_id=..., member_persistent_id=..., send_welcome_email=..., is_directory_restricted=..., role_ids=...) -> None:
        ...
    
    role_ids = ...


MemberAddV2Arg_validator = ...
class MemberAddV2Result(MemberAddResultBase):
    """
    Describes the result of attempting to add a single user to the team.
    'success' is the only value indicating that a user was indeed added to the
    team - the other values explain the type of failure that occurred, and
    include the email of the user for which the operation has failed.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamMemberInfoV2 MemberAddV2Result.success: Describes a user that was
        successfully added to the team.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param TeamMemberInfoV2 val:
        :rtype: MemberAddV2Result
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a user that was successfully added to the team.

        Only call this if :meth:`is_success` is true.

        :rtype: TeamMemberInfoV2
        """
        ...
    


MemberAddV2Result_validator = ...
class MemberDevices(bb.Struct):
    """
    Information on devices of a team's member.

    :ivar team.MemberDevices.team_member_id: The member unique Id.
    :ivar team.MemberDevices.web_sessions: List of web sessions made by this
        team member.
    :ivar team.MemberDevices.desktop_clients: List of desktop clients by this
        team member.
    :ivar team.MemberDevices.mobile_clients: List of mobile clients by this team
        member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., web_sessions=..., desktop_clients=..., mobile_clients=...) -> None:
        ...
    
    team_member_id = ...
    web_sessions = ...
    desktop_clients = ...
    mobile_clients = ...


MemberDevices_validator = ...
class MemberLinkedApps(bb.Struct):
    """
    Information on linked applications of a team member.

    :ivar team.MemberLinkedApps.team_member_id: The member unique Id.
    :ivar team.MemberLinkedApps.linked_api_apps: List of third party
        applications linked by this team member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., linked_api_apps=...) -> None:
        ...
    
    team_member_id = ...
    linked_api_apps = ...


MemberLinkedApps_validator = ...
class MemberProfile(bb.Struct):
    """
    Basic member profile.

    :ivar team.MemberProfile.team_member_id: ID of user as a member of a team.
    :ivar team.MemberProfile.external_id: External ID that a team can attach to
        the user. An application using the API may find it easier to use their
        own IDs instead of Dropbox IDs like account_id or team_member_id.
    :ivar team.MemberProfile.account_id: A user's account identifier.
    :ivar team.MemberProfile.email: Email address of user.
    :ivar team.MemberProfile.email_verified: Is true if the user's email is
        verified to be owned by the user.
    :ivar team.MemberProfile.secondary_emails: Secondary emails of a user.
    :ivar team.MemberProfile.status: The user's status as a member of a specific
        team.
    :ivar team.MemberProfile.name: Representations for a person's name.
    :ivar team.MemberProfile.membership_type: The user's membership type: full
        (normal team member) vs limited (does not use a license; no access to
        the team's shared quota).
    :ivar team.MemberProfile.invited_on: The date and time the user was invited
        to the team (contains value only when the member's status matches
        ``TeamMemberStatus.invited``).
    :ivar team.MemberProfile.joined_on: The date and time the user joined as a
        member of a specific team.
    :ivar team.MemberProfile.suspended_on: The date and time the user was
        suspended from the team (contains value only when the member's status
        matches ``TeamMemberStatus.suspended``).
    :ivar team.MemberProfile.persistent_id: Persistent ID that a team can attach
        to the user. The persistent ID is unique ID to be used for SAML
        authentication.
    :ivar team.MemberProfile.is_directory_restricted: Whether the user is a
        directory restricted user.
    :ivar team.MemberProfile.profile_photo_url: URL for the photo representing
        the user, if one is set.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., email=..., email_verified=..., status=..., name=..., membership_type=..., external_id=..., account_id=..., secondary_emails=..., invited_on=..., joined_on=..., suspended_on=..., persistent_id=..., is_directory_restricted=..., profile_photo_url=...) -> None:
        ...
    
    team_member_id = ...
    external_id = ...
    account_id = ...
    email = ...
    email_verified = ...
    secondary_emails = ...
    status = ...
    name = ...
    membership_type = ...
    invited_on = ...
    joined_on = ...
    suspended_on = ...
    persistent_id = ...
    is_directory_restricted = ...
    profile_photo_url = ...


MemberProfile_validator = ...
class UserSelectorError(bb.Union):
    """
    Error that can be returned whenever a struct derived from
    :class:`UserSelectorArg` is used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.UserSelectorError.user_not_found: No matching user found. The
        provided team_member_id, email, or external_id does not exist on this
        team.
    """
    _catch_all = ...
    user_not_found = ...
    def is_user_not_found(self):
        """
        Check if the union tag is ``user_not_found``.

        :rtype: bool
        """
        ...
    


UserSelectorError_validator = ...
class MemberSelectorError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MemberSelectorError.user_not_in_team: The user is not a member of
        the team.
    """
    user_not_in_team = ...
    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        ...
    


MemberSelectorError_validator = ...
class MembersAddArgBase(bb.Struct):
    """
    :ivar team.MembersAddArgBase.force_async: Whether to force the add to happen
        asynchronously.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, force_async=...) -> None:
        ...
    
    force_async = ...


MembersAddArgBase_validator = ...
class MembersAddArg(MembersAddArgBase):
    """
    :ivar team.MembersAddArg.new_members: Details of new members to be added to
        the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, new_members=..., force_async=...) -> None:
        ...
    
    new_members = ...


MembersAddArg_validator = ...
class MembersAddJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [MemberAddResult] team.MembersAddJobStatus.complete: The
        asynchronous job has finished. For each member that was specified in the
        parameter :type:`MembersAddArg` that was provided to
        :route:`members/add`, a corresponding item is returned in this list.
    :ivar str team.MembersAddJobStatus.failed: The asynchronous job returned an
        error. The string contains an error message.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddResult] val:
        :rtype: MembersAddJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param str val:
        :rtype: MembersAddJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The asynchronous job has finished. For each member that was specified in
        the parameter :class:`MembersAddArg` that was provided to
        :meth:`dropbox.dropbox_client.Dropbox.team_members_add`, a corresponding
        item is returned in this list.

        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddResult]
        """
        ...
    
    def get_failed(self): # -> None:
        """
        The asynchronous job returned an error. The string contains an error
        message.

        Only call this if :meth:`is_failed` is true.

        :rtype: str
        """
        ...
    


MembersAddJobStatus_validator = ...
class MembersAddJobStatusV2Result(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [MemberAddV2Result] team.MembersAddJobStatusV2Result.complete:
        The asynchronous job has finished. For each member that was specified in
        the parameter :type:`MembersAddArg` that was provided to
        :route:`members/add:2`, a corresponding item is returned in this list.
    :ivar str team.MembersAddJobStatusV2Result.failed: The asynchronous job
        returned an error. The string contains an error message.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddV2Result] val:
        :rtype: MembersAddJobStatusV2Result
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param str val:
        :rtype: MembersAddJobStatusV2Result
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The asynchronous job has finished. For each member that was specified in
        the parameter :class:`MembersAddArg` that was provided to
        :meth:`dropbox.dropbox_client.Dropbox.team_members_add`, a corresponding
        item is returned in this list.

        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddV2Result]
        """
        ...
    
    def get_failed(self): # -> None:
        """
        The asynchronous job returned an error. The string contains an error
        message.

        Only call this if :meth:`is_failed` is true.

        :rtype: str
        """
        ...
    


MembersAddJobStatusV2Result_validator = ...
class MembersAddLaunch(async_.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddResult] val:
        :rtype: MembersAddLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddResult]
        """
        ...
    


MembersAddLaunch_validator = ...
class MembersAddLaunchV2Result(async_.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddV2Result] val:
        :rtype: MembersAddLaunchV2Result
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddV2Result]
        """
        ...
    


MembersAddLaunchV2Result_validator = ...
class MembersAddV2Arg(MembersAddArgBase):
    """
    :ivar team.MembersAddV2Arg.new_members: Details of new members to be added
        to the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, new_members=..., force_async=...) -> None:
        ...
    
    new_members = ...


MembersAddV2Arg_validator = ...
class MembersDeactivateBaseArg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar team.MembersDeactivateBaseArg.user: Identity of user to
        remove/suspend/have their files moved.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=...) -> None:
        ...
    
    user = ...


MembersDeactivateBaseArg_validator = ...
class MembersDataTransferArg(MembersDeactivateBaseArg):
    """
    :ivar team.MembersDataTransferArg.transfer_dest_id: Files from the deleted
        member account will be transferred to this user.
    :ivar team.MembersDataTransferArg.transfer_admin_id: Errors during the
        transfer process will be sent via email to this user.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., transfer_dest_id=..., transfer_admin_id=...) -> None:
        ...
    
    transfer_dest_id = ...
    transfer_admin_id = ...


MembersDataTransferArg_validator = ...
class MembersDeactivateArg(MembersDeactivateBaseArg):
    """
    :ivar team.MembersDeactivateArg.wipe_data: If provided, controls if the
        user's data will be deleted on their linked devices.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., wipe_data=...) -> None:
        ...
    
    wipe_data = ...


MembersDeactivateArg_validator = ...
class MembersDeactivateError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersDeactivateError.user_not_in_team: The user is not a member
        of the team.
    """
    _catch_all = ...
    user_not_in_team = ...
    other = ...
    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersDeactivateError_validator = ...
class MembersDeleteProfilePhotoArg(bb.Struct):
    """
    :ivar team.MembersDeleteProfilePhotoArg.user: Identity of the user whose
        profile photo will be deleted.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=...) -> None:
        ...
    
    user = ...


MembersDeleteProfilePhotoArg_validator = ...
class MembersDeleteProfilePhotoError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersDeleteProfilePhotoError.set_profile_disallowed: Modifying
        deleted users is not allowed.
    """
    _catch_all = ...
    set_profile_disallowed = ...
    other = ...
    def is_set_profile_disallowed(self):
        """
        Check if the union tag is ``set_profile_disallowed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersDeleteProfilePhotoError_validator = ...
class MembersGetAvailableTeamMemberRolesResult(bb.Struct):
    """
    Available TeamMemberRole for the connected team. To be used with
    :meth:`dropbox.dropbox_client.Dropbox.team_members_set_admin_permissions`.

    :ivar team.MembersGetAvailableTeamMemberRolesResult.roles: Available roles.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, roles=...) -> None:
        ...
    
    roles = ...


MembersGetAvailableTeamMemberRolesResult_validator = ...
class MembersGetInfoArgs(bb.Struct):
    """
    :ivar team.MembersGetInfoArgs.members: List of team members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members=...) -> None:
        ...
    
    members = ...


MembersGetInfoArgs_validator = ...
class MembersGetInfoError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersGetInfoError_validator = ...
class MembersGetInfoItemBase(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.MembersGetInfoItemBase.id_not_found: An ID that was provided
        as a parameter to :route:`members/get_info` or
        :route:`members/get_info:2`, and did not match a corresponding user.
        This might be a team_member_id, an email, or an external ID, depending
        on how the method was called.
    """
    _catch_all = ...
    @classmethod
    def id_not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: MembersGetInfoItemBase
        """
        ...
    
    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        ...
    
    def get_id_not_found(self): # -> None:
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox_client.Dropbox.team_members_get_info` or
        :meth:`dropbox.dropbox_client.Dropbox.team_members_get_info`, and did
        not match a corresponding user. This might be a team_member_id, an
        email, or an external ID, depending on how the method was called.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        ...
    


MembersGetInfoItemBase_validator = ...
class MembersGetInfoItem(MembersGetInfoItemBase):
    """
    Describes a result obtained for a single user whose id was specified in the
    parameter of :meth:`dropbox.dropbox_client.Dropbox.team_members_get_info`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamMemberInfo MembersGetInfoItem.member_info: Info about a team
        member.
    """
    @classmethod
    def member_info(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``member_info`` tag with
        value ``val``.

        :param TeamMemberInfo val:
        :rtype: MembersGetInfoItem
        """
        ...
    
    def is_member_info(self):
        """
        Check if the union tag is ``member_info``.

        :rtype: bool
        """
        ...
    
    def get_member_info(self): # -> None:
        """
        Info about a team member.

        Only call this if :meth:`is_member_info` is true.

        :rtype: TeamMemberInfo
        """
        ...
    


MembersGetInfoItem_validator = ...
class MembersGetInfoItemV2(MembersGetInfoItemBase):
    """
    Describes a result obtained for a single user whose id was specified in the
    parameter of :meth:`dropbox.dropbox_client.Dropbox.team_members_get_info`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamMemberInfoV2 MembersGetInfoItemV2.member_info: Info about a team
        member.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def member_info(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``member_info`` tag with
        value ``val``.

        :param TeamMemberInfoV2 val:
        :rtype: MembersGetInfoItemV2
        """
        ...
    
    def is_member_info(self):
        """
        Check if the union tag is ``member_info``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_member_info(self): # -> None:
        """
        Info about a team member.

        Only call this if :meth:`is_member_info` is true.

        :rtype: TeamMemberInfoV2
        """
        ...
    


MembersGetInfoItemV2_validator = ...
class MembersGetInfoV2Arg(bb.Struct):
    """
    :ivar team.MembersGetInfoV2Arg.members: List of team members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members=...) -> None:
        ...
    
    members = ...


MembersGetInfoV2Arg_validator = ...
class MembersGetInfoV2Result(bb.Struct):
    """
    :ivar team.MembersGetInfoV2Result.members_info: List of team members info.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members_info=...) -> None:
        ...
    
    members_info = ...


MembersGetInfoV2Result_validator = ...
class MembersInfo(bb.Struct):
    """
    :ivar team.MembersInfo.team_member_ids: Team member IDs of the users under
        this hold.
    :ivar team.MembersInfo.permanently_deleted_users: The number of permanently
        deleted users that were under this hold.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_ids=..., permanently_deleted_users=...) -> None:
        ...
    
    team_member_ids = ...
    permanently_deleted_users = ...


MembersInfo_validator = ...
class MembersListArg(bb.Struct):
    """
    :ivar team.MembersListArg.limit: Number of results to return per call.
    :ivar team.MembersListArg.include_removed: Whether to return removed
        members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=..., include_removed=...) -> None:
        ...
    
    limit = ...
    include_removed = ...


MembersListArg_validator = ...
class MembersListContinueArg(bb.Struct):
    """
    :ivar team.MembersListContinueArg.cursor: Indicates from what point to get
        the next set of members.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


MembersListContinueArg_validator = ...
class MembersListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersListContinueError.invalid_cursor: The cursor is invalid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersListContinueError_validator = ...
class MembersListError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersListError_validator = ...
class MembersListResult(bb.Struct):
    """
    :ivar team.MembersListResult.members: List of team members.
    :ivar team.MembersListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_members_list_continue` to
        obtain the additional members.
    :ivar team.MembersListResult.has_more: Is true if there are additional team
        members that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_members_list_continue` can
        retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members=..., cursor=..., has_more=...) -> None:
        ...
    
    members = ...
    cursor = ...
    has_more = ...


MembersListResult_validator = ...
class MembersListV2Result(bb.Struct):
    """
    :ivar team.MembersListV2Result.members: List of team members.
    :ivar team.MembersListV2Result.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_members_list_continue` to
        obtain the additional members.
    :ivar team.MembersListV2Result.has_more: Is true if there are additional
        team members that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_members_list_continue` can
        retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, members=..., cursor=..., has_more=...) -> None:
        ...
    
    members = ...
    cursor = ...
    has_more = ...


MembersListV2Result_validator = ...
class MembersRecoverArg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar team.MembersRecoverArg.user: Identity of user to recover.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=...) -> None:
        ...
    
    user = ...


MembersRecoverArg_validator = ...
class MembersRecoverError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersRecoverError.user_unrecoverable: The user is not
        recoverable.
    :ivar team.MembersRecoverError.user_not_in_team: The user is not a member of
        the team.
    :ivar team.MembersRecoverError.team_license_limit: Team is full. The
        organization has no available licenses.
    """
    _catch_all = ...
    user_unrecoverable = ...
    user_not_in_team = ...
    team_license_limit = ...
    other = ...
    def is_user_unrecoverable(self):
        """
        Check if the union tag is ``user_unrecoverable``.

        :rtype: bool
        """
        ...
    
    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersRecoverError_validator = ...
class MembersRemoveArg(MembersDeactivateArg):
    """
    :ivar team.MembersRemoveArg.transfer_dest_id: If provided, files from the
        deleted member account will be transferred to this user.
    :ivar team.MembersRemoveArg.transfer_admin_id: If provided, errors during
        the transfer process will be sent via email to this user. If the
        transfer_dest_id argument was provided, then this argument must be
        provided as well.
    :ivar team.MembersRemoveArg.keep_account: Downgrade the member to a Basic
        account. The user will retain the email address associated with their
        Dropbox  account and data in their account that is not restricted to
        team members. In order to keep the account the argument ``wipe_data``
        should be set to ``False``.
    :ivar team.MembersRemoveArg.retain_team_shares: If provided, allows removed
        users to keep access to Dropbox folders (not Dropbox Paper folders)
        already explicitly shared with them (not via a group) when they are
        downgraded to a Basic account. Users will not retain access to folders
        that do not allow external sharing. In order to keep the sharing
        relationships, the arguments ``wipe_data`` should be set to ``False``
        and ``keep_account`` should be set to ``True``.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., wipe_data=..., transfer_dest_id=..., transfer_admin_id=..., keep_account=..., retain_team_shares=...) -> None:
        ...
    
    transfer_dest_id = ...
    transfer_admin_id = ...
    keep_account = ...
    retain_team_shares = ...


MembersRemoveArg_validator = ...
class MembersTransferFilesError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar
        team.MembersTransferFilesError.removed_and_transfer_dest_should_differ:
        Expected removed user and transfer_dest user to be different.
    :ivar
        team.MembersTransferFilesError.removed_and_transfer_admin_should_differ:
        Expected removed user and transfer_admin user to be different.
    :ivar team.MembersTransferFilesError.transfer_dest_user_not_found: No
        matching user found for the argument transfer_dest_id.
    :ivar team.MembersTransferFilesError.transfer_dest_user_not_in_team: The
        provided transfer_dest_id does not exist on this team.
    :ivar team.MembersTransferFilesError.transfer_admin_user_not_in_team: The
        provided transfer_admin_id does not exist on this team.
    :ivar team.MembersTransferFilesError.transfer_admin_user_not_found: No
        matching user found for the argument transfer_admin_id.
    :ivar team.MembersTransferFilesError.unspecified_transfer_admin_id: The
        transfer_admin_id argument must be provided when file transfer is
        requested.
    :ivar team.MembersTransferFilesError.transfer_admin_is_not_admin: Specified
        transfer_admin user is not a team admin.
    :ivar team.MembersTransferFilesError.recipient_not_verified: The recipient
        user's email is not verified.
    """
    removed_and_transfer_dest_should_differ = ...
    removed_and_transfer_admin_should_differ = ...
    transfer_dest_user_not_found = ...
    transfer_dest_user_not_in_team = ...
    transfer_admin_user_not_in_team = ...
    transfer_admin_user_not_found = ...
    unspecified_transfer_admin_id = ...
    transfer_admin_is_not_admin = ...
    recipient_not_verified = ...
    def is_removed_and_transfer_dest_should_differ(self):
        """
        Check if the union tag is ``removed_and_transfer_dest_should_differ``.

        :rtype: bool
        """
        ...
    
    def is_removed_and_transfer_admin_should_differ(self):
        """
        Check if the union tag is ``removed_and_transfer_admin_should_differ``.

        :rtype: bool
        """
        ...
    
    def is_transfer_dest_user_not_found(self):
        """
        Check if the union tag is ``transfer_dest_user_not_found``.

        :rtype: bool
        """
        ...
    
    def is_transfer_dest_user_not_in_team(self):
        """
        Check if the union tag is ``transfer_dest_user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_transfer_admin_user_not_in_team(self):
        """
        Check if the union tag is ``transfer_admin_user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_transfer_admin_user_not_found(self):
        """
        Check if the union tag is ``transfer_admin_user_not_found``.

        :rtype: bool
        """
        ...
    
    def is_unspecified_transfer_admin_id(self):
        """
        Check if the union tag is ``unspecified_transfer_admin_id``.

        :rtype: bool
        """
        ...
    
    def is_transfer_admin_is_not_admin(self):
        """
        Check if the union tag is ``transfer_admin_is_not_admin``.

        :rtype: bool
        """
        ...
    
    def is_recipient_not_verified(self):
        """
        Check if the union tag is ``recipient_not_verified``.

        :rtype: bool
        """
        ...
    


MembersTransferFilesError_validator = ...
class MembersRemoveError(MembersTransferFilesError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersRemoveError.remove_last_admin: The user is the last admin
        of the team, so it cannot be removed from it.
    :ivar team.MembersRemoveError.cannot_keep_account_and_transfer: Cannot keep
        account and transfer the data to another user at the same time.
    :ivar team.MembersRemoveError.cannot_keep_account_and_delete_data: Cannot
        keep account and delete the data at the same time. To keep the account
        the argument wipe_data should be set to ``False``.
    :ivar team.MembersRemoveError.email_address_too_long_to_be_disabled: The
        email address of the user is too long to be disabled.
    :ivar team.MembersRemoveError.cannot_keep_invited_user_account: Cannot keep
        account of an invited user.
    :ivar team.MembersRemoveError.cannot_retain_shares_when_data_wiped: Cannot
        retain team shares when the user's data is marked for deletion on their
        linked devices. The argument wipe_data should be set to ``False``.
    :ivar team.MembersRemoveError.cannot_retain_shares_when_no_account_kept: The
        user's account must be kept in order to retain team shares. The argument
        keep_account should be set to ``True``.
    :ivar
        team.MembersRemoveError.cannot_retain_shares_when_team_external_sharing_off:
        Externally sharing files, folders, and links must be enabled in team
        settings in order to retain team shares for the user.
    :ivar team.MembersRemoveError.cannot_keep_account: Only a team admin, can
        convert this account to a Basic account.
    :ivar team.MembersRemoveError.cannot_keep_account_under_legal_hold: This
        user content is currently being held. To convert this member's account
        to a Basic account, you'll first need to remove them from the hold.
    :ivar team.MembersRemoveError.cannot_keep_account_required_to_sign_tos: To
        convert this member to a Basic account, they'll first need to sign in to
        Dropbox and agree to the terms of service.
    """
    remove_last_admin = ...
    cannot_keep_account_and_transfer = ...
    cannot_keep_account_and_delete_data = ...
    email_address_too_long_to_be_disabled = ...
    cannot_keep_invited_user_account = ...
    cannot_retain_shares_when_data_wiped = ...
    cannot_retain_shares_when_no_account_kept = ...
    cannot_retain_shares_when_team_external_sharing_off = ...
    cannot_keep_account = ...
    cannot_keep_account_under_legal_hold = ...
    cannot_keep_account_required_to_sign_tos = ...
    def is_remove_last_admin(self):
        """
        Check if the union tag is ``remove_last_admin``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_account_and_transfer(self):
        """
        Check if the union tag is ``cannot_keep_account_and_transfer``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_account_and_delete_data(self):
        """
        Check if the union tag is ``cannot_keep_account_and_delete_data``.

        :rtype: bool
        """
        ...
    
    def is_email_address_too_long_to_be_disabled(self):
        """
        Check if the union tag is ``email_address_too_long_to_be_disabled``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_invited_user_account(self):
        """
        Check if the union tag is ``cannot_keep_invited_user_account``.

        :rtype: bool
        """
        ...
    
    def is_cannot_retain_shares_when_data_wiped(self):
        """
        Check if the union tag is ``cannot_retain_shares_when_data_wiped``.

        :rtype: bool
        """
        ...
    
    def is_cannot_retain_shares_when_no_account_kept(self):
        """
        Check if the union tag is ``cannot_retain_shares_when_no_account_kept``.

        :rtype: bool
        """
        ...
    
    def is_cannot_retain_shares_when_team_external_sharing_off(self):
        """
        Check if the union tag is ``cannot_retain_shares_when_team_external_sharing_off``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_account(self):
        """
        Check if the union tag is ``cannot_keep_account``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_account_under_legal_hold(self):
        """
        Check if the union tag is ``cannot_keep_account_under_legal_hold``.

        :rtype: bool
        """
        ...
    
    def is_cannot_keep_account_required_to_sign_tos(self):
        """
        Check if the union tag is ``cannot_keep_account_required_to_sign_tos``.

        :rtype: bool
        """
        ...
    


MembersRemoveError_validator = ...
class MembersSendWelcomeError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersSendWelcomeError_validator = ...
class MembersSetPermissions2Arg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar team.MembersSetPermissions2Arg.user: Identity of user whose role will
        be set.
    :ivar team.MembersSetPermissions2Arg.new_roles: The new roles for the
        member. Send empty list to make user member only. For now, only up to
        one role is allowed.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., new_roles=...) -> None:
        ...
    
    user = ...
    new_roles = ...


MembersSetPermissions2Arg_validator = ...
class MembersSetPermissions2Error(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersSetPermissions2Error.last_admin: Cannot remove the admin
        setting of the last admin.
    :ivar team.MembersSetPermissions2Error.user_not_in_team: The user is not a
        member of the team.
    :ivar team.MembersSetPermissions2Error.cannot_set_permissions: Cannot
        remove/grant permissions. This can happen if the team member is
        suspended.
    :ivar team.MembersSetPermissions2Error.role_not_found: No matching role
        found. At least one of the provided new_roles does not exist on this
        team.
    """
    _catch_all = ...
    last_admin = ...
    user_not_in_team = ...
    cannot_set_permissions = ...
    role_not_found = ...
    other = ...
    def is_last_admin(self):
        """
        Check if the union tag is ``last_admin``.

        :rtype: bool
        """
        ...
    
    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_cannot_set_permissions(self):
        """
        Check if the union tag is ``cannot_set_permissions``.

        :rtype: bool
        """
        ...
    
    def is_role_not_found(self):
        """
        Check if the union tag is ``role_not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersSetPermissions2Error_validator = ...
class MembersSetPermissions2Result(bb.Struct):
    """
    :ivar team.MembersSetPermissions2Result.team_member_id: The member ID of the
        user to which the change was applied.
    :ivar team.MembersSetPermissions2Result.roles: The roles after the change.
        Empty in case the user become a non-admin.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., roles=...) -> None:
        ...
    
    team_member_id = ...
    roles = ...


MembersSetPermissions2Result_validator = ...
class MembersSetPermissionsArg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar team.MembersSetPermissionsArg.user: Identity of user whose role will
        be set.
    :ivar team.MembersSetPermissionsArg.new_role: The new role of the member.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., new_role=...) -> None:
        ...
    
    user = ...
    new_role = ...


MembersSetPermissionsArg_validator = ...
class MembersSetPermissionsError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersSetPermissionsError.last_admin: Cannot remove the admin
        setting of the last admin.
    :ivar team.MembersSetPermissionsError.user_not_in_team: The user is not a
        member of the team.
    :ivar team.MembersSetPermissionsError.cannot_set_permissions: Cannot
        remove/grant permissions.
    :ivar team.MembersSetPermissionsError.team_license_limit: Team is full. The
        organization has no available licenses.
    """
    _catch_all = ...
    last_admin = ...
    user_not_in_team = ...
    cannot_set_permissions = ...
    team_license_limit = ...
    other = ...
    def is_last_admin(self):
        """
        Check if the union tag is ``last_admin``.

        :rtype: bool
        """
        ...
    
    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        ...
    
    def is_cannot_set_permissions(self):
        """
        Check if the union tag is ``cannot_set_permissions``.

        :rtype: bool
        """
        ...
    
    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersSetPermissionsError_validator = ...
class MembersSetPermissionsResult(bb.Struct):
    """
    :ivar team.MembersSetPermissionsResult.team_member_id: The member ID of the
        user to which the change was applied.
    :ivar team.MembersSetPermissionsResult.role: The role after the change.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., role=...) -> None:
        ...
    
    team_member_id = ...
    role = ...


MembersSetPermissionsResult_validator = ...
class MembersSetProfileArg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account. At least one of new_email, new_external_id,
    new_given_name, and/or new_surname must be provided.

    :ivar team.MembersSetProfileArg.user: Identity of user whose profile will be
        set.
    :ivar team.MembersSetProfileArg.new_email: New email for member.
    :ivar team.MembersSetProfileArg.new_external_id: New external ID for member.
    :ivar team.MembersSetProfileArg.new_given_name: New given name for member.
    :ivar team.MembersSetProfileArg.new_surname: New surname for member.
    :ivar team.MembersSetProfileArg.new_persistent_id: New persistent ID. This
        field only available to teams using persistent ID SAML configuration.
    :ivar team.MembersSetProfileArg.new_is_directory_restricted: New value for
        whether the user is a directory restricted user.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., new_email=..., new_external_id=..., new_given_name=..., new_surname=..., new_persistent_id=..., new_is_directory_restricted=...) -> None:
        ...
    
    user = ...
    new_email = ...
    new_external_id = ...
    new_given_name = ...
    new_surname = ...
    new_persistent_id = ...
    new_is_directory_restricted = ...


MembersSetProfileArg_validator = ...
class MembersSetProfileError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersSetProfileError.external_id_and_new_external_id_unsafe: It
        is unsafe to use both external_id and new_external_id.
    :ivar team.MembersSetProfileError.no_new_data_specified: None of new_email,
        new_given_name, new_surname, or new_external_id are specified.
    :ivar team.MembersSetProfileError.email_reserved_for_other_user: Email is
        already reserved for another user.
    :ivar team.MembersSetProfileError.external_id_used_by_other_user: The
        external ID is already in use by another team member.
    :ivar team.MembersSetProfileError.set_profile_disallowed: Modifying deleted
        users is not allowed.
    :ivar team.MembersSetProfileError.param_cannot_be_empty: Parameter new_email
        cannot be empty.
    :ivar team.MembersSetProfileError.persistent_id_disabled: Persistent ID is
        only available to teams with persistent ID SAML configuration. Please
        contact Dropbox for more information.
    :ivar team.MembersSetProfileError.persistent_id_used_by_other_user: The
        persistent ID is already in use by another team member.
    :ivar team.MembersSetProfileError.directory_restricted_off: Directory
        Restrictions option is not available.
    """
    _catch_all = ...
    external_id_and_new_external_id_unsafe = ...
    no_new_data_specified = ...
    email_reserved_for_other_user = ...
    external_id_used_by_other_user = ...
    set_profile_disallowed = ...
    param_cannot_be_empty = ...
    persistent_id_disabled = ...
    persistent_id_used_by_other_user = ...
    directory_restricted_off = ...
    other = ...
    def is_external_id_and_new_external_id_unsafe(self):
        """
        Check if the union tag is ``external_id_and_new_external_id_unsafe``.

        :rtype: bool
        """
        ...
    
    def is_no_new_data_specified(self):
        """
        Check if the union tag is ``no_new_data_specified``.

        :rtype: bool
        """
        ...
    
    def is_email_reserved_for_other_user(self):
        """
        Check if the union tag is ``email_reserved_for_other_user``.

        :rtype: bool
        """
        ...
    
    def is_external_id_used_by_other_user(self):
        """
        Check if the union tag is ``external_id_used_by_other_user``.

        :rtype: bool
        """
        ...
    
    def is_set_profile_disallowed(self):
        """
        Check if the union tag is ``set_profile_disallowed``.

        :rtype: bool
        """
        ...
    
    def is_param_cannot_be_empty(self):
        """
        Check if the union tag is ``param_cannot_be_empty``.

        :rtype: bool
        """
        ...
    
    def is_persistent_id_disabled(self):
        """
        Check if the union tag is ``persistent_id_disabled``.

        :rtype: bool
        """
        ...
    
    def is_persistent_id_used_by_other_user(self):
        """
        Check if the union tag is ``persistent_id_used_by_other_user``.

        :rtype: bool
        """
        ...
    
    def is_directory_restricted_off(self):
        """
        Check if the union tag is ``directory_restricted_off``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MembersSetProfileError_validator = ...
class MembersSetProfilePhotoArg(bb.Struct):
    """
    :ivar team.MembersSetProfilePhotoArg.user: Identity of the user whose
        profile photo will be set.
    :ivar team.MembersSetProfilePhotoArg.photo: Image to set as the member's new
        profile photo.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., photo=...) -> None:
        ...
    
    user = ...
    photo = ...


MembersSetProfilePhotoArg_validator = ...
class MembersSetProfilePhotoError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersSetProfilePhotoError.set_profile_disallowed: Modifying
        deleted users is not allowed.
    """
    _catch_all = ...
    set_profile_disallowed = ...
    other = ...
    @classmethod
    def photo_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``photo_error`` tag with
        value ``val``.

        :param account.SetProfilePhotoError val:
        :rtype: MembersSetProfilePhotoError
        """
        ...
    
    def is_set_profile_disallowed(self):
        """
        Check if the union tag is ``set_profile_disallowed``.

        :rtype: bool
        """
        ...
    
    def is_photo_error(self):
        """
        Check if the union tag is ``photo_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_photo_error(self): # -> None:
        """
        Only call this if :meth:`is_photo_error` is true.

        :rtype: account.SetProfilePhotoError
        """
        ...
    


MembersSetProfilePhotoError_validator = ...
class MembersSuspendError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersSuspendError.suspend_inactive_user: The user is not
        active, so it cannot be suspended.
    :ivar team.MembersSuspendError.suspend_last_admin: The user is the last
        admin of the team, so it cannot be suspended.
    :ivar team.MembersSuspendError.team_license_limit: Team is full. The
        organization has no available licenses.
    """
    suspend_inactive_user = ...
    suspend_last_admin = ...
    team_license_limit = ...
    def is_suspend_inactive_user(self):
        """
        Check if the union tag is ``suspend_inactive_user``.

        :rtype: bool
        """
        ...
    
    def is_suspend_last_admin(self):
        """
        Check if the union tag is ``suspend_last_admin``.

        :rtype: bool
        """
        ...
    
    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        ...
    


MembersSuspendError_validator = ...
class MembersTransferFormerMembersFilesError(MembersTransferFilesError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar
        team.MembersTransferFormerMembersFilesError.user_data_is_being_transferred:
        The user's data is being transferred. Please wait some time before
        retrying.
    :ivar team.MembersTransferFormerMembersFilesError.user_not_removed: No
        matching removed user found for the argument user.
    :ivar
        team.MembersTransferFormerMembersFilesError.user_data_cannot_be_transferred:
        User files aren't transferable anymore.
    :ivar
        team.MembersTransferFormerMembersFilesError.user_data_already_transferred:
        User's data has already been transferred to another user.
    """
    user_data_is_being_transferred = ...
    user_not_removed = ...
    user_data_cannot_be_transferred = ...
    user_data_already_transferred = ...
    def is_user_data_is_being_transferred(self):
        """
        Check if the union tag is ``user_data_is_being_transferred``.

        :rtype: bool
        """
        ...
    
    def is_user_not_removed(self):
        """
        Check if the union tag is ``user_not_removed``.

        :rtype: bool
        """
        ...
    
    def is_user_data_cannot_be_transferred(self):
        """
        Check if the union tag is ``user_data_cannot_be_transferred``.

        :rtype: bool
        """
        ...
    
    def is_user_data_already_transferred(self):
        """
        Check if the union tag is ``user_data_already_transferred``.

        :rtype: bool
        """
        ...
    


MembersTransferFormerMembersFilesError_validator = ...
class MembersUnsuspendArg(bb.Struct):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar team.MembersUnsuspendArg.user: Identity of user to unsuspend.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=...) -> None:
        ...
    
    user = ...


MembersUnsuspendArg_validator = ...
class MembersUnsuspendError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MembersUnsuspendError.unsuspend_non_suspended_member: The user is
        unsuspended, so it cannot be unsuspended again.
    :ivar team.MembersUnsuspendError.team_license_limit: Team is full. The
        organization has no available licenses.
    """
    unsuspend_non_suspended_member = ...
    team_license_limit = ...
    def is_unsuspend_non_suspended_member(self):
        """
        Check if the union tag is ``unsuspend_non_suspended_member``.

        :rtype: bool
        """
        ...
    
    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        ...
    


MembersUnsuspendError_validator = ...
class MobileClientPlatform(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.MobileClientPlatform.iphone: Official Dropbox iPhone client.
    :ivar team.MobileClientPlatform.ipad: Official Dropbox iPad client.
    :ivar team.MobileClientPlatform.android: Official Dropbox Android client.
    :ivar team.MobileClientPlatform.windows_phone: Official Dropbox Windows
        phone client.
    :ivar team.MobileClientPlatform.blackberry: Official Dropbox Blackberry
        client.
    """
    _catch_all = ...
    iphone = ...
    ipad = ...
    android = ...
    windows_phone = ...
    blackberry = ...
    other = ...
    def is_iphone(self):
        """
        Check if the union tag is ``iphone``.

        :rtype: bool
        """
        ...
    
    def is_ipad(self):
        """
        Check if the union tag is ``ipad``.

        :rtype: bool
        """
        ...
    
    def is_android(self):
        """
        Check if the union tag is ``android``.

        :rtype: bool
        """
        ...
    
    def is_windows_phone(self):
        """
        Check if the union tag is ``windows_phone``.

        :rtype: bool
        """
        ...
    
    def is_blackberry(self):
        """
        Check if the union tag is ``blackberry``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


MobileClientPlatform_validator = ...
class MobileClientSession(DeviceSession):
    """
    Information about linked Dropbox mobile client sessions.

    :ivar team.MobileClientSession.device_name: The device name.
    :ivar team.MobileClientSession.client_type: The mobile application type.
    :ivar team.MobileClientSession.client_version: The dropbox client version.
    :ivar team.MobileClientSession.os_version: The hosting OS version.
    :ivar team.MobileClientSession.last_carrier: last carrier used by the
        device.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., device_name=..., client_type=..., ip_address=..., country=..., created=..., updated=..., client_version=..., os_version=..., last_carrier=...) -> None:
        ...
    
    device_name = ...
    client_type = ...
    client_version = ...
    os_version = ...
    last_carrier = ...


MobileClientSession_validator = ...
class NamespaceMetadata(bb.Struct):
    """
    Properties of a namespace.

    :ivar team.NamespaceMetadata.name: The name of this namespace.
    :ivar team.NamespaceMetadata.namespace_id: The ID of this namespace.
    :ivar team.NamespaceMetadata.namespace_type: The type of this namespace.
    :ivar team.NamespaceMetadata.team_member_id: If this is a team member or app
        folder, the ID of the owning team member. Otherwise, this field is not
        present.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., namespace_id=..., namespace_type=..., team_member_id=...) -> None:
        ...
    
    name = ...
    namespace_id = ...
    namespace_type = ...
    team_member_id = ...


NamespaceMetadata_validator = ...
class NamespaceType(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.NamespaceType.app_folder: App sandbox folder.
    :ivar team.NamespaceType.shared_folder: Shared folder.
    :ivar team.NamespaceType.team_folder: Top-level team-owned folder.
    :ivar team.NamespaceType.team_member_folder: Team member's home folder.
    """
    _catch_all = ...
    app_folder = ...
    shared_folder = ...
    team_folder = ...
    team_member_folder = ...
    other = ...
    def is_app_folder(self):
        """
        Check if the union tag is ``app_folder``.

        :rtype: bool
        """
        ...
    
    def is_shared_folder(self):
        """
        Check if the union tag is ``shared_folder``.

        :rtype: bool
        """
        ...
    
    def is_team_folder(self):
        """
        Check if the union tag is ``team_folder``.

        :rtype: bool
        """
        ...
    
    def is_team_member_folder(self):
        """
        Check if the union tag is ``team_member_folder``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


NamespaceType_validator = ...
class RemoveCustomQuotaResult(bb.Union):
    """
    User result for setting member custom quota.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserSelectorArg RemoveCustomQuotaResult.success: Successfully removed
        user.
    :ivar UserSelectorArg RemoveCustomQuotaResult.invalid_user: Invalid user
        (not in team).
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param UserSelectorArg val:
        :rtype: RemoveCustomQuotaResult
        """
        ...
    
    @classmethod
    def invalid_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_user`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: RemoveCustomQuotaResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_invalid_user(self):
        """
        Check if the union tag is ``invalid_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Successfully removed user.

        Only call this if :meth:`is_success` is true.

        :rtype: UserSelectorArg
        """
        ...
    
    def get_invalid_user(self): # -> None:
        """
        Invalid user (not in team).

        Only call this if :meth:`is_invalid_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    


RemoveCustomQuotaResult_validator = ...
class RemovedStatus(bb.Struct):
    """
    :ivar team.RemovedStatus.is_recoverable: True if the removed team member is
        recoverable.
    :ivar team.RemovedStatus.is_disconnected: True if the team member's account
        was converted to individual account.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, is_recoverable=..., is_disconnected=...) -> None:
        ...
    
    is_recoverable = ...
    is_disconnected = ...


RemovedStatus_validator = ...
class ResendSecondaryEmailResult(bb.Union):
    """
    Result of trying to resend verification email to a secondary email address.
    'success' is the only value indicating that a verification email was
    successfully sent. The other values explain the type of error that occurred,
    and include the email for which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.ResendSecondaryEmailResult.success: A verification email was
        successfully sent to the secondary email address.
    :ivar str team.ResendSecondaryEmailResult.not_pending: This secondary email
        address is not pending for the user.
    :ivar str team.ResendSecondaryEmailResult.rate_limited: Too many emails are
        being sent to this email address. Please try again later.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param str val:
        :rtype: ResendSecondaryEmailResult
        """
        ...
    
    @classmethod
    def not_pending(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``not_pending`` tag with
        value ``val``.

        :param str val:
        :rtype: ResendSecondaryEmailResult
        """
        ...
    
    @classmethod
    def rate_limited(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``rate_limited`` tag with
        value ``val``.

        :param str val:
        :rtype: ResendSecondaryEmailResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_not_pending(self):
        """
        Check if the union tag is ``not_pending``.

        :rtype: bool
        """
        ...
    
    def is_rate_limited(self):
        """
        Check if the union tag is ``rate_limited``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        A verification email was successfully sent to the secondary email
        address.

        Only call this if :meth:`is_success` is true.

        :rtype: str
        """
        ...
    
    def get_not_pending(self): # -> None:
        """
        This secondary email address is not pending for the user.

        Only call this if :meth:`is_not_pending` is true.

        :rtype: str
        """
        ...
    
    def get_rate_limited(self): # -> None:
        """
        Too many emails are being sent to this email address. Please try again
        later.

        Only call this if :meth:`is_rate_limited` is true.

        :rtype: str
        """
        ...
    


ResendSecondaryEmailResult_validator = ...
class ResendVerificationEmailArg(bb.Struct):
    """
    :ivar team.ResendVerificationEmailArg.emails_to_resend: List of users and
        secondary emails to resend verification emails to.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, emails_to_resend=...) -> None:
        ...
    
    emails_to_resend = ...


ResendVerificationEmailArg_validator = ...
class ResendVerificationEmailResult(bb.Struct):
    """
    List of users and resend results.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, results=...) -> None:
        ...
    
    results = ...


ResendVerificationEmailResult_validator = ...
class RevokeDesktopClientArg(DeviceSessionArg):
    """
    :ivar team.RevokeDesktopClientArg.delete_on_unlink: Whether to delete all
        files of the account (this is possible only if supported by the desktop
        client and  will be made the next time the client access the account).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, session_id=..., team_member_id=..., delete_on_unlink=...) -> None:
        ...
    
    delete_on_unlink = ...


RevokeDesktopClientArg_validator = ...
class RevokeDeviceSessionArg(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar DeviceSessionArg RevokeDeviceSessionArg.web_session: End an active
        session.
    :ivar RevokeDesktopClientArg RevokeDeviceSessionArg.desktop_client: Unlink a
        linked desktop device.
    :ivar DeviceSessionArg RevokeDeviceSessionArg.mobile_client: Unlink a linked
        mobile device.
    """
    _catch_all = ...
    @classmethod
    def web_session(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``web_session`` tag with
        value ``val``.

        :param DeviceSessionArg val:
        :rtype: RevokeDeviceSessionArg
        """
        ...
    
    @classmethod
    def desktop_client(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``desktop_client`` tag with
        value ``val``.

        :param RevokeDesktopClientArg val:
        :rtype: RevokeDeviceSessionArg
        """
        ...
    
    @classmethod
    def mobile_client(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``mobile_client`` tag with
        value ``val``.

        :param DeviceSessionArg val:
        :rtype: RevokeDeviceSessionArg
        """
        ...
    
    def is_web_session(self):
        """
        Check if the union tag is ``web_session``.

        :rtype: bool
        """
        ...
    
    def is_desktop_client(self):
        """
        Check if the union tag is ``desktop_client``.

        :rtype: bool
        """
        ...
    
    def is_mobile_client(self):
        """
        Check if the union tag is ``mobile_client``.

        :rtype: bool
        """
        ...
    
    def get_web_session(self): # -> None:
        """
        End an active session.

        Only call this if :meth:`is_web_session` is true.

        :rtype: DeviceSessionArg
        """
        ...
    
    def get_desktop_client(self): # -> None:
        """
        Unlink a linked desktop device.

        Only call this if :meth:`is_desktop_client` is true.

        :rtype: RevokeDesktopClientArg
        """
        ...
    
    def get_mobile_client(self): # -> None:
        """
        Unlink a linked mobile device.

        Only call this if :meth:`is_mobile_client` is true.

        :rtype: DeviceSessionArg
        """
        ...
    


RevokeDeviceSessionArg_validator = ...
class RevokeDeviceSessionBatchArg(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, revoke_devices=...) -> None:
        ...
    
    revoke_devices = ...


RevokeDeviceSessionBatchArg_validator = ...
class RevokeDeviceSessionBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


RevokeDeviceSessionBatchError_validator = ...
class RevokeDeviceSessionBatchResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, revoke_devices_status=...) -> None:
        ...
    
    revoke_devices_status = ...


RevokeDeviceSessionBatchResult_validator = ...
class RevokeDeviceSessionError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.RevokeDeviceSessionError.device_session_not_found: Device session
        not found.
    :ivar team.RevokeDeviceSessionError.member_not_found: Member not found.
    """
    _catch_all = ...
    device_session_not_found = ...
    member_not_found = ...
    other = ...
    def is_device_session_not_found(self):
        """
        Check if the union tag is ``device_session_not_found``.

        :rtype: bool
        """
        ...
    
    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


RevokeDeviceSessionError_validator = ...
class RevokeDeviceSessionStatus(bb.Struct):
    """
    :ivar team.RevokeDeviceSessionStatus.success: Result of the revoking
        request.
    :ivar team.RevokeDeviceSessionStatus.error_type: The error cause in case of
        a failure.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, success=..., error_type=...) -> None:
        ...
    
    success = ...
    error_type = ...


RevokeDeviceSessionStatus_validator = ...
class RevokeLinkedApiAppArg(bb.Struct):
    """
    :ivar team.RevokeLinkedApiAppArg.app_id: The application's unique id.
    :ivar team.RevokeLinkedApiAppArg.team_member_id: The unique id of the member
        owning the device.
    :ivar team.RevokeLinkedApiAppArg.keep_app_folder: This flag is not longer
        supported, the application dedicated folder (in case the application
        uses  one) will be kept.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, app_id=..., team_member_id=..., keep_app_folder=...) -> None:
        ...
    
    app_id = ...
    team_member_id = ...
    keep_app_folder = ...


RevokeLinkedApiAppArg_validator = ...
class RevokeLinkedApiAppBatchArg(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, revoke_linked_app=...) -> None:
        ...
    
    revoke_linked_app = ...


RevokeLinkedApiAppBatchArg_validator = ...
class RevokeLinkedAppBatchError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_revoke_linked_app_batch`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    other = ...
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


RevokeLinkedAppBatchError_validator = ...
class RevokeLinkedAppBatchResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, revoke_linked_app_status=...) -> None:
        ...
    
    revoke_linked_app_status = ...


RevokeLinkedAppBatchResult_validator = ...
class RevokeLinkedAppError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_linked_apps_revoke_linked_app`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.RevokeLinkedAppError.app_not_found: Application not found.
    :ivar team.RevokeLinkedAppError.member_not_found: Member not found.
    :ivar team.RevokeLinkedAppError.app_folder_removal_not_supported: App folder
        removal is not supported.
    """
    _catch_all = ...
    app_not_found = ...
    member_not_found = ...
    app_folder_removal_not_supported = ...
    other = ...
    def is_app_not_found(self):
        """
        Check if the union tag is ``app_not_found``.

        :rtype: bool
        """
        ...
    
    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        ...
    
    def is_app_folder_removal_not_supported(self):
        """
        Check if the union tag is ``app_folder_removal_not_supported``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


RevokeLinkedAppError_validator = ...
class RevokeLinkedAppStatus(bb.Struct):
    """
    :ivar team.RevokeLinkedAppStatus.success: Result of the revoking request.
    :ivar team.RevokeLinkedAppStatus.error_type: The error cause in case of a
        failure.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, success=..., error_type=...) -> None:
        ...
    
    success = ...
    error_type = ...


RevokeLinkedAppStatus_validator = ...
class SetCustomQuotaArg(bb.Struct):
    """
    :ivar team.SetCustomQuotaArg.users_and_quotas: List of users and their
        custom quotas.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, users_and_quotas=...) -> None:
        ...
    
    users_and_quotas = ...


SetCustomQuotaArg_validator = ...
class SetCustomQuotaError(CustomQuotaError):
    """
    Error returned when setting member custom quota.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.SetCustomQuotaError.some_users_are_excluded: Some of the users
        are on the excluded users list and can't have custom quota set.
    """
    some_users_are_excluded = ...
    def is_some_users_are_excluded(self):
        """
        Check if the union tag is ``some_users_are_excluded``.

        :rtype: bool
        """
        ...
    


SetCustomQuotaError_validator = ...
class SharingAllowlistAddArgs(bb.Struct):
    """
    Structure representing Approve List entries. Domain and emails are
    supported. At least one entry of any supported type is required.

    :ivar team.SharingAllowlistAddArgs.domains: List of domains represented by
        valid string representation (RFC-1034/5).
    :ivar team.SharingAllowlistAddArgs.emails: List of emails represented by
        valid string representation (RFC-5322/822).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, domains=..., emails=...) -> None:
        ...
    
    domains = ...
    emails = ...


SharingAllowlistAddArgs_validator = ...
class SharingAllowlistAddError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.SharingAllowlistAddError.malformed_entry: One of provided
        values is not valid.
    :ivar team.SharingAllowlistAddError.no_entries_provided: Neither single
        domain nor email provided.
    :ivar team.SharingAllowlistAddError.too_many_entries_provided: Too many
        entries provided within one call.
    :ivar team.SharingAllowlistAddError.team_limit_reached: Team entries limit
        reached.
    :ivar team.SharingAllowlistAddError.unknown_error: Unknown error.
    :ivar str team.SharingAllowlistAddError.entries_already_exist: Entries
        already exists.
    """
    _catch_all = ...
    no_entries_provided = ...
    too_many_entries_provided = ...
    team_limit_reached = ...
    unknown_error = ...
    other = ...
    @classmethod
    def malformed_entry(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``malformed_entry`` tag with
        value ``val``.

        :param str val:
        :rtype: SharingAllowlistAddError
        """
        ...
    
    @classmethod
    def entries_already_exist(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``entries_already_exist``
        tag with value ``val``.

        :param str val:
        :rtype: SharingAllowlistAddError
        """
        ...
    
    def is_malformed_entry(self):
        """
        Check if the union tag is ``malformed_entry``.

        :rtype: bool
        """
        ...
    
    def is_no_entries_provided(self):
        """
        Check if the union tag is ``no_entries_provided``.

        :rtype: bool
        """
        ...
    
    def is_too_many_entries_provided(self):
        """
        Check if the union tag is ``too_many_entries_provided``.

        :rtype: bool
        """
        ...
    
    def is_team_limit_reached(self):
        """
        Check if the union tag is ``team_limit_reached``.

        :rtype: bool
        """
        ...
    
    def is_unknown_error(self):
        """
        Check if the union tag is ``unknown_error``.

        :rtype: bool
        """
        ...
    
    def is_entries_already_exist(self):
        """
        Check if the union tag is ``entries_already_exist``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_malformed_entry(self): # -> None:
        """
        One of provided values is not valid.

        Only call this if :meth:`is_malformed_entry` is true.

        :rtype: str
        """
        ...
    
    def get_entries_already_exist(self): # -> None:
        """
        Entries already exists.

        Only call this if :meth:`is_entries_already_exist` is true.

        :rtype: str
        """
        ...
    


SharingAllowlistAddError_validator = ...
class SharingAllowlistAddResponse(bb.Struct):
    """
    This struct is empty. The comment here is intentionally emitted to avoid
    indentation issues with Stone.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self) -> None:
        ...
    


SharingAllowlistAddResponse_validator = ...
class SharingAllowlistListArg(bb.Struct):
    """
    :ivar team.SharingAllowlistListArg.limit: The number of entries to fetch at
        one time.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=...) -> None:
        ...
    
    limit = ...


SharingAllowlistListArg_validator = ...
class SharingAllowlistListContinueArg(bb.Struct):
    """
    :ivar team.SharingAllowlistListContinueArg.cursor: The cursor returned from
        a previous call to
        :meth:`dropbox.dropbox_client.Dropbox.team_sharing_allowlist_list` or
        :meth:`dropbox.dropbox_client.Dropbox.team_sharing_allowlist_list_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


SharingAllowlistListContinueArg_validator = ...
class SharingAllowlistListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.SharingAllowlistListContinueError.invalid_cursor: Provided cursor
        is not valid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


SharingAllowlistListContinueError_validator = ...
class SharingAllowlistListError(bb.Struct):
    """
    This struct is empty. The comment here is intentionally emitted to avoid
    indentation issues with Stone.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self) -> None:
        ...
    


SharingAllowlistListError_validator = ...
class SharingAllowlistListResponse(bb.Struct):
    """
    :ivar team.SharingAllowlistListResponse.domains: List of domains represented
        by valid string representation (RFC-1034/5).
    :ivar team.SharingAllowlistListResponse.emails: List of emails represented
        by valid string representation (RFC-5322/822).
    :ivar team.SharingAllowlistListResponse.cursor: If this is nonempty, there
        are more entries that can be fetched with
        :meth:`dropbox.dropbox_client.Dropbox.team_sharing_allowlist_list_continue`.
    :ivar team.SharingAllowlistListResponse.has_more: if true indicates that
        more entries can be fetched with
        :meth:`dropbox.dropbox_client.Dropbox.team_sharing_allowlist_list_continue`.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, domains=..., emails=..., cursor=..., has_more=...) -> None:
        ...
    
    domains = ...
    emails = ...
    cursor = ...
    has_more = ...


SharingAllowlistListResponse_validator = ...
class SharingAllowlistRemoveArgs(bb.Struct):
    """
    :ivar team.SharingAllowlistRemoveArgs.domains: List of domains represented
        by valid string representation (RFC-1034/5).
    :ivar team.SharingAllowlistRemoveArgs.emails: List of emails represented by
        valid string representation (RFC-5322/822).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, domains=..., emails=...) -> None:
        ...
    
    domains = ...
    emails = ...


SharingAllowlistRemoveArgs_validator = ...
class SharingAllowlistRemoveError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.SharingAllowlistRemoveError.malformed_entry: One of provided
        values is not valid.
    :ivar str team.SharingAllowlistRemoveError.entries_do_not_exist: One or more
        provided values do not exist.
    :ivar team.SharingAllowlistRemoveError.no_entries_provided: Neither single
        domain nor email provided.
    :ivar team.SharingAllowlistRemoveError.too_many_entries_provided: Too many
        entries provided within one call.
    :ivar team.SharingAllowlistRemoveError.unknown_error: Unknown error.
    """
    _catch_all = ...
    no_entries_provided = ...
    too_many_entries_provided = ...
    unknown_error = ...
    other = ...
    @classmethod
    def malformed_entry(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``malformed_entry`` tag with
        value ``val``.

        :param str val:
        :rtype: SharingAllowlistRemoveError
        """
        ...
    
    @classmethod
    def entries_do_not_exist(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``entries_do_not_exist`` tag
        with value ``val``.

        :param str val:
        :rtype: SharingAllowlistRemoveError
        """
        ...
    
    def is_malformed_entry(self):
        """
        Check if the union tag is ``malformed_entry``.

        :rtype: bool
        """
        ...
    
    def is_entries_do_not_exist(self):
        """
        Check if the union tag is ``entries_do_not_exist``.

        :rtype: bool
        """
        ...
    
    def is_no_entries_provided(self):
        """
        Check if the union tag is ``no_entries_provided``.

        :rtype: bool
        """
        ...
    
    def is_too_many_entries_provided(self):
        """
        Check if the union tag is ``too_many_entries_provided``.

        :rtype: bool
        """
        ...
    
    def is_unknown_error(self):
        """
        Check if the union tag is ``unknown_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_malformed_entry(self): # -> None:
        """
        One of provided values is not valid.

        Only call this if :meth:`is_malformed_entry` is true.

        :rtype: str
        """
        ...
    
    def get_entries_do_not_exist(self): # -> None:
        """
        One or more provided values do not exist.

        Only call this if :meth:`is_entries_do_not_exist` is true.

        :rtype: str
        """
        ...
    


SharingAllowlistRemoveError_validator = ...
class SharingAllowlistRemoveResponse(bb.Struct):
    """
    This struct is empty. The comment here is intentionally emitted to avoid
    indentation issues with Stone.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self) -> None:
        ...
    


SharingAllowlistRemoveResponse_validator = ...
class StorageBucket(bb.Struct):
    """
    Describes the number of users in a specific storage bucket.

    :ivar team.StorageBucket.bucket: The name of the storage bucket. For
        example, '1G' is a bucket of users with storage size up to 1 Giga.
    :ivar team.StorageBucket.users: The number of people whose storage is in the
        range of this storage bucket.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, bucket=..., users=...) -> None:
        ...
    
    bucket = ...
    users = ...


StorageBucket_validator = ...
class TeamFolderAccessError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderAccessError.invalid_team_folder_id: The team folder ID
        is invalid.
    :ivar team.TeamFolderAccessError.no_access: The authenticated app does not
        have permission to manage that team folder.
    """
    _catch_all = ...
    invalid_team_folder_id = ...
    no_access = ...
    other = ...
    def is_invalid_team_folder_id(self):
        """
        Check if the union tag is ``invalid_team_folder_id``.

        :rtype: bool
        """
        ...
    
    def is_no_access(self):
        """
        Check if the union tag is ``no_access``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamFolderAccessError_validator = ...
class TeamFolderActivateError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    ...


TeamFolderActivateError_validator = ...
class TeamFolderIdArg(bb.Struct):
    """
    :ivar team.TeamFolderIdArg.team_folder_id: The ID of the team folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_id=...) -> None:
        ...
    
    team_folder_id = ...


TeamFolderIdArg_validator = ...
class TeamFolderArchiveArg(TeamFolderIdArg):
    """
    :ivar team.TeamFolderArchiveArg.force_async_off: Whether to force the
        archive to happen synchronously.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_id=..., force_async_off=...) -> None:
        ...
    
    force_async_off = ...


TeamFolderArchiveArg_validator = ...
class TeamFolderArchiveError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    ...


TeamFolderArchiveError_validator = ...
class TeamFolderArchiveJobStatus(async_.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamFolderMetadata TeamFolderArchiveJobStatus.complete: The archive
        job has finished. The value is the metadata for the resulting team
        folder.
    :ivar TeamFolderArchiveError TeamFolderArchiveJobStatus.failed: Error
        occurred while performing an asynchronous job from
        :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_archive`.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderArchiveJobStatus
        """
        ...
    
    @classmethod
    def failed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param TeamFolderArchiveError val:
        :rtype: TeamFolderArchiveJobStatus
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        The archive job has finished. The value is the metadata for the
        resulting team folder.

        Only call this if :meth:`is_complete` is true.

        :rtype: TeamFolderMetadata
        """
        ...
    
    def get_failed(self): # -> None:
        """
        Error occurred while performing an asynchronous job from
        :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_archive`.

        Only call this if :meth:`is_failed` is true.

        :rtype: TeamFolderArchiveError
        """
        ...
    


TeamFolderArchiveJobStatus_validator = ...
class TeamFolderArchiveLaunch(async_.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    @classmethod
    def complete(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderArchiveLaunch
        """
        ...
    
    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        ...
    
    def get_complete(self): # -> None:
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: TeamFolderMetadata
        """
        ...
    


TeamFolderArchiveLaunch_validator = ...
class TeamFolderCreateArg(bb.Struct):
    """
    :ivar team.TeamFolderCreateArg.name: Name for the new team folder.
    :ivar team.TeamFolderCreateArg.sync_setting: The sync setting to apply to
        this team folder. Only permitted if the team has team selective sync
        enabled.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., sync_setting=...) -> None:
        ...
    
    name = ...
    sync_setting = ...


TeamFolderCreateArg_validator = ...
class TeamFolderCreateError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderCreateError.invalid_folder_name: The provided name
        cannot be used.
    :ivar team.TeamFolderCreateError.folder_name_already_used: There is already
        a team folder with the provided name.
    :ivar team.TeamFolderCreateError.folder_name_reserved: The provided name
        cannot be used because it is reserved.
    :ivar SyncSettingsError TeamFolderCreateError.sync_settings_error: An error
        occurred setting the sync settings.
    """
    _catch_all = ...
    invalid_folder_name = ...
    folder_name_already_used = ...
    folder_name_reserved = ...
    other = ...
    @classmethod
    def sync_settings_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``sync_settings_error`` tag
        with value ``val``.

        :param files.SyncSettingsError val:
        :rtype: TeamFolderCreateError
        """
        ...
    
    def is_invalid_folder_name(self):
        """
        Check if the union tag is ``invalid_folder_name``.

        :rtype: bool
        """
        ...
    
    def is_folder_name_already_used(self):
        """
        Check if the union tag is ``folder_name_already_used``.

        :rtype: bool
        """
        ...
    
    def is_folder_name_reserved(self):
        """
        Check if the union tag is ``folder_name_reserved``.

        :rtype: bool
        """
        ...
    
    def is_sync_settings_error(self):
        """
        Check if the union tag is ``sync_settings_error``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_sync_settings_error(self): # -> None:
        """
        An error occurred setting the sync settings.

        Only call this if :meth:`is_sync_settings_error` is true.

        :rtype: files.SyncSettingsError
        """
        ...
    


TeamFolderCreateError_validator = ...
class TeamFolderGetInfoItem(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str team.TeamFolderGetInfoItem.id_not_found: An ID that was provided
        as a parameter to :route:`team_folder/get_info` did not match any of the
        team's team folders.
    :ivar TeamFolderMetadata TeamFolderGetInfoItem.team_folder_metadata:
        Properties of a team folder.
    """
    _catch_all = ...
    @classmethod
    def id_not_found(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: TeamFolderGetInfoItem
        """
        ...
    
    @classmethod
    def team_folder_metadata(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``team_folder_metadata`` tag
        with value ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderGetInfoItem
        """
        ...
    
    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        ...
    
    def is_team_folder_metadata(self):
        """
        Check if the union tag is ``team_folder_metadata``.

        :rtype: bool
        """
        ...
    
    def get_id_not_found(self): # -> None:
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_get_info` did not
        match any of the team's team folders.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        ...
    
    def get_team_folder_metadata(self): # -> None:
        """
        Properties of a team folder.

        Only call this if :meth:`is_team_folder_metadata` is true.

        :rtype: TeamFolderMetadata
        """
        ...
    


TeamFolderGetInfoItem_validator = ...
class TeamFolderIdListArg(bb.Struct):
    """
    :ivar team.TeamFolderIdListArg.team_folder_ids: The list of team folder IDs.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_ids=...) -> None:
        ...
    
    team_folder_ids = ...


TeamFolderIdListArg_validator = ...
class TeamFolderInvalidStatusError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderInvalidStatusError.active: The folder is active and the
        operation did not succeed.
    :ivar team.TeamFolderInvalidStatusError.archived: The folder is archived and
        the operation did not succeed.
    :ivar team.TeamFolderInvalidStatusError.archive_in_progress: The folder is
        being archived and the operation did not succeed.
    """
    _catch_all = ...
    active = ...
    archived = ...
    archive_in_progress = ...
    other = ...
    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        ...
    
    def is_archived(self):
        """
        Check if the union tag is ``archived``.

        :rtype: bool
        """
        ...
    
    def is_archive_in_progress(self):
        """
        Check if the union tag is ``archive_in_progress``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamFolderInvalidStatusError_validator = ...
class TeamFolderListArg(bb.Struct):
    """
    :ivar team.TeamFolderListArg.limit: The maximum number of results to return
        per request.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=...) -> None:
        ...
    
    limit = ...


TeamFolderListArg_validator = ...
class TeamFolderListContinueArg(bb.Struct):
    """
    :ivar team.TeamFolderListContinueArg.cursor: Indicates from what point to
        get the next set of team folders.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


TeamFolderListContinueArg_validator = ...
class TeamFolderListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderListContinueError.invalid_cursor: The cursor is
        invalid.
    """
    _catch_all = ...
    invalid_cursor = ...
    other = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamFolderListContinueError_validator = ...
class TeamFolderListError(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, access_error=...) -> None:
        ...
    
    access_error = ...


TeamFolderListError_validator = ...
class TeamFolderListResult(bb.Struct):
    """
    Result for :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_list` and
    :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_list_continue`.

    :ivar team.TeamFolderListResult.team_folders: List of all team folders in
        the authenticated team.
    :ivar team.TeamFolderListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_list_continue` to
        obtain additional team folders.
    :ivar team.TeamFolderListResult.has_more: Is true if there are additional
        team folders that have not been returned yet. An additional call to
        :meth:`dropbox.dropbox_client.Dropbox.team_team_folder_list_continue`
        can retrieve them.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folders=..., cursor=..., has_more=...) -> None:
        ...
    
    team_folders = ...
    cursor = ...
    has_more = ...


TeamFolderListResult_validator = ...
class TeamFolderMetadata(bb.Struct):
    """
    Properties of a team folder.

    :ivar team.TeamFolderMetadata.team_folder_id: The ID of the team folder.
    :ivar team.TeamFolderMetadata.name: The name of the team folder.
    :ivar team.TeamFolderMetadata.status: The status of the team folder.
    :ivar team.TeamFolderMetadata.is_team_shared_dropbox: True if this team
        folder is a shared team root.
    :ivar team.TeamFolderMetadata.sync_setting: The sync setting applied to this
        team folder.
    :ivar team.TeamFolderMetadata.content_sync_settings: Sync settings applied
        to contents of this team folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_id=..., name=..., status=..., is_team_shared_dropbox=..., sync_setting=..., content_sync_settings=...) -> None:
        ...
    
    team_folder_id = ...
    name = ...
    status = ...
    is_team_shared_dropbox = ...
    sync_setting = ...
    content_sync_settings = ...


TeamFolderMetadata_validator = ...
class TeamFolderPermanentlyDeleteError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    ...


TeamFolderPermanentlyDeleteError_validator = ...
class TeamFolderRenameArg(TeamFolderIdArg):
    """
    :ivar team.TeamFolderRenameArg.name: New team folder name.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_id=..., name=...) -> None:
        ...
    
    name = ...


TeamFolderRenameArg_validator = ...
class TeamFolderRenameError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderRenameError.invalid_folder_name: The provided folder
        name cannot be used.
    :ivar team.TeamFolderRenameError.folder_name_already_used: There is already
        a team folder with the same name.
    :ivar team.TeamFolderRenameError.folder_name_reserved: The provided name
        cannot be used because it is reserved.
    """
    invalid_folder_name = ...
    folder_name_already_used = ...
    folder_name_reserved = ...
    def is_invalid_folder_name(self):
        """
        Check if the union tag is ``invalid_folder_name``.

        :rtype: bool
        """
        ...
    
    def is_folder_name_already_used(self):
        """
        Check if the union tag is ``folder_name_already_used``.

        :rtype: bool
        """
        ...
    
    def is_folder_name_reserved(self):
        """
        Check if the union tag is ``folder_name_reserved``.

        :rtype: bool
        """
        ...
    


TeamFolderRenameError_validator = ...
class TeamFolderStatus(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderStatus.active: The team folder and sub-folders are
        available to all members.
    :ivar team.TeamFolderStatus.archived: The team folder is not accessible
        outside of the team folder manager.
    :ivar team.TeamFolderStatus.archive_in_progress: The team folder is not
        accessible outside of the team folder manager.
    """
    _catch_all = ...
    active = ...
    archived = ...
    archive_in_progress = ...
    other = ...
    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        ...
    
    def is_archived(self):
        """
        Check if the union tag is ``archived``.

        :rtype: bool
        """
        ...
    
    def is_archive_in_progress(self):
        """
        Check if the union tag is ``archive_in_progress``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamFolderStatus_validator = ...
class TeamFolderTeamSharedDropboxError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamFolderTeamSharedDropboxError.disallowed: This action is not
        allowed for a shared team root.
    """
    _catch_all = ...
    disallowed = ...
    other = ...
    def is_disallowed(self):
        """
        Check if the union tag is ``disallowed``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamFolderTeamSharedDropboxError_validator = ...
class TeamFolderUpdateSyncSettingsArg(TeamFolderIdArg):
    """
    :ivar team.TeamFolderUpdateSyncSettingsArg.sync_setting: Sync setting to
        apply to the team folder itself. Only meaningful if the team folder is
        not a shared team root.
    :ivar team.TeamFolderUpdateSyncSettingsArg.content_sync_settings: Sync
        settings to apply to contents of this team folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_folder_id=..., sync_setting=..., content_sync_settings=...) -> None:
        ...
    
    sync_setting = ...
    content_sync_settings = ...


TeamFolderUpdateSyncSettingsArg_validator = ...
class TeamFolderUpdateSyncSettingsError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar SyncSettingsError
        TeamFolderUpdateSyncSettingsError.sync_settings_error: An error occurred
        setting the sync settings.
    """
    @classmethod
    def sync_settings_error(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``sync_settings_error`` tag
        with value ``val``.

        :param files.SyncSettingsError val:
        :rtype: TeamFolderUpdateSyncSettingsError
        """
        ...
    
    def is_sync_settings_error(self):
        """
        Check if the union tag is ``sync_settings_error``.

        :rtype: bool
        """
        ...
    
    def get_sync_settings_error(self): # -> None:
        """
        An error occurred setting the sync settings.

        Only call this if :meth:`is_sync_settings_error` is true.

        :rtype: files.SyncSettingsError
        """
        ...
    


TeamFolderUpdateSyncSettingsError_validator = ...
class TeamGetInfoResult(bb.Struct):
    """
    :ivar team.TeamGetInfoResult.name: The name of the team.
    :ivar team.TeamGetInfoResult.team_id: The ID of the team.
    :ivar team.TeamGetInfoResult.num_licensed_users: The number of licenses
        available to the team.
    :ivar team.TeamGetInfoResult.num_provisioned_users: The number of accounts
        that have been invited or are already active members of the team.
    :ivar team.TeamGetInfoResult.num_used_licenses: The number of licenses used
        on the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, name=..., team_id=..., num_licensed_users=..., num_provisioned_users=..., policies=..., num_used_licenses=...) -> None:
        ...
    
    name = ...
    team_id = ...
    num_licensed_users = ...
    num_provisioned_users = ...
    num_used_licenses = ...
    policies = ...


TeamGetInfoResult_validator = ...
class TeamMemberInfo(bb.Struct):
    """
    Information about a team member.

    :ivar team.TeamMemberInfo.profile: Profile of a user as a member of a team.
    :ivar team.TeamMemberInfo.role: The user's role in the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, profile=..., role=...) -> None:
        ...
    
    profile = ...
    role = ...


TeamMemberInfo_validator = ...
class TeamMemberInfoV2(bb.Struct):
    """
    Information about a team member.

    :ivar team.TeamMemberInfoV2.profile: Profile of a user as a member of a
        team.
    :ivar team.TeamMemberInfoV2.roles: The user's roles in the team.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, profile=..., roles=...) -> None:
        ...
    
    profile = ...
    roles = ...


TeamMemberInfoV2_validator = ...
class TeamMemberInfoV2Result(bb.Struct):
    """
    Information about a team member, after the change, like at
    :meth:`dropbox.dropbox_client.Dropbox.team_members_set_profile`.

    :ivar team.TeamMemberInfoV2Result.member_info: Member info, after the
        change.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, member_info=...) -> None:
        ...
    
    member_info = ...


TeamMemberInfoV2Result_validator = ...
class TeamMemberProfile(MemberProfile):
    """
    Profile of a user as a member of a team.

    :ivar team.TeamMemberProfile.groups: List of group IDs of groups that the
        user belongs to.
    :ivar team.TeamMemberProfile.member_folder_id: The namespace id of the
        user's root folder.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, team_member_id=..., email=..., email_verified=..., status=..., name=..., membership_type=..., groups=..., member_folder_id=..., external_id=..., account_id=..., secondary_emails=..., invited_on=..., joined_on=..., suspended_on=..., persistent_id=..., is_directory_restricted=..., profile_photo_url=...) -> None:
        ...
    
    groups = ...
    member_folder_id = ...


TeamMemberProfile_validator = ...
class TeamMemberRole(bb.Struct):
    """
    A role which can be attached to a team member. This replaces AdminTier; each
    AdminTier corresponds to a new TeamMemberRole with a matching name.

    :ivar team.TeamMemberRole.role_id: A string containing encoded role ID. For
        roles defined by Dropbox, this is the same across all teams.
    :ivar team.TeamMemberRole.name: The role display name.
    :ivar team.TeamMemberRole.description: Role description. Describes which
        permissions come with this role.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, role_id=..., name=..., description=...) -> None:
        ...
    
    role_id = ...
    name = ...
    description = ...


TeamMemberRole_validator = ...
class TeamMemberStatus(bb.Union):
    """
    The user's status as a member of a specific team.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamMemberStatus.active: User has successfully joined the team.
    :ivar team.TeamMemberStatus.invited: User has been invited to a team, but
        has not joined the team yet.
    :ivar team.TeamMemberStatus.suspended: User is no longer a member of the
        team, but the account can be un-suspended, re-establishing the user as a
        team member.
    :ivar RemovedStatus TeamMemberStatus.removed: User is no longer a member of
        the team. Removed users are only listed when include_removed is true in
        members/list.
    """
    _catch_all = ...
    active = ...
    invited = ...
    suspended = ...
    @classmethod
    def removed(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``removed`` tag with value
        ``val``.

        :param RemovedStatus val:
        :rtype: TeamMemberStatus
        """
        ...
    
    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        ...
    
    def is_invited(self):
        """
        Check if the union tag is ``invited``.

        :rtype: bool
        """
        ...
    
    def is_suspended(self):
        """
        Check if the union tag is ``suspended``.

        :rtype: bool
        """
        ...
    
    def is_removed(self):
        """
        Check if the union tag is ``removed``.

        :rtype: bool
        """
        ...
    
    def get_removed(self): # -> None:
        """
        User is no longer a member of the team. Removed users are only listed
        when include_removed is true in members/list.

        Only call this if :meth:`is_removed` is true.

        :rtype: RemovedStatus
        """
        ...
    


TeamMemberStatus_validator = ...
class TeamMembershipType(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamMembershipType.full: User uses a license and has full access
        to team resources like the shared quota.
    :ivar team.TeamMembershipType.limited: User does not have access to the
        shared quota and team admins have restricted administrative control.
    """
    _catch_all = ...
    full = ...
    limited = ...
    def is_full(self):
        """
        Check if the union tag is ``full``.

        :rtype: bool
        """
        ...
    
    def is_limited(self):
        """
        Check if the union tag is ``limited``.

        :rtype: bool
        """
        ...
    


TeamMembershipType_validator = ...
class TeamNamespacesListArg(bb.Struct):
    """
    :ivar team.TeamNamespacesListArg.limit: Specifying a value here has no
        effect.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, limit=...) -> None:
        ...
    
    limit = ...


TeamNamespacesListArg_validator = ...
class TeamNamespacesListContinueArg(bb.Struct):
    """
    :ivar team.TeamNamespacesListContinueArg.cursor: Indicates from what point
        to get the next set of team-accessible namespaces.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, cursor=...) -> None:
        ...
    
    cursor = ...


TeamNamespacesListContinueArg_validator = ...
class TeamNamespacesListError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamNamespacesListError.invalid_arg: Argument passed in is
        invalid.
    """
    _catch_all = ...
    invalid_arg = ...
    other = ...
    def is_invalid_arg(self):
        """
        Check if the union tag is ``invalid_arg``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamNamespacesListError_validator = ...
class TeamNamespacesListContinueError(TeamNamespacesListError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamNamespacesListContinueError.invalid_cursor: The cursor is
        invalid.
    """
    invalid_cursor = ...
    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        ...
    


TeamNamespacesListContinueError_validator = ...
class TeamNamespacesListResult(bb.Struct):
    """
    Result for :meth:`dropbox.dropbox_client.Dropbox.team_namespaces_list`.

    :ivar team.TeamNamespacesListResult.namespaces: List of all namespaces the
        team can access.
    :ivar team.TeamNamespacesListResult.cursor: Pass the cursor into
        :meth:`dropbox.dropbox_client.Dropbox.team_namespaces_list_continue` to
        obtain additional namespaces. Note that duplicate namespaces may be
        returned.
    :ivar team.TeamNamespacesListResult.has_more: Is true if there are
        additional namespaces that have not been returned yet.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, namespaces=..., cursor=..., has_more=...) -> None:
        ...
    
    namespaces = ...
    cursor = ...
    has_more = ...


TeamNamespacesListResult_validator = ...
class TeamReportFailureReason(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TeamReportFailureReason.temporary_error: We couldn't create the
        report, but we think this was a fluke. Everything should work if you try
        it again.
    :ivar team.TeamReportFailureReason.many_reports_at_once: Too many other
        reports are being created right now. Try creating this report again once
        the others finish.
    :ivar team.TeamReportFailureReason.too_much_data: We couldn't create the
        report. Try creating the report again with less data.
    """
    _catch_all = ...
    temporary_error = ...
    many_reports_at_once = ...
    too_much_data = ...
    other = ...
    def is_temporary_error(self):
        """
        Check if the union tag is ``temporary_error``.

        :rtype: bool
        """
        ...
    
    def is_many_reports_at_once(self):
        """
        Check if the union tag is ``many_reports_at_once``.

        :rtype: bool
        """
        ...
    
    def is_too_much_data(self):
        """
        Check if the union tag is ``too_much_data``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TeamReportFailureReason_validator = ...
class TokenGetAuthenticatedAdminError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox_client.Dropbox.team_token_get_authenticated_admin`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.TokenGetAuthenticatedAdminError.mapping_not_found: The current
        token is not associated with a team admin, because mappings were not
        recorded when the token was created. Consider re-authorizing a new
        access token to record its authenticating admin.
    :ivar team.TokenGetAuthenticatedAdminError.admin_not_active: Either the team
        admin that authorized this token is no longer an active member of the
        team or no longer a team admin.
    """
    _catch_all = ...
    mapping_not_found = ...
    admin_not_active = ...
    other = ...
    def is_mapping_not_found(self):
        """
        Check if the union tag is ``mapping_not_found``.

        :rtype: bool
        """
        ...
    
    def is_admin_not_active(self):
        """
        Check if the union tag is ``admin_not_active``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    


TokenGetAuthenticatedAdminError_validator = ...
class TokenGetAuthenticatedAdminResult(bb.Struct):
    """
    Results for
    :meth:`dropbox.dropbox_client.Dropbox.team_token_get_authenticated_admin`.

    :ivar team.TokenGetAuthenticatedAdminResult.admin_profile: The admin who
        authorized the token.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, admin_profile=...) -> None:
        ...
    
    admin_profile = ...


TokenGetAuthenticatedAdminResult_validator = ...
class UploadApiRateLimitValue(bb.Union):
    """
    The value for ``Feature.upload_api_rate_limit``.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team.UploadApiRateLimitValue.unlimited: This team has unlimited upload
        API quota. So far both server version account and legacy  account type
        have unlimited monthly upload api quota.
    :ivar int team.UploadApiRateLimitValue.limit: The number of upload API calls
        allowed per month.
    """
    _catch_all = ...
    unlimited = ...
    other = ...
    @classmethod
    def limit(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``limit`` tag with value
        ``val``.

        :param int val:
        :rtype: UploadApiRateLimitValue
        """
        ...
    
    def is_unlimited(self):
        """
        Check if the union tag is ``unlimited``.

        :rtype: bool
        """
        ...
    
    def is_limit(self):
        """
        Check if the union tag is ``limit``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_limit(self): # -> None:
        """
        The number of upload API calls allowed per month.

        Only call this if :meth:`is_limit` is true.

        :rtype: int
        """
        ...
    


UploadApiRateLimitValue_validator = ...
class UserAddResult(bb.Union):
    """
    Result of trying to add secondary emails to a user. 'success' is the only
    value indicating that a user was successfully retrieved for adding secondary
    emails. The other values explain the type of error that occurred, and
    include the user for which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserSecondaryEmailsResult UserAddResult.success: Describes a user and
        the results for each attempt to add a secondary email.
    :ivar UserSelectorArg UserAddResult.invalid_user: Specified user is not a
        valid target for adding secondary emails.
    :ivar UserSelectorArg UserAddResult.unverified: Secondary emails can only be
        added to verified users.
    :ivar UserSelectorArg UserAddResult.placeholder_user: Secondary emails
        cannot be added to placeholder users.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param UserSecondaryEmailsResult val:
        :rtype: UserAddResult
        """
        ...
    
    @classmethod
    def invalid_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_user`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: UserAddResult
        """
        ...
    
    @classmethod
    def unverified(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``unverified`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: UserAddResult
        """
        ...
    
    @classmethod
    def placeholder_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``placeholder_user`` tag
        with value ``val``.

        :param UserSelectorArg val:
        :rtype: UserAddResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_invalid_user(self):
        """
        Check if the union tag is ``invalid_user``.

        :rtype: bool
        """
        ...
    
    def is_unverified(self):
        """
        Check if the union tag is ``unverified``.

        :rtype: bool
        """
        ...
    
    def is_placeholder_user(self):
        """
        Check if the union tag is ``placeholder_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a user and the results for each attempt to add a secondary
        email.

        Only call this if :meth:`is_success` is true.

        :rtype: UserSecondaryEmailsResult
        """
        ...
    
    def get_invalid_user(self): # -> None:
        """
        Specified user is not a valid target for adding secondary emails.

        Only call this if :meth:`is_invalid_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    
    def get_unverified(self): # -> None:
        """
        Secondary emails can only be added to verified users.

        Only call this if :meth:`is_unverified` is true.

        :rtype: UserSelectorArg
        """
        ...
    
    def get_placeholder_user(self): # -> None:
        """
        Secondary emails cannot be added to placeholder users.

        Only call this if :meth:`is_placeholder_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    


UserAddResult_validator = ...
class UserCustomQuotaArg(bb.Struct):
    """
    User and their required custom quota in GB (1 TB = 1024 GB).
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., quota_gb=...) -> None:
        ...
    
    user = ...
    quota_gb = ...


UserCustomQuotaArg_validator = ...
class UserCustomQuotaResult(bb.Struct):
    """
    User and their custom quota in GB (1 TB = 1024 GB).  No quota returns if the
    user has no custom quota set.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., quota_gb=...) -> None:
        ...
    
    user = ...
    quota_gb = ...


UserCustomQuotaResult_validator = ...
class UserDeleteEmailsResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., results=...) -> None:
        ...
    
    user = ...
    results = ...


UserDeleteEmailsResult_validator = ...
class UserDeleteResult(bb.Union):
    """
    Result of trying to delete a user's secondary emails. 'success' is the only
    value indicating that a user was successfully retrieved for deleting
    secondary emails. The other values explain the type of error that occurred,
    and include the user for which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserDeleteEmailsResult UserDeleteResult.success: Describes a user and
        the results for each attempt to delete a secondary email.
    :ivar UserSelectorArg UserDeleteResult.invalid_user: Specified user is not a
        valid target for deleting secondary emails.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param UserDeleteEmailsResult val:
        :rtype: UserDeleteResult
        """
        ...
    
    @classmethod
    def invalid_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_user`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: UserDeleteResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_invalid_user(self):
        """
        Check if the union tag is ``invalid_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a user and the results for each attempt to delete a secondary
        email.

        Only call this if :meth:`is_success` is true.

        :rtype: UserDeleteEmailsResult
        """
        ...
    
    def get_invalid_user(self): # -> None:
        """
        Specified user is not a valid target for deleting secondary emails.

        Only call this if :meth:`is_invalid_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    


UserDeleteResult_validator = ...
class UserResendEmailsResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., results=...) -> None:
        ...
    
    user = ...
    results = ...


UserResendEmailsResult_validator = ...
class UserResendResult(bb.Union):
    """
    Result of trying to resend verification emails to a user. 'success' is the
    only value indicating that a user was successfully retrieved for sending
    verification emails. The other values explain the type of error that
    occurred, and include the user for which the error occurred.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar UserResendEmailsResult UserResendResult.success: Describes a user and
        the results for each attempt to resend verification emails.
    :ivar UserSelectorArg UserResendResult.invalid_user: Specified user is not a
        valid target for resending verification emails.
    """
    _catch_all = ...
    other = ...
    @classmethod
    def success(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param UserResendEmailsResult val:
        :rtype: UserResendResult
        """
        ...
    
    @classmethod
    def invalid_user(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``invalid_user`` tag with
        value ``val``.

        :param UserSelectorArg val:
        :rtype: UserResendResult
        """
        ...
    
    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        ...
    
    def is_invalid_user(self):
        """
        Check if the union tag is ``invalid_user``.

        :rtype: bool
        """
        ...
    
    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        ...
    
    def get_success(self): # -> None:
        """
        Describes a user and the results for each attempt to resend verification
        emails.

        Only call this if :meth:`is_success` is true.

        :rtype: UserResendEmailsResult
        """
        ...
    
    def get_invalid_user(self): # -> None:
        """
        Specified user is not a valid target for resending verification emails.

        Only call this if :meth:`is_invalid_user` is true.

        :rtype: UserSelectorArg
        """
        ...
    


UserResendResult_validator = ...
class UserSecondaryEmailsArg(bb.Struct):
    """
    User and a list of secondary emails.
    """
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., secondary_emails=...) -> None:
        ...
    
    user = ...
    secondary_emails = ...


UserSecondaryEmailsArg_validator = ...
class UserSecondaryEmailsResult(bb.Struct):
    __slots__ = ...
    _has_required_fields = ...
    def __init__(self, user=..., results=...) -> None:
        ...
    
    user = ...
    results = ...


UserSecondaryEmailsResult_validator = ...
class UserSelectorArg(bb.Union):
    """
    Argument for selecting a single user, either by team_member_id, external_id
    or email.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """
    _catch_all = ...
    @classmethod
    def team_member_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``team_member_id`` tag with
        value ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        ...
    
    @classmethod
    def external_id(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``external_id`` tag with
        value ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        ...
    
    @classmethod
    def email(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``email`` tag with value
        ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        ...
    
    def is_team_member_id(self):
        """
        Check if the union tag is ``team_member_id``.

        :rtype: bool
        """
        ...
    
    def is_external_id(self):
        """
        Check if the union tag is ``external_id``.

        :rtype: bool
        """
        ...
    
    def is_email(self):
        """
        Check if the union tag is ``email``.

        :rtype: bool
        """
        ...
    
    def get_team_member_id(self): # -> None:
        """
        Only call this if :meth:`is_team_member_id` is true.

        :rtype: str
        """
        ...
    
    def get_external_id(self): # -> None:
        """
        Only call this if :meth:`is_external_id` is true.

        :rtype: str
        """
        ...
    
    def get_email(self): # -> None:
        """
        Only call this if :meth:`is_email` is true.

        :rtype: str
        """
        ...
    


UserSelectorArg_validator = ...
class UsersSelectorArg(bb.Union):
    """
    Argument for selecting a list of users, either by team_member_ids,
    external_ids or emails.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [str] team.UsersSelectorArg.team_member_ids: List of member
        IDs.
    :ivar list of [str] team.UsersSelectorArg.external_ids: List of external
        user IDs.
    :ivar list of [str] team.UsersSelectorArg.emails: List of email addresses.
    """
    _catch_all = ...
    @classmethod
    def team_member_ids(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``team_member_ids`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        ...
    
    @classmethod
    def external_ids(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``external_ids`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        ...
    
    @classmethod
    def emails(cls, val): # -> Self:
        """
        Create an instance of this class set to the ``emails`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        ...
    
    def is_team_member_ids(self):
        """
        Check if the union tag is ``team_member_ids``.

        :rtype: bool
        """
        ...
    
    def is_external_ids(self):
        """
        Check if the union tag is ``external_ids``.

        :rtype: bool
        """
        ...
    
    def is_emails(self):
        """
        Check if the union tag is ``emails``.

        :rtype: bool
        """
        ...
    
    def get_team_member_ids(self): # -> None:
        """
        List of member IDs.

        Only call this if :meth:`is_team_member_ids` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_external_ids(self): # -> None:
        """
        List of external user IDs.

        Only call this if :meth:`is_external_ids` is true.

        :rtype: list of [str]
        """
        ...
    
    def get_emails(self): # -> None:
        """
        List of email addresses.

        Only call this if :meth:`is_emails` is true.

        :rtype: list of [str]
        """
        ...
    


UsersSelectorArg_validator = ...
GroupsGetInfoResult_validator = ...
LegalHoldId_validator = ...
LegalHoldPolicyDescription_validator = ...
LegalHoldPolicyName_validator = ...
LegalHoldsGetPolicyResult_validator = ...
LegalHoldsGetPolicyResult = LegalHoldPolicy
LegalHoldsPolicyCreateResult_validator = ...
LegalHoldsPolicyCreateResult = LegalHoldPolicy
LegalHoldsPolicyUpdateResult_validator = ...
LegalHoldsPolicyUpdateResult = LegalHoldPolicy
ListHeldRevisionCursor_validator = ...
MembersGetInfoResult_validator = ...
NumberPerDay_validator = ...
Path_validator = ...
SecondaryEmail_validator = ...
SecondaryEmail = secondary_emails.SecondaryEmail
TeamMemberRoleId_validator = ...
UserQuota_validator = ...
devices_list_member_devices = ...
devices_list_members_devices = ...
devices_list_team_devices = ...
devices_revoke_device_session = ...
devices_revoke_device_session_batch = ...
features_get_values = ...
get_info = ...
groups_create = ...
groups_delete = ...
groups_get_info = ...
groups_job_status_get = ...
groups_list = ...
groups_list_continue = ...
groups_members_add = ...
groups_members_list = ...
groups_members_list_continue = ...
groups_members_remove = ...
groups_members_set_access_type = ...
groups_update = ...
legal_holds_create_policy = ...
legal_holds_get_policy = ...
legal_holds_list_held_revisions = ...
legal_holds_list_held_revisions_continue = ...
legal_holds_list_policies = ...
legal_holds_release_policy = ...
legal_holds_update_policy = ...
linked_apps_list_member_linked_apps = ...
linked_apps_list_members_linked_apps = ...
linked_apps_list_team_linked_apps = ...
linked_apps_revoke_linked_app = ...
linked_apps_revoke_linked_app_batch = ...
member_space_limits_excluded_users_add = ...
member_space_limits_excluded_users_list = ...
member_space_limits_excluded_users_list_continue = ...
member_space_limits_excluded_users_remove = ...
member_space_limits_get_custom_quota = ...
member_space_limits_remove_custom_quota = ...
member_space_limits_set_custom_quota = ...
members_add_v2 = ...
members_add = ...
members_add_job_status_get_v2 = ...
members_add_job_status_get = ...
members_delete_profile_photo_v2 = ...
members_delete_profile_photo = ...
members_get_available_team_member_roles = ...
members_get_info_v2 = ...
members_get_info = ...
members_list_v2 = ...
members_list = ...
members_list_continue_v2 = ...
members_list_continue = ...
members_move_former_member_files = ...
members_move_former_member_files_job_status_check = ...
members_recover = ...
members_remove = ...
members_remove_job_status_get = ...
members_secondary_emails_add = ...
members_secondary_emails_delete = ...
members_secondary_emails_resend_verification_emails = ...
members_send_welcome_email = ...
members_set_admin_permissions_v2 = ...
members_set_admin_permissions = ...
members_set_profile_v2 = ...
members_set_profile = ...
members_set_profile_photo_v2 = ...
members_set_profile_photo = ...
members_suspend = ...
members_unsuspend = ...
namespaces_list = ...
namespaces_list_continue = ...
properties_template_add = ...
properties_template_get = ...
properties_template_list = ...
properties_template_update = ...
reports_get_activity = ...
reports_get_devices = ...
reports_get_membership = ...
reports_get_storage = ...
sharing_allowlist_add = ...
sharing_allowlist_list = ...
sharing_allowlist_list_continue = ...
sharing_allowlist_remove = ...
team_folder_activate = ...
team_folder_archive = ...
team_folder_archive_check = ...
team_folder_create = ...
team_folder_get_info = ...
team_folder_list = ...
team_folder_list_continue = ...
team_folder_permanently_delete = ...
team_folder_rename = ...
team_folder_update_sync_settings = ...
token_get_authenticated_admin = ...
ROUTES = ...
