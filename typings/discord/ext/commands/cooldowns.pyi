"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Generic, Optional, TYPE_CHECKING, TypeVar, Union
from discord.enums import Enum
from .context import Context
from discord.app_commands import Cooldown as Cooldown
from typing_extensions import Self
from ...message import Message

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
__all__ = ('BucketType', 'Cooldown', 'CooldownMapping', 'DynamicCooldownMapping', 'MaxConcurrency')
T_contra = TypeVar('T_contra', contravariant=True)
class BucketType(Enum):
    default = ...
    user = ...
    guild = ...
    channel = ...
    member = ...
    category = ...
    role = ...
    def get_key(self, msg: Union[Message, Context[Any]]) -> Any:
        ...
    
    def __call__(self, msg: Union[Message, Context[Any]]) -> Any:
        ...
    


class CooldownMapping(Generic[T_contra]):
    def __init__(self, original: Optional[Cooldown], type: Callable[[T_contra], Any]) -> None:
        ...
    
    def copy(self) -> CooldownMapping[T_contra]:
        ...
    
    @property
    def valid(self) -> bool:
        ...
    
    @property
    def type(self) -> Callable[[T_contra], Any]:
        ...
    
    @classmethod
    def from_cooldown(cls, rate: float, per: float, type: Callable[[T_contra], Any]) -> Self:
        ...
    
    def create_bucket(self, message: T_contra) -> Cooldown:
        ...
    
    def get_bucket(self, message: T_contra, current: Optional[float] = ...) -> Optional[Cooldown]:
        ...
    
    def update_rate_limit(self, message: T_contra, current: Optional[float] = ..., tokens: int = ...) -> Optional[float]:
        ...
    


class DynamicCooldownMapping(CooldownMapping[T_contra]):
    def __init__(self, factory: Callable[[T_contra], Optional[Cooldown]], type: Callable[[T_contra], Any]) -> None:
        ...
    
    def copy(self) -> DynamicCooldownMapping[T_contra]:
        ...
    
    @property
    def valid(self) -> bool:
        ...
    
    def create_bucket(self, message: T_contra) -> Optional[Cooldown]:
        ...
    


class _Semaphore:
    """This class is a version of a semaphore.

    If you're wondering why asyncio.Semaphore isn't being used,
    it's because it doesn't expose the internal value. This internal
    value is necessary because I need to support both `wait=True` and
    `wait=False`.

    An asyncio.Queue could have been used to do this as well -- but it is
    not as inefficient since internally that uses two queues and is a bit
    overkill for what is basically a counter.
    """
    __slots__ = ...
    def __init__(self, number: int) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def locked(self) -> bool:
        ...
    
    def is_active(self) -> bool:
        ...
    
    def wake_up(self) -> None:
        ...
    
    async def acquire(self, *, wait: bool = ...) -> bool:
        ...
    
    def release(self) -> None:
        ...
    


class MaxConcurrency:
    __slots__ = ...
    def __init__(self, number: int, *, per: BucketType, wait: bool) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def get_key(self, message: Union[Message, Context[Any]]) -> Any:
        ...
    
    async def acquire(self, message: Union[Message, Context[Any]]) -> None:
        ...
    
    async def release(self, message: Union[Message, Context[Any]]) -> None:
        ...
    


